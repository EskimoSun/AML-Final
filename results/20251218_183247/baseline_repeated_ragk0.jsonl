{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.336345911026}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build the string\n    s = []\n    current_char = 'a'\n    i = 0\n    while i < n:\n        # Determine the length of the next block of same letters\n        # We need to find the smallest j > i such that c[j] > 0\n        # Actually, we can think: c[i] tells us how many blocks of length i exist\n        # But we need to construct from left to right\n        # Alternative approach: use c to deduce block lengths\n        # Let's think: c[1] is total number of single-letter substrings = n\n        # c[2] is number of length-2 same-letter substrings\n        # For a block of length L, it contributes:\n        # - L to c[1]\n        # - L-1 to c[2]\n        # - L-2 to c[3]\n        # ...\n        # - 1 to c[L]\n        # So we can reconstruct by greedily taking the largest possible block\n        # that fits the remaining c values\n        \n        # Find maximum block length we can start at position i\n        max_len = 1\n        for length in range(1, n - i + 1):\n            # Check if we can have a block of this length\n            # It would require c[length] >= 1, c[length-1] >= 1, ..., c[1] >= 1\n            # Actually simpler: we just need c[length] > 0\n            # But we also need to account that longer blocks consume more from c\n            # Let's try a greedy approach: take the largest L where c[L] > 0\n            if length <= n - i and c[length-1] > 0:\n                max_len = length\n        \n        # Add block of max_len with current_char\n        s.extend([current_char] * max_len)\n        \n        # Update c values: subtract contributions of this block\n        for l in range(1, max_len + 1):\n            c[l-1] -= (max_len - l + 1)\n        \n        # Move to next position and next character\n        i += max_len\n        current_char = chr(ord(current_char) + 1)\n        if current_char > 'z':\n            current_char = 'a'\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 59.46144890785217}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 36.86162090301514}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.height = 0\n\ndef insert(root, value, depth, counter):\n    if root is None:\n        return Node(value), depth\n    \n    if value < root.value:\n        root.left, new_depth = insert(root.left, value, depth + 1, counter)\n    else:\n        root.right, new_depth = insert(root.right, value, depth + 1, counter)\n    \n    return root, new_depth\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    values = list(map(int, data[1:1+n]))\n    \n    root = None\n    counter = 0\n    results = []\n    \n    for value in values:\n        if root is None:\n            root = Node(value)\n            depth = 0\n        else:\n            root, depth = insert(root, value, 0, counter)\n        \n        counter += depth\n        results.append(str(counter))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.43572497367859}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.4322338104248}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    \n    X = int(data[0])  # Total money\n    A = int(data[1])  # Price of one cake\n    B = int(data[2])  # Price of one donut\n    \n    # First, buy one cake\n    remaining_after_cake = X - A\n    \n    # Then, buy as many donuts as possible\n    # Integer division gives the maximum number of donuts we can buy\n    max_donuts = remaining_after_cake // B\n    \n    # Calculate remaining money after buying donuts\n    remaining_after_donuts = remaining_after_cake - (max_donuts * B)\n    \n    # Output the result\n    print(remaining_after_donuts)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.957337856292725}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.71255302429199}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\n\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Preprocess: sort indices by value descending, then by index ascending\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))\n\n# For each possible k, store the indices of the optimal subsequence\noptimal_indices = [[] for _ in range(n + 1)]\n\n# Build optimal subsequences for all k\nselected = [False] * n\nfor i in range(n):\n    idx_to_add = indices[i]\n    selected[idx_to_add] = True\n    # Determine current k (i+1 elements selected)\n    k = i + 1\n    # Collect selected indices in order\n    seq_indices = [j for j in range(n) if selected[j]]\n    optimal_indices[k] = seq_indices[:]\n\n# Process queries\nanswers = []\nfor k, pos in queries:\n    idx_in_seq = optimal_indices[k][pos - 1]\n    answers.append(a[idx_in_seq])\n\nprint('\\n'.join(map(str, answers)))", "complexity_estimate": null, "runtime_sec": 49.03344011306763}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.85173726081848}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 62.49310493469238}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.30708312988281}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 77.47197890281677}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.38437175750732}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom functools import lru_cache\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP over gcd values\n    INF = 10**18\n    dp = {0: 0}\n    for i in range(n):\n        new_dp = dict(dp)\n        for g_val, cost in dp.items():\n            new_g = math.gcd(g_val, l[i])\n            new_cost = cost + c[i]\n            if new_g not in new_dp or new_cost < new_dp[new_g]:\n                new_dp[new_g] = new_cost\n        dp = new_dp\n    \n    ans = dp.get(1, INF)\n    print(ans if ans < INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.549164056777954}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse integers\n    D, T, S = map(int, data)\n    \n    # Calculate time needed to travel D meters at speed S\n    # Since all values are integers, we can compare T * S with D\n    # If T * S >= D, he arrives in time\n    if T * S >= D:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.165892839431763}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 1, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.94068098068237}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 67.14791917800903}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find player start\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # BFS to explore reachable safe squares\n    from collections import deque\n    visited = [[False]*W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    # Directions: up, down, left, right\n    dirs = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    while queue:\n        r, c = queue.popleft()\n        \n        # Check if current cell has gold\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        has_adjacent_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if grid[nr][nc] == 'T':\n                    has_adjacent_trap = True\n                    break\n        \n        # If adjacent to trap, don't explore further from this cell\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if not visited[nr][nc] and grid[nr][nc] != '#':\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.889852285385132}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.53278589248657}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.21091794967651}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # The game is equivalent to a Nim game where each branch piece\n    # corresponds to a pile with Grundy number = piece_length - 1\n    # The Grundy number for length n is (n-1) % 2\n    # So Alice wins if (n-1) is odd, Bob wins if (n-1) is even\n    \n    if (n - 1) % 2 == 1:  # Alice wins\n        print(\"Alice\")\n        # For winning move: break off 1 piece of length 1\n        # This leaves piece of length n-1 with Grundy (n-2) % 2 = 0\n        # which is losing position for Bob\n        print(1)\n    else:  # Bob wins\n        print(\"Bob\")\n\ndef main():\n    solve()\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.372145891189575}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.57722020149231}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            need = target - current_height\n            days_used += need\n            if days_used > m:\n                return False\n            \n            # Water w flowers starting from i\n            current += need\n            if i + w <= n:\n                diff[i + w] -= need\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for maximum possible minimum height\n    low = min(heights)\n    high = min(heights) + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.256798028945923}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.393853187561035}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.3964400291443}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.04794192314148}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 35.772183895111084}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.44407796859741}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (2^4 - 1)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.67359209060669}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Use a set to track seen elements from right to left\n    seen = set()\n    result = []\n    \n    # Traverse from right to left to keep rightmost occurrences\n    for i in range(n - 1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    \n    # Reverse result to restore original order\n    result.reverse()\n    \n    # Output\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.616546154022217}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 85.97257328033447}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Calculate current average without best and worst\n    # After sorting: times[0] is best, times[3] is worst among first four\n    current_avg = (times[1] + times[2]) / 2\n    \n    # If current average is already <= target, she wins regardless of last solve\n    if current_avg <= target:\n        print(\"infinite\")\n        return\n    \n    # We need to find worst possible last time t5 such that final score <= target\n    # Final score calculation: sort all 5 times, discard best and worst, average middle 3\n    \n    # Helper function to calculate final score given t5\n    def final_score(t5):\n        all_times = sorted(times + [t5])\n        # Discard best (all_times[0]) and worst (all_times[4])\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3\n    \n    # Binary search for maximum t5 that still achieves target\n    # t5 can be up to 20.00 (inclusive) per problem constraints\n    lo, hi = 1.0, 20.0\n    eps = 1e-9\n    \n    # Check if even with best possible t5 (1.00) we can't reach target\n    if final_score(1.0) > target + eps:\n        print(\"impossible\")\n        return\n    \n    # Binary search for maximum t5\n    for _ in range(100):  # Sufficient precision for 2 decimal places\n        mid = (lo + hi) / 2\n        if final_score(mid) <= target + eps:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to 2 decimal places\n    result = round(lo, 2)\n    # Ensure it doesn't exceed 20.00\n    if result > 20.0:\n        result = 20.0\n    \n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.520102977752686}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 7.199083089828491}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.78751492500305}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            sys.stdout.write(s)\n            break\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.518295049667358}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    X, Y = map(int, data[:2])\n    # Total cost: train fare X + half of bus fare Y\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.38170599937439}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    scenarios = []  # store scenarios to output later\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == 'E':\n            # Event happens\n            event = parts[1]\n            events_stack.append(event)\n        elif cmd == 'D':\n            # Dream: remove last r events\n            r = int(parts[1])\n            for _ in range(r):\n                if events_stack:\n                    events_stack.pop()\n        elif cmd == 'S':\n            # Scenario\n            k = int(parts[1])\n            scenario_events = parts[2:2 + k]\n            \n            # Check if scenario is consistent with current events\n            current_events = set(events_stack)\n            consistent = True\n            for e in scenario_events:\n                if e.startswith('!'):\n                    # Event should NOT have happened\n                    event_name = e[1:]\n                    if event_name in current_events:\n                        consistent = False\n                        break\n                else:\n                    # Event should have happened\n                    if e not in current_events:\n                        consistent = False\n                        break\n            \n            if consistent:\n                scenarios.append(\"Yes\")\n                continue\n            \n            # If not consistent, check if adding a dream before scenario makes it consistent\n            # Try all possible r from 1 to len(events_stack)\n            min_r = None\n            for r in range(1, len(events_stack) + 1):\n                # Simulate removing last r events\n                temp_events = set(events_stack[:-r]) if r <= len(events_stack) else set()\n                temp_consistent = True\n                for e in scenario_events:\n                    if e.startswith('!'):\n                        event_name = e[1:]\n                        if event_name in temp_events:\n                            temp_consistent = False\n                            break\n                    else:\n                        if e not in temp_events:\n                            temp_consistent = False\n                            break\n                if temp_consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                scenarios.append(f\"{min_r} Just A Dream\")\n            else:\n                scenarios.append(\"Plot Error\")\n    \n    # Output all scenario results\n    sys.stdout.write('\\n'.join(scenarios))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.903024911880493}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"TLE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    T = int(input[1])\n    dishes = []\n    idx = 2\n    for _ in range(N):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        dishes.append((a, b))\n        idx += 2\n    \n    # Sort dishes by eating time\n    dishes.sort(key=lambda x: x[0])\n    \n    # DP array: dp[t] = max happiness achievable with total eating time exactly t\n    dp = [-1] * (T + 1)\n    dp[0] = 0\n    \n    max_happiness = 0\n    \n    for a, b in dishes:\n        # Process in reverse to avoid reusing the same dish\n        for t in range(T - 1, -1, -1):\n            if dp[t] >= 0:\n                new_t = t + a\n                if new_t < T:\n                    dp[new_t] = max(dp[new_t], dp[t] + b)\n                else:\n                    # If adding this dish would exceed T-0.5, we can still order it\n                    # as long as we start before T-0.5\n                    max_happiness = max(max_happiness, dp[t] + b)\n        \n        # Also consider this dish as the first dish\n        if a < T:\n            dp[a] = max(dp[a], b)\n        else:\n            max_happiness = max(max_happiness, b)\n    \n    # Check maximum from dp array\n    max_happiness = max(max_happiness, max(dp))\n    \n    print(max_happiness)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 65.53043675422668}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    P, Q, R = map(int, input().split())\n    # The route involves exactly two flights between three airports\n    # All possible sums of two distinct flight times\n    sums = [P + Q, Q + R, R + P]\n    print(min(sums))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.603714942932129}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 153.3506441116333}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.45766568183899}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        out_lines.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.009268045425415}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 49.03182816505432}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.70232892036438}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    X = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    total_eaten = 0\n    for a in A:\n        # Days when participant eats: 1, a+1, 2a+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += a\n    \n    prepared = total_eaten + X\n    print(prepared)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.873167037963867}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    caps = [int(next(it)) for _ in range(n)]\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * n\n    components = []\n    \n    for i in range(n):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            components.append(comp)\n    \n    # Count needed edits: (number_of_components - 1) * 2\n    needed = (len(components) - 1) * 2 if len(components) > 1 else 0\n    \n    # Check socket capacity constraints\n    for comp in components:\n        total_sockets = sum(caps[v] for v in comp)\n        existing_edges = sum(len(adj[v]) for v in comp) // 2\n        max_possible_edges = total_sockets // 2\n        if existing_edges > max_possible_edges:\n            print(\"no\")\n            return\n        # For connectivity within component, we need at least |comp|-1 edges\n        if existing_edges < len(comp) - 1:\n            # Need to add edges within component\n            needed += (len(comp) - 1 - existing_edges)\n    \n    print(\"yes\" if needed <= k else \"no\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 105.69955921173096}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct_nums[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (given to left robot)\n    for i in range(m):\n        p = distinct_nums[i]\n        # Find the rightmost position where left robot stops\n        # It stops at the first occurrence of p from left\n        # So all positions before first occurrence are to the left\n        # Actually, we need to find the first index where arr[idx] == p\n        # But we can compute using prefix sums\n        # The number of positions where left robot can stop = freq[p]\n        # But the left robot stops at the first occurrence, so only one position\n        # However, we need to consider all possible q such that the right robot stops after that position\n        \n        # The left robot stops at the first occurrence of p\n        # Find the index of first occurrence\n        first_idx = arr.index(p)  # O(n) but we can optimize\n        \n        # For each possible q (given to right robot)\n        for j in range(m):\n            q = distinct_nums[j]\n            if p == q:\n                # Both robots look for same number\n                # They won't meet if left robot's first occurrence is before right robot's last occurrence\n                # Right robot stops at the last occurrence of q\n                # Find last occurrence of q\n                last_idx = len(arr) - 1 - arr[::-1].index(q)\n                if first_idx < last_idx:\n                    total_pairs += 1\n            else:\n                # Different numbers\n                # Left robot stops at first occurrence of p\n                # Right robot stops at last occurrence of q (from right)\n                last_idx = len(arr) - 1 - arr[::-1].index(q)\n                if first_idx < last_idx:\n                    total_pairs += 1\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 64.96622085571289}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "RE": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 86.36670994758606}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.83281207084656}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.832101821899414}

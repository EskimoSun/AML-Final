{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 50.376242876052856}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build the string\n    s = []\n    current_char = 'a'\n    i = 0\n    while i < n:\n        # Determine the length of the next block of identical letters\n        # We need to find the smallest j > i such that c[j] > 0\n        # Actually, we can think: c[k] tells us how many substrings of length k exist.\n        # For a block of length L, it contributes 1 to c[L], L-1 to c[L-1], ..., and L to c[1]?\n        # Wait, let's derive: For a block of length L, the number of substrings of length i within it is max(0, L - i + 1).\n        # So c[i] = sum over all blocks of max(0, block_len - i + 1).\n        # We can reconstruct by greedily taking the largest possible block that fits.\n        # But there's a simpler approach: c[1] gives total characters, so we know n.\n        # We can reconstruct by looking at differences: c[i] - c[i+1] gives number of blocks of length at least i+1?\n        # Actually, for a single block of length L, the contribution to c[i] is L - i + 1 if i <= L, else 0.\n        # So c[i] - c[i+1] = number of blocks with length >= i+1.\n        # Let d[i] = c[i] - c[i+1] for i from 1 to n-1, and d[n] = c[n].\n        # Then d[i] is the number of blocks with length exactly i? Let's check:\n        # For a block of length L, it contributes 1 to d[L], and 0 to other d's.\n        # Yes! Because for i < L, contribution to c[i] and c[i+1] are both L-i+1 and L-i, so difference is 1.\n        # For i = L, contribution to c[L] is 1, to c[L+1] is 0, so difference is 1.\n        # For i > L, both contributions are 0, difference 0.\n        # So d[i] counts exactly the number of blocks of length i.\n        # Therefore, we can reconstruct by having d[i] blocks of length i.\n        # We need to assign letters to these blocks, ensuring adjacent blocks have different letters.\n        # We can just use consecutive letters for each block.\n        \n        # Compute d\n        d = [0]*(n+1)  # 1-indexed for simplicity\n        for i in range(1, n+1):\n            if i < n:\n                d[i] = c[i-1] - c[i]\n            else:\n                d[i] = c[i-1]\n        \n        # Now build string\n        s_chars = []\n        current_char = 'a'\n        for length in range(1, n+1):\n            count = d[length]\n            for _ in range(count):\n                s_chars.append(current_char * length)\n                # Move to next letter for next block\n                current_char = chr(ord(current_char) + 1)\n                if current_char > 'z':\n                    current_char = 'a'  # Wrap around if needed, though with n<=2000, 26 letters should suffice\n        \n        result = ''.join(s_chars)\n        # Verify length\n        if len(result) != n:\n            # This shouldn't happen given problem guarantees, but just in case\n            # Adjust by truncating or extending (though extending shouldn't be needed)\n            result = result[:n]\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 42.326712131500244}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "a = int(input())\nif a % 10 == 0:\n    print(0)\nelse:\n    print(1)", "runtime_sec": 8.962154150009155}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(400000)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    seq = list(map(int, data[1:1+n]))\n    \n    # BST node structure\n    class Node:\n        __slots__ = ('val', 'left', 'right')\n        def __init__(self, val):\n            self.val = val\n            self.left = None\n            self.right = None\n    \n    root = None\n    total_depth = 0\n    out_lines = []\n    \n    # Insert each number\n    for num in seq:\n        depth = 0\n        if root is None:\n            root = Node(num)\n        else:\n            cur = root\n            while True:\n                depth += 1\n                if num < cur.val:\n                    if cur.left is None:\n                        cur.left = Node(num)\n                        break\n                    else:\n                        cur = cur.left\n                else:  # num > cur.val (since distinct)\n                    if cur.right is None:\n                        cur.right = Node(num)\n                        break\n                    else:\n                        cur = cur.right\n        total_depth += depth\n        out_lines.append(str(total_depth))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 16.77351212501526}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 51.59075617790222}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    \n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Calculate remaining money after buying cake\n    remaining_after_cake = X - A\n    \n    # Calculate how many donuts can be bought\n    donuts_count = remaining_after_cake // B\n    \n    # Calculate remaining money after buying donuts\n    remaining_after_donuts = remaining_after_cake - (donuts_count * B)\n    \n    # Output the result\n    print(remaining_after_donuts)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.313621997833252}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom itertools import permutations\n\ndef solve():\n    # Read input\n    ratios = []\n    for _ in range(12):\n        line = sys.stdin.readline().strip()\n        if not line:\n            continue\n        n_str, d_str = line.split('/')\n        n, d = int(n_str), int(d_str)\n        g = math.gcd(n, d)\n        ratios.append((n//g, d//g))\n    \n    # Try all possible front sprocket pairs\n    # Since n_i, d_i ≤ 100, front sprockets must be ≤ 10000\n    # We'll generate candidates from the numerators and denominators\n    candidates = set()\n    for n, d in ratios:\n        candidates.add(n)\n        candidates.add(d)\n    \n    # Generate all pairs from candidates (with values ≤ 10000)\n    candidate_list = sorted([c for c in candidates if c <= 10000])\n    \n    # Try all pairs of front sprockets\n    for i in range(len(candidate_list)):\n        for j in range(i+1, len(candidate_list)):\n            front1, front2 = candidate_list[i], candidate_list[j]\n            \n            # For each front sprocket, determine possible rear sprockets\n            # from the ratios\n            rear_candidates = []\n            for n, d in ratios:\n                # Check if ratio matches front1/rear or front2/rear\n                # rear = front * d / n must be integer\n                if front1 * d % n == 0:\n                    rear = front1 * d // n\n                    if 1 <= rear <= 10000:\n                        rear_candidates.append(rear)\n                if front2 * d % n == 0:\n                    rear = front2 * d // n\n                    if 1 <= rear <= 10000:\n                        rear_candidates.append(rear)\n            \n            # We need exactly 6 unique rear sprockets\n            rear_set = set(rear_candidates)\n            if len(rear_set) != 6:\n                continue\n            \n            # Check if all 12 ratios can be generated\n            rear_list = sorted(rear_set)\n            generated_ratios = set()\n            for f in [front1, front2]:\n                for r in rear_list:\n                    g = math.gcd(f, r)\n                    generated_ratios.add((f//g, r//g))\n            \n            if generated_ratios == set(ratios):\n                # Output solution\n                print(front1, front2)\n                print(' '.join(map(str, rear_list)))\n                return\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.820054054260254}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\n\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Preprocess: sort indices by value descending, then by index ascending for tie-breaking\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))\n\n# For each k from 1 to n, store the indices of the optimal subsequence\noptimal_indices = [None] * (n + 1)\n# We'll build incrementally\nselected = []\nfor k in range(1, n + 1):\n    # Add the k-th best element (by value, then index)\n    selected.append(indices[k - 1])\n    # Sort selected indices to maintain original order\n    selected.sort()\n    optimal_indices[k] = selected.copy()\n\n# Answer queries\nanswers = []\nfor k, pos in queries:\n    idx_in_optimal = optimal_indices[k][pos - 1]\n    answers.append(a[idx_in_optimal])\n\nprint('\\n'.join(map(str, answers)))", "runtime_sec": 22.945401906967163}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Check if solution exists\n    if k == 1:\n        # With only 1 color, can't have b_i != g_i\n        print(\"NO\")\n        return\n    \n    if n > k * (k - 1):\n        # Maximum distinct pairs with b_i != g_i is k*(k-1)\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using two alternating sequences\n    # We'll use colors 1..k for men and women\n    # Create pairs where b_i and g_i are different and follow adjacency rules\n    \n    # Strategy: Use two interleaved cycles\n    # For men: 1,2,3,...,k,1,2,3,... (ensuring consecutive men differ)\n    # For women: shift by 1 each time to ensure b_i != g_i\n    # And ensure consecutive women differ by using a different shift pattern\n    \n    men = []\n    women = []\n    \n    # Generate men's sequence: 1,2,...,k,1,2,...\n    for i in range(n):\n        men.append((i % k) + 1)\n    \n    # Generate women's sequence with shift\n    # We need to ensure:\n    # 1. b_i != g_i for all i\n    # 2. g_i != g_{i+1} for all i\n    # 3. All pairs (b_i, g_i) are distinct\n    \n    # Use pattern: women's color = (men's color + shift) mod k, with shift changing\n    shift = 1\n    used_pairs = set()\n    \n    for i in range(n):\n        man_color = men[i]\n        # Try different shifts until we find a valid woman color\n        for s in range(1, k):\n            woman_color = ((man_color - 1 + s) % k) + 1\n            if woman_color == man_color:\n                continue\n            \n            # Check if this pair was already used\n            pair = (man_color, woman_color)\n            if pair in used_pairs:\n                continue\n            \n            # Check adjacency with previous woman (if any)\n            if i > 0 and woman_color == women[-1]:\n                continue\n            \n            # Valid choice found\n            women.append(woman_color)\n            used_pairs.add(pair)\n            break\n        else:\n            # Should not happen given our existence check\n            print(\"NO\")\n            return\n    \n    # Output the pairs\n    for i in range(n):\n        print(f\"{men[i]} {women[i]}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.12366700172424}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    guests = []\n    idx = 1\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        guests.append((l, r))\n        idx += 2\n    \n    # Sort guests by (l_i + r_i) descending\n    guests.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    total_chairs = 0\n    # For each guest, add max(l_i, r_i) to total\n    for l, r in guests:\n        total_chairs += max(l, r)\n    \n    # Add n for the guests themselves\n    total_chairs += n\n    \n    print(total_chairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 18.068042993545532}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef prime_factors(n):\n    \"\"\"Return prime factorization as dict {prime: exponent}\"\"\"\n    factors = defaultdict(int)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1 if d == 2 else 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Collect all prime factors from all numbers\n    total_factors = defaultdict(int)\n    for num in arr:\n        pf = prime_factors(num)\n        for p, exp in pf.items():\n            total_factors[p] += exp\n    \n    # Step 2: Determine maximal possible GCD\n    # For each prime, we can redistribute exponents among numbers\n    # Maximal GCD exponent for prime p is floor(total_exponent / n)\n    gcd_factors = {}\n    for p, total_exp in total_factors.items():\n        gcd_exp = total_exp // n\n        if gcd_exp > 0:\n            gcd_factors[p] = gcd_exp\n    \n    # Calculate maximal GCD value\n    max_gcd = 1\n    for p, exp in gcd_factors.items():\n        max_gcd *= p ** exp\n    \n    # Step 3: Calculate minimal operations needed\n    # For each prime p, we need to move exponents to reach target gcd_exp per number\n    operations = 0\n    for p, target_exp in gcd_factors.items():\n        needed_per_number = target_exp\n        # Count how many numbers have less than target_exp exponents of p\n        for num in arr:\n            pf = prime_factors(num)\n            current_exp = pf.get(p, 0)\n            if current_exp < needed_per_number:\n                operations += needed_per_number - current_exp\n    \n    print(f\"{max_gcd} {operations}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.62206268310547}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    f = list(map(int, data[1:1+n]))\n    \n    # Determine who is already assigned as a receiver\n    receiver_set = set()\n    for i in range(n):\n        if f[i] != 0:\n            receiver_set.add(f[i])\n    \n    # Find all friends who are not receiving a gift yet\n    not_receiving = [i+1 for i in range(n) if (i+1) not in receiver_set]\n    \n    # Find indices where f[i] == 0 (unknown givers)\n    unknown_indices = [i for i in range(n) if f[i] == 0]\n    \n    # Pair unknown givers with not_receiving friends\n    # Avoid self-gifting by checking and adjusting\n    m = len(unknown_indices)\n    for idx in range(m):\n        giver_idx = unknown_indices[idx]\n        receiver = not_receiving[idx]\n        # If assigning to self, swap with next receiver\n        if receiver == giver_idx + 1:\n            # Find a different receiver\n            swap_idx = (idx + 1) % m\n            not_receiving[idx], not_receiving[swap_idx] = not_receiving[swap_idx], not_receiving[idx]\n            receiver = not_receiving[idx]\n        f[giver_idx] = receiver\n    \n    # Output the result\n    print(' '.join(map(str, f)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.20720386505127}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef max_polygon_area(segments):\n    \"\"\"Return maximum area polygon that can be formed from given segments.\"\"\"\n    n = len(segments)\n    if n < 3:\n        return 0.0\n    \n    # Sort segments in descending order\n    segments.sort(reverse=True)\n    \n    # Try all possible subsets of segments\n    max_area = 0.0\n    \n    # We need at least 3 segments to form a polygon\n    for mask in range(1, 1 << n):\n        # Count bits (number of segments in this subset)\n        count = bin(mask).count('1')\n        if count < 3:\n            continue\n        \n        # Sum of lengths in this subset\n        total = 0\n        selected = []\n        for i in range(n):\n            if mask & (1 << i):\n                total += segments[i]\n                selected.append(segments[i])\n        \n        # Polygon condition: longest side < sum of other sides\n        max_side = selected[0]  # since sorted descending\n        if max_side >= total - max_side:\n            continue\n        \n        # For a polygon with given side lengths, maximum area is achieved\n        # when it's cyclic (inscribed in a circle)\n        # Using Brahmagupta's formula for cyclic quadrilaterals and\n        # generalization for polygons with more sides\n        \n        # For triangles, use Heron's formula\n        if count == 3:\n            a, b, c = selected\n            s = (a + b + c) / 2.0\n            area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n            max_area = max(max_area, area)\n            continue\n        \n        # For polygons with 4+ sides, approximate maximum area\n        # by treating as a cyclic polygon\n        # We can use the fact that for a cyclic polygon,\n        # area = 1/4 * sqrt(4R^2 * sum(a_i^2) - (sum(a_i^2))^2)\n        # where R is circumradius\n        # But simpler: approximate by regular polygon area formula\n        # with perimeter = total and number of sides = count\n        \n        # Perimeter of selected segments\n        perimeter = total\n        \n        # For a regular n-gon with perimeter P, area = (P^2 / (4*n)) * cot(pi/n)\n        # cot(pi/n) = 1/tan(pi/n)\n        n_sides = count\n        if n_sides >= 3:\n            # Regular polygon area formula\n            area = (perimeter * perimeter) / (4.0 * n_sides * math.tan(math.pi / n_sides))\n            max_area = max(max_area, area)\n    \n    return max_area\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    segments = list(map(int, data[1:1+n]))\n    \n    result = max_polygon_area(segments)\n    \n    # Format output with sufficient precision\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 36.19636511802673}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for length in l:\n        g = math.gcd(g, length)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP over gcd values\n    INF = 10**18\n    dp = defaultdict(lambda: INF)\n    dp[0] = 0  # gcd 0 corresponds to no cards selected\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for current_gcd, cost in dp.items():\n            new_gcd = math.gcd(current_gcd, l[i])\n            new_cost = cost + c[i]\n            if new_cost < new_dp[new_gcd]:\n                new_dp[new_gcd] = new_cost\n        dp = new_dp\n    \n    result = dp.get(1, INF)\n    print(result if result != INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 20.640177965164185}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Calculate time needed to travel D meters at speed S\n    time_needed = D / S\n    # Compare with available time T\n    if time_needed <= T:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 9.910890102386475}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    k = int(next(it))\n    n = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        d = int(next(it))\n        for _ in range(d):\n            neighbor = int(next(it)) - 1  # convert to 0-index\n            adj[i].append(neighbor)\n    \n    # DP on tree (graph is a forest)\n    visited = [False] * n\n    dp = [[0, 0] for _ in range(n)]  # dp[u][0]: max without u, dp[u][1]: max with u\n    \n    def dfs(u, parent):\n        visited[u] = True\n        dp[u][0] = 0\n        dp[u][1] = 1  # place drone at u\n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u)\n            dp[u][0] += max(dp[v][0], dp[v][1])\n            dp[u][1] += dp[v][0]\n    \n    total_max = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1)\n            total_max += max(dp[i][0], dp[i][1])\n    \n    # Check feasibility\n    if k <= total_max:\n        # Need to verify exact k is achievable\n        # Since we can always reduce from max by removing some drones\n        # while maintaining independence, k is possible if k <= max\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.468897104263306}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\nn = int(lines[0])\nc = list(map(int, lines[1:1+n]))\n\n# Total number of people\nP = sum(c)\n\n# Validate input constraints\nif P > 365:\n    # This case requires special handling since we can't assign more than 365 distinct birthdays\n    # But the problem states 1 ≤ n ≤ 365 and 1 ≤ c_i ≤ 100, so P could be > 365\n    # However, if P > 365, it's impossible to have all birthdays distinct as required by the problem\n    # Actually, the problem doesn't require all birthdays to be distinct - it allows sharing\n    # So we proceed with the calculation\n    pass\n\n# Number of distinct birthdays\nk = n\n\n# Step 1: Choose which k birthdays out of 365 are used\n# Number of ways: C(365, k)\nlog_ways_choose_birthdays = math.lgamma(365 + 1) - math.lgamma(k + 1) - math.lgamma(365 - k + 1)\n\n# Step 2: Assign the c_i people to their respective birthdays\n# For each birthday group of size c_i, there's exactly 1 way to assign since they all share that birthday\n# So this factor is 1, log is 0\nlog_ways_assign_people = 0.0\n\n# Step 3: Distribute the P people among the 365 days with the given group sizes\n# This is a multinomial coefficient: P! / (c_1! * c_2! * ... * c_k!)\nlog_multinomial = math.lgamma(P + 1)\nfor ci in c:\n    log_multinomial -= math.lgamma(ci + 1)\n\n# Step 4: Total number of ways to assign birthdays to P people without restrictions\n# Each person has 365 choices: 365^P\nlog_total_ways = P * math.log(365)\n\n# Step 5: Probability = (ways for this distribution) / (total ways)\nlog_prob = log_ways_choose_birthdays + log_ways_assign_people + log_multinomial - log_total_ways\n\n# Convert to log10\nlog10_prob = log_prob / math.log(10)\n\n# Output with sufficient precision\nprint(f\"{log10_prob:.15f}\")", "runtime_sec": 28.043750286102295}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Mark unsafe squares (adjacent to traps)\n    unsafe = [[False]*W for _ in range(H)]\n    dirs = [(-1,0), (1,0), (0,-1), (0,1)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'T':\n                for di, dj in dirs:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < H and 0 <= nj < W:\n                        unsafe[ni][nj] = True\n    \n    # BFS to find reachable safe gold\n    visited = [[False]*W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while queue:\n        i, j = queue.pop(0)\n        if grid[i][j] == 'G':\n            gold_count += 1\n        \n        for di, dj in dirs:\n            ni, nj = i+di, j+dj\n            if 0 <= ni < H and 0 <= nj < W and not visited[ni][nj]:\n                # Can't move into walls or unsafe squares\n                if grid[ni][nj] == '#':\n                    continue\n                if unsafe[ni][nj]:\n                    continue\n                visited[ni][nj] = True\n                queue.append((ni, nj))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.367860794067383}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 50.13545203208923}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data)\n    \n    # Find maximum k such that total hours for first k notes <= a + b\n    # Using binary search since a, b up to 1e9\n    low, high = 0, 2 * 10**5  # Upper bound: k*(k+1)/2 <= 2e9 => k ~ 63k, but safe bound\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_hours = mid * (mid + 1) // 2\n        if total_hours <= a + b:\n            low = mid\n        else:\n            high = mid - 1\n    max_notes = low\n    \n    # Determine which notes go to day1 and day2\n    day1 = []\n    day2 = []\n    remaining_a = a\n    \n    # Greedy: assign largest notes to day1 if possible\n    for note in range(max_notes, 0, -1):\n        if remaining_a >= note:\n            day1.append(note)\n            remaining_a -= note\n        else:\n            day2.append(note)\n    \n    # Output\n    print(len(day1))\n    if day1:\n        print(' '.join(map(str, day1)))\n    else:\n        print()\n    \n    print(len(day2))\n    if day2:\n        print(' '.join(map(str, day2)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.271141290664673}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 49.40414524078369}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.readline\n    Q = int(input().strip())\n    \n    # Fenwick tree for prefix sums\n    class FenwickTree:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 1)\n        \n        def update(self, idx, delta):\n            while idx <= self.n:\n                self.bit[idx] += delta\n                idx += idx & -idx\n        \n        def query(self, idx):\n            res = 0\n            while idx > 0:\n                res += self.bit[idx]\n                idx -= idx & -idx\n            return res\n        \n        def find_kth(self, k):\n            \"\"\"Find smallest idx such that prefix sum >= k\"\"\"\n            idx = 0\n            bit_mask = 1 << (self.n.bit_length() - 1)\n            while bit_mask:\n                next_idx = idx + bit_mask\n                if next_idx <= self.n and self.bit[next_idx] < k:\n                    k -= self.bit[next_idx]\n                    idx = next_idx\n                bit_mask >>= 1\n            return idx + 1\n    \n    # Maximum possible movies: Q insertions\n    MAX_N = Q + 5\n    ft = FenwickTree(MAX_N)\n    \n    # creation_order[i] = creation index of movie with plot index i\n    creation_order = [0] * (MAX_N + 1)\n    next_creation_idx = 1\n    \n    out_lines = []\n    \n    for _ in range(Q):\n        parts = input().split()\n        q = int(parts[0])\n        x = int(parts[1])\n        \n        if q == 1:\n            # Insert movie at plot position x\n            # Find actual position in current array\n            pos = ft.find_kth(x)\n            ft.update(pos, 1)\n            creation_order[pos] = next_creation_idx\n            next_creation_idx += 1\n        else:  # q == 2\n            # Find creation index of movie at plot position x\n            pos = ft.find_kth(x)\n            out_lines.append(str(creation_order[pos]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 25.206502199172974}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            needed = target - current_height\n            days_used += needed\n            if days_used > m:\n                return False\n            current += needed\n            # Mark the end of the watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.182605028152466}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 12.0464608669281}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.size = 1\n        while self.size < n:\n            self.size <<= 1\n        self.sum = [0] * (2 * self.size)\n        self.lazy_a = [0] * (2 * self.size)\n        self.lazy_b = [0] * (2 * self.size)\n        self.lazy_start = [0] * (2 * self.size)\n    \n    def _apply(self, idx, l, r, a, b, start):\n        length = r - l + 1\n        first = ((start - l + 1) * a) % b\n        if b == 1:\n            self.sum[idx] = 0\n        else:\n            total = 0\n            if length <= b:\n                for i in range(length):\n                    total += (first + i * a) % b\n            else:\n                full_cycles = length // b\n                remainder = length % b\n                cycle_sum = 0\n                for i in range(b):\n                    cycle_sum += (first + i * a) % b\n                total = full_cycles * cycle_sum\n                for i in range(remainder):\n                    total += (first + i * a) % b\n            self.sum[idx] = total\n        self.lazy_a[idx] = a\n        self.lazy_b[idx] = b\n        self.lazy_start[idx] = start\n    \n    def _push(self, idx, l, r):\n        if self.lazy_b[idx] != 0:\n            mid = (l + r) // 2\n            self._apply(idx * 2, l, mid, self.lazy_a[idx], self.lazy_b[idx], self.lazy_start[idx])\n            self._apply(idx * 2 + 1, mid + 1, r, self.lazy_a[idx], self.lazy_b[idx], self.lazy_start[idx])\n            self.lazy_a[idx] = 0\n            self.lazy_b[idx] = 0\n            self.lazy_start[idx] = 0\n    \n    def update(self, ql, qr, a, b):\n        self._update(1, 1, self.n, ql, qr, a, b, ql)\n    \n    def _update(self, idx, l, r, ql, qr, a, b, start):\n        if ql > r or qr < l:\n            return\n        if ql <= l and r <= qr:\n            self._apply(idx, l, r, a, b, start)\n            return\n        self._push(idx, l, r)\n        mid = (l + r) // 2\n        self._update(idx * 2, l, mid, ql, qr, a, b, start)\n        self._update(idx * 2 + 1, mid + 1, r, ql, qr, a, b, start)\n        self.sum[idx] = self.sum[idx * 2] + self.sum[idx * 2 + 1]\n    \n    def query(self, ql, qr):\n        return self._query(1, 1, self.n, ql, qr)\n    \n    def _query(self, idx, l, r, ql, qr):\n        if ql > r or qr < l:\n            return 0\n        if ql <= l and r <= qr:\n            return self.sum[idx]\n        self._push(idx, l, r)\n        mid = (l + r) // 2\n        return self._query(idx * 2, l, mid, ql, qr) + self._query(idx * 2 + 1, mid + 1, r, ql, qr)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n    \n    seg = SegmentTree(N)\n    \n    results = []\n    for _ in range(Q):\n        t = int(next(it))\n        if t == 1:\n            L = int(next(it))\n            R = int(next(it))\n            A = int(next(it))\n            B = int(next(it))\n            seg.update(L, R, A, B)\n        else:\n            L = int(next(it))\n            R = int(next(it))\n            results.append(str(seg.query(L, R)))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 49.25257873535156}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef insertion_sort_swaps(arr):\n    \"\"\"Return number of swaps performed by insertion sort on array.\"\"\"\n    n = len(arr)\n    swaps = 0\n    for i in range(1, n):\n        j = i\n        while j > 0 and arr[j] < arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            swaps += 1\n            j -= 1\n    return swaps\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    perm = list(map(int, data[1:1 + n]))\n    \n    # Step 1: Compute original swaps\n    original_arr = perm[:]\n    original_swaps = insertion_sort_swaps(original_arr)\n    \n    # Step 2: Try all swaps and track minimum\n    min_swaps = float('inf')\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create copy with swapped elements\n            arr_copy = perm[:]\n            arr_copy[i], arr_copy[j] = arr_copy[j], arr_copy[i]\n            \n            # Compute swaps after swap\n            current_swaps = insertion_sort_swaps(arr_copy)\n            \n            if current_swaps < min_swaps:\n                min_swaps = current_swaps\n                count = 1\n            elif current_swaps == min_swaps:\n                count += 1\n    \n    print(f\"{min_swaps} {count}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.16258931159973}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    total = 0.0\n    \n    idx = 1\n    for _ in range(n):\n        x_str = data[idx]\n        u = data[idx + 1]\n        idx += 2\n        \n        if u == \"JPY\":\n            total += float(x_str)\n        else:  # BTC\n            total += float(x_str) * 380000.0\n    \n    # Print with sufficient precision\n    print(f\"{total:.10f}\".rstrip('0').rstrip('.'))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 10.9653000831604}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 51.11009097099304}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (2^4 - 1)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 13.954159259796143}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    seen = set()\n    result = []\n    \n    # Traverse from right to left to keep rightmost occurrences\n    for i in range(n - 1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    \n    # Reverse to restore original order\n    result.reverse()\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 12.31355619430542}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**6 + 7\n\ndef modinv(a, mod=MOD):\n    \"\"\"Return modular inverse using Fermat's little theorem\"\"\"\n    return pow(a, mod-2, mod)\n\ndef nCr_mod(n, r, mod=MOD):\n    \"\"\"Compute nCr modulo mod using factorial and modular inverse\"\"\"\n    if r < 0 or r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Use smaller of r and n-r\n    r = min(r, n-r)\n    \n    numerator = 1\n    denominator = 1\n    for i in range(1, r+1):\n        numerator = (numerator * (n - i + 1)) % mod\n        denominator = (denominator * i) % mod\n    \n    return (numerator * modinv(denominator, mod)) % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N, M, K = map(int, data[:3])\n    \n    # If K > N*M, impossible\n    if K > N * M:\n        print(0)\n        return\n    \n    # Use stars and bars with inclusion-exclusion\n    # Number of non-negative integer solutions to x1 + x2 + ... + xN = K\n    # with 0 <= xi <= M\n    # Using inclusion-exclusion: sum_{i=0}^{N} (-1)^i * C(N, i) * C(K - i*(M+1) + N - 1, N - 1)\n    \n    result = 0\n    for i in range(N + 1):\n        # Check if K - i*(M+1) >= 0\n        remaining = K - i * (M + 1)\n        if remaining < 0:\n            break\n        \n        # Compute C(N, i) * C(remaining + N - 1, N - 1)\n        term = (nCr_mod(N, i) * nCr_mod(remaining + N - 1, N - 1)) % MOD\n        \n        if i % 2 == 0:\n            result = (result + term) % MOD\n        else:\n            result = (result - term) % MOD\n    \n    # Ensure result is non-negative\n    result = (result + MOD) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.670479774475098}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 51.964881896972656}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 7.04367470741272}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 50.57359194755554}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            sys.stdout.write(s)\n            break\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 15.73842191696167}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data[:2])\n    # Total cost: train fare X + half of bus fare Y\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 8.199769735336304}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    scenarios = []  # store scenarios to output later\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        if parts[0] == 'E':\n            events_stack.append(parts[1])\n        elif parts[0] == 'D':\n            r = int(parts[1])\n            # remove last r events\n            events_stack = events_stack[:-r] if r < len(events_stack) else []\n        elif parts[0] == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:2 + k]\n            # check consistency with current events\n            current_events = set(events_stack)\n            consistent = True\n            for event in scenario_events:\n                if event.startswith('!'):\n                    actual_event = event[1:]\n                    if actual_event in current_events:\n                        consistent = False\n                        break\n                else:\n                    if event not in current_events:\n                        consistent = False\n                        break\n            if consistent:\n                scenarios.append(\"Yes\")\n            else:\n                # find smallest r such that scenario would be consistent\n                min_r = None\n                # try all possible r from 1 to len(events_stack)\n                for r in range(1, len(events_stack) + 1):\n                    # hypothetical events after removing r\n                    hypothetical_events = set(events_stack[:-r] if r < len(events_stack) else [])\n                    hypothetical_consistent = True\n                    for event in scenario_events:\n                        if event.startswith('!'):\n                            actual_event = event[1:]\n                            if actual_event in hypothetical_events:\n                                hypothetical_consistent = False\n                                break\n                        else:\n                            if event not in hypothetical_events:\n                                hypothetical_consistent = False\n                                break\n                    if hypothetical_consistent:\n                        min_r = r\n                        break\n                if min_r is not None:\n                    scenarios.append(f\"{min_r} Just A Dream\")\n                else:\n                    scenarios.append(\"Plot Error\")\n    # output all scenarios\n    sys.stdout.write('\\n'.join(scenarios))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 27.60980796813965}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 51.72844314575195}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    P, Q, R = map(int, input().split())\n    # The route involves exactly two flights between three airports\n    # We need to consider all possible ordered pairs of flights\n    # Since flights are bidirectional, we can think of visiting all three airports\n    # with exactly two flights, which means skipping one direct connection\n    # The minimum sum will be the sum of the two smallest flight times\n    # Because we can choose to not take the longest direct flight\n    times = [P, Q, R]\n    times.sort()\n    result = times[0] + times[1]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.28498387336731}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 51.52812600135803}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    boys = [int(next(it)) for _ in range(N)]\n    A = int(next(it))\n    B = int(next(it))\n    \n    # Ensure A and B are odd if possible, or adjust to nearest odd in range\n    if A % 2 == 0:\n        A += 1\n    if B % 2 == 0:\n        B -= 1\n    if A > B:\n        # No odd numbers in range\n        print(A - 1)  # Could be any, but return A-1 (even) as fallback\n        return\n    \n    # Sort boys for binary search\n    boys.sort()\n    \n    # Helper: find min distance from x to any boy\n    def min_dist(x):\n        from bisect import bisect_left\n        idx = bisect_left(boys, x)\n        best = float('inf')\n        if idx < N:\n            best = min(best, abs(boys[idx] - x))\n        if idx > 0:\n            best = min(best, abs(boys[idx - 1] - x))\n        return best\n    \n    # Check all odd candidates in [A, B]\n    best_x = A\n    best_dist = min_dist(A)\n    \n    x = A\n    while x <= B:\n        d = min_dist(x)\n        if d > best_dist:\n            best_dist = d\n            best_x = x\n        x += 2  # Only odd numbers\n    \n    print(best_x)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.024775743484497}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        a = [int(next(it)) for _ in range(n)]\n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        alice_turn = True\n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if alice_turn:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            alice_turn = not alice_turn\n        out_lines.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.612128973007202}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, A, B = map(int, data)\n    \n    # Check feasibility using Dilworth's theorem / Erdős–Szekeres theorem\n    if A * B < N or A + B > N + 1:\n        print(-1)\n        return\n    \n    # Construct sequence using blocks\n    result = []\n    remaining = N\n    \n    # First, create B decreasing blocks of size up to A\n    for block in range(B):\n        size = min(A, remaining - (B - block - 1))\n        if size <= 0:\n            print(-1)\n            return\n        \n        # Start value for this decreasing block\n        start = remaining - size + 1\n        # Add decreasing sequence\n        for val in range(start, remaining + 1):\n            result.append(val)\n        remaining -= size\n    \n    # Reverse to get correct order\n    result.reverse()\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.157641172409058}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    # Handle negative coordinates by working with absolute values\n    sign_x = 1 if X >= 0 else -1\n    sign_y = 1 if Y >= 0 else -1\n    x = abs(X)\n    y = abs(Y)\n    \n    # Total Manhattan distance to target\n    total_dist = x + y\n    \n    # Check if it's impossible\n    if K % 2 == 0 and total_dist % 2 == 1:\n        print(-1)\n        return\n    \n    # Determine minimum number of strokes\n    strokes = (total_dist + K - 1) // K  # Ceiling division\n    \n    # Adjust strokes if parity doesn't match\n    while (strokes * K - total_dist) % 2 != 0:\n        strokes += 1\n    \n    # Generate path\n    path = []\n    cur_x, cur_y = 0, 0\n    remaining = strokes * K - total_dist\n    \n    # First, move toward target with K steps\n    for i in range(strokes):\n        # Calculate how much we need to move in x and y\n        move_x = min(x, K)\n        move_y = K - move_x\n        \n        # Adjust if we overshoot y\n        if move_y > y:\n            move_y = y\n            move_x = K - move_y\n        \n        # Apply the move\n        cur_x += move_x\n        cur_y += move_y\n        x -= move_x\n        y -= move_y\n        \n        # Adjust for remaining extra distance\n        if remaining > 0:\n            if remaining >= 2:\n                # Use diagonal adjustment\n                if cur_x > 0:\n                    cur_x -= 1\n                    cur_y += 1\n                    remaining -= 2\n                elif cur_y > 0:\n                    cur_x += 1\n                    cur_y -= 1\n                    remaining -= 2\n        \n        path.append((cur_x * sign_x, cur_y * sign_y))\n    \n    # Output\n    print(strokes)\n    for px, py in path:\n        print(f\"{px} {py}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.826700925827026}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    X = int(next(it))\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(next(it))\n        # Days when participant eats: 1, A+1, 2A+1, ... ≤ D\n        # Equivalent to: day = k*A + 1 where k ≥ 0 and day ≤ D\n        # So k = 0,1,2,... while k*A + 1 ≤ D\n        # Number of eating days = floor((D-1)/A) + 1\n        days_eaten = (D - 1) // A + 1\n        total_eaten += days_eaten\n    \n    # Initial pieces = eaten + remaining\n    initial = total_eaten + X\n    print(initial)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.376083850860596}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * n\n    components = []\n    \n    for i in range(n):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            components.append(comp)\n    \n    # Count needed edits to connect components\n    needed_edges = len(components) - 1\n    \n    # Check socket constraints\n    for comp in components:\n        total_sockets = sum(capacities[v] for v in comp)\n        existing_edges = sum(len(adj[v]) for v in comp) // 2\n        max_possible_edges = total_sockets // 2\n        \n        # Within component, we need to ensure we don't exceed socket limits\n        # The existing edges already respect capacities, so we only need to check\n        # if we can add edges to connect to other components\n        # For connecting components, each component needs at least one free socket\n        free_sockets = total_sockets - 2 * existing_edges\n        if free_sockets < 1 and len(components) > 1:\n            print(\"no\")\n            return\n    \n    # Check if we have enough edits\n    if needed_edges <= k:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.903075695037842}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct_nums[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (given to first robot)\n    for i in range(m):\n        p = distinct_nums[i]\n        # Find the first position where p appears\n        first_pos = -1\n        for idx in range(n):\n            if arr[idx] == p:\n                first_pos = idx\n                break\n        \n        # For each possible q (given to second robot)\n        for j in range(m):\n            q = distinct_nums[j]\n            # Find the last position where q appears\n            last_pos = -1\n            for idx in range(n-1, -1, -1):\n                if arr[idx] == q:\n                    last_pos = idx\n                    break\n            \n            # Robots won't meet if first robot stops before second robot\n            # First robot stops at first occurrence of p\n            # Second robot stops at last occurrence of q\n            if first_pos < last_pos:\n                total_pairs += 1\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.60452389717102}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = list(map(int, data[2:2+n]))\n    \n    # Count frequencies of each element in s\n    freq = {}\n    for num in s:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # We need to choose k elements (with repetitions allowed) to maximize\n    # the number of complete copies we can cut out.\n    # The maximum number of copies we can get is limited by the total\n    # available count of each chosen element divided by how many times\n    # that element appears in t.\n    # Let cnt[x] be frequency of x in s.\n    # Suppose we choose t with multiset T (counts of each value in t).\n    # Then number of copies = min_{x} floor(cnt[x] / T[x]) over x in T.\n    # We want to maximize this min.\n    \n    # Since k <= n <= 2e5, we can try to find the best possible answer\n    # by considering each possible number of copies m.\n    # For a given m, we need to check if we can pick k elements (with repetitions)\n    # such that for each chosen element x, we have cnt[x] >= m * (how many times x appears in t).\n    # Actually, if we want exactly m copies, then for each element x,\n    # the number of times we can include it in t is at most floor(cnt[x] / m).\n    # So total available \"slots\" = sum over x of floor(cnt[x] / m).\n    # If this sum >= k, then we can form a t that yields at least m copies.\n    # We want the maximum m such that sum floor(cnt[x] / m) >= k.\n    \n    # Binary search on m from 1 to n (since at most n copies possible).\n    low, high = 1, n\n    best_m = 1\n    while low <= high:\n        mid = (low + high) // 2\n        total = 0\n        for count in freq.values():\n            total += count // mid\n        if total >= k:\n            best_m = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Now we have best_m = maximum copies possible.\n    # Construct t by taking elements greedily: for each element x,\n    # we can include it floor(cnt[x] / best_m) times in t.\n    # We need exactly k elements in t.\n    t = []\n    for x, count in freq.items():\n        take = count // best_m\n        # Add x take times, but don't exceed k total.\n        for _ in range(take):\n            t.append(x)\n            if len(t) == k:\n                break\n        if len(t) == k:\n            break\n    \n    # If we still haven't filled k elements (unlikely if best_m is correct),\n    # pad with any element (e.g., the first element in s).\n    while len(t) < k:\n        t.append(s[0])\n    \n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.069758892059326}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 50.87352180480957}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.421868085861206}

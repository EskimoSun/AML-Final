{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.00051093101501}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.82098317146301}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 36.34575295448303}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass Node:\n    __slots__ = ('value', 'left', 'right', 'depth')\n    def __init__(self, value, depth):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.depth = depth\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    \n    if N == 0:\n        return\n    \n    # Read first number\n    first_val = int(input().strip())\n    root = Node(first_val, 0)\n    \n    # Initialize counter and output\n    C = 0\n    outputs = [0]  # First insertion depth is 0\n    \n    # Process remaining numbers\n    for _ in range(N - 1):\n        val = int(input().strip())\n        current = root\n        depth = 0\n        \n        while True:\n            depth += 1\n            if val < current.value:\n                if current.left is None:\n                    current.left = Node(val, depth)\n                    C += depth\n                    outputs.append(C)\n                    break\n                else:\n                    current = current.left\n            else:  # val > current.value (since values are distinct)\n                if current.right is None:\n                    current.right = Node(val, depth)\n                    C += depth\n                    outputs.append(C)\n                    break\n                else:\n                    current = current.right\n    \n    # Print all outputs\n    sys.stdout.write('\\n'.join(map(str, outputs)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.104162216186523}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.51185512542725}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining // B\n    remaining -= donuts_count * B\n    \n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.419113159179688}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.2403130531311}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nqueries = []\nfor _ in range(m):\n    k, pos = map(int, input().split())\n    queries.append((k, pos))\n\n# Preprocess: sort indices by value (descending) and then by index (ascending)\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))\n\n# For each k from 1 to n, compute the optimal subsequence indices\noptimal_indices = [None] * (n + 1)\n# We'll store for each k the sorted list of indices of the optimal subsequence\n# Build incrementally\nsorted_indices_for_k = []\nfor k in range(1, n + 1):\n    # Add the k-th best element (by value, then index) to our set\n    # The k-th element in 'indices' corresponds to the k-th largest value\n    # But we need to maintain the original order for lexicographic minimality\n    # Actually, we need to pick the k largest values, and among those with same value, pick the earliest possible\n    # The sorting (-a[i], i) ensures that when we take first k, we get the k largest values with smallest indices for ties\n    # However, we must then sort these indices to maintain original order for subsequence\n    candidate_indices = indices[:k]\n    candidate_indices.sort()  # sort by original index to get subsequence order\n    optimal_indices[k] = candidate_indices\n\n# Answer queries\nanswers = []\nfor k, pos in queries:\n    idx = optimal_indices[k][pos - 1]  # pos is 1-indexed\n    answers.append(a[idx])\n\nprint('\\n'.join(map(str, answers)))", "complexity_estimate": null, "runtime_sec": 31.049904108047485}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.07671117782593}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 147.6778540611267}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.67523217201233}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.78483200073242}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 130.91894793510437}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP over gcd values\n    INF = 10**18\n    dp = defaultdict(lambda: INF)\n    dp[0] = 0\n    \n    for li, ci in zip(l, c):\n        new_dp = dp.copy()\n        for g_val, cost in dp.items():\n            new_g = math.gcd(g_val, li)\n            if cost + ci < new_dp[new_g]:\n                new_dp[new_g] = cost + ci\n        dp = new_dp\n    \n    result = dp.get(1, INF)\n    print(result if result != INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.639332056045532}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    \n    # Calculate time needed to travel D meters at speed S\n    # Since all values are integers, we can compare D <= T * S\n    # This avoids floating point comparison\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.9024658203125}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.75027990341187}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 58.4978609085083}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    W, H = int(data[0]), int(data[1])\n    grid = []\n    idx = 2\n    for _ in range(H):\n        row = list(data[idx])\n        idx += 1\n        grid.append(row)\n    \n    # Find player start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # BFS to find all reachable safe squares\n    visited = [[False] * W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    gold_count = 0\n    \n    while queue:\n        r, c = queue.pop(0)\n        \n        # Check if current cell has gold\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        has_adjacent_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if grid[nr][nc] == 'T':\n                    has_adjacent_trap = True\n                    break\n        \n        # If there's an adjacent trap, we cannot move further from this cell\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                # Can only move to non-wall, non-trap, unvisited cells\n                if grid[nr][nc] != '#' and grid[nr][nc] != 'T' and not visited[nr][nc]:\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.210548877716064}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 146.34246397018433}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.04297113418579}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.46774506568909}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.48739385604858}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0  # current prefix sum of diff\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            need = target - current_height\n            if need > m - days_used:\n                return False\n            days_used += need\n            current += need\n            # Mark the end of the watering range\n            end = i + w\n            if end < n:\n                diff[end] -= need\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum possible minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.36720371246338}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.483580350875854}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.27234721183777}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.18909692764282}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 37.589510917663574}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.55056428909302}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_split_equally(a):\n    \"\"\"Check if we can split 4 numbers into two groups with equal sum.\"\"\"\n    total = sum(a)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    \n    # Try all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (excluding empty subset)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            return True\n    return False\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = list(map(int, data[:4]))\n    result = \"YES\" if can_split_equally(a) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.123693704605103}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    seen = set()\n    result = []\n    \n    # Traverse from right to left to keep rightmost occurrences\n    for i in range(n - 1, -1, -1):\n        if a[i] not in seen:\n            seen.add(a[i])\n            result.append(a[i])\n    \n    # Reverse to restore original order\n    result.reverse()\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.833778858184814}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.62736082077026}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort the first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to compute final score given five times\n    def final_score(five_times):\n        sorted_times = sorted(five_times)\n        # Discard best (smallest) and worst (largest)\n        return sum(sorted_times[1:4]) / 3.0\n    \n    # Case 1: Check if already winning regardless of last solve\n    # We need to see if even with worst possible last solve (20.00), final score <= target\n    worst_last = 20.00\n    five_times_worst = times + [worst_last]\n    if final_score(five_times_worst) <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 2: Check if impossible to win\n    # Best possible last solve is 1.00\n    best_last = 1.00\n    five_times_best = times + [best_last]\n    if final_score(five_times_best) > target:\n        print(\"impossible\")\n        return\n    \n    # Case 3: Binary search for worst possible last solve\n    lo, hi = 1.00, 20.00\n    eps = 1e-9\n    for _ in range(100):  # enough iterations for precision\n        mid = (lo + hi) / 2.0\n        five_times = times + [mid]\n        if final_score(five_times) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Output with exactly two decimal places\n    print(f\"{lo:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.777716875076294}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input\n    N = input().strip()\n    \n    # Check if it's a palindrome by comparing with its reverse\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.33486819267273}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.09306812286377}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Fast I/O\ninput = sys.stdin.readline\n\n# Read N\nN = int(input().strip())\n\n# Read initial strings\nstrings = [input().strip() for _ in range(N)]\n\n# Read operations\noperations = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\n# Track which strings are still active (not emptied)\n# Initially all strings are active\nactive = [True] * N\n\n# Process operations in order\nfor a, b in operations:\n    # Convert to 0-based indexing\n    a_idx = a - 1\n    b_idx = b - 1\n    \n    # Append string b to string a\n    strings[a_idx] += strings[b_idx]\n    \n    # Empty string b\n    strings[b_idx] = \"\"\n    active[b_idx] = False\n\n# Find the last remaining non-empty string\nfor i in range(N):\n    if active[i]:\n        print(strings[i])\n        break", "complexity_estimate": null, "runtime_sec": 19.71127676963806}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data)\n    # Total cost: train fare X + bus fare Y/2 (since Y is even)\n    total_cost = X + Y // 2\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.926002979278564}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Fast I/O\ninput = sys.stdin.readline\n\n# Main function\ndef solve():\n    n = int(input().strip())\n    \n    # Stack to track events that have actually happened\n    actual_stack = []\n    # Set to quickly check if an event is currently in the actual stack\n    actual_set = set()\n    \n    # List to store output lines\n    output_lines = []\n    \n    for _ in range(n):\n        line = input().strip()\n        if not line:\n            continue\n        \n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == 'E':\n            # Event: add to actual stack\n            event = parts[1]\n            actual_stack.append(event)\n            actual_set.add(event)\n            \n        elif cmd == 'D':\n            # Dream: remove last r events from actual stack\n            r = int(parts[1])\n            for _ in range(r):\n                event = actual_stack.pop()\n                actual_set.remove(event)\n            \n        elif cmd == 'S':\n            # Scenario: check consistency\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Parse scenario events into (event, happened) pairs\n            scenario = []\n            for e in scenario_events:\n                if e.startswith('!'):\n                    scenario.append((e[1:], False))  # Event should NOT happen\n                else:\n                    scenario.append((e, True))       # Event should happen\n            \n            # Check if scenario is consistent with current actual events\n            consistent_with_actual = True\n            for event, should_happen in scenario:\n                is_in_actual = event in actual_set\n                if should_happen and not is_in_actual:\n                    consistent_with_actual = False\n                    break\n                if not should_happen and is_in_actual:\n                    consistent_with_actual = False\n                    break\n            \n            if consistent_with_actual:\n                output_lines.append(\"Yes\")\n                continue\n            \n            # If not consistent with actual, check if adding a dream makes it consistent\n            # We need to find smallest r such that removing last r events makes scenario consistent\n            min_r = None\n            \n            # Try all possible r from 1 to len(actual_stack)\n            for r in range(1, len(actual_stack) + 1):\n                # Check consistency after removing last r events\n                consistent = True\n                # Create temporary set of events after dream\n                temp_set = set(actual_stack[:-r]) if r < len(actual_stack) else set()\n                \n                for event, should_happen in scenario:\n                    is_in_temp = event in temp_set\n                    if should_happen and not is_in_temp:\n                        consistent = False\n                        break\n                    if not should_happen and is_in_temp:\n                        consistent = False\n                        break\n                \n                if consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                output_lines.append(f\"{min_r} Just A Dream\")\n            else:\n                output_lines.append(\"Plot Error\")\n    \n    # Print all output\n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.205904960632324}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N, T = map(int, input().split())\n    dishes = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        dishes.append((a, b))\n    \n    # Sort dishes by eating time (A_i) to help with DP\n    dishes.sort()\n    \n    # DP array: dp[t] = max happiness achievable with total eating time exactly t\n    # We use -1 to indicate unreachable states initially\n    dp = [-1] * (T + 1)\n    dp[0] = 0  # Base case: no time spent, no happiness\n    \n    # Process each dish\n    for a, b in dishes:\n        # Update DP from right to left to avoid using the same dish multiple times\n        for t in range(T - 1, -1, -1):\n            if dp[t] != -1:\n                new_time = t + a\n                if new_time < T:\n                    dp[new_time] = max(dp[new_time], dp[t] + b)\n                else:\n                    # If adding this dish would exceed T, we can still order it\n                    # as long as we order before T-0.5, which means new_time <= T\n                    # Actually, we can always add the dish's happiness if we can order it\n                    # The key insight: we can order a dish even if we don't have time to eat it completely\n                    # because we can continue eating after T-0.5\n                    # So we update dp[T] as well\n                    dp[T] = max(dp[T], dp[t] + b)\n    \n    # The answer is the maximum value in dp array\n    answer = max(dp)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 36.10557579994202}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data)\n    # All possible routes with 2 flights:\n    # A->B->C: P + Q\n    # A->C->B: R + Q\n    # B->A->C: P + R\n    # B->C->A: Q + R\n    # C->A->B: R + P\n    # C->B->A: Q + P\n    # Since addition is commutative, we only need to consider 3 sums:\n    sums = [P + Q, Q + R, R + P]\n    print(min(sums))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.544088125228882}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 146.38835287094116}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.82920598983765}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    left, right = 0, n - 1\n    moves = 0\n    alice_total, bob_total = 0, 0\n    alice_last, bob_last = 0, 0\n    \n    while left <= right:\n        # Alice's turn\n        current_sum = 0\n        while left <= right and current_sum <= bob_last:\n            current_sum += a[left]\n            left += 1\n        alice_total += current_sum\n        alice_last = current_sum\n        moves += 1\n        \n        if left > right:\n            break\n        \n        # Bob's turn\n        current_sum = 0\n        while left <= right and current_sum <= alice_last:\n            current_sum += a[right]\n            right -= 1\n        bob_total += current_sum\n        bob_last = current_sum\n        moves += 1\n    \n    print(moves, alice_total, bob_total)", "complexity_estimate": null, "runtime_sec": 13.482950925827026}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 46.998733043670654}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.37192392349243}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A_i = int(data[idx]); idx += 1\n        # Count days participant eats chocolate: day 1, A_i+1, 2A_i+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A_i\n    \n    # Total prepared = eaten + remaining\n    result = total_eaten + X\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.26445484161377}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 86.72762084007263}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 72.79948115348816}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 66.31281399726868}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.424222946167}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Read input efficiently\ninput = sys.stdin.readline\n\n# Read n\nn = int(input().strip())\n\n# Read direction string and jump lengths\ns = input().strip()\nd = list(map(int, input().split()))\n\n# Track visited cells to detect cycles\nvisited = [False] * n\n\n# Start from cell 0 (1-based index 1)\npos = 0\n\n# Simulate jumps until we exit or detect a cycle\nwhile 0 <= pos < n:\n    # If we've visited this cell before, we're in a cycle -> INFINITE\n    if visited[pos]:\n        print(\"INFINITE\")\n        sys.exit()\n    \n    # Mark current cell as visited\n    visited[pos] = True\n    \n    # Calculate next position based on direction and jump length\n    if s[pos] == '>':\n        pos += d[pos]\n    else:  # s[pos] == '<'\n        pos -= d[pos]\n\n# If we exit the loop, we've jumped out of bounds -> FINITE\nprint(\"FINITE\")", "complexity_estimate": null, "runtime_sec": 16.91213297843933}

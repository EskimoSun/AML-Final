{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ninput = sys.stdin.readline\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n    \n    def update(self, idx, delta):\n        while idx <= self.n:\n            self.bit[idx] ^= delta\n            idx += idx & -idx\n    \n    def query(self, idx):\n        res = 0\n        while idx > 0:\n            res ^= self.bit[idx]\n            idx -= idx & -idx\n        return res\n    \n    def range_query(self, l, r):\n        return self.query(r) ^ self.query(l - 1)\n\ndef solve():\n    N, K, P = map(int, input().split())\n    \n    # Compress coordinates\n    rows = []\n    cols = []\n    rooks = []\n    \n    for _ in range(K):\n        r, c, x = map(int, input().split())\n        rows.append(r)\n        cols.append(c)\n        rooks.append((r, c, x))\n    \n    moves = []\n    for _ in range(P):\n        r1, c1, r2, c2 = map(int, input().split())\n        rows.append(r1)\n        cols.append(c1)\n        rows.append(r2)\n        cols.append(r2)\n        moves.append((r1, c1, r2, c2))\n    \n    # Coordinate compression\n    row_map = {v: i+1 for i, v in enumerate(sorted(set(rows)))}\n    col_map = {v: i+1 for i, v in enumerate(sorted(set(cols)))}\n    \n    max_row = len(row_map)\n    max_col = len(col_map)\n    \n    # Initialize data structures\n    row_xor = Fenwick(max_row)\n    col_xor = Fenwick(max_col)\n    \n    # Track rooks by position\n    rook_at = {}\n    row_count = [0] * (max_row + 1)\n    col_count = [0] * (max_col + 1)\n    \n    # Place initial rooks\n    for r, c, x in rooks:\n        rr = row_map[r]\n        cc = col_map[c]\n        rook_at[(rr, cc)] = x\n        row_xor.update(rr, x)\n        col_xor.update(cc, x)\n        row_count[rr] += 1\n        col_count[cc] += 1\n    \n    # Helper functions\n    def is_attacked(r, c):\n        row_val = row_xor.query(r) ^ (rook_at.get((r, c), 0) if (r, c) in rook_at else 0)\n        col_val = col_xor.query(c) ^ (rook_at.get((r, c), 0) if (r, c) in rook_at else 0)\n        return (row_val ^ col_val) > 0\n    \n    def move_rook(r1, c1, r2, c2):\n        rr1 = row_map[r1]\n        cc1 = col_map[c1]\n        rr2 = row_map[r2]\n        cc2 = col_map[c2]\n        \n        x = rook_at.pop((rr1, cc1))\n        \n        # Remove from old position\n        row_xor.update(rr1, x)\n        col_xor.update(cc1, x)\n        row_count[rr1] -= 1\n        col_count[cc1] -= 1\n        \n        # Add to new position\n        rook_at[(rr2, cc2)] = x\n        row_xor.update(rr2, x)\n        col_xor.update(cc2, x)\n        row_count[rr2] += 1\n        col_count[cc2] += 1\n    \n    # Process moves\n    results = []\n    for r1, c1, r2, c2 in moves:\n        move_rook(r1, c1, r2, c2)\n        \n        # Count attacked fields\n        attacked = 0\n        \n        # Count rows with non-zero XOR\n        rows_with_xor = 0\n        for i in range(1, max_row + 1):\n            if row_xor.query(i) > 0:\n                rows_with_xor += 1\n        \n        # Count columns with non-zero XOR\n        cols_with_xor = 0\n        for i in range(1, max_col + 1):\n            if col_xor.query(i) > 0:\n                cols_with_xor += 1\n        \n        # Total attacked fields = rows_with_xor * N + cols_with_xor * N - 2 * rows_with_xor * cols_with_xor\n        # But we need to handle the actual board size\n        attacked = rows_with_xor * N + cols_with_xor * N - 2 * rows_with_xor * cols_with_xor\n        \n        # Adjust for double counting of intersections\n        # Actually the formula above is correct for counting attacked fields\n        # where a field is attacked if row_xor ^ col_xor > 0\n        # This simplifies to: attacked = (N - cols_with_xor) * rows_with_xor + (N - rows_with_xor) * cols_with_xor\n        attacked = (N - cols_with_xor) * rows_with_xor + (N - rows_with_xor) * cols_with_xor\n        \n        results.append(str(attacked))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 56.66043829917908}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Initialize result string with 'a'\n    result = ['a'] * n\n    \n    # Process from longest substring length to shortest\n    for length in range(n, 0, -1):\n        count = c[length-1]\n        if count == 0:\n            continue\n        \n        # Find positions where we can place blocks of same letters\n        i = 0\n        while i < n and count > 0:\n            # Skip if this position already has a different letter\n            if i > 0 and result[i] != result[i-1]:\n                i += 1\n                continue\n            \n            # Check if we can place a block starting at i\n            can_place = True\n            # Ensure we don't go out of bounds\n            if i + length > n:\n                i += 1\n                continue\n            \n            # Check if all positions in the block are currently the same\n            for j in range(i, i+length):\n                if result[j] != result[i]:\n                    can_place = False\n                    break\n            \n            if can_place:\n                # Place the block by changing the letter to next available\n                # Find next available letter\n                current_char = result[i]\n                next_char = chr(ord(current_char) + 1)\n                if next_char > 'z':\n                    next_char = 'a'\n                \n                # Change the block to next_char\n                for j in range(i, i+length):\n                    result[j] = next_char\n                \n                count -= 1\n                i += length  # Skip this block\n            else:\n                i += 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.232415199279785}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a = int(data)\n    # Check if the number is prime\n    if a < 2:\n        print(0)\n        return\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            print(0)\n            return\n    print(1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.009896755218506}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\n\nclass Node:\n    __slots__ = ('val', 'left', 'right', 'size')\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.size = 1\n\ndef size(node):\n    return node.size if node else 0\n\ndef update(node):\n    if node:\n        node.size = 1 + size(node.left) + size(node.right)\n\ndef rotate_right(node):\n    left_child = node.left\n    node.left = left_child.right\n    left_child.right = node\n    update(node)\n    update(left_child)\n    return left_child\n\ndef rotate_left(node):\n    right_child = node.right\n    node.right = right_child.left\n    right_child.left = node\n    update(node)\n    update(right_child)\n    return right_child\n\ndef splay(root, val, depth_counter):\n    if not root or root.val == val:\n        return root\n    if val < root.val:\n        if not root.left:\n            return root\n        if val < root.left.val:\n            root.left.left = splay(root.left.left, val, depth_counter)\n            root = rotate_right(root)\n        elif val > root.left.val:\n            root.left.right = splay(root.left.right, val, depth_counter)\n            if root.left.right:\n                root.left = rotate_left(root.left)\n        if root.left:\n            depth_counter[0] += 1 + size(root.left.right)\n            root = rotate_right(root)\n    else:\n        if not root.right:\n            return root\n        if val < root.right.val:\n            root.right.left = splay(root.right.left, val, depth_counter)\n            if root.right.left:\n                root.right = rotate_right(root.right)\n        elif val > root.right.val:\n            root.right.right = splay(root.right.right, val, depth_counter)\n            root = rotate_left(root)\n        if root.right:\n            depth_counter[0] += 1 + size(root.right.left)\n            root = rotate_left(root)\n    return root\n\ndef insert(root, val, depth_counter):\n    if not root:\n        return Node(val)\n    root = splay(root, val, depth_counter)\n    if root.val == val:\n        return root\n    new_node = Node(val)\n    if val < root.val:\n        new_node.right = root\n        new_node.left = root.left\n        root.left = None\n    else:\n        new_node.left = root\n        new_node.right = root.right\n        root.right = None\n    update(root)\n    update(new_node)\n    return new_node\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    root = None\n    c = 0\n    out_lines = []\n    for _ in range(n):\n        val = int(next(it))\n        depth_counter = [0]\n        root = insert(root, val, depth_counter)\n        c += depth_counter[0]\n        out_lines.append(str(c))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 36.27796769142151}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:1+n]))\n\n# We need to find how many powers of 2 to add to make sum = 2^v - 1\n# Observation: 2^v - 1 in binary is v ones: 111...111 (v bits)\n# So we need to fill all bits from 0 up to some maximum\n\n# Process the array: each a[i] contributes 2^{a[i]}\n# We can think in binary: we have counts of each power\n\n# Since a_i can be up to 2e9, we can't store array of that size\n# But we only need to process carries\n\n# We'll process powers in increasing order\n# Use a dictionary to store counts of each power\nfrom collections import defaultdict\n\ncount = defaultdict(int)\nfor val in a:\n    count[val] += 1\n\n# Process carries\nanswer = 0\npowers = sorted(count.keys())\n\nfor power in powers:\n    cnt = count[power]\n    if cnt == 0:\n        continue\n    \n    # Carry over to higher powers\n    carry = cnt // 2\n    remaining = cnt % 2\n    \n    if remaining == 1:\n        # This power is present in the final sum\n        # No need to add anything for this power\n        pass\n    \n    if carry > 0:\n        # Add carry to next power\n        count[power + 1] += carry\n        # If power+1 wasn't in the dict before, we need to process it\n        if power + 1 not in count:\n            powers.append(power + 1)\n            powers.sort()\n\n# Now count contains the binary representation of the sum\n# We need to add numbers to make it all ones\n# For each power where count[power] == 0, we need to add 2^power\n# But only up to the maximum power where count[power] > 0\n\nif not count:\n    # Empty case (shouldn't happen with n >= 1)\n    print(0)\n    sys.exit(0)\n\nmax_power = max(count.keys())\n\n# We need to ensure all bits from 0 to max_power are 1\nfor power in range(max_power + 1):\n    if count[power] == 0:\n        answer += 1\n    elif count[power] > 1:\n        # This shouldn't happen after processing carries\n        # But handle just in case\n        extra = count[power] - 1\n        # Each extra can be combined to form higher powers\n        # But for our answer, we just need to know if bit is 0 or 1\n        # Since count[power] > 1, the bit is 1 (after carry processing)\n        pass\n\nprint(answer)", "runtime_sec": 40.27425789833069}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    # Integer division gives number of donuts we can buy\n    donuts_count = remaining // B\n    \n    # Calculate remaining money after buying donuts\n    result = remaining - (donuts_count * B)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 16.14785099029541}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.315712451934814}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    idx = 0\n    n = int(data[idx]); idx += 1\n    a = list(map(int, data[idx:idx + n])); idx += n\n    m = int(data[idx]); idx += 1\n    queries = []\n    for _ in range(m):\n        k = int(data[idx]); idx += 1\n        pos = int(data[idx]); idx += 1\n        queries.append((k, pos, _))\n    \n    # Sort queries by k\n    queries_sorted = sorted(queries, key=lambda x: x[0])\n    \n    # Preprocess: sort indices by value (descending), then by index (ascending for lexicographic minimality)\n    indices_sorted = sorted(range(n), key=lambda i: (-a[i], i))\n    \n    # Process queries in increasing order of k\n    result = [0] * m\n    selected_indices = []  # will maintain sorted order of indices\n    q_idx = 0\n    \n    for k, pos, query_idx in queries_sorted:\n        # Add more elements until we have k selected\n        while len(selected_indices) < k:\n            new_idx = indices_sorted[len(selected_indices)]\n            # Insert new_idx into selected_indices while keeping it sorted\n            lo, hi = 0, len(selected_indices)\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if selected_indices[mid] < new_idx:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            selected_indices.insert(lo, new_idx)\n        \n        # Now selected_indices contains exactly k indices in sorted order\n        # The optimal subsequence is a[selected_indices[0]], a[selected_indices[1]], ..., a[selected_indices[k-1]]\n        result[query_idx] = a[selected_indices[pos - 1]]\n    \n    # Output results in original query order\n    out_lines = [str(result[i]) for i in range(m)]\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.109619140625}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Check if solution exists\n    if k == 1:\n        # With only 1 color, can't have b_i != g_i\n        print(\"NO\")\n        return\n    \n    if n > k * (k - 1):\n        # Maximum distinct pairs with b_i != g_i is k*(k-1)\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using a systematic approach\n    # We'll generate all possible (b, g) pairs with b != g\n    # Then output them in an order that satisfies adjacent constraints\n    \n    pairs = []\n    # Generate all valid pairs\n    for b in range(1, k + 1):\n        for g in range(1, k + 1):\n            if b != g:\n                pairs.append((b, g))\n    \n    # We need to output exactly n pairs\n    # We'll use a greedy approach to select pairs\n    result = []\n    used = set()\n    \n    # Start with first pair\n    result.append(pairs[0])\n    used.add(pairs[0])\n    \n    # Build the sequence\n    for i in range(1, n):\n        last_b, last_g = result[-1]\n        found = False\n        \n        # Try to find a pair that:\n        # 1. Hasn't been used before\n        # 2. b != last_b\n        # 3. g != last_g\n        for pair in pairs:\n            b, g = pair\n            if pair not in used and b != last_b and g != last_g:\n                result.append(pair)\n                used.add(pair)\n                found = True\n                break\n        \n        if not found:\n            # If no perfect match, find any unused pair with b != last_b\n            for pair in pairs:\n                b, g = pair\n                if pair not in used and b != last_b:\n                    result.append(pair)\n                    used.add(pair)\n                    found = True\n                    break\n            \n            if not found:\n                # Last resort: any unused pair\n                for pair in pairs:\n                    if pair not in used:\n                        result.append(pair)\n                        used.add(pair)\n                        found = True\n                        break\n    \n    # Output the result\n    for b, g in result:\n        print(f\"{b} {g}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 38.47462558746338}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\nguests = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    guests.append((l, r))\n\n# Sort guests by (l_i + r_i) in descending order\n# This ensures we place guests with larger total space requirements first\n# which helps minimize total chairs\nsorted_guests = sorted(guests, key=lambda x: x[0] + x[1], reverse=True)\n\n# Greedy approach: try to place each guest in existing circles\n# If not possible, create a new circle\ncircles = []  # each circle stores list of (l_i, r_i) for guests in that circle\n\nfor l, r in sorted_guests:\n    placed = False\n    \n    # Try to place in existing circles\n    for circle in circles:\n        # Check if we can place this guest in this circle\n        # We need to check all possible positions in the circle\n        # Since circles are circular, we can think of inserting between any two guests\n        \n        # For a circle with k guests, there are k possible insertion points\n        # We need to check if there's enough space at some insertion point\n        \n        # The condition for inserting between guest A (with r_A) and guest B (with l_B)\n        # is: r_A >= l and r >= l_B\n        \n        # For simplicity, we'll check all possible insertion points\n        # Since n <= 10^5 and we're using greedy, this should be efficient enough\n        \n        k = len(circle)\n        for i in range(k):\n            # Insert between guest i and guest (i+1) mod k\n            prev_r = circle[i][1]\n            next_l = circle[(i + 1) % k][0]\n            \n            if prev_r >= l and r >= next_l:\n                # Can insert here\n                circle.insert(i + 1, (l, r))\n                placed = True\n                break\n        \n        if placed:\n            break\n    \n    # If couldn't place in any existing circle, create new circle\n    if not placed:\n        circles.append([(l, r)])\n\n# Calculate total chairs needed\n# For each circle, the number of chairs needed is:\n# sum of max(l_i, r_{i-1}) for all guests in the circle\n# where indices are circular\n\ntotal_chairs = 0\nfor circle in circles:\n    k = len(circle)\n    if k == 1:\n        # Special case: single guest in circle\n        l, r = circle[0]\n        total_chairs += l + r + 1\n    else:\n        # For multiple guests, we need to find arrangement that minimizes chairs\n        # This is equivalent to finding minimum of sum(max(l_i, r_{i-1}))\n        # We can try all starting points since k is small\n        \n        min_chairs_for_circle = float('inf')\n        \n        # Try each guest as starting point\n        for start in range(k):\n            chairs = 0\n            for i in range(k):\n                idx = (start + i) % k\n                prev_idx = (start + i - 1) % k\n                chairs += max(circle[idx][0], circle[prev_idx][1])\n            \n            # Add 1 for each guest (the chair they occupy)\n            chairs += k\n            min_chairs_for_circle = min(min_chairs_for_circle, chairs)\n        \n        total_chairs += min_chairs_for_circle\n\nprint(total_chairs)", "runtime_sec": 43.75180244445801}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef prime_factors(num):\n    \"\"\"Return prime factorization as dictionary {prime: exponent}\"\"\"\n    factors = {}\n    d = 2\n    while d * d <= num:\n        while num % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            num //= d\n        d += 1 if d == 2 else 2\n    if num > 1:\n        factors[num] = factors.get(num, 0) + 1\n    return factors\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Compute prime factor counts for all numbers\n    total_factors = {}\n    for num in arr:\n        factors = prime_factors(num)\n        for p, exp in factors.items():\n            total_factors[p] = total_factors.get(p, 0) + exp\n    \n    # Step 2: Determine maximum possible GCD\n    max_gcd = 1\n    for p, total_exp in total_factors.items():\n        # Each prime can contribute floor(total_exp/n) to GCD\n        common_exp = total_exp // n\n        if common_exp > 0:\n            max_gcd *= (p ** common_exp)\n    \n    # Step 3: Calculate minimum operations needed\n    operations = 0\n    for num in arr:\n        # For each number, compute how many prime factors need to be removed\n        # to reach the target GCD contribution\n        factors = prime_factors(num)\n        for p, common_exp in [(p, total_factors.get(p, 0) // n) for p in total_factors]:\n            if common_exp > 0:\n                current_exp = factors.get(p, 0)\n                if current_exp > common_exp:\n                    # Need to remove (current_exp - common_exp) factors of p\n                    operations += (current_exp - common_exp)\n    \n    print(f\"{max_gcd} {operations}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 29.63040280342102}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    f = list(map(int, data[1:1+n]))\n    \n    # Track which friends are already assigned as receivers\n    receiver = [False] * (n + 1)\n    for i in range(n):\n        if f[i] != 0:\n            receiver[f[i]] = True\n    \n    # Lists of friends who need to give (zeros) and who need to receive (not receiver)\n    givers = []\n    receivers = []\n    for i in range(1, n + 1):\n        if f[i-1] == 0:\n            givers.append(i)\n        if not receiver[i]:\n            receivers.append(i)\n    \n    # Match givers to receivers, avoiding self-gifts\n    # Sort both lists to handle cases where last giver equals last receiver\n    givers.sort()\n    receivers.sort()\n    \n    # If the last giver equals the last receiver, swap to avoid self-gift\n    if len(givers) > 0 and givers[-1] == receivers[-1]:\n        receivers[-1], receivers[-2] = receivers[-2], receivers[-1]\n    \n    # Assign receivers to givers\n    result = f[:]\n    for i in range(len(givers)):\n        idx = givers[i] - 1\n        result[idx] = receivers[i]\n    \n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.504324197769165}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef max_polygon_area(lengths):\n    \"\"\"\n    Returns the maximum area of a polygon that can be formed using a subset\n    of the given segment lengths.\n    \"\"\"\n    n = len(lengths)\n    if n < 3:\n        return 0.0\n    \n    # Sort lengths in descending order\n    lengths.sort(reverse=True)\n    \n    # Use DP to find maximum perimeter for each possible number of sides\n    total_sum = sum(lengths)\n    max_sides = min(n, 80)  # n <= 80 from constraints\n    \n    # dp[k][s] = whether we can form k sides with total length s\n    dp = [[False] * (total_sum + 1) for _ in range(max_sides + 1)]\n    dp[0][0] = True\n    \n    for length in lengths:\n        # Update DP backwards to avoid reusing the same segment multiple times\n        for k in range(max_sides, 0, -1):\n            for s in range(total_sum, length - 1, -1):\n                if dp[k - 1][s - length]:\n                    dp[k][s] = True\n    \n    max_area = 0.0\n    \n    # For each possible number of sides k >= 3\n    for k in range(3, max_sides + 1):\n        # For each possible perimeter p\n        for p in range(1, total_sum + 1):\n            if dp[k][p]:\n                # Check polygon inequality: longest side < half perimeter\n                # Since lengths are sorted descending, first k lengths are the ones used\n                # We need to ensure we can actually select k segments with sum p\n                # where each segment < p/2\n                \n                # We can approximate by checking if we can form a polygon\n                # For a polygon with k sides and perimeter p, maximum area occurs\n                # when polygon is regular (all sides equal)\n                side_length = p / k\n                \n                # Area of regular k-gon with side length s\n                # Formula: (k * s^2) / (4 * tan(pi/k))\n                if k == 3:\n                    # Triangle: Heron's formula for equilateral triangle\n                    area = (math.sqrt(3) / 4) * (side_length ** 2)\n                elif k == 4:\n                    # Square\n                    area = side_length ** 2\n                else:\n                    # Regular polygon\n                    area = (k * side_length ** 2) / (4 * math.tan(math.pi / k))\n                \n                max_area = max(max_area, area)\n    \n    return max_area\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    lengths = list(map(int, data[1:1+n]))\n    \n    result = max_polygon_area(lengths)\n    \n    # Format output with sufficient precision\n    print(f\"{result:.3f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 42.20051550865173}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for length in l:\n        g = math.gcd(g, length)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP array: dp[gcd_value] = minimal cost to achieve that gcd\n    INF = 10**18\n    dp = {}\n    dp[0] = 0  # gcd 0 corresponds to no cards selected\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for g_val, cost in dp.items():\n            new_g = math.gcd(g_val, l[i])\n            new_cost = cost + c[i]\n            if new_g not in new_dp or new_cost < new_dp[new_g]:\n                new_dp[new_g] = new_cost\n        dp = new_dp\n    \n    # Answer is minimal cost to achieve gcd = 1\n    if 1 in dp:\n        print(dp[1])\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.044657468795776}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data[:3])\n    # Calculate time needed to travel D meters at speed S meters per minute\n    time_needed = D / S\n    # Compare with available time T\n    if time_needed <= T:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.765764236450195}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\n# Read input\nk = int(sys.stdin.readline().strip())\nn = int(sys.stdin.readline().strip())\n\n# Build adjacency list\nadj = [[] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    line = list(map(int, sys.stdin.readline().split()))\n    d = line[0]\n    neighbors = line[1:]\n    for neighbor in neighbors:\n        adj[i].append(neighbor)\n        adj[neighbor].append(i)\n\n# Remove duplicates from adjacency lists\nfor i in range(1, n + 1):\n    adj[i] = list(set(adj[i]))\n\n# DP on tree (graph is a tree due to constraints)\n# dp[node][0] = max drones in subtree when node has no drone\n# dp[node][1] = max drones in subtree when node has drone\n\ndp0 = [0] * (n + 1)\ndp1 = [0] * (n + 1)\nvisited = [False] * (n + 1)\n\n# DFS to compute DP\nstack = [(1, 0, False)]  # (node, parent, visited_flag)\norder = []\nwhile stack:\n    node, parent, visited_flag = stack.pop()\n    if visited_flag:\n        # Post-order processing\n        dp0[node] = 0\n        dp1[node] = 1\n        for child in adj[node]:\n            if child == parent:\n                continue\n            dp0[node] += max(dp0[child], dp1[child])\n            dp1[node] += dp0[child]\n    else:\n        if visited[node]:\n            continue\n        visited[node] = True\n        stack.append((node, parent, True))\n        for child in adj[node]:\n            if child != parent:\n                stack.append((child, node, False))\n\n# Find maximum drones possible\nmax_drones = max(dp0[1], dp1[1])\n\n# Check if k is feasible\nif k <= max_drones:\n    print(\"possible\")\nelse:\n    print(\"impossible\")", "runtime_sec": 29.502407789230347}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\n\nn = int(lines[0])\nc = list(map(int, lines[1:1+n]))\n\n# Total number of people\nP = sum(c)\n\n# Validate input constraints\nif P > 365:\n    # This case requires handling when P > 365, but probability would be 0\n    # Since log10(0) is undefined, we output -inf\n    print(\"-inf\")\n    sys.exit(0)\n\n# Number of distinct birthdays\nk = n\n\n# Calculate probability using combinatorial formula:\n# b = (365! / (365-k)!) * (1/365)^P * (P! / (c1! * c2! * ... * ck!))\n# Then take log10\n\n# Compute log10 of factorial terms using log10 gamma for large numbers\ndef log10_factorial(x):\n    return math.lgamma(x + 1) / math.log(10)\n\n# Compute log10 of numerator: log10(365! / (365-k)!)\n# This is sum_{i=0}^{k-1} log10(365 - i)\nlog_numerator = 0.0\nfor i in range(k):\n    log_numerator += math.log10(365 - i)\n\n# Compute log10 of (1/365)^P\nlog_power = -P * math.log10(365)\n\n# Compute log10 of multinomial coefficient: log10(P! / (c1! * c2! * ... * ck!))\nlog_multinomial = log10_factorial(P)\nfor ci in c:\n    log_multinomial -= log10_factorial(ci)\n\n# Total log probability\nlog_prob = log_numerator + log_power + log_multinomial\n\n# Output with sufficient precision\nprint(f\"{log_prob:.15f}\")", "runtime_sec": 28.66242003440857}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to find all reachable safe squares\n    from collections import deque\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        \n        # Check if current cell has gold\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        has_adjacent_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 'T':\n                has_adjacent_trap = True\n                break\n        \n        # If adjacent to trap, cannot move further from this cell\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] != '#':\n                visited[nr][nc] = True\n                queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.245617628097534}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    d, b, f, t0, t1, t2 = map(int, data)\n    \n    # DP state: dp[day][bling][fruits][t0][t1][t2]\n    # We'll use a dictionary to store reachable states\n    # Initialize with starting state\n    start_state = (b, f, t0, t1, t2)\n    dp = {start_state: True}\n    \n    for day in range(d):\n        new_dp = {}\n        for state in dp:\n            bling, fruits, t0_curr, t1_curr, t2_curr = state\n            \n            # Harvest fruits from trees that are ready today\n            harvest = t0_curr\n            fruits_after_harvest = fruits + harvest\n            \n            # Trees age: t0 becomes t1, t1 becomes t2, t2 becomes new t0 (after 3 days)\n            # But we need to track trees that will yield in 0,1,2 days\n            # After today, trees that yielded today (t0) become trees that will yield in 2 days\n            # t1 becomes trees that will yield in 0 days tomorrow\n            # t2 becomes trees that will yield in 1 day tomorrow\n            \n            # We'll consider all possible actions for today\n            # Actions: sell fruits, plant fruits, buy exotic fruit, sell exotic fruit, plant exotic fruit\n            # Since we can do any number of actions in any order, we need to consider all combinations\n            \n            # First, consider selling normal fruits\n            for sell_normal in range(fruits_after_harvest + 1):\n                fruits_after_sell = fruits_after_harvest - sell_normal\n                bling_after_sell = bling + sell_normal * 100\n                \n                # Consider planting normal fruits\n                for plant_normal in range(fruits_after_sell + 1):\n                    fruits_after_plant = fruits_after_sell - plant_normal\n                    # When planting, the tree will yield in 3 days\n                    # So it becomes a tree that yields in 2 days tomorrow\n                    \n                    # Consider buying exotic fruit (at most once per day)\n                    for buy_exotic in [0, 1]:\n                        if buy_exotic == 1 and bling_after_sell >= 400:\n                            bling_after_buy = bling_after_sell - 400\n                            # We have 1 exotic fruit to use\n                            # Consider selling or planting it\n                            for exotic_action in ['sell', 'plant', 'none']:\n                                bling_final = bling_after_buy\n                                exotic_trees_added = 0\n                                \n                                if exotic_action == 'sell':\n                                    bling_final += 500\n                                elif exotic_action == 'plant':\n                                    exotic_trees_added = 1\n                                \n                                # Update tree counts for tomorrow\n                                # Normal trees: t0 becomes t2 (since they yielded today)\n                                # t1 becomes new t0\n                                # t2 becomes new t1\n                                # Newly planted trees become new t2\n                                new_t0 = t1_curr\n                                new_t1 = t2_curr\n                                new_t2 = t0_curr + plant_normal  # t0 yielded today, newly planted yield in 2 days\n                                \n                                # Exotic trees follow same pattern but separate count\n                                # We don't have exotic trees initially, so we only track newly planted ones\n                                # For simplicity, we'll treat exotic fruits/trees separately\n                                # Since we can have at most 1 exotic tree per day planted, and they yield every 3 days\n                                # We need to track exotic tree ages too\n                                # For now, we'll simplify: exotic trees yield 3 exotic fruits every 3 days\n                                # We'll track exotic fruits and exotic tree ages similarly\n                                \n                                # For this solution, we'll use a simplified approach:\n                                # Since d <= 40 and numbers are small, we can brute force all possibilities\n                                # We'll use a more comprehensive state representation\n                                \n                                # Create new state\n                                new_state = (bling_final, fruits_after_plant, new_t0, new_t1, new_t2)\n                                new_dp[new_state] = True\n                        else:\n                            # No exotic fruit bought\n                            bling_final = bling_after_sell\n                            new_t0 = t1_curr\n                            new_t1 = t2_curr\n                            new_t2 = t0_curr + plant_normal\n                            new_state = (bling_final, fruits_after_plant, new_t0, new_t1, new_t2)\n                            new_dp[new_state] = True\n        \n        dp = new_dp\n    \n    # Find maximum bling after d days\n    max_bling = 0\n    for state in dp:\n        bling, _, _, _, _ = state\n        max_bling = max(max_bling, bling)\n    \n    print(max_bling)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 57.48705196380615}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    # Find maximum k such that k*(k+1)//2 <= a+b\n    total = a + b\n    left, right = 0, int(2e9)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if mid * (mid + 1) // 2 <= total:\n            left = mid\n        else:\n            right = mid - 1\n    k = left\n    \n    # Generate all notes from 1 to k\n    notes = list(range(1, k + 1))\n    \n    # Greedy assignment: try to assign largest notes to first day\n    day1 = []\n    day2 = []\n    remaining_a = a\n    \n    for note in reversed(notes):\n        if note <= remaining_a:\n            day1.append(note)\n            remaining_a -= note\n        else:\n            day2.append(note)\n    \n    # Output\n    print(len(day1))\n    if day1:\n        print(' '.join(map(str, day1)))\n    else:\n        print()\n    \n    print(len(day2))\n    if day2:\n        print(' '.join(map(str, day2)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.815938472747803}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # The game is equivalent to a Nim game where each piece of length x\n    # corresponds to a Grundy number g(x) = mex{g(i) XOR g(x-i) for 1 <= i <= x-1}\n    # For this specific breaking game, the pattern is:\n    # g(1) = 0 (terminal position, cannot break)\n    # g(2) = mex{g(1) XOR g(1)} = mex{0 XOR 0} = mex{0} = 1\n    # g(3) = mex{g(1) XOR g(2), g(2) XOR g(1)} = mex{0 XOR 1, 1 XOR 0} = mex{1, 1} = mex{1} = 0\n    # g(4) = mex{g(1) XOR g(3), g(2) XOR g(2), g(3) XOR g(1)} = mex{0 XOR 0, 1 XOR 1, 0 XOR 0} = mex{0, 0, 0} = 1\n    # This gives pattern: g(x) = 1 if x is even, 0 if x is odd\n    \n    # Alice wins if g(n) != 0 (since she starts)\n    # So Alice wins if n is even\n    \n    if n % 2 == 0:\n        print(\"Alice\")\n        # For even n, breaking off 1 always works:\n        # After breaking n into 1 and n-1:\n        # - g(1) = 0\n        # - g(n-1) = 0 (since n-1 is odd)\n        # Total XOR = 0 XOR 0 = 0, which is losing position for Bob\n        print(1)\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.638209342956543}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\nclass FenwickTree:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 2)\n    \n    def update(self, idx, delta):\n        while idx <= self.n:\n            self.bit[idx] += delta\n            idx += idx & -idx\n    \n    def query(self, idx):\n        res = 0\n        while idx > 0:\n            res += self.bit[idx]\n            idx -= idx & -idx\n        return res\n    \n    def find_kth(self, k):\n        pos = 0\n        bit_mask = 1 << (self.n.bit_length() - 1)\n        while bit_mask:\n            next_pos = pos + bit_mask\n            if next_pos <= self.n and self.bit[next_pos] < k:\n                k -= self.bit[next_pos]\n                pos = next_pos\n            bit_mask >>= 1\n        return pos + 1\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    Q = int(input_data[0])\n    idx = 1\n    \n    max_n = Q + 5\n    ft = FenwickTree(max_n)\n    \n    creation_to_plot = [0] * (max_n + 1)\n    plot_to_creation = [0] * (max_n + 1)\n    \n    creation_idx = 1\n    plot_idx = 1\n    \n    output_lines = []\n    \n    for _ in range(Q):\n        q = int(input_data[idx]); idx += 1\n        x = int(input_data[idx]); idx += 1\n        \n        if q == 1:\n            actual_plot_pos = ft.find_kth(x)\n            creation_to_plot[creation_idx] = actual_plot_pos\n            plot_to_creation[actual_plot_pos] = creation_idx\n            ft.update(actual_plot_pos, 1)\n            creation_idx += 1\n        else:\n            output_lines.append(str(plot_to_creation[x]))\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 28.372385501861572}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    operations = 0\n    current = 0\n    \n    for i in range(n):\n        # Apply previous range updates\n        current += diff[i]\n        needed = max(0, target - (heights[i] + current))\n        \n        if needed > 0:\n            operations += needed\n            if operations > m:\n                return False\n            \n            # Water w contiguous flowers starting at i\n            current += needed\n            # Mark the end of the watering effect\n            if i + w < n:\n                diff[i + w] -= needed\n    \n    return operations <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n        \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3+n]))\n    \n    # Binary search for the maximum minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.229493141174316}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 16.454208850860596}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [None] * (4 * n)\n    \n    def _apply(self, node, l, r, params):\n        A, B, L = params\n        length = r - l + 1\n        first = ((l - L + 1) * A) % B\n        last = ((r - L + 1) * A) % B\n        if B == 1:\n            total = 0\n        else:\n            total = (first + last) * length // 2\n        self.tree[node] = total\n        self.lazy[node] = params\n    \n    def _push(self, node, l, r):\n        if self.lazy[node] is not None:\n            mid = (l + r) // 2\n            self._apply(node * 2, l, mid, self.lazy[node])\n            self._apply(node * 2 + 1, mid + 1, r, self.lazy[node])\n            self.lazy[node] = None\n    \n    def update(self, ql, qr, A, B, L):\n        self._update(1, 1, self.n, ql, qr, (A, B, L))\n    \n    def _update(self, node, l, r, ql, qr, params):\n        if ql > r or qr < l:\n            return\n        if ql <= l and r <= qr:\n            self._apply(node, l, r, params)\n            return\n        self._push(node, l, r)\n        mid = (l + r) // 2\n        self._update(node * 2, l, mid, ql, qr, params)\n        self._update(node * 2 + 1, mid + 1, r, ql, qr, params)\n        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n    \n    def query(self, ql, qr):\n        return self._query(1, 1, self.n, ql, qr)\n    \n    def _query(self, node, l, r, ql, qr):\n        if ql > r or qr < l:\n            return 0\n        if ql <= l and r <= qr:\n            return self.tree[node]\n        self._push(node, l, r)\n        mid = (l + r) // 2\n        return self._query(node * 2, l, mid, ql, qr) + self._query(node * 2 + 1, mid + 1, r, ql, qr)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n    \n    seg = SegmentTree(N)\n    output = []\n    \n    for _ in range(Q):\n        t = int(next(it))\n        if t == 1:\n            L = int(next(it))\n            R = int(next(it))\n            A = int(next(it))\n            B = int(next(it))\n            seg.update(L, R, A, B, L)\n        else:\n            L = int(next(it))\n            R = int(next(it))\n            output.append(str(seg.query(L, R)))\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 46.34730792045593}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\n# Function to compute number of swaps in insertion sort for a given permutation\ndef count_swaps(arr):\n    n = len(arr)\n    # Create a copy to avoid modifying original\n    a = arr[:]\n    swaps = 0\n    for i in range(1, n):\n        j = i\n        while j > 0 and a[j] < a[j - 1]:\n            a[j], a[j - 1] = a[j - 1], a[j]\n            swaps += 1\n            j -= 1\n    return swaps\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    perm = list(map(int, data[1:1 + n]))\n    \n    # Step 1: Compute original number of swaps\n    original_swaps = count_swaps(perm)\n    \n    # Step 2: For each pair (i, j) with i < j, compute swaps after swapping\n    min_swaps = original_swaps  # initialize with original\n    count_pairs = 0\n    \n    # Precompute positions for O(1) lookup\n    pos = [0] * n\n    for idx, val in enumerate(perm):\n        pos[val] = idx\n    \n    # For each pair (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Swap elements at i and j\n            perm[i], perm[j] = perm[j], perm[i]\n            \n            # Compute swaps efficiently\n            # The change in swaps depends on relative positions and values\n            # We can compute by analyzing the inversion count change\n            \n            # Count inversions involving positions between i and j\n            # When swapping a[i] and a[j], inversions change for elements between them\n            swaps_change = 0\n            a_i, a_j = perm[i], perm[j]\n            \n            # For elements between i and j\n            for k in range(i + 1, j):\n                if a_i < perm[k] < a_j:\n                    # Both comparisons change\n                    swaps_change += 2\n                elif perm[k] < a_i or perm[k] > a_j:\n                    # One comparison changes\n                    swaps_change += 1\n                # else: no change when perm[k] == a_i or a_j (impossible here)\n            \n            # Also consider the swap itself\n            if a_i > a_j:\n                swaps_change -= 1  # swapping fixes one inversion\n            else:\n                swaps_change += 1  # swapping creates one inversion\n            \n            new_swaps = original_swaps + swaps_change\n            \n            if new_swaps < min_swaps:\n                min_swaps = new_swaps\n                count_pairs = 1\n            elif new_swaps == min_swaps:\n                count_pairs += 1\n            \n            # Swap back for next iteration\n            perm[i], perm[j] = perm[j], perm[i]\n    \n    print(f\"{min_swaps} {count_pairs}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 46.57127404212952}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    total = 0.0\n    \n    idx = 1\n    for _ in range(n):\n        x_str = data[idx]\n        u = data[idx + 1]\n        idx += 2\n        \n        if u == \"JPY\":\n            total += int(x_str)\n        else:  # BTC\n            total += float(x_str) * 380000.0\n    \n    print(f\"{total:.10f}\".rstrip('0').rstrip('.'))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 15.569931745529175}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 246234 tokens (244634 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 13.211763381958008}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_split_equally(a):\n    \"\"\"Check if we can split 4 bags into two groups with equal sum.\"\"\"\n    total = sum(a)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    \n    # Try all subsets of the 4 bags (2^4 = 16 possibilities)\n    for mask in range(1 << 4):\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            return True\n    return False\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = list(map(int, data[:4]))\n    result = \"YES\" if can_split_equally(a) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 22.80265474319458}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    seen = set()\n    result = []\n    \n    # Traverse from right to left to keep rightmost occurrences\n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    \n    # Reverse to restore original order\n    result.reverse()\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.100064754486084}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 10**6 + 7\n\ndef mod_pow(a, b, mod):\n    \"\"\"Fast exponentiation modulo mod\"\"\"\n    result = 1\n    a %= mod\n    while b > 0:\n        if b & 1:\n            result = (result * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return result\n\ndef mod_inv(a, mod):\n    \"\"\"Modular inverse using Fermat's little theorem\"\"\"\n    return mod_pow(a, mod - 2, mod)\n\ndef factorial_mod(n, mod):\n    \"\"\"Compute factorial modulo mod using precomputation\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % mod\n    return fact\n\ndef nCr_mod(n, r, fact, mod):\n    \"\"\"Compute nCr modulo mod using precomputed factorials\"\"\"\n    if r < 0 or r > n:\n        return 0\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % mod\n    return (numerator * mod_inv(denominator, mod)) % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, M, K = map(int, data[:3])\n    \n    # If K > N*M, impossible\n    if K > N * M:\n        print(0)\n        return\n    \n    # Precompute factorials up to N + K\n    max_n = N + K\n    fact = factorial_mod(max_n, MOD)\n    \n    # Using stars and bars with inclusion-exclusion\n    # Number of non-negative integer solutions to x1 + x2 + ... + xN = K\n    # with 0 <= xi <= M\n    # Total unrestricted solutions: C(N + K - 1, K)\n    # Subtract those where at least one xi > M\n    \n    total = 0\n    sign = 1\n    for i in range(N + 1):\n        if K - i * (M + 1) < 0:\n            break\n        term = (nCr_mod(N, i, fact, MOD) * \n                nCr_mod(N + K - i * (M + 1) - 1, K - i * (M + 1), fact, MOD)) % MOD\n        total = (total + sign * term) % MOD\n        sign *= -1\n    \n    print(total % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.66226029396057}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to compute final score given fifth time\n    def final_score(fifth: float) -> float:\n        all_times = times + [fifth]\n        all_times.sort()\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Check if infinite (always win)\n    # With fifth time = 20 (maximum possible), if still <= target, then infinite\n    if final_score(20.0) <= target + 1e-9:\n        print(\"infinite\")\n        return\n    \n    # Check if impossible\n    # With fifth time = 1 (minimum possible), if still > target, then impossible\n    if final_score(1.0) > target + 1e-9:\n        print(\"impossible\")\n        return\n    \n    # Binary search for worst possible fifth time\n    lo, hi = 1.0, 20.0\n    for _ in range(100):  # Sufficient precision for 2 decimal places\n        mid = (lo + hi) / 2.0\n        if final_score(mid) <= target + 1e-9:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Output with exactly two decimal places\n    print(f\"{lo:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.69218158721924}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 10.113396644592285}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # For n=1, no move is possible because 2*x+1 <= n cannot be satisfied for any positive integer x\n    if n == 1:\n        print(-1)\n        return\n    \n    # For n=2, check if any move is possible: x must satisfy 2*x+1 <= 2 => x <= 0.5, no positive integer x\n    if n == 2:\n        print(-1)\n        return\n    \n    # For n>=3, we can use dynamic programming\n    # dp[i] = minimum moves to make chest i have 0 coins, considering only chests from i to n\n    # We process from n down to 1 because moves affect chests x, 2x, 2x+1\n    INF = 10**9\n    dp = [INF] * (n + 2)  # 1-indexed, with padding\n    dp[n+1] = 0  # base case beyond n\n    \n    for i in range(n, 0, -1):\n        # Option 1: Use moves that affect chest i\n        # We need to consider all x such that i is in {x, 2x, 2x+1}\n        # Actually, we need to consider x where chest i is the \"parent\" or \"child\" in the move\n        # But simpler: For each chest i, we can use moves with x = i, or x where i = 2*x or i = 2*x+1\n        # However, the move removes from x, 2x, 2x+1 simultaneously\n        # So we need to consider the maximum over the affected chests\n        \n        # Let's think differently: The move pattern forms a binary tree structure\n        # For each x, it affects x (parent), 2x (left child), 2x+1 (right child)\n        # To empty chest i, we need to consider moves where i is involved\n        # The minimal moves for chest i is determined by:\n        # dp[i] = max(a[i-1], min(dp[2*i], dp[2*i+1]))? Not exactly\n        \n        # Actually, we can model as: For each x, we need to perform at least max(a[x-1], a[2*x-1], a[2*x+1-1]) moves\n        # But moves can be shared between different x\n        \n        # Let's use a greedy approach: Process from largest x to smallest\n        # For each x from floor(n/2) down to 1, we need to perform enough moves to cover all three chests\n        moves_needed = 0\n        for x in range(n//2, 0, -1):\n            if 2*x + 1 <= n:\n                # Chests involved: x, 2x, 2x+1\n                required = max(a[x-1], a[2*x-1], a[2*x+1-1])\n                if required > 0:\n                    moves_needed += required\n                    # Subtract the moves from these chests\n                    a[x-1] -= required\n                    a[2*x-1] -= required\n                    a[2*x+1-1] -= required\n        \n        # Check if all chests are empty\n        if all(ai <= 0 for ai in a):\n            print(moves_needed)\n        else:\n            print(-1)\n        return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 49.3473105430603}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\n# Read N\nN = int(input().strip())\n\n# Read initial strings\nstrings = [input().strip() for _ in range(N)]\n\n# Read operations\noperations = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\n# Parent array for union-find\nparent = list(range(N))\n\n# Find with path compression\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\n# Union operation\ndef union(a, b):\n    root_a = find(a)\n    root_b = find(b)\n    if root_a != root_b:\n        parent[root_b] = root_a\n        return True\n    return False\n\n# Process operations in reverse order\n# We'll build the final string by tracking which strings get appended to which\n# Since operations guarantee b won't be used again, we can process in reverse\n# and build the final string by appending in reverse order\n\n# We'll store for each index what string it should contribute\n# Initially each index has its own string\ncontributions = [strings[i] for i in range(N)]\n\n# Process operations in reverse\nfor a, b in reversed(operations):\n    # Convert to 0-based indexing\n    a -= 1\n    b -= 1\n    \n    # Find the current root of b (where its string currently resides)\n    root_b = find(b)\n    \n    # Append b's contribution to a's contribution\n    contributions[a] += contributions[root_b]\n    \n    # Clear b's contribution (not strictly necessary but clean)\n    contributions[root_b] = \"\"\n    \n    # Union: a becomes parent of b\n    union(a, b)\n\n# Find the root that contains all strings\nfinal_root = find(0)\nprint(contributions[final_root])", "runtime_sec": 25.998648405075073}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    # Total cost = train fare + half of bus fare\n    total_cost = X + Y // 2\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 11.295875310897827}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    event_set = set()  # set of events currently considered to have happened\n    results = []\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n            \n        parts = line.split()\n        if parts[0] == 'E':\n            event = parts[1]\n            events_stack.append(event)\n            event_set.add(event)\n            \n        elif parts[0] == 'D':\n            r = int(parts[1])\n            for _ in range(r):\n                if events_stack:\n                    event_set.remove(events_stack.pop())\n            \n        elif parts[0] == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current state\n            consistent = True\n            for event in scenario_events:\n                if event.startswith('!'):\n                    actual_event = event[1:]\n                    if actual_event in event_set:\n                        consistent = False\n                        break\n                else:\n                    if event not in event_set:\n                        consistent = False\n                        break\n            \n            if consistent:\n                results.append(\"Yes\")\n                continue\n            \n            # Find smallest r such that if we undo r events, scenario becomes consistent\n            # We need to consider undoing events from the stack\n            min_r = None\n            \n            # Try all possible r from 1 to len(events_stack)\n            for r in range(1, len(events_stack) + 1):\n                # Temporarily remove r events from the end\n                temp_removed = []\n                temp_event_set = set(event_set)\n                \n                for j in range(r):\n                    if events_stack:\n                        event_to_remove = events_stack[-j-1]\n                        temp_removed.append(event_to_remove)\n                        temp_event_set.remove(event_to_remove)\n                \n                # Check consistency with this temporary state\n                temp_consistent = True\n                for event in scenario_events:\n                    if event.startswith('!'):\n                        actual_event = event[1:]\n                        if actual_event in temp_event_set:\n                            temp_consistent = False\n                            break\n                    else:\n                        if event not in temp_event_set:\n                            temp_consistent = False\n                            break\n                \n                if temp_consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                results.append(f\"{min_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 34.52192831039429}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 214766 tokens (213166 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 10.585906028747559}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data[:3])\n    # All possible routes with 2 flights (3 airports visited in order)\n    # Since flights are bidirectional, we consider all permutations of 3 airports\n    # But we only need the sum of two consecutive flight times\n    # The possible sums are: P+Q, Q+R, R+P\n    # We want the minimum of these three\n    result = min(P + Q, Q + R, R + P)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.802472591400146}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 58.170214891433716}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    boys = [int(next(it)) for _ in range(N)]\n    A = int(next(it))\n    B = int(next(it))\n    \n    # Sort boys for easier distance calculation\n    boys.sort()\n    \n    # Helper to get minimum distance from X to any boy\n    def min_distance(x):\n        # Binary search to find closest boy\n        import bisect\n        idx = bisect.bisect_left(boys, x)\n        best = float('inf')\n        if idx < N:\n            best = min(best, abs(boys[idx] - x))\n        if idx > 0:\n            best = min(best, abs(boys[idx-1] - x))\n        return best\n    \n    # Consider all odd candidates in [A, B]\n    best_x = -1\n    best_dist = -1\n    \n    # Start from first odd in range\n    start = A if A % 2 == 1 else A + 1\n    \n    # Check each odd number in range\n    x = start\n    while x <= B:\n        dist = min_distance(x)\n        if dist > best_dist:\n            best_dist = dist\n            best_x = x\n        x += 2  # Move to next odd\n    \n    # If no odd in range (shouldn't happen per constraints), fallback\n    if best_x == -1:\n        # Find any number with max distance\n        for x in range(A, B+1):\n            if x % 2 == 1:\n                dist = min_distance(x)\n                if dist > best_dist:\n                    best_dist = dist\n                    best_x = x\n    \n    print(best_x)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.02318811416626}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        a = list(map(int, input_data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        moves = 0\n        alice_total = 0\n        bob_total = 0\n        last_eaten = 0\n        current_sum = 0\n        \n        while left <= right:\n            # Alice's turn\n            current_sum = 0\n            while left <= right and current_sum <= last_eaten:\n                current_sum += a[left]\n                left += 1\n            alice_total += current_sum\n            moves += 1\n            last_eaten = current_sum\n            \n            if left > right:\n                break\n            \n            # Bob's turn\n            current_sum = 0\n            while left <= right and current_sum <= last_eaten:\n                current_sum += a[right]\n                right -= 1\n            bob_total += current_sum\n            moves += 1\n            last_eaten = current_sum\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.029657125473022}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Check necessary condition: A * B >= N and A + B <= N + 1\n    if A * B < N or A + B > N + 1:\n        print(-1)\n        return\n    \n    result = []\n    # Construct sequence using the block method\n    # We'll create B blocks, each of size at most A\n    remaining = N\n    for block in range(B):\n        # Determine size of current block\n        block_size = min(A, remaining - (B - block - 1))\n        if block_size <= 0:\n            block_size = 1\n        \n        # Create decreasing block\n        start = remaining - block_size + 1\n        for i in range(start, remaining + 1):\n            result.append(i)\n        remaining -= block_size\n    \n    # Reverse to get increasing blocks\n    result.reverse()\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 20.628949642181396}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    # Handle special case where K is 1\n    if K == 1:\n        dist = abs(X) + abs(Y)\n        print(dist)\n        x, y = 0, 0\n        for _ in range(dist):\n            if X > x:\n                x += 1\n            elif X < x:\n                x -= 1\n            elif Y > y:\n                y += 1\n            else:\n                y -= 1\n            print(f\"{x} {y}\")\n        return\n    \n    # Calculate Manhattan distance to target\n    D = abs(X) + abs(Y)\n    \n    # Check if it's possible to reach the target\n    if D % 2 != K % 2 or D > K:\n        # Need to check if we can reach with multiple moves\n        # The minimum number of moves is ceil(D/K) but parity must match\n        min_moves = (D + K - 1) // K\n        if min_moves % 2 != D % 2:\n            min_moves += 1\n        \n        # Check if we can actually reach with min_moves moves\n        # We need D <= min_moves * K and parity condition\n        if min_moves % 2 != D % 2 or D > min_moves * K:\n            print(-1)\n            return\n        \n        # We can reach with min_moves moves\n        print(min_moves)\n        \n        # Generate path\n        x, y = 0, 0\n        remaining_moves = min_moves\n        remaining_dist = D\n        \n        for move in range(min_moves):\n            # Calculate how much distance we should cover in this move\n            # We want to make progress toward target while maintaining parity\n            move_dist = K\n            \n            # Adjust move distance if needed for final approach\n            if remaining_moves == 1:\n                # Last move must reach exactly the target\n                dx = X - x\n                dy = Y - y\n                print(f\"{X} {Y}\")\n                return\n            \n            # Try to move toward target\n            # We need to move K Manhattan distance from current position\n            # Choose a point that makes progress toward target\n            \n            # Calculate how much we need to move in x and y directions\n            target_dx = X - x\n            target_dy = Y - y\n            \n            # We need to move exactly K total\n            # Try to use as much as possible in the direction of target\n            move_x = min(abs(target_dx), K)\n            if target_dx < 0:\n                move_x = -move_x\n            \n            remaining_for_y = K - abs(move_x)\n            move_y = min(abs(target_dy), remaining_for_y)\n            if target_dy < 0:\n                move_y = -move_y\n            \n            # If we still have distance left, adjust\n            if abs(move_x) + abs(move_y) < K:\n                # Need to add extra movement\n                extra = K - (abs(move_x) + abs(move_y))\n                if target_dx >= 0:\n                    move_x += extra\n                else:\n                    move_x -= extra\n            \n            x += move_x\n            y += move_y\n            print(f\"{x} {y}\")\n            \n            remaining_moves -= 1\n            remaining_dist = abs(X - x) + abs(Y - y)\n        \n        # Final check - we should be at target\n        if x != X or y != Y:\n            print(f\"{X} {Y}\")\n        \n    else:\n        # We can reach in one move\n        print(1)\n        print(f\"{X} {Y}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 47.54828906059265}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(data[idx]); idx += 1\n        # Count days when participant eats: day 1, A+1, 2A+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A\n    \n    # Total prepared = eaten + remaining\n    result = total_eaten + X\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 16.98696732521057}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        if self.size[x_root] < self.size[y_root]:\n            x_root, y_root = y_root, x_root\n        self.parent[y_root] = x_root\n        self.size[x_root] += self.size[y_root]\n        self.components -= 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    capacities = list(map(int, data[idx:idx+n])); idx += n\n    \n    dsu = DSU(n)\n    degree = [0] * n\n    \n    for _ in range(m):\n        u = int(data[idx]); idx += 1\n        v = int(data[idx]); idx += 1\n        degree[u] += 1\n        degree[v] += 1\n        dsu.union(u, v)\n    \n    # Check capacity constraints\n    for i in range(n):\n        if degree[i] > capacities[i]:\n            print(\"no\")\n            return\n    \n    # Count needed connections\n    needed_connections = dsu.components - 1\n    \n    # Count available sockets\n    available_sockets = sum(capacities[i] - degree[i] for i in range(n))\n    \n    # Each connection uses 2 sockets\n    max_possible_connections = available_sockets // 2\n    \n    # Edits needed = needed_connections (to add) + (m - (n - dsu.components)) (to remove redundant)\n    # But we can think: we need at least needed_connections new edges\n    # Each new edge requires 2 edits (add connection)\n    # But we can also remove existing edges and add new ones\n    \n    # Minimum edits if we only add edges\n    min_edits_add_only = needed_connections\n    \n    # If we have enough sockets to add all needed connections\n    if needed_connections <= max_possible_connections:\n        # Check if we can do it with k edits\n        if min_edits_add_only <= k:\n            print(\"yes\")\n            return\n    \n    # If not enough sockets, we need to remove some edges first\n    # We need to free up sockets by removing edges\n    # Each edge removal frees 2 sockets but costs 1 edit\n    # After removing r edges, we have available_sockets + 2r sockets\n    # We need needed_connections new edges, each requiring 2 sockets\n    # So we need: available_sockets + 2r >= 2 * needed_connections\n    # => r >= needed_connections - available_sockets/2\n    # Total edits = r (removals) + needed_connections (additions)\n    \n    if available_sockets < 2 * needed_connections:\n        # Need to remove edges to free sockets\n        r_needed = (2 * needed_connections - available_sockets + 1) // 2\n        total_edits = r_needed + needed_connections\n        if total_edits <= k:\n            print(\"yes\")\n            return\n    else:\n        # Enough sockets, just check if we can add needed connections\n        if needed_connections <= k:\n            print(\"yes\")\n            return\n    \n    print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 44.421568155288696}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in a:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all unique numbers\n    unique_nums = list(freq.keys())\n    m = len(unique_nums)\n    \n    # Total possible pairs without restrictions\n    total_pairs = m * m\n    \n    # Subtract pairs where robots would meet\n    # Robots meet if first robot's stop position >= second robot's stop position\n    # This happens when the first occurrence of p is at or after the last occurrence of q\n    \n    # Find first occurrence of each number\n    first_occurrence = {}\n    for i, num in enumerate(a):\n        if num not in first_occurrence:\n            first_occurrence[num] = i\n    \n    # Find last occurrence of each number\n    last_occurrence = {}\n    for i in range(n-1, -1, -1):\n        num = a[i]\n        if num not in last_occurrence:\n            last_occurrence[num] = i\n    \n    # Count bad pairs where robots would meet\n    bad_pairs = 0\n    for p in unique_nums:\n        for q in unique_nums:\n            if first_occurrence[p] >= last_occurrence[q]:\n                bad_pairs += 1\n    \n    result = total_pairs - bad_pairs\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 28.55552649497986}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ninput = sys.stdin.readline\n\ndef solve():\n    data = input().split()\n    if not data:\n        return\n    n, k = map(int, data)\n    s = list(map(int, input().split()))\n    \n    # Count frequencies of each element in s\n    freq = {}\n    for num in s:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # We need to choose k elements for t\n    # Strategy: sort elements by frequency, pick the most frequent ones\n    # But we need to consider that we can use each element multiple times in t\n    # The maximum number of copies we can cut is limited by the element with smallest frequency\n    \n    # Create list of (value, frequency) pairs\n    items = list(freq.items())\n    # Sort by frequency descending\n    items.sort(key=lambda x: x[1], reverse=True)\n    \n    # We'll try to maximize the minimum frequency among chosen elements\n    # This is a binary search problem: find maximum m such that we can pick k elements\n    # where each element has frequency >= m\n    \n    # Binary search on m\n    low, high = 0, n\n    best_m = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        # Count how many elements have frequency >= mid\n        count = 0\n        for _, f in items:\n            if f >= mid:\n                count += f // mid  # Each element can contribute multiple times if f >= mid\n            if count >= k:\n                break\n        \n        if count >= k:\n            best_m = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Now construct t using best_m\n    t = []\n    remaining = k\n    \n    for val, f in items:\n        if remaining <= 0:\n            break\n        # How many times we can use this value\n        use = min(f // best_m, remaining)\n        for _ in range(use):\n            t.append(val)\n            remaining -= 1\n        if remaining <= 0:\n            break\n    \n    # If we still need more elements (shouldn't happen with correct binary search)\n    # Fill with any available elements\n    if remaining > 0:\n        for val, f in items:\n            if remaining <= 0:\n                break\n            # Use whatever is left\n            use = min(f, remaining)\n            for _ in range(use):\n                t.append(val)\n                remaining -= 1\n            if remaining <= 0:\n                break\n    \n    # Output t\n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.4850435256958}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 58.20369243621826}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 15.4568030834198}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            result.append(x - 1)\n        else:\n            result.append(x)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.436981439590454}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    names = data[1:1+n]\n    \n    target = \"ThoreHusfeldt\"\n    target_index = names.index(target)\n    \n    # Check if ThoreHusfeldt is first\n    if target_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check names above ThoreHusfeldt\n    above_names = names[:target_index]\n    \n    # Check for \"Thore sucks\" condition\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    for prefix_len in range(1, len(target) + 1):\n        prefix = target[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Fallback (should not happen given constraints)\n    print(target)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 19.532286405563354}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef count_pairs_less_equal(x, A, pos, neg, zero):\n    \"\"\"Count number of pairs with product <= x\"\"\"\n    cnt = 0\n    \n    # Handle zero cases\n    if x >= 0:\n        # All pairs with zero have product = 0 <= x\n        cnt += zero * (len(A) - 1)  # zero with all other elements\n        cnt -= zero * (zero - 1) // 2  # subtract double counted zero-zero pairs\n    \n    # Positive products\n    if pos:\n        # For each positive number a, we need b <= x/a\n        for i, a in enumerate(pos):\n            if a == 0:\n                continue\n            if x >= 0:\n                # For positive x, we need b <= x/a\n                max_val = x // a\n                # Count how many positive numbers <= max_val\n                idx = bisect.bisect_right(pos, max_val)\n                cnt += max(0, idx - i - 1)\n            else:\n                # For negative x, positive * positive > 0 > x\n                # So no positive-positive pairs contribute\n                pass\n    \n    # Negative products\n    if neg:\n        # Sort negatives in descending order (more negative first)\n        neg_desc = sorted(neg, reverse=True)\n        for i, a in enumerate(neg_desc):\n            if x >= 0:\n                # For positive x, negative * negative gives positive product\n                # We need a*b <= x where both a,b are negative\n                # Since both negative, product is positive\n                # We need b >= x/a (since a is negative, inequality reverses)\n                min_val = (x + (-a) - 1) // (-a)  # ceil division\n                # Count how many negative numbers >= min_val (in original order)\n                # Since neg_desc is sorted descending, we need numbers <= -min_val\n                max_allowed = -min_val\n                idx = bisect.bisect_right(neg_desc, max_allowed, key=lambda y: -y)\n                cnt += max(0, idx - i - 1)\n            else:\n                # For negative x\n                # Negative * positive gives negative product\n                # We need a*b <= x where a negative, b positive\n                # Since x negative, we need b >= x/a (a negative, so inequality reverses)\n                if pos:\n                    min_val = (x + (-a) - 1) // (-a)  # ceil division\n                    # Count positive numbers >= min_val\n                    idx = bisect.bisect_left(pos, min_val)\n                    cnt += len(pos) - idx\n                # Negative * negative gives positive product > 0 > x\n                # So no contribution\n    \n    # Positive-negative pairs where positive first\n    if pos and neg:\n        for a in pos:\n            if a == 0:\n                continue\n            if x >= 0:\n                # For positive x, positive * negative <= 0 <= x always\n                cnt += len(neg)\n            else:\n                # For negative x, we need a*b <= x\n                # Since b negative, we need b >= x/a (inequality reverses)\n                min_val = (x + a - 1) // a  # ceil division\n                # Count negative numbers >= min_val\n                idx = bisect.bisect_left(neg, min_val)\n                cnt += len(neg) - idx\n    \n    return cnt\n\ndef main():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Separate numbers by sign\n    pos = [x for x in A if x > 0]\n    neg = [x for x in A if x < 0]\n    zero = [x for x in A if x == 0]\n    \n    pos.sort()\n    neg.sort()\n    \n    # Binary search for the K-th smallest product\n    low = -10**18\n    high = 10**18\n    \n    while low < high:\n        mid = (low + high) // 2\n        cnt = count_pairs_less_equal(mid, A, pos, neg, len(zero))\n        if cnt >= K:\n            high = mid\n        else:\n            low = mid + 1\n    \n    print(low)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 45.671324729919434}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef min_moves_to_divisible_by_25(n_str):\n    \"\"\"Return minimum adjacent swaps to make number divisible by 25, or -1 if impossible.\"\"\"\n    n = n_str\n    length = len(n)\n    \n    # A number is divisible by 25 if its last two digits are 00, 25, 50, or 75\n    target_endings = [\"00\", \"25\", \"50\", \"75\"]\n    \n    min_moves = float('inf')\n    \n    for ending in target_endings:\n        # Find positions of the two required digits from right to left\n        # We need to bring these digits to the last two positions\n        pos1 = -1  # position of first digit (from ending[0])\n        pos2 = -1  # position of second digit (from ending[1])\n        \n        # Find the rightmost occurrence of ending[1] for the last digit\n        for i in range(length - 1, -1, -1):\n            if n[i] == ending[1]:\n                pos2 = i\n                break\n        if pos2 == -1:\n            continue  # Cannot form this ending\n        \n        # Find the rightmost occurrence of ending[0] before pos2 for the second-last digit\n        for i in range(pos2 - 1, -1, -1):\n            if n[i] == ending[0]:\n                pos1 = i\n                break\n        if pos1 == -1:\n            continue  # Cannot form this ending\n        \n        # Calculate moves to bring these digits to the end\n        # Moves to bring pos2 to last position (index length-1)\n        moves = (length - 1 - pos2)\n        # Moves to bring pos1 to second-last position (index length-2)\n        # If pos1 was originally to the right of pos2, after moving pos2, pos1 index shifts\n        if pos1 > pos2:\n            # pos1 was to the right of pos2, after moving pos2 left, pos1 index decreases by 1\n            moves += (length - 2 - (pos1 - 1))\n        else:\n            moves += (length - 2 - pos1)\n        \n        # Check for leading zero after swaps\n        # We need to ensure the first digit is not '0' after moving digits\n        # Create a copy of digits to simulate\n        digits = list(n)\n        # Remove the two digits we're moving\n        d1 = digits.pop(pos1)\n        # Adjust pos2 if pos1 was before pos2\n        if pos1 < pos2:\n            pos2 -= 1\n        d2 = digits.pop(pos2)\n        # Insert them at the end\n        digits.append(d1)\n        digits.append(d2)\n        \n        if digits[0] == '0':\n            # Need to swap with a non-zero digit from left\n            # Find first non-zero digit from left that can be swapped to front\n            found = False\n            for i in range(1, length - 2):  # Excluding the last two positions we fixed\n                if digits[i] != '0':\n                    # Need i swaps to bring this digit to front\n                    moves += i\n                    found = True\n                    break\n            if not found:\n                continue  # Would result in leading zero, skip this ending\n        \n        min_moves = min(min_moves, moves)\n    \n    return -1 if min_moves == float('inf') else min_moves\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    n_str = input_data\n    result = min_moves_to_divisible_by_25(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 43.269789695739746}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef cross(o, a, b):\n    \"\"\"Cross product of vectors OA and OB\"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    \"\"\"Andrew's monotone chain algorithm\"\"\"\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef collinear(a, b, c):\n    \"\"\"Check if three points are collinear\"\"\"\n    return cross(a, b, c) == 0\n\ndef min_lines_to_cover(points):\n    \"\"\"Find minimum number of lines to cover all points on convex polygon boundary\"\"\"\n    hull = convex_hull(points)\n    m = len(hull)\n    \n    # Special case: all points collinear\n    if m <= 2:\n        return 1\n    \n    # DP approach: dp[i][j] = True if points from i to j can be covered by one line\n    dp = [[False] * m for _ in range(m)]\n    \n    # Initialize for consecutive points\n    for i in range(m):\n        dp[i][(i+1)%m] = True\n    \n    # Check all ranges\n    for length in range(2, m):\n        for i in range(m):\n            j = (i + length) % m\n            \n            # Check if all points from i to j are collinear\n            collinear_all = True\n            k = (i + 1) % m\n            while k != j:\n                if not collinear(hull[i], hull[j], hull[k]):\n                    collinear_all = False\n                    break\n                k = (k + 1) % m\n            \n            if collinear_all:\n                dp[i][j] = True\n            else:\n                # Try to split the range\n                for k in range(1, length):\n                    mid = (i + k) % m\n                    if dp[i][mid] and dp[mid][j]:\n                        dp[i][j] = True\n                        break\n    \n    # Find minimum number of lines\n    INF = float('inf')\n    min_lines = [INF] * m\n    min_lines[0] = 1\n    \n    for i in range(1, m):\n        for j in range(i):\n            if dp[j][i]:\n                min_lines[i] = min(min_lines[i], min_lines[j] + 1)\n    \n    return min_lines[m-1]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    points = []\n    for i in range(n):\n        x = int(data[1 + 2*i])\n        y = int(data[2 + 2*i])\n        points.append((x, y))\n    \n    result = min_lines_to_cover(points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 41.613916873931885}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.97342872619629}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    \"\"\"Find the largest bus number  m.\"\"\"\n    if m < 1729:\n        return \"none\"\n    \n    # Precompute all sums of two positive cubes up to m\n    # Since a^3 + b^3  m and a,b  1, max a,b  cube_root(m)\n    max_val = int(m ** (1/3)) + 2  # Add margin for safety\n    \n    # Dictionary to count ways: sum -> count of representations\n    ways = {}\n    \n    # Generate all sums a^3 + b^3 where 1  a  b  max_val\n    for a in range(1, max_val + 1):\n        a_cube = a * a * a\n        if a_cube > m:\n            break\n        for b in range(a, max_val + 1):\n            s = a_cube + b * b * b\n            if s > m:\n                break\n            ways[s] = ways.get(s, 0) + 1\n    \n    # Find the largest number with at least 2 representations\n    result = \"none\"\n    for num in sorted(ways.keys(), reverse=True):\n        if ways[num] >= 2:\n            result = str(num)\n            break\n    \n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    print(find_largest_bus_number(m))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 23.936453580856323}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\nMOD = 1000003\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"begin repairs\"\n    \n    idx = 0\n    Y = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    x_init = int(data[idx]); idx += 1\n    \n    grid = []\n    for _ in range(Y):\n        row = data[idx]; idx += 1\n        grid.append(row)\n    \n    # Find castle position\n    castle_y = castle_x = -1\n    for y in range(Y):\n        for x in range(X):\n            if grid[y][x] == '@':\n                castle_y, castle_x = y, x\n                break\n        if castle_y != -1:\n            break\n    \n    # DP table: dp[y][x] = number of ways to reach (y,x)\n    dp = [[0] * X for _ in range(Y)]\n    dp[Y-1][x_init] = 1  # Starting position\n    \n    # Process from bottom to top (since we can only move north)\n    for y in range(Y-1, -1, -1):\n        for x in range(X-1, -1, -1):\n            if dp[y][x] == 0:\n                continue\n            \n            # Move north (lower sails)\n            if y > 0 and grid[y-1][x] != '#':\n                dp[y-1][x] = (dp[y-1][x] + dp[y][x]) % MOD\n            \n            # Move according to current\n            cell = grid[y][x]\n            if cell == '>':\n                nx = x + 1\n                if nx < X and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n            elif cell == '<':\n                nx = x - 1\n                if nx >= 0 and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n            elif cell == '~':\n                # Can move east or west from open sea\n                # East\n                nx = x + 1\n                if nx < X and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n                # West\n                nx = x - 1\n                if nx >= 0 and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n    \n    result = dp[castle_y][castle_x] % MOD\n    if result == 0:\n        return \"begin repairs\"\n    return str(result)\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 33.23802900314331}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    c = int(data[1])\n    b = int(data[2])\n    broken = set(map(int, data[3:3+b]))\n    \n    # Initialize result with all zeros\n    res = ['0'] * n\n    \n    # First bit is always 0 (since first bit is not broken and we start with 0)\n    # Last bit is always 0 (broken)\n    \n    # We'll create bit changes by alternating between 0 and 1\n    # Start from position 2 (index 1) since position 1 is fixed\n    current_bit = '0'\n    changes_made = 0\n    \n    # We need exactly c changes\n    # Strategy: create changes in non-broken positions\n    i = 1  # position 1 (0-indexed)\n    while i < n and changes_made < c:\n        if i + 1 in broken:  # next position is broken\n            # Skip broken positions\n            i += 1\n            continue\n        \n        # Create a change at position i+1\n        if changes_made < c:\n            # Flip the bit\n            new_bit = '1' if current_bit == '0' else '0'\n            res[i] = new_bit\n            current_bit = new_bit\n            changes_made += 1\n            \n            # Move to next position that can have a change\n            # We need at least one position between changes\n            i += 2\n        else:\n            break\n    \n    # If we still need more changes, try to add them where possible\n    if changes_made < c:\n        # Try from the end\n        i = n - 2  # position n-1 (0-indexed)\n        while i > 0 and changes_made < c:\n            if i + 1 in broken:  # position is broken\n                i -= 1\n                continue\n            \n            # Check if we can add a change here\n            if res[i] == '0':\n                # Flip if it creates a change with neighbor\n                if i > 0 and res[i-1] == '0':\n                    res[i] = '1'\n                    changes_made += 1\n                elif i < n-1 and res[i+1] == '0':\n                    res[i] = '1'\n                    changes_made += 1\n            i -= 1\n    \n    # Ensure broken bits remain 0\n    for pos in broken:\n        res[pos-1] = '0'\n    \n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.53580045700073}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival_time, aggressive_time, calm_time):\n    \"\"\"\n    Determine if a dog is aggressive at a given arrival time.\n    The dog alternates between aggressive and calm periods.\n    \"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival_time % cycle_length\n    # Dog is aggressive during the first aggressive_time minutes of each cycle\n    return position_in_cycle < aggressive_time\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse A, B, C, D\n    A, B, C, D = map(int, data[:4])\n    \n    # Parse arrival times P, M, G\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: problem states arrival during minute X means at time X-1\n    # For example, arrival during minute 3 means at time 2 (0-based)\n    arrivals = [P - 1, M - 1, G - 1]\n    \n    results = []\n    for arrival in arrivals:\n        # Check each dog\n        dog1_aggressive = is_aggressive(arrival, A, B)\n        dog2_aggressive = is_aggressive(arrival, C, D)\n        \n        # Count aggressive dogs\n        aggressive_count = dog1_aggressive + dog2_aggressive\n        \n        if aggressive_count == 2:\n            results.append(\"both\")\n        elif aggressive_count == 1:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 26.001308917999268}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror mapping for capital letters\n    mirror_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O',\n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',\n        'Y': 'Y',\n        # Letters that are not mirror-symmetric\n        'B': None, 'C': None, 'D': None, 'E': None, 'F': None,\n        'G': None, 'J': None, 'K': None, 'L': None, 'N': None,\n        'P': None, 'Q': None, 'R': None, 'S': None, 'Z': None\n    }\n    \n    n = len(word)\n    # Check each character and its mirror position\n    for i in range((n + 1) // 2):  # Only need to check half\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Check if left character has a mirror mapping\n        if left_char not in mirror_map:\n            return False\n        \n        # Check if left character maps to right character\n        if mirror_map[left_char] != right_char:\n            return False\n    \n    return True\n\ndef main():\n    # Read input\n    word = sys.stdin.readline().strip()\n    \n    # Check if word is mirror-symmetric\n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 30.60093116760254}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    vectors = []\n    idx = 1\n    for i in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        idx += 2\n        vectors.append((x, y, i+1))\n    \n    # Compute angle for each vector using atan2, result in [-pi, pi]\n    angles = []\n    for x, y, idx in vectors:\n        angle = math.atan2(y, x)  # returns in radians\n        angles.append((angle, idx))\n    \n    # Sort by angle\n    angles.sort(key=lambda t: t[0])\n    \n    # Initialize minimal angle and answer indices\n    min_angle = float('inf')\n    ans_a, ans_b = -1, -1\n    \n    # Check consecutive angles in sorted order\n    for i in range(n):\n        angle1, idx1 = angles[i]\n        angle2, idx2 = angles[(i+1) % n]\n        diff = angle2 - angle1\n        # Normalize diff to [0, 2*pi)\n        if diff < 0:\n            diff += 2 * math.pi\n        # Non-oriented angle is min(diff, 2*pi - diff)\n        non_oriented = min(diff, 2 * math.pi - diff)\n        if non_oriented < min_angle:\n            min_angle = non_oriented\n            ans_a, ans_b = idx1, idx2\n    \n    # Also check the pair that wraps around (last with first)\n    # Already handled by (i+1) % n above\n    \n    print(f\"{ans_a} {ans_b}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 24.413877725601196}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    record = sys.stdin.readline().strip()\n    alice_score = 0\n    barbara_score = 0\n    i = 0\n    while i < len(record):\n        player = record[i]\n        points = int(record[i + 1])\n        if player == 'A':\n            alice_score += points\n        else:\n            barbara_score += points\n        i += 2\n        # Check for win conditions\n        if alice_score >= 11 and barbara_score <= alice_score - 2:\n            print('A')\n            return\n        if barbara_score >= 11 and alice_score <= barbara_score - 2:\n            print('B')\n            return\n        # Check for tie at 10-10 and win by 2 rule\n        if alice_score >= 10 and barbara_score >= 10:\n            if abs(alice_score - barbara_score) >= 2:\n                print('A' if alice_score > barbara_score else 'B')\n                return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 18.996825218200684}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(400000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    \n    # Build tree adjacency list\n    adj = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(next(it))\n        adj[parent].append(i)\n        adj[i].append(parent)\n    \n    # DP arrays\n    # dp_down[node] = max marks in subtree rooted at node when node is NOT marked\n    # dp_up[node] = max marks in subtree rooted at node when node IS marked\n    dp_down = [0] * N\n    dp_up = [0] * N\n    \n    # For tracking distances to nearest marked node in subtree\n    # dist_down[node] = min distance to nearest marked node in subtree when node is NOT marked\n    # dist_up[node] = min distance to nearest marked node in subtree when node IS marked\n    dist_down = [float('inf')] * N\n    dist_up = [0] * N  # When node is marked, distance to itself is 0\n    \n    def dfs(u, parent):\n        # Process children first\n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u)\n        \n        # Case 1: u is NOT marked\n        # We can choose to mark some children, but must respect distance D\n        best_marks = 0\n        best_dist = float('inf')\n        \n        # Try all possibilities: either take dp_up[child] or dp_down[child]\n        # But need to ensure distance constraints\n        for v in adj[u]:\n            if v == parent:\n                continue\n            \n            # Option 1: child v is marked\n            if dist_up[v] + 1 >= D:\n                # Valid to mark child v\n                marks_if_marked = dp_up[v]\n                dist_if_marked = min(best_dist, dist_up[v] + 1)\n                \n                # Option 2: child v is not marked\n                marks_if_not = dp_down[v]\n                dist_if_not = min(best_dist, dist_down[v] + 1)\n                \n                # Choose better option\n                if marks_if_marked > marks_if_not:\n                    best_marks += marks_if_marked\n                    best_dist = dist_if_marked\n                elif marks_if_marked < marks_if_not:\n                    best_marks += marks_if_not\n                    best_dist = dist_if_not\n                else:\n                    # Equal marks, choose better distance\n                    best_marks += marks_if_marked\n                    best_dist = min(dist_if_marked, dist_if_not)\n            else:\n                # Cannot mark child v, must take dp_down[v]\n                best_marks += dp_down[v]\n                best_dist = min(best_dist, dist_down[v] + 1)\n        \n        dp_down[u] = best_marks\n        dist_down[u] = best_dist if best_dist != float('inf') else float('inf')\n        \n        # Case 2: u IS marked\n        # All children must not be marked (distance would be 1 < D for D>1)\n        marks_marked = 1  # u itself\n        for v in adj[u]:\n            if v == parent:\n                continue\n            marks_marked += dp_down[v]\n        \n        dp_up[u] = marks_marked\n        dist_up[u] = 0  # u is marked, so distance to nearest marked is 0\n    \n    dfs(0, -1)\n    \n    # Answer is max of marking root or not marking root\n    result = max(dp_down[0], dp_up[0])\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 41.31702709197998}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for dice in range(1, 7):\n        diff_a = abs(a - dice)\n        diff_b = abs(b - dice)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 15.64660358428955}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\n# Map values to indices for easier processing\nVALUE_TO_IDX = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n\n# Read input efficiently\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    print(0)\n    sys.exit(0)\n\nn = int(input_data[0])\na = [VALUE_TO_IDX[int(x)] for x in input_data[1:1+n]]\n\n# Count occurrences of each value\ncounts = [0] * 6\nfor val in a:\n    counts[val] += 1\n\n# We need to form complete sequences of [0,1,2,3,4,5]\n# The bottleneck is the minimum count of any value in the sequence\n# But we must respect the order: each value must appear after the previous one\n\n# Track how many sequences we can form\nsequences = 0\n# Track how many of each value we have available for current sequence\navailable = [0] * 6\n\nfor val in a:\n    if val == 0:  # 4 - start of sequence\n        available[0] += 1\n    else:\n        # Check if we have the previous value available\n        if available[val-1] > 0:\n            available[val-1] -= 1\n            available[val] += 1\n        # else: this element cannot be used in any sequence\n\n# The number of complete sequences is available[5] (42s)\ncomplete_sequences = available[5]\n\n# Total elements in good array = complete_sequences * 6\n# Elements to remove = n - (complete_sequences * 6)\nresult = n - (complete_sequences * 6)\nprint(result)", "runtime_sec": 25.71450161933899}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2124942 tokens (2123342 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 17.003330945968628}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.57890558242798}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    t = int(input())\n    out_lines = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        xs = list(map(int, input().split()))\n        ys = list(map(int, input().split()))\n        \n        # Sort points by x-coordinate\n        points = sorted(zip(xs, ys))\n        xs_sorted = [p[0] for p in points]\n        \n        # Precompute prefix counts for sliding window\n        prefix = [0] * (n + 1)\n        j = 0\n        for i in range(n):\n            while j < n and xs_sorted[j] <= xs_sorted[i] + k:\n                j += 1\n            prefix[i + 1] = max(prefix[i], j - i)\n        \n        # Compute suffix counts and answer\n        suffix = [0] * (n + 1)\n        j = n - 1\n        for i in range(n - 1, -1, -1):\n            while j >= 0 and xs_sorted[j] >= xs_sorted[i] - k:\n                j -= 1\n            suffix[i] = max(suffix[i + 1], i - j)\n        \n        ans = 0\n        for i in range(n + 1):\n            ans = max(ans, prefix[i] + suffix[i])\n        \n        out_lines.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 26.21090841293335}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef rotate_row(matrix, i, k):\n    \"\"\"Rotate i-th row (0-indexed) k elements to the right\"\"\"\n    row = matrix[i]\n    n = len(row)\n    k = k % n\n    if k == 0:\n        return\n    matrix[i] = row[-k:] + row[:-k]\n\ndef rotate_col(matrix, j, k):\n    \"\"\"Rotate j-th column (0-indexed) k elements down\"\"\"\n    m = len(matrix)\n    k = k % m\n    if k == 0:\n        return\n    col = [matrix[i][j] for i in range(m)]\n    for i in range(m):\n        matrix[i][j] = col[(i - k) % m]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    R = int(data[idx]); idx += 1\n    C = int(data[idx]); idx += 1\n    \n    matrix = []\n    for _ in range(R):\n        row = []\n        for _ in range(C):\n            row.append(int(data[idx])); idx += 1\n        matrix.append(row)\n    \n    operations = []\n    \n    # Step 1: Use negR and negS to make all rows and columns non-negative sum if beneficial\n    row_negated = [False] * R\n    col_negated = [False] * C\n    \n    # For each row, if sum is negative, negate it if not already negated\n    for i in range(R):\n        row_sum = sum(matrix[i])\n        if row_sum < 0 and not row_negated[i]:\n            for j in range(C):\n                matrix[i][j] *= -1\n            row_negated[i] = True\n            operations.append(f\"negR {i+1}\")\n    \n    # For each column, if sum is negative, negate it if not already negated\n    for j in range(C):\n        col_sum = sum(matrix[i][j] for i in range(R))\n        if col_sum < 0 and not col_negated[j]:\n            for i in range(R):\n                matrix[i][j] *= -1\n            col_negated[j] = True\n            operations.append(f\"negS {j+1}\")\n    \n    # Step 2: Use rotations to bring largest element to top-left corner for further optimization\n    # Find global maximum\n    max_val = -10**9\n    max_i, max_j = 0, 0\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] > max_val:\n                max_val = matrix[i][j]\n                max_i, max_j = i, j\n    \n    # Rotate row of max element to bring it to first row\n    if max_i != 0:\n        # Rotate column containing max element to bring it to first row\n        # Actually, we can rotate the row itself if allowed\n        # But we need to rotate column to move the element up\n        # Simpler: rotate the row of max element to bring max to first column? Not directly.\n        # Instead, we'll just use rotations to potentially increase sum\n        # For simplicity, skip complex rotations and rely on negations\n        pass\n    \n    # Step 3: Additional simple heuristic: if any row has negative sum after previous steps, negate it\n    for i in range(R):\n        if sum(matrix[i]) < 0 and not row_negated[i]:\n            for j in range(C):\n                matrix[i][j] *= -1\n            row_negated[i] = True\n            operations.append(f\"negR {i+1}\")\n    \n    # Step 4: Calculate final sum\n    total_sum = sum(sum(row) for row in matrix)\n    \n    # Output\n    print(f\"{total_sum} {len(operations)}\")\n    for op in operations:\n        print(op)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 48.12604355812073}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef factorize(m):\n    \"\"\"Return prime factorization of m as list of (prime, exponent) pairs.\"\"\"\n    factors = []\n    d = 2\n    while d * d <= m:\n        if m % d == 0:\n            cnt = 0\n            while m % d == 0:\n                m //= d\n                cnt += 1\n            factors.append((d, cnt))\n        d += 1 if d == 2 else 2\n    if m > 1:\n        factors.append((m, 1))\n    return factors\n\ndef modinv(a, mod=MOD):\n    \"\"\"Return modular inverse of a modulo mod using Fermat's little theorem.\"\"\"\n    return pow(a, mod-2, mod)\n\ndef nCr(n, r, fact, inv_fact):\n    \"\"\"Return n choose r modulo MOD using precomputed factorials.\"\"\"\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    N = int(input_data[0])\n    M = int(input_data[1])\n    \n    # Factorize M\n    factors = factorize(M)\n    \n    # Precompute factorials up to N + max_exponent\n    max_exp = max((exp for _, exp in factors), default=0)\n    max_n = N + max_exp\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = modinv(fact[max_n])\n    for i in range(max_n, 0, -1):\n        inv_fact[i-1] = inv_fact[i] * i % MOD\n    \n    # For each prime factor, compute number of ways to distribute its exponent across N positions\n    ans = 1\n    for _, exp in factors:\n        # Number of nonnegative integer solutions to x1 + x2 + ... + xN = exp\n        # is C(exp + N - 1, N - 1)\n        ways = nCr(exp + N - 1, N - 1, fact, inv_fact)\n        ans = ans * ways % MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 36.189350605010986}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Since moving by 2 is free, we only care about parity of positions\n    # Chips with same parity can be moved together for free\n    # We need to choose target parity (0 or 1) that minimizes cost\n    \n    # Count chips at even and odd positions\n    even_count = 0\n    odd_count = 0\n    \n    for x in chips:\n        if x % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Minimum coins needed is the smaller count\n    # Because we can move all chips to have same parity using free moves (by 2)\n    # Then we need to adjust parity for the smaller group (cost 1 coin per chip)\n    result = min(even_count, odd_count)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.526618480682373}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Set to store distinct suffixes\n    suffixes = set()\n    \n    # Try all possible root lengths (from 5 to n-2)\n    # Root must have at least 5 characters, and we need at least 2 characters for suffix\n    for root_len in range(5, n - 1):  # n-1 because we need at least 2 chars for suffix\n        # The remaining part after root must be composed of 2 or 3 character segments\n        # with no two consecutive segments being identical\n        remaining = s[root_len:]\n        \n        # Check if remaining can be partitioned into segments of length 2 or 3\n        # with no two consecutive segments equal\n        def can_partition(rem):\n            if not rem:\n                return True\n            \n            # Try starting with length 2\n            if len(rem) >= 2:\n                first = rem[:2]\n                if can_partition_helper(rem[2:], first):\n                    return True\n            \n            # Try starting with length 3\n            if len(rem) >= 3:\n                first = rem[:3]\n                if can_partition_helper(rem[3:], first):\n                    return True\n            \n            return False\n        \n        def can_partition_helper(rem, prev):\n            if not rem:\n                return True\n            \n            # Try length 2\n            if len(rem) >= 2:\n                seg = rem[:2]\n                if seg != prev:\n                    if can_partition_helper(rem[2:], seg):\n                        return True\n            \n            # Try length 3\n            if len(rem) >= 3:\n                seg = rem[:3]\n                if seg != prev:\n                    if can_partition_helper(rem[3:], seg):\n                        return True\n            \n            return False\n        \n        if can_partition(remaining):\n            # If remaining can be partitioned, all segments are valid suffixes\n            # We need to collect all distinct segments of length 2 or 3 from remaining\n            # that appear in at least one valid partition\n            \n            # We'll find all possible partitions and collect segments\n            partitions = []\n            \n            def find_partitions(rem, current, prev):\n                if not rem:\n                    partitions.append(current.copy())\n                    return\n                \n                # Try length 2\n                if len(rem) >= 2:\n                    seg = rem[:2]\n                    if seg != prev:\n                        current.append(seg)\n                        find_partitions(rem[2:], current, seg)\n                        current.pop()\n                \n                # Try length 3\n                if len(rem) >= 3:\n                    seg = rem[:3]\n                    if seg != prev:\n                        current.append(seg)\n                        find_partitions(rem[3:], current, seg)\n                        current.pop()\n            \n            # Start with empty previous segment\n            find_partitions(remaining, [], \"\")\n            \n            # Collect all segments from valid partitions\n            for partition in partitions:\n                for seg in partition:\n                    suffixes.add(seg)\n    \n    # Also check the case where root is the entire string (no suffixes)\n    # This is already covered by the loop not adding anything when root_len >= n-1\n    \n    # Sort suffixes lexicographically\n    result = sorted(suffixes)\n    \n    # Output\n    print(len(result))\n    for suffix in result:\n        print(suffix)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 42.555808305740356}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nclass VesselSystem:\n    def __init__(self, n, capacities):\n        self.n = n\n        self.capacities = capacities\n        self.water = [0] * (n + 1)  # 1-indexed for convenience\n        self.parent = list(range(n + 1))\n        self.overflow = [0] * (n + 1)\n        \n    def find(self, x):\n        # Find root with path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        # Union two sets\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n    \n    def pour(self, p, x):\n        # Pour x liters into vessel p\n        current = p\n        remaining = x\n        \n        while current <= self.n and remaining > 0:\n            root = self.find(current)\n            \n            # Calculate available space in this vessel\n            available = self.capacities[root - 1] - self.water[root]\n            \n            if available >= remaining:\n                # All water fits in this vessel\n                self.water[root] += remaining\n                remaining = 0\n            else:\n                # Fill this vessel to capacity\n                self.water[root] = self.capacities[root - 1]\n                remaining -= available\n                \n                # Mark this vessel as full and union with next\n                if root < self.n:\n                    self.union(root, root + 1)\n                    current = root + 1\n                else:\n                    # Overflow from last vessel spills on floor\n                    remaining = 0\n    \n    def query(self, k):\n        # Return water in vessel k\n        return self.water[k]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n        \n    idx = 0\n    n = int(data[idx]); idx += 1\n    capacities = list(map(int, data[idx:idx + n])); idx += n\n    m = int(data[idx]); idx += 1\n    \n    system = VesselSystem(n, capacities)\n    \n    results = []\n    for _ in range(m):\n        query_type = int(data[idx]); idx += 1\n        \n        if query_type == 1:\n            p = int(data[idx]); idx += 1\n            x = int(data[idx]); idx += 1\n            system.pour(p, x)\n        else:  # query_type == 2\n            k = int(data[idx]); idx += 1\n            results.append(str(system.query(k)))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 34.537909507751465}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    a = int(data[1])\n    enemy_ships = list(map(int, data[2:2+n]))\n    \n    # Sort enemy ships in ascending order\n    enemy_ships.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemy_ships:\n        # To win, Atli needs to send enemy + 1 ships\n        ships_needed = enemy + 1\n        \n        # Check if we have enough ships remaining\n        if ships_used + ships_needed <= a:\n            wins += 1\n            ships_used += ships_needed\n        else:\n            # Not enough ships for this battle, break since list is sorted\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.777869701385498}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.3674578666687}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    \n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, which is equivalent to a == k * b\n    # So we need to check if there exists b in [x, y] such that k * b is in [l, r]\n    \n    # Iterate through possible b values\n    for b in range(x, y + 1):\n        a = k * b\n        if l <= a <= r:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.015300273895264}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+n]]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # First pass: place 'E' on every land cell that has no adjacent 'E' yet\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                can_place = True\n                # Check all 4 adjacent cells\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m:\n                        if grid[ni][nj] == 'E':\n                            can_place = False\n                            break\n                if can_place:\n                    grid[i][j] = 'E'\n    \n    # Second pass: ensure every land cell has an adjacent 'E'\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m:\n                        if grid[ni][nj] == 'E':\n                            has_adjacent_E = True\n                            break\n                if not has_adjacent_E:\n                    # Place 'E' in this cell\n                    grid[i][j] = 'E'\n    \n    # Output the result\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.087980031967163}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s):\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Binary search on answer length\n    low, high = 0, n - 1\n    answer = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Check if there exists substring of length mid that repeats\n        found = False\n        seen = set()\n        \n        for i in range(n - mid + 1):\n            substring = s[i:i + mid]\n            if substring in seen:\n                found = True\n                break\n            seen.add(substring)\n        \n        if found:\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return answer\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L = int(data[0])\n    s = data[1]\n    \n    result = longest_repeated_substring(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.644787549972534}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples(n):\n    \"\"\"Count right-angled triangles with 1  a  b  c  n.\"\"\"\n    count = 0\n    # Iterate over possible a and b values\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):  # b >= a\n            c_squared = a * a + b * b\n            c = int(c_squared ** 0.5)\n            # Check if c is integer and within bounds\n            if c * c == c_squared and c <= n:\n                count += 1\n    return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.998788595199585}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data[:3])\n    \n    # Calculate days from best-by date to eating\n    # Bought A days before best-by, ate B days after buying\n    # So ate (B - A) days after best-by date\n    days_after_best_by = B - A\n    \n    if days_after_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_after_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.594849586486816}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Calculate distance from origin to the line\n    # Line through (x1,y1) and (x2,y2)\n    # General form: Ax + By + C = 0\n    A = y2 - y1\n    B = x1 - x2\n    C = x2*y1 - x1*y2\n    \n    # Distance from (0,0) to line\n    dist = abs(C) / math.sqrt(A*A + B*B) if (A != 0 or B != 0) else 0\n    \n    # Binary search for minimum chain length\n    low, high = 0, 20000  # Upper bound: sqrt(L/pi) + dist + some margin\n    ans = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        r = mid\n        \n        # Calculate area dog can cover with chain length r\n        # Dog is at (0,0), wall is a line at distance 'dist' from origin\n        # If r <= dist: dog can only cover half circle on its side\n        # If r > dist: dog can cover full circle minus a circular segment\n        \n        if r <= dist:\n            # Only half circle on dog's side of wall\n            area = 0.5 * math.pi * r * r\n        else:\n            # Full circle minus circular segment blocked by wall\n            # Height of segment: h = r - dist\n            # Angle of segment: theta = 2 * acos(dist/r)\n            # Area of segment: r^2 * (theta - sin(theta))/2\n            theta = 2 * math.acos(dist / r)\n            segment_area = 0.5 * r * r * (theta - math.sin(theta))\n            area = math.pi * r * r - segment_area\n        \n        if area >= L:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 32.74150776863098}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+n]]\n    \n    # Find all white pixel positions\n    whites = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                whites.append((i, j))\n    \n    if not whites:\n        print(-1)\n        return\n    \n    # Find bounding box of whites\n    min_r = min(w[0] for w in whites)\n    max_r = max(w[0] for w in whites)\n    min_c = min(w[1] for w in whites)\n    max_c = max(w[1] for w in whites)\n    \n    # Determine possible square frame size\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    size = max(height, width)\n    \n    # Check if frame fits within screen\n    if min_r + size - 1 >= n or min_c + size - 1 >= m:\n        print(-1)\n        return\n    \n    # Generate frame positions for this size\n    frame_positions = set()\n    top = min_r\n    bottom = min_r + size - 1\n    left = min_c\n    right = min_c + size - 1\n    \n    # Top and bottom borders\n    for j in range(left, right + 1):\n        frame_positions.add((top, j))\n        frame_positions.add((bottom, j))\n    # Left and right borders (excluding corners already added)\n    for i in range(top + 1, bottom):\n        frame_positions.add((i, left))\n        frame_positions.add((i, right))\n    \n    # Check if all whites are on frame\n    white_set = set(whites)\n    if not white_set.issubset(frame_positions):\n        print(-1)\n        return\n    \n    # Check if there are any non-white pixels on frame that shouldn't be white\n    # (all non-white pixels on frame must be black '.')\n    for pos in frame_positions:\n        i, j = pos\n        if grid[i][j] not in ['w', '.']:\n            print(-1)\n            return\n        if grid[i][j] == '.' and pos not in white_set:\n            # This is fine - we can mark it as '+' later\n            pass\n    \n    # Create output grid\n    output = [list(row) for row in grid]\n    for i, j in frame_positions:\n        if output[i][j] == '.':\n            output[i][j] = '+'\n    \n    # Print result\n    for row in output:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.79123783111572}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    print(A * B)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 10.888756275177002}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count Pythagorean triples modulo n where 1 <= a <= b <= n-1 and a^2 + b^2  c^2 (mod n).\"\"\"\n    # Precompute squares modulo n\n    squares_mod = [0] * n\n    for i in range(n):\n        squares_mod[i] = (i * i) % n\n    \n    # Count frequencies of each square residue\n    residue_count = [0] * n\n    for i in range(1, n):\n        residue_count[squares_mod[i]] += 1\n    \n    total = 0\n    # Iterate over all a and b with a <= b\n    for a in range(1, n):\n        a_sq = squares_mod[a]\n        for b in range(a, n):\n            target = (a_sq + squares_mod[b]) % n\n            total += residue_count[target]\n    \n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 21.110814809799194}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    S = data[0].strip()\n    Q = int(data[1].strip())\n    queries = data[2:2+Q]\n    \n    # Use two deques to represent the string efficiently\n    from collections import deque\n    front = deque()\n    back = deque(S)\n    \n    reversed_flag = False  # False means normal order, True means reversed\n    \n    for query in queries:\n        parts = query.strip().split()\n        t = int(parts[0])\n        \n        if t == 1:\n            # Reverse operation: just flip the flag\n            reversed_flag = not reversed_flag\n        else:  # t == 2\n            f = int(parts[1])\n            c = parts[2]\n            \n            # Determine actual side considering reversal\n            if not reversed_flag:\n                # Normal orientation\n                if f == 1:\n                    front.appendleft(c)  # Add to beginning\n                else:  # f == 2\n                    back.append(c)       # Add to end\n            else:\n                # Reversed orientation\n                if f == 1:\n                    back.append(c)       # Beginning becomes end when reversed\n                else:  # f == 2\n                    front.appendleft(c)  # End becomes beginning when reversed\n    \n    # Construct final string\n    if not reversed_flag:\n        result = ''.join(front) + ''.join(back)\n    else:\n        result = ''.join(reversed(back)) + ''.join(reversed(front))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.38294267654419}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef polygon_area(points):\n    \"\"\"Calculate area of polygon using shoelace formula.\"\"\"\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    return abs(area) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    original_points = []\n    for _ in range(n):\n        x = float(data[idx]); idx += 1\n        y = float(data[idx]); idx += 1\n        original_points.append((x, y))\n    \n    target_area = float(data[idx]); idx += 1\n    \n    # Calculate original area\n    original_area = polygon_area(original_points)\n    \n    # Calculate scaling factor\n    # Since area scales with square of linear dimensions\n    scale_factor = math.sqrt(target_area / original_area)\n    \n    # Scale the polygon\n    scaled_points = []\n    for x, y in original_points:\n        scaled_points.append((x * scale_factor, y * scale_factor))\n    \n    # Find min x and min y after scaling\n    min_x = min(x for x, y in scaled_points)\n    min_y = min(y for x, y in scaled_points)\n    \n    # Translate so min_x = 0 and min_y = 0\n    final_points = []\n    for x, y in scaled_points:\n        final_points.append((x - min_x, y - min_y))\n    \n    # Output results\n    for x, y in final_points:\n        print(f\"{x:.10f} {y:.10f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 26.189685583114624}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 59.70238780975342}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any additional sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        remaining_sleep = a - b\n        sleep_per_cycle = c - d  # net sleep gained per alarm cycle\n        \n        # Number of full cycles needed (ceil division)\n        cycles_needed = (remaining_sleep + sleep_per_cycle - 1) // sleep_per_cycle\n        \n        # Total time = first alarm + cycles * alarm interval\n        total_time = b + cycles_needed * c\n        results.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.3070011138916}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # Initialize sieve list: True means not crossed out (prime or not yet processed)\n    sieve = [True] * (N + 1)\n    sieve[0] = sieve[1] = False  # 0 and 1 are not considered\n    \n    crossed_out = []\n    \n    for p in range(2, N + 1):\n        if sieve[p]:  # p is prime\n            # Cross out p itself\n            if not (p in crossed_out):\n                crossed_out.append(p)\n                sieve[p] = False\n                if len(crossed_out) == K:\n                    print(crossed_out[-1])\n                    return\n            \n            # Cross out multiples of p\n            for multiple in range(p * 2, N + 1, p):\n                if sieve[multiple]:\n                    crossed_out.append(multiple)\n                    sieve[multiple] = False\n                    if len(crossed_out) == K:\n                        print(crossed_out[-1])\n                        return\n    \n    # In case K is larger than total crossed out numbers (should not happen given constraints)\n    print(crossed_out[K - 1])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.515135765075684}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, enemy kills one gnome per turn regardless of grouping\n    if k == 1:\n        # Sum of 1 to n\n        total = n * (n + 1) // 2\n        print(total)\n        return\n    \n    # If m is large enough to have each gnome in its own group\n    if m >= n:\n        # Each turn kills exactly k gnomes (or remaining if less)\n        total = 0\n        remaining = n\n        while remaining > 0:\n            total += remaining\n            remaining -= min(k, remaining)\n        print(total)\n        return\n    \n    # General case: we need to decide group sizes\n    # Let x be the number of groups with size > k\n    # We want to maximize damage\n    \n    # Binary search on number of large groups\n    def can_do(x):\n        # x large groups, m-x small groups\n        if x > m:\n            return False\n        # Distribute n gnomes: large groups have > k, small groups have <= k\n        # Minimum gnomes in large groups: x*(k+1)\n        if x * (k + 1) > n:\n            return False\n        remaining = n - x * (k + 1)\n        # Remaining gnomes go to small groups\n        # Each small group can have at most k gnomes\n        max_small = (m - x) * k\n        return remaining <= max_small\n    \n    # Find maximum x\n    low, high = 0, m\n    best = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_do(mid):\n            best = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    x = best  # number of large groups\n    \n    # Calculate damage\n    total = 0\n    remaining = n\n    \n    # Phase 1: large groups exist\n    # Each turn, enemy targets a large group if possible\n    # Damage per turn = remaining gnomes\n    # Killed per turn = k (from a large group)\n    large_group_size = k + 1  # initial size of each large group\n    large_gnomes = x * large_group_size\n    small_gnomes = n - large_gnomes\n    \n    # Process large groups\n    while large_gnomes > 0:\n        total += remaining\n        # Enemy kills k from a large group\n        large_gnomes -= k\n        remaining -= k\n        # If a large group becomes small (<= k), it's effectively a small group now\n        # But we continue until all large groups are gone\n    \n    # Now only small groups remain (all groups have <= k gnomes)\n    # Enemy kills one group per turn\n    # Sort group sizes descending for optimal enemy strategy\n    groups = []\n    # Distribute small_gnomes into (m - x) groups, each <= k\n    # To maximize damage, make groups as large as possible\n    num_small_groups = m - x\n    if num_small_groups > 0:\n        base = small_gnomes // num_small_groups\n        extra = small_gnomes % num_small_groups\n        for _ in range(extra):\n            groups.append(base + 1)\n        for _ in range(num_small_groups - extra):\n            groups.append(base)\n    \n    # Process small groups\n    groups.sort(reverse=True)\n    for size in groups:\n        if size == 0:\n            continue\n        # This group will be killed in ceil(size/k) turns\n        # But enemy kills entire group in one turn if size <= k\n        # Actually, since all are <= k, enemy kills each group in one turn\n        for _ in range(size):\n            total += remaining\n            remaining -= 1\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 49.599279165267944}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 59.99309849739075}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = input[idx]\n        score = int(input[idx + 1])\n        restaurants.append((city, score, i))\n        idx += 2\n    \n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    for _, _, id_num in restaurants:\n        print(id_num)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 13.631100416183472}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10**6)\n\ndef bfs(grid, start, visited, n, m, state):\n    \"\"\"Perform BFS to mark all cells reachable from start within the same state.\"\"\"\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                if grid[nx][ny] == state or grid[nx][ny] == '.':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n\ndef find_components(grid, n, m, state):\n    \"\"\"Find all connected components for a given state, including '.' cells.\"\"\"\n    visited = [[False]*m for _ in range(n)]\n    components = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state and not visited[i][j]:\n                # Start BFS from a state cell\n                bfs(grid, (i, j), visited, n, m, state)\n                # Collect all visited cells in this component\n                comp = []\n                for x in range(n):\n                    for y in range(m):\n                        if visited[x][y]:\n                            comp.append((x, y))\n                components.append(comp)\n    return components\n\ndef min_distance_between_components(comp1, comp2, grid, n, m):\n    \"\"\"Compute the minimum Manhattan distance between two components.\"\"\"\n    min_dist = float('inf')\n    for x1, y1 in comp1:\n        for x2, y2 in comp2:\n            # Check if both cells are passable or can be made passable\n            if grid[x1][y1] != '#' and grid[x2][y2] != '#':\n                dist = abs(x1 - x2) + abs(y1 - y2) - 1\n                if dist < min_dist:\n                    min_dist = dist\n    return min_dist if min_dist != float('inf') else float('inf')\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return -1\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    if len(grid) != n:\n        # Handle case where input might be split differently\n        grid = data[2:2+n]\n    \n    # Find components for each state\n    components = {}\n    for state in ['1', '2', '3']:\n        comps = find_components(grid, n, m, state)\n        if not comps:\n            return -1  # State has no reachable cells\n        components[state] = comps\n    \n    # Check if any state is completely isolated by '#'\n    for state in ['1', '2', '3']:\n        if all(grid[x][y] == '#' for comp in components[state] for x, y in comp):\n            return -1\n    \n    # Compute pairwise minimum distances between states\n    distances = {}\n    states = ['1', '2', '3']\n    for i in range(3):\n        for j in range(i+1, 3):\n            s1, s2 = states[i], states[j]\n            min_dist = float('inf')\n            for comp1 in components[s1]:\n                for comp2 in components[s2]:\n                    dist = min_distance_between_components(comp1, comp2, grid, n, m)\n                    if dist < min_dist:\n                        min_dist = dist\n            distances[(s1, s2)] = min_dist\n    \n    # Check for direct connectivity (distance 0 means already connected)\n    for dist in distances.values():\n        if dist == float('inf'):\n            return -1\n    \n    # Consider three scenarios: connect via third state or directly\n    # Scenario 1: Connect all three pairwise directly\n    direct_sum = sum(distances.values())\n    # Scenario 2: Connect two states via the third\n    via_third = float('inf')\n    for center in states:\n        others = [s for s in states if s != center]\n        via_dist = distances.get((center, others[0]), float('inf')) + distances.get((center, others[1]), float('inf'))\n        if via_dist < via_third:\n            via_third = via_dist\n    \n    result = min(direct_sum, via_third)\n    return result if result != float('inf') else -1\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 51.69787335395813}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Step 1: Check if graph is complete tripartite\n    # We'll try to 3-color the complement graph\n    # In complement graph, edges exist where original graph has no edge\n    # For tripartite in original, complement must be 3-colorable with certain structure\n    \n    # Build complement adjacency for dense check\n    # Since n up to 1e5, we need O(n+m) approach\n    \n    # First, check if graph is complete tripartite\n    # Conditions: \n    # 1. Each part is independent set (no edges within part)\n    # 2. All edges between different parts exist\n    \n    # Try to find 3 parts by checking neighborhoods\n    color = [-1] * n\n    \n    # Start BFS from first vertex\n    from collections import deque\n    \n    # We'll try to assign parts based on adjacency\n    # If vertex u is in part 1, then:\n    # - All vertices not adjacent to u must be in same part as u (since they must connect to parts 2 and 3)\n    # - Actually, let's think differently\n    \n    # For complete tripartite graph:\n    # Take any vertex v, let A = {v}  (vertices not adjacent to v)\n    # A must be one of the parts\n    # Then remaining vertices must form complete bipartite between them\n    \n    for start in range(n):\n        if color[start] != -1:\n            continue\n        \n        # Find all vertices not connected to start\n        not_adj = set(range(n))\n        not_adj.remove(start)\n        for nb in adj[start]:\n            not_adj.discard(nb)\n        \n        # These vertices + start form one part\n        part1 = [start] + list(not_adj)\n        for v in part1:\n            if color[v] != -1:\n                # Conflict, try different start\n                color = [-1] * n\n                break\n            color[v] = 1\n        else:\n            # Now we have part1 assigned\n            # Remaining vertices must form complete bipartite\n            remaining = [i for i in range(n) if color[i] == -1]\n            if not remaining:\n                # Only one part, need at least 3 non-empty parts\n                color = [-1] * n\n                continue\n            \n            # Pick first remaining vertex as part2\n            part2_start = remaining[0]\n            # Find vertices not adjacent to part2_start among remaining\n            not_adj2 = set(remaining)\n            for nb in adj[part2_start]:\n                not_adj2.discard(nb)\n            \n            part2 = list(not_adj2)\n            for v in part2:\n                if color[v] != -1:\n                    color = [-1] * n\n                    break\n                color[v] = 2\n            else:\n                # Remaining are part3\n                part3 = [i for i in range(n) if color[i] == -1]\n                if not part3:\n                    color = [-1] * n\n                    continue\n                for v in part3:\n                    color[v] = 3\n                \n                # Verify the assignment\n                valid = True\n                # Check each part is independent\n                parts = {1: [], 2: [], 3: []}\n                for i in range(n):\n                    parts[color[i]].append(i)\n                \n                if not parts[1] or not parts[2] or not parts[3]:\n                    valid = False\n                \n                # Check no edges within parts\n                for part_id in [1, 2, 3]:\n                    for u in parts[part_id]:\n                        for v in parts[part_id]:\n                            if u < v and v in adj[u]:\n                                valid = False\n                                break\n                        if not valid:\n                            break\n                    if not valid:\n                        break\n                \n                # Check all edges between different parts exist\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if color[i] != color[j]:\n                            if j not in adj[i]:\n                                valid = False\n                                break\n                    if not valid:\n                        break\n                \n                if valid:\n                    # Output result\n                    print(' '.join(str(color[i]) for i in range(n)))\n                    return\n                else:\n                    color = [-1] * n\n                    continue\n            \n            color = [-1] * n\n    \n    # If we get here, no valid partition found\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 54.313162088394165}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    \n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    increase = []\n    decrease = []\n    \n    for a, b in projects:\n        if b >= 0:\n            increase.append((a, b))\n        else:\n            decrease.append((a, b))\n    \n    # Sort increasing projects by required rating (a) ascending\n    increase.sort(key=lambda x: x[0])\n    \n    # Sort decreasing projects by (a + b) descending, then by a descending\n    # This ensures we do projects with higher final rating first\n    decrease.sort(key=lambda x: (-(x[0] + x[1]), -x[0]))\n    \n    # Process increasing projects first\n    for a, b in increase:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    # Process decreasing projects\n    for a, b in decrease:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.760828733444214}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.58743238449097}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+m]))\n\n# Track count of each difficulty in pool\ncount = [0] * (n + 1)\n# Track number of distinct difficulties currently in pool\ndistinct = 0\nresult = []\n\nfor difficulty in a:\n    # Add problem to pool\n    if count[difficulty] == 0:\n        distinct += 1\n    count[difficulty] += 1\n    \n    # Check if we can hold a round\n    if distinct == n:\n        result.append('1')\n        # Remove one problem of each difficulty\n        for d in range(1, n + 1):\n            count[d] -= 1\n            if count[d] == 0:\n                distinct -= 1\n    else:\n        result.append('0')\n\nprint(''.join(result))", "runtime_sec": 20.65227746963501}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    ans = 0\n    for a in range(1, N + 1):\n        max_b = N // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 15.379852533340454}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    n = int(data[0])\n    roads = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx]); b = int(data[idx+1])\n        idx += 2\n        roads.append((a, b))\n    \n    # Count how many times each city appears as endpoint\n    degree = [0] * (n + 1)\n    for a, b in roads:\n        degree[a] += 1\n        degree[b] += 1\n    \n    # For each road, assign it to the city with smaller current degree\n    # to balance the assignment\n    assigned = [False] * n\n    result = []\n    \n    # Process roads\n    for i, (a, b) in enumerate(roads):\n        if degree[a] <= degree[b]:\n            result.append(f\"{a} {b}\")\n            degree[a] -= 1\n        else:\n            result.append(f\"{b} {a}\")\n            degree[b] -= 1\n    \n    # Output\n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.312097311019897}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Check if they are in the same residue class modulo k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Determine direction\n    step = k if t_pos > g_pos else -k\n    \n    # Check all cells along the path\n    pos = g_pos\n    while pos != t_pos:\n        pos += step\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.220324277877808}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Mark all water cells as visited\n    visited = [[False] * c for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'W':\n                visited[i][j] = True\n    \n    # BFS to mark all connected land cells\n    def bfs(start_i, start_j):\n        queue = [(start_i, start_j)]\n        visited[start_i][start_j] = True\n        while queue:\n            i, j = queue.pop(0)\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < r and 0 <= nj < c and not visited[ni][nj] and grid[ni][nj] != 'W':\n                    visited[ni][nj] = True\n                    queue.append((ni, nj))\n    \n    # Count islands\n    islands = 0\n    for i in range(r):\n        for j in range(c):\n            if not visited[i][j] and grid[i][j] != 'W':\n                islands += 1\n                bfs(i, j)\n    \n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.586580514907837}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x[i] = int(next(it))\n        y[i] = int(next(it))\n    \n    # Compute area using shoelace formula\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += x[i] * y[j] - x[j] * y[i]\n    area = abs(area) / 2.0\n    \n    # Compute integrals for expected Manhattan distance\n    # E[|x1 - x2|] = (1/A^2) *  |x1 - x2| dA1 dA2\n    # = (1/A) *  (x^2 * f(x) - 2*x * g(x) + h(x)) dx, where:\n    # f(x) = probability density of x coordinate\n    # g(x) = _{-}^{x} t * f(t) dt\n    # h(x) = _{-}^{x} t^2 * f(t) dt\n    # Similar for y.\n    \n    # For convex polygon, we can compute by decomposing into triangles from a fixed point\n    # But a simpler approach: use formula for expected L1 distance in convex polygon\n    # Known result: E[|x1-x2|+|y1-y2|] = (1/(6*A)) * _{i=0}^{n-1} (|x_i - x_{i+1}| * (x_i^2 + x_i*x_{i+1} + x_{i+1}^2 + y_i^2 + y_i*y_{i+1} + y_{i+1}^2))\n    # Wait, that seems off. Let's derive properly.\n    \n    # Actually, for Manhattan distance, we can separate x and y:\n    # E[|x1-x2|+|y1-y2|] = E[|x1-x2|] + E[|y1-y2|]\n    # And E[|x1-x2|] = (1/A^2) *  |x1-x2| dx1 dy1 dx2 dy2\n    # This can be computed using:\n    # E[|x1-x2|] = (1/(3*A)) * _{i=0}^{n-1} |x_i - x_{i+1}| * (x_i^2 + x_i*x_{i+1} + x_{i+1}^2) / (x_i - x_{i+1})^2? No.\n    \n    # Let's use the correct formula from known solutions:\n    # For convex polygon with area A, expected Manhattan distance between two random points is:\n    # (1/(6*A)) * _{i=0}^{n-1} (|dx| * (x_i^2 + x_i*x_{i+1} + x_{i+1}^2) + |dy| * (y_i^2 + y_i*y_{i+1} + y_{i+1}^2))\n    # where dx = x_{i+1} - x_i, dy = y_{i+1} - y_i\n    \n    total = 0.0\n    for i in range(n):\n        x1, y1 = x[i], y[i]\n        x2, y2 = x[(i+1)%n], y[(i+1)%n]\n        dx = x2 - x1\n        dy = y2 - y1\n        \n        # Contribution from x-coordinate part\n        if abs(dx) > 1e-12:\n            total += abs(dx) * (x1*x1 + x1*x2 + x2*x2)\n        # Contribution from y-coordinate part\n        if abs(dy) > 1e-12:\n            total += abs(dy) * (y1*y1 + y1*y2 + y2*y2)\n    \n    expected = total / (6.0 * area)\n    print(f\"{expected:.15f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 46.08437395095825}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\nimport math\n\n# Function to count number of quadruples (a, b, c, d) where a < b < c < d <= n\n# and b = a * k, c = b * k, d = c * k for some integer k > 1\ndef count_ways(n):\n    ways = 0\n    # For each possible first thief amount a\n    for a in range(1, n + 1):\n        # For each possible multiplier k > 1\n        for k in range(2, n + 1):\n            b = a * k\n            if b > n:\n                break\n            c = b * k\n            if c > n:\n                break\n            d = c * k\n            if d > n:\n                break\n            ways += 1\n    return ways\n\n# Optimized function using mathematical formula\n# For each a and k where a*k^3 <= n, we have a valid quadruple\n# So ways = sum_{a=1}^{n} sum_{k=2}^{floor(n/a)^{1/3}} 1\n# = sum_{a=1}^{n} (floor((n/a)^{1/3}) - 1) for floor((n/a)^{1/3}) >= 2\n# We can compute this efficiently using integer cube roots\n\ndef count_ways_fast(n):\n    ways = 0\n    max_a = n\n    for a in range(1, max_a + 1):\n        # Find maximum k such that a*k^3 <= n\n        max_k = int(round((n / a) ** (1/3)))\n        # Adjust for floating point errors\n        while a * (max_k + 1) ** 3 <= n:\n            max_k += 1\n        while a * max_k ** 3 > n:\n            max_k -= 1\n        if max_k >= 2:\n            ways += (max_k - 1)\n    return ways\n\n# Even faster using the observation that for each k, a can be from 1 to floor(n/k^3)\n# So ways = sum_{k=2}^{floor(n^{1/3})} floor(n/k^3)\ndef count_ways_fastest(n):\n    ways = 0\n    max_k = int(round(n ** (1/3)))\n    # Adjust for floating point errors\n    while (max_k + 1) ** 3 <= n:\n        max_k += 1\n    while max_k ** 3 > n:\n        max_k -= 1\n    \n    for k in range(2, max_k + 1):\n        ways += n // (k * k * k)\n    return ways\n\n# Binary search to find smallest n with exactly m ways\ndef find_smallest_n(m):\n    if m <= 0:\n        return -1\n    \n    # Upper bound: for n = m*8, we have at least m ways (rough estimate)\n    low, high = 1, max(8, m * 8)\n    \n    # Increase high until we find n with ways >= m\n    while count_ways_fastest(high) < m:\n        high *= 2\n        if high > 10**18:  # Safety limit\n            break\n    \n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        ways = count_ways_fastest(mid)\n        if ways == m:\n            result = mid\n            high = mid - 1  # Look for smaller n\n        elif ways < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    result = find_smallest_n(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 48.50637435913086}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    q = int(data[idx]); idx += 1\n    results = []\n    \n    # Precompute the infinite RGB pattern\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); idx += 1\n        k = int(data[idx]); idx += 1\n        s = data[idx]; idx += 1\n        \n        # We need to check all possible starting positions for the substring\n        # and all three possible starting characters in the RGB pattern\n        min_changes = float('inf')\n        \n        # For each possible starting character in the RGB pattern\n        for start_char_idx in range(3):\n            # Precompute prefix sums of mismatches for this pattern alignment\n            # pattern_char = pattern[(start_char_idx + i) % 3] for position i\n            prefix = [0] * (n + 1)\n            for i in range(n):\n                expected_char = pattern[(start_char_idx + i) % 3]\n                mismatch = 1 if s[i] != expected_char else 0\n                prefix[i + 1] = prefix[i] + mismatch\n            \n            # Check all substrings of length k\n            for i in range(n - k + 1):\n                changes = prefix[i + k] - prefix[i]\n                min_changes = min(min_changes, changes)\n        \n        results.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.45489501953125}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    dictionary = data[1:1+n]\n    start = dictionary[0]\n    end = dictionary[1]\n    original_dict = set(dictionary)\n    \n    # BFS to find shortest path without adding any word\n    def bfs(start_word, end_word, word_set):\n        if start_word == end_word:\n            return 0\n        visited = {start_word}\n        queue = deque([(start_word, 0)])\n        while queue:\n            word, dist = queue.popleft()\n            for i in range(len(word)):\n                for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word == end_word:\n                        return dist + 1\n                    if new_word in word_set and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, dist + 1))\n        return float('inf')\n    \n    original_distance = bfs(start, end, original_dict)\n    \n    # If start and end are same length but not in dictionary or unreachable\n    if original_distance == float('inf'):\n        # Try adding one word to connect\n        best_word = \"0\"\n        best_distance = float('inf')\n        \n        # Generate all possible words of same length\n        word_len = len(start)\n        all_possible = set()\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                for word in original_dict:\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word not in original_dict:\n                        all_possible.add(new_word)\n        \n        # Also consider words that are one letter change from start or end\n        for word in [start, end]:\n            for i in range(word_len):\n                for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word not in original_dict:\n                        all_possible.add(new_word)\n        \n        # Try each candidate word\n        candidates = []\n        for candidate in sorted(all_possible):\n            new_dict = original_dict | {candidate}\n            dist = bfs(start, end, new_dict)\n            if dist < best_distance:\n                best_distance = dist\n                best_word = candidate\n                candidates = [(candidate, dist)]\n            elif dist == best_distance and dist < float('inf'):\n                candidates.append((candidate, dist))\n        \n        if candidates:\n            # Sort alphabetically and by distance\n            candidates.sort(key=lambda x: (x[1], x[0]))\n            best_word, best_distance = candidates[0]\n            print(best_word)\n            print(best_distance)\n        else:\n            print(\"0\")\n            print(\"-1\")\n    else:\n        # Original path exists, check if adding a word can shorten it\n        best_word = \"0\"\n        best_distance = original_distance\n        \n        # Generate candidate words that could create shortcuts\n        word_len = len(start)\n        all_possible = set()\n        \n        # Words that are one change from any dictionary word\n        for word in original_dict:\n            for i in range(word_len):\n                for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word not in original_dict:\n                        all_possible.add(new_word)\n        \n        # Try each candidate\n        improved = False\n        candidates = []\n        for candidate in sorted(all_possible):\n            new_dict = original_dict | {candidate}\n            dist = bfs(start, end, new_dict)\n            if dist < best_distance:\n                best_distance = dist\n                best_word = candidate\n                improved = True\n                candidates = [(candidate, dist)]\n            elif dist == best_distance and dist < best_distance:\n                candidates.append((candidate, dist))\n        \n        if improved:\n            if candidates:\n                candidates.sort(key=lambda x: (x[1], x[0]))\n                best_word, best_distance = candidates[0]\n            print(best_word)\n            print(best_distance)\n        else:\n            print(\"0\")\n            print(original_distance)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 50.813841104507446}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:2*n+1]))\n    \n    # Track whether we've seen the first sock of each pair\n    seen = [False] * (n + 1)\n    current_on_table = 0\n    max_on_table = 0\n    \n    for sock in socks:\n        if not seen[sock]:\n            # First sock of this pair\n            seen[sock] = True\n            current_on_table += 1\n        else:\n            # Second sock of this pair\n            current_on_table -= 1\n        \n        # Update maximum\n        if current_on_table > max_on_table:\n            max_on_table = current_on_table\n    \n    print(max_on_table)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 19.31363582611084}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2, solve for R2: R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 12.833533763885498}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef days_in_month(month):\n    \"\"\"Return number of days in given month (1-indexed).\"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    return days[month - 1]\n\ndef date_to_days(d, m):\n    \"\"\"Convert day and month to day number in year (1 to 365).\"\"\"\n    total = 0\n    for month in range(1, m):\n        total += days_in_month(month)\n    total += d\n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    # Build linear equations: for each telescope, sum_i (duration_i * count_i) = observation_days\n    equations = []\n    for _ in range(N):\n        d1 = int(data[idx]); idx += 1\n        m1 = int(data[idx]); idx += 1\n        d2 = int(data[idx]); idx += 1\n        m2 = int(data[idx]); idx += 1\n        \n        start_day = date_to_days(d1, m1)\n        end_day = date_to_days(d2, m2)\n        \n        # Handle wrap-around across year boundary\n        if end_day < start_day:\n            end_day += 365\n        observation_days = end_day - start_day + 1  # inclusive\n        \n        counts = []\n        for __ in range(M):\n            counts.append(int(data[idx])); idx += 1\n        \n        equations.append((counts, observation_days))\n    \n    # Solve using Gaussian elimination over integers\n    # Variables: durations[0..M-1]\n    # Constraints: 1 <= duration_i <= 365\n    \n    # Try all possible durations (1 to 365) for each event type\n    # Since M <= 200, brute force over all combinations is impossible (365^200).\n    # Instead, treat as system of linear equations and find integer solution.\n    \n    # Build augmented matrix\n    A = []\n    b = []\n    for counts, obs in equations:\n        A.append(counts[:])\n        b.append(obs)\n    \n    # Gaussian elimination with integer arithmetic\n    rows = len(A)\n    cols = M\n    \n    # Forward elimination\n    row = 0\n    col = 0\n    while row < rows and col < cols:\n        # Find pivot\n        pivot = -1\n        for i in range(row, rows):\n            if A[i][col] != 0:\n                pivot = i\n                break\n        if pivot == -1:\n            col += 1\n            continue\n        \n        # Swap rows\n        A[row], A[pivot] = A[pivot], A[row]\n        b[row], b[pivot] = b[pivot], b[row]\n        \n        # Eliminate below\n        for i in range(row + 1, rows):\n            if A[i][col] == 0:\n                continue\n            # Compute LCM to avoid fractions\n            lcm_val = abs(A[row][col] * A[i][col]) // math.gcd(abs(A[row][col]), abs(A[i][col]))\n            factor1 = lcm_val // A[row][col]\n            factor2 = lcm_val // A[i][col]\n            \n            for j in range(col, cols):\n                A[i][j] = A[i][j] * factor2 - A[row][j] * factor1\n            b[i] = b[i] * factor2 - b[row] * factor1\n        \n        row += 1\n        col += 1\n    \n    # Back substitution\n    durations = [0] * M\n    for i in range(min(rows, cols) - 1, -1, -1):\n        # Find first non-zero coefficient\n        col_idx = -1\n        for j in range(cols):\n            if A[i][j] != 0:\n                col_idx = j\n                break\n        if col_idx == -1:\n            if b[i] != 0:\n                print(-1)\n                return\n            continue\n        \n        # Solve for variable at col_idx\n        coeff = A[i][col_idx]\n        total = b[i]\n        for j in range(col_idx + 1, cols):\n            total -= A[i][j] * durations[j]\n        \n        if total % coeff != 0:\n            print(-1)\n            return\n        \n        durations[col_idx] = total // coeff\n        \n        # Check bounds\n        if durations[col_idx] < 1 or durations[col_idx] > 365:\n            print(-1)\n            return\n    \n    # Set any remaining free variables to 1 (valid since 1 <= duration <= 365)\n    for i in range(cols):\n        if durations[i] == 0:\n            durations[i] = 1\n    \n    # Verify all equations\n    for counts, obs in equations:\n        total = 0\n        for j in range(M):\n            total += counts[j] * durations[j]\n        if total != obs:\n            print(-1)\n            return\n    \n    print(' '.join(map(str, durations)))\n\nif __name__ == \"__main__\":\n    import math\n    solve()", "runtime_sec": 53.63780641555786}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * (n + 1)\n    comp_id = [0] * (n + 1)\n    comp_nodes = []\n    \n    def dfs(node, cid):\n        stack = [node]\n        comp_nodes.append([])\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            comp_id[u] = cid\n            comp_nodes[cid].append(u)\n            for v in adj[u]:\n                if not visited[v]:\n                    stack.append(v)\n    \n    cid = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, cid)\n            cid += 1\n    \n    # For each component, find min and max node number\n    comp_min = [n + 1] * cid\n    comp_max = [0] * cid\n    for i in range(cid):\n        for node in comp_nodes[i]:\n            if node < comp_min[i]:\n                comp_min[i] = node\n            if node > comp_max[i]:\n                comp_max[i] = node\n    \n    # Sort components by min node\n    comps = list(range(cid))\n    comps.sort(key=lambda i: comp_min[i])\n    \n    # Merge overlapping intervals\n    merged = []\n    for i in comps:\n        if not merged:\n            merged.append([comp_min[i], comp_max[i]])\n        else:\n            last_min, last_max = merged[-1]\n            if comp_min[i] <= last_max + 1:\n                # Overlap or adjacent, merge\n                if comp_max[i] > last_max:\n                    merged[-1][1] = comp_max[i]\n            else:\n                merged.append([comp_min[i], comp_max[i]])\n    \n    # Count gaps between merged intervals\n    edges_to_add = 0\n    for i in range(1, len(merged)):\n        edges_to_add += merged[i][0] - merged[i-1][1] - 1\n    \n    print(edges_to_add)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.58686709403992}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # For each value, consider it becoming X, or X-1, or X+1\n    max_count = 0\n    for val in set(a):\n        # Count how many can become val\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n        \n        # Also consider val-1 and val+1 as potential X\n        if val-1 >= 0:\n            count_minus = freq.get(val-1, 0)\n            count_minus += freq.get(val-2, 0)\n            count_minus += freq.get(val, 0)\n            max_count = max(max_count, count_minus)\n        \n        count_plus = freq.get(val+1, 0)\n        count_plus += freq.get(val, 0)\n        count_plus += freq.get(val+2, 0)\n        max_count = max(max_count, count_plus)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.91574788093567}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.91995716094971}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    jobs = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        jobs.append((b, a))  # (deadline, duration)\n    \n    # Sort jobs by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.696362972259521}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1 + n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        g = math.gcd(lcm_val, t)\n        lcm_val = (lcm_val // g) * t\n        if lcm_val > 10**18:\n            # Early exit if LCM exceeds the guaranteed maximum answer\n            print(10**18)\n            return\n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.784590244293213}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.70370626449585}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    idx = 0\n    n = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    a = [int(data[idx + i]) for i in range(n)]; idx += n\n    q = int(data[idx]); idx += 1\n    queries = [int(data[idx + i]) for i in range(q)]\n    \n    # Precompute all possible sums using at most k bills of at most two denominations\n    possible = {}\n    \n    # Single denomination\n    for i in range(n):\n        denom = a[i]\n        for count in range(1, k + 1):\n            s = denom * count\n            if s not in possible or count < possible[s]:\n                possible[s] = count\n    \n    # Two denominations\n    for i in range(n):\n        for j in range(i + 1, n):\n            d1, d2 = a[i], a[j]\n            for c1 in range(k + 1):\n                for c2 in range(k + 1 - c1):\n                    if c1 + c2 == 0:\n                        continue\n                    s = d1 * c1 + d2 * c2\n                    bills = c1 + c2\n                    if s not in possible or bills < possible[s]:\n                        possible[s] = bills\n    \n    # Answer queries\n    res = []\n    for x in queries:\n        if x in possible:\n            res.append(str(possible[x]))\n        else:\n            res.append(\"-1\")\n    print(\"\\n\".join(res))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.63554549217224}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    remainder_count = [0] * k\n    for candies in d:\n        remainder_count[candies % k] += 1\n    \n    # Pair boxes with remainder 0 with themselves\n    pairs = remainder_count[0] // 2\n    \n    # Pair complementary remainders (i and k-i)\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        pairs += min(remainder_count[i], remainder_count[j])\n    \n    # Special case when k is even: pair remainder k/2 with itself\n    if k % 2 == 0:\n        pairs += remainder_count[k // 2] // 2\n    \n    # Each pair uses 2 boxes\n    print(pairs * 2)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.561373710632324}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    k, d, t = map(int, data)\n    \n    # If k is multiple of d, stove always on after first turn on\n    if k % d == 0:\n        print(float(t))\n        return\n    \n    # Calculate cycle parameters\n    # Cycle: stove on for k minutes, then off until next multiple of d\n    off_time = d - (k % d)\n    cycle_time = k + off_time\n    \n    # Cooking progress per cycle\n    # When on: 1/t per minute, when off: 1/(2t) per minute\n    progress_per_cycle = k / t + off_time / (2 * t)\n    \n    # Number of full cycles needed\n    full_cycles = math.floor(1.0 / progress_per_cycle)\n    remaining_progress = 1.0 - full_cycles * progress_per_cycle\n    \n    # Time for full cycles\n    total_time = full_cycles * cycle_time\n    \n    # Handle remaining progress\n    if remaining_progress > 0:\n        # First try to use on time\n        progress_from_on = k / t\n        if remaining_progress <= progress_from_on:\n            total_time += remaining_progress * t\n        else:\n            total_time += k\n            remaining_progress -= progress_from_on\n            # Use off time\n            total_time += remaining_progress * (2 * t)\n    \n    # Output with sufficient precision\n    print(f\"{total_time:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.429182767868042}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Build adjacency list for the directed graph of important pairs\n    adj = [[] for _ in range(n + 1)]\n    indeg = [0] * (n + 1)\n    outdeg = [0] * (n + 1)\n    \n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        outdeg[a] += 1\n        indeg[b] += 1\n    \n    # Find strongly connected components (SCCs) using Kosaraju's algorithm\n    visited = [False] * (n + 1)\n    order = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Build reversed graph\n    rev_adj = [[] for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n    \n    comp = [0] * (n + 1)\n    comp_id = 0\n    \n    def dfs2(u, cid):\n        comp[u] = cid\n        for v in rev_adj[u]:\n            if comp[v] == 0:\n                dfs2(v, cid)\n    \n    for u in reversed(order):\n        if comp[u] == 0:\n            comp_id += 1\n            dfs2(u, comp_id)\n    \n    # Count SCCs\n    num_scc = comp_id\n    if num_scc == 1:\n        print(0)\n        return\n    \n    # Build condensation DAG\n    dag_adj = [set() for _ in range(num_scc + 1)]\n    for u in range(1, n + 1):\n        cu = comp[u]\n        for v in adj[u]:\n            cv = comp[v]\n            if cu != cv:\n                dag_adj[cu].add(cv)\n    \n    # Count sources and sinks in the condensation DAG\n    sources = 0\n    sinks = 0\n    for i in range(1, num_scc + 1):\n        if len(dag_adj[i]) == 0:\n            sinks += 1\n        # Check if it's a source: no incoming edges from other SCCs\n        has_incoming = False\n        for j in range(1, num_scc + 1):\n            if i in dag_adj[j]:\n                has_incoming = True\n                break\n        if not has_incoming:\n            sources += 1\n    \n    # Minimum edges to make condensation DAG strongly connected\n    result = max(sources, sinks)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 42.18993401527405}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    s = int(input().strip())\n    seen = {}\n    current = s\n    idx = 1\n    \n    while True:\n        if current in seen:\n            print(idx)\n            return\n        seen[current] = idx\n        if current % 2 == 0:\n            current //= 2\n        else:\n            current = 3 * current + 1\n        idx += 1\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.928444862365723}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.490769147872925}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open+1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close-1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon+1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 50.462751626968384}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        skills = list(map(int, input_data[idx:idx + n]))\n        idx += n\n        \n        # Count frequency of each skill\n        freq = collections.Counter(skills)\n        \n        # Get unique skills count and maximum frequency\n        unique_count = len(freq)\n        max_freq = max(freq.values()) if freq else 0\n        \n        # Calculate possible team size\n        # Option 1: Use unique skills for team1, and same skills for team2\n        # We can take min(unique_count-1, max_freq) or min(unique_count, max_freq-1)\n        # The maximum size is the maximum of these two options\n        \n        option1 = min(unique_count - 1, max_freq) if unique_count > 0 else 0\n        option2 = min(unique_count, max_freq - 1) if max_freq > 0 else 0\n        \n        ans = max(option1, option2)\n        results.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.930715084075928}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Find the minimum bid\n    min_val = min(a)\n    \n    # For each bid, divide by 2 and 3 until we can't\n    # The core idea: all numbers must reduce to the same value after removing factors of 2 and 3\n    for x in a:\n        # Divide by 2 as much as possible\n        while x % 2 == 0:\n            x //= 2\n        # Divide by 3 as much as possible\n        while x % 3 == 0:\n            x //= 3\n        \n        # Now do the same for the minimum value\n        y = min_val\n        while y % 2 == 0:\n            y //= 2\n        while y % 3 == 0:\n            y //= 3\n        \n        # If the reduced values don't match, it's impossible\n        if x != y:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.143980979919434}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\n# Read all input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\n\nidx = 0\nB = int(lines[idx]); idx += 1\n\n# Read tax bands\nbands = []\nfor _ in range(B):\n    s = float(lines[idx]); idx += 1\n    p = float(lines[idx]); idx += 1\n    bands.append((s, p))\n\nP = float(lines[idx]); idx += 1\nF = int(lines[idx]); idx += 1\n\n# Process each friend\nresults = []\nfor _ in range(F):\n    e = float(lines[idx]); idx += 1\n    m = float(lines[idx]); idx += 1\n    \n    # Function to compute after-tax amount given pre-tax gift\n    def after_tax(gift):\n        total_income = e + gift\n        tax = 0.0\n        prev_bound = 0.0\n        \n        # Apply tax bands\n        for s, p in bands:\n            if total_income > prev_bound:\n                taxable = min(s - prev_bound, total_income - prev_bound)\n                tax += taxable * (p / 100.0)\n                prev_bound = s\n            else:\n                break\n        \n        # Apply final percentage on income above last band\n        if total_income > prev_bound:\n            tax += (total_income - prev_bound) * (P / 100.0)\n        \n        return gift - tax\n    \n    # Binary search for the correct gift amount\n    low = 0.0\n    high = 1e12  # Upper bound large enough\n    \n    # Perform binary search until desired precision\n    for _ in range(100):  # 100 iterations gives precision ~1e-30\n        mid = (low + high) / 2.0\n        if after_tax(mid) < m:\n            low = mid\n        else:\n            high = mid\n    \n    results.append(f\"{(low + high) / 2.0:.6f}\")\n\n# Output results\nprint(\"\\n\".join(results))", "runtime_sec": 31.28803300857544}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport heapq\n\nINF = 10**18\n\ndef dijkstra(start, n, graph):\n    dist = [INF] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    graph = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        w = int(next(it))\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n        edges.append((u, v, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute shortest distances from each route endpoint\n    dist_from = {}\n    for a, b in routes:\n        if a not in dist_from:\n            dist_from[a] = dijkstra(a, n, graph)\n        if b not in dist_from:\n            dist_from[b] = dijkstra(b, n, graph)\n    \n    # Compute original total cost\n    original_total = 0\n    for a, b in routes:\n        original_total += dist_from[a][b]\n    \n    # Try making each road zero cost\n    best_total = original_total\n    for u, v, w in edges:\n        # For each route, new distance is min(original, using zero-cost road)\n        new_total = 0\n        for a, b in routes:\n            original = dist_from[a][b]\n            # Path via zero-cost road: a->u + 0 + v->b or a->v + 0 + u->b\n            via_u_v = dist_from[a][u] + dist_from[v][b]\n            via_v_u = dist_from[a][v] + dist_from[u][b]\n            new_dist = min(original, via_u_v, via_v_u)\n            new_total += new_dist\n        best_total = min(best_total, new_total)\n    \n    print(best_total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 37.599613189697266}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ninput = sys.stdin.readline\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    root_x = find(x, parent)\n    root_y = find(y, parent)\n    if root_x == root_y:\n        return\n    if size[root_x] < size[root_y]:\n        root_x, root_y = root_y, root_x\n    parent[root_y] = root_x\n    size[root_x] += size[root_y]\n\ndef bfs(start, adj):\n    from collections import deque\n    n = len(adj)\n    dist = [-1] * n\n    dist[start] = 0\n    q = deque([start])\n    farthest = start\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n                if dist[v] > dist[farthest]:\n                    farthest = v\n    return farthest, dist\n\ndef tree_diameter(adj, component_nodes):\n    if not component_nodes:\n        return 0\n    start = next(iter(component_nodes))\n    farthest1, _ = bfs(start, adj)\n    farthest2, dist = bfs(farthest1, adj)\n    return dist[farthest2]\n\ndef main():\n    c, l = map(int, input().split())\n    adj = [[] for _ in range(c)]\n    parent = list(range(c))\n    size = [1] * c\n    \n    for _ in range(l):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n        union(a, b, parent, size)\n    \n    components = {}\n    for i in range(c):\n        root = find(i, parent)\n        if root not in components:\n            components[root] = []\n        components[root].append(i)\n    \n    diameters = []\n    for nodes in components.values():\n        diameters.append(tree_diameter(adj, nodes))\n    \n    diameters.sort(reverse=True)\n    \n    if len(diameters) == 1:\n        print(diameters[0])\n        return\n    \n    max_hops = diameters[0]\n    for i in range(1, len(diameters)):\n        candidate = (max_hops + 1) // 2 + (diameters[i] + 1) // 2 + 1\n        max_hops = max(max_hops, diameters[i], candidate)\n    \n    print(max_hops)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 33.240381717681885}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count total wins for each player\n    total_wins = [0, 0]\n    for x in a:\n        total_wins[x-1] += 1\n    \n    results = []\n    \n    # Try all possible t values (points to win a set)\n    # t must be at least 1 and at most max(total_wins[0], total_wins[1])\n    max_t = max(total_wins[0], total_wins[1])\n    \n    for t in range(1, max_t + 1):\n        # Simulate the match with this t\n        sets_won = [0, 0]\n        points = [0, 0]\n        last_set_winner = -1\n        valid = True\n        \n        for serve in a:\n            player = serve - 1  # 0 for Petya, 1 for Gena\n            points[player] += 1\n            \n            # Check if set is won\n            if points[player] == t:\n                sets_won[player] += 1\n                last_set_winner = player\n                points = [0, 0]\n                \n                # Check if match is over\n                if sets_won[player] > sets_won[1-player]:\n                    # Match should end when this player reaches s sets\n                    # Check if this is the last serve\n                    if serve == a[-1]:\n                        # This is valid, s = sets_won[player]\n                        s = sets_won[player]\n                        # Verify that the other player has exactly s-1 sets\n                        if sets_won[1-player] == s - 1:\n                            results.append((s, t))\n                        valid = False\n                        break\n                    else:\n                        # Match ended but there are more serves - invalid\n                        valid = False\n                        break\n        \n        # If we processed all serves and match wasn't decided, it's invalid\n        if valid:\n            # Match didn't finish - invalid\n            continue\n    \n    # Sort results\n    results.sort()\n    \n    # Output\n    print(len(results))\n    for s, t in results:\n        print(f\"{s} {t}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.20341730117798}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B, C, D, E, F = map(int, sys.stdin.readline().split())\n    \n    # Maximum water mass we can have (in grams)\n    max_water = F // 100 * 100\n    \n    # Generate all possible water amounts using operations 1 and 2\n    water_amounts = set()\n    for i in range(max_water // (100 * A) + 1):\n        for j in range((max_water - i * 100 * A) // (100 * B) + 1):\n            water = i * 100 * A + j * 100 * B\n            if water <= max_water and water > 0:\n                water_amounts.add(water)\n    \n    # Generate all possible sugar amounts using operations 3 and 4\n    max_sugar = F\n    sugar_amounts = set()\n    for i in range(max_sugar // C + 1):\n        for j in range((max_sugar - i * C) // D + 1):\n            sugar = i * C + j * D\n            if sugar <= max_sugar:\n                sugar_amounts.add(sugar)\n    \n    best_total = 100 * A  # minimum water amount\n    best_sugar = 0\n    best_density = 0.0\n    \n    # Try all combinations of water and sugar\n    for water in water_amounts:\n        max_dissolved_sugar = min(water // 100 * E, F - water)\n        \n        # Find the maximum sugar amount <= max_dissolved_sugar\n        max_possible_sugar = 0\n        for sugar in sugar_amounts:\n            if sugar <= max_dissolved_sugar:\n                max_possible_sugar = max(max_possible_sugar, sugar)\n        \n        if max_possible_sugar == 0:\n            continue\n        \n        total = water + max_possible_sugar\n        if total > F:\n            continue\n        \n        # Calculate density (percentage)\n        density = (100 * max_possible_sugar) / total if total > 0 else 0.0\n        \n        # Update best solution\n        if density > best_density or (abs(density - best_density) < 1e-9 and total > best_total):\n            best_density = density\n            best_total = total\n            best_sugar = max_possible_sugar\n        \n        # Also consider using less sugar if it gives same density but larger total\n        for sugar in sugar_amounts:\n            if sugar < max_possible_sugar and sugar > 0:\n                total2 = water + sugar\n                if total2 > F:\n                    continue\n                density2 = (100 * sugar) / total2\n                if abs(density2 - best_density) < 1e-9 and total2 > best_total:\n                    best_total = total2\n                    best_sugar = sugar\n    \n    # If no sugar water found (only pure water possible)\n    if best_sugar == 0:\n        # Find maximum water amount <= F\n        max_water_only = 0\n        for water in water_amounts:\n            if water <= F and water > max_water_only:\n                max_water_only = water\n        print(f\"{max_water_only} 0\")\n    else:\n        print(f\"{best_total} {best_sugar}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 42.97540783882141}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    p = int(data[0])\n    seq = list(map(int, data[1:1 + p]))\n    return p, seq\n\ndef find_triple_correlation(p, seq):\n    min_threshold = (p + 39) // 40 + 1  # ceil(p/40) + 1\n    best = None  # (start_idx, n, m, a, b, c)\n    \n    # Try all possible a, b, c (digits 0-9) and n, m (distances)\n    for a in range(10):\n        for b in range(10):\n            for c in range(10):\n                for n in range(1, p):  # n >= 1\n                    for m in range(1, p):  # m >= 1\n                        if n + m >= p:\n                            continue  # a(n)b(m)c pattern would exceed sequence length\n                        \n                        # Check all three conditions\n                        valid = True\n                        count = 0\n                        \n                        # Condition 1: a followed n later by b implies c m after b\n                        for i in range(p - (n + m)):\n                            if seq[i] == a and seq[i + n] == b:\n                                if seq[i + n + m] != c:\n                                    valid = False\n                                    break\n                                count += 1\n                        if not valid:\n                            continue\n                        \n                        # Condition 2: b followed m later by c implies a n before b\n                        for i in range(n, p - m):\n                            if seq[i] == b and seq[i + m] == c:\n                                if seq[i - n] != a:\n                                    valid = False\n                                    break\n                        if not valid:\n                            continue\n                        \n                        # Condition 3: a followed n+m later by c implies b n after a\n                        for i in range(p - (n + m)):\n                            if seq[i] == a and seq[i + n + m] == c:\n                                if seq[i + n] != b:\n                                    valid = False\n                                    break\n                        if not valid:\n                            continue\n                        \n                        # Check minimum occurrence threshold\n                        if count >= min_threshold:\n                            # Find earliest occurrence\n                            first_occurrence = -1\n                            for i in range(p - (n + m)):\n                                if seq[i] == a and seq[i + n] == b and seq[i + n + m] == c:\n                                    first_occurrence = i\n                                    break\n                            \n                            if first_occurrence != -1:\n                                candidate = (first_occurrence, n, m, a, b, c)\n                                if best is None:\n                                    best = candidate\n                                else:\n                                    # Compare based on rules: earliest start, smaller n, smaller m\n                                    if first_occurrence < best[0]:\n                                        best = candidate\n                                    elif first_occurrence == best[0]:\n                                        if n < best[1]:\n                                            best = candidate\n                                        elif n == best[1] and m < best[2]:\n                                            best = candidate\n    \n    return best\n\ndef main():\n    p, seq = read_input()\n    result = find_triple_correlation(p, seq)\n    \n    if result is None:\n        print(\"random sequence\")\n    else:\n        _, n, m, a, b, c = result\n        print(f\"triple correlation {a}({n}){b}({m}){c} found\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 46.64837312698364}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    # Function to calculate maximum beauty for a target character\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            # Shrink window if we've used too many changes\n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            # Update maximum length\n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    # Calculate for both 'a' and 'b' and take maximum\n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 21.06867790222168}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    nums = list(map(int, data[1:1 + n * n]))\n    \n    # Count frequencies\n    freq = collections.Counter(nums)\n    \n    # Determine positions based on symmetry\n    # For an n x n matrix, positions are categorized by their symmetry:\n    # - Center (if n odd): 1 position\n    # - Middle row/col (if n odd): (n-1) positions each, but they pair\n    # - Four symmetric quadrants: each cell appears 4 times\n    # Actually simpler: each cell (i,j) has a symmetric partner (n-1-i, j), (i, n-1-j), (n-1-i, n-1-j)\n    # So positions are grouped into sets of size 1, 2, or 4\n    \n    # Precompute which positions are equivalent\n    used = [[False] * n for _ in range(n)]\n    pos_groups = []  # list of lists of (i,j)\n    for i in range(n):\n        for j in range(n):\n            if used[i][j]:\n                continue\n            group = []\n            # Add all symmetric positions\n            sym_pos = [(i, j), (n-1-i, j), (i, n-1-j), (n-1-i, n-1-j)]\n            for (r, c) in sym_pos:\n                if not used[r][c]:\n                    used[r][c] = True\n                    group.append((r, c))\n            pos_groups.append(group)\n    \n    # Sort groups by size (descending) to match with frequencies\n    pos_groups.sort(key=len, reverse=True)\n    \n    # Sort numbers by frequency (descending)\n    num_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Greedy assignment: assign numbers with highest frequency to largest groups\n    matrix = [[0] * n for _ in range(n)]\n    idx = 0\n    for group in pos_groups:\n        size = len(group)\n        if idx >= len(num_freq) or num_freq[idx][1] < size:\n            print(\"NO\")\n            return\n        num = num_freq[idx][0]\n        freq[num] -= size\n        if freq[num] == 0:\n            idx += 1\n        # Fill all positions in the group with this number\n        for (r, c) in group:\n            matrix[r][c] = num\n    \n    # Verify all numbers used\n    if any(freq[num] > 0 for num in freq):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.64651083946228}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nsys.setrecursionlimit(1 << 25)\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, A, B = map(int, data)\n    \n    # Special case: N = 1\n    if N == 1:\n        if A == 1 or B == 1:\n            print(1)\n        else:\n            print(-1)\n        return\n    \n    # Ensure A <= B for easier handling\n    if A > B:\n        A, B = B, A\n    \n    # Check feasibility\n    # We need to partition N into cycles of lengths A and B.\n    # Let x be number of cycles of length A, y of length B.\n    # Then: x*A + y*B = N, with x, y >= 0 integers.\n    # Also, if A == 1, we can have any number of 1-cycles.\n    # If B == 1, similar.\n    \n    # Find non-negative integer solutions for x and y\n    found = False\n    best_x = best_y = -1\n    \n    # Try all possible x from 0 to N//A\n    max_x = N // A\n    for x in range(max_x + 1):\n        remaining = N - x * A\n        if remaining % B == 0:\n            y = remaining // B\n            if y >= 0:\n                found = True\n                best_x, best_y = x, y\n                break\n    \n    if not found:\n        print(-1)\n        return\n    \n    # Construct permutation with cycles of lengths A and B\n    P = [0] * (N + 1)  # 1-indexed\n    idx = 1\n    \n    # Helper to create a cycle of given length starting at start_idx\n    def make_cycle(length: int, start_idx: int) -> None:\n        nonlocal idx\n        if length == 1:\n            P[start_idx] = start_idx\n            return\n        for j in range(length):\n            cur = start_idx + j\n            nxt = start_idx + ((j + 1) % length)\n            P[cur] = nxt\n    \n    # Create cycles of length A\n    for _ in range(best_x):\n        make_cycle(A, idx)\n        idx += A\n    \n    # Create cycles of length B\n    for _ in range(best_y):\n        make_cycle(B, idx)\n        idx += B\n    \n    # Output permutation (1-indexed to 0-indexed for output)\n    print(' '.join(str(P[i]) for i in range(1, N + 1)))\n\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.84533905982971}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(r, c, n, m):\n    \"\"\"Rotate point (r,c) in nm matrix 90 clockwise.\"\"\"\n    return c, n - r + 1\n\ndef rotate_90_counterclockwise(r, c, n, m):\n    \"\"\"Rotate point (r,c) in nm matrix 90 counterclockwise.\"\"\"\n    return m - c + 1, r\n\ndef horizontal_flip(r, c, n, m):\n    \"\"\"Horizontal flip (mirror) of point (r,c) in nm matrix.\"\"\"\n    return r, m - c + 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = identity\n    x %= 4\n    z %= 4\n    \n    results = []\n    for _ in range(p):\n        r = int(next(it))\n        c = int(next(it))\n        curr_n, curr_m = n, m\n        \n        # Apply x clockwise rotations\n        for _ in range(x):\n            r, c = rotate_90_clockwise(r, c, curr_n, curr_m)\n            curr_n, curr_m = curr_m, curr_n\n        \n        # Apply y horizontal flips\n        for _ in range(y % 2):  # y mod 2 since two flips = identity\n            r, c = horizontal_flip(r, c, curr_n, curr_m)\n        \n        # Apply z counterclockwise rotations\n        for _ in range(z):\n            r, c = rotate_90_counterclockwise(r, c, curr_n, curr_m)\n            curr_n, curr_m = curr_m, curr_n\n        \n        results.append(f\"{r} {c}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 32.1309289932251}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # Each of the 3 positions can be any digit from 1 to N\n    # Total possibilities = N * N * N = N^3\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 11.378054857254028}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L1 = int(data[0])\n    L2 = int(data[1])\n    N = int(data[2])\n    tubes = list(map(int, data[3:3+N]))\n    \n    # Sort tubes for efficient processing\n    tubes.sort()\n    \n    # Generate all possible pairs for L1 and L2\n    pairs_L1 = []\n    pairs_L2 = []\n    \n    # Generate all pairs (i < j) for both distances\n    for i in range(N):\n        for j in range(i+1, N):\n            pair_sum = tubes[i] + tubes[j]\n            if pair_sum <= L1:\n                pairs_L1.append(pair_sum)\n            if pair_sum <= L2:\n                pairs_L2.append(pair_sum)\n    \n    # If we don't have enough pairs for both distances, it's impossible\n    if not pairs_L1 or not pairs_L2:\n        print(\"Impossible\")\n        return\n    \n    # Sort pairs for binary search\n    pairs_L1.sort()\n    pairs_L2.sort()\n    \n    # Find maximum total length\n    max_total = -1\n    \n    # For each pair in L1, find the best complementary pair in L2\n    for sum1 in pairs_L1:\n        # Find the largest sum2 such that sum1 + sum2 is maximized\n        # We need to find the largest sum2 in pairs_L2\n        # Since pairs_L2 is sorted, we can use binary search to find the best match\n        \n        # We want to maximize sum1 + sum2, so we want the largest sum2\n        # But we don't have any constraint on sum1 + sum2, only individual constraints\n        # So we can simply take the largest sum2\n        if pairs_L2:\n            max_total = max(max_total, sum1 + pairs_L2[-1])\n    \n    if max_total == -1:\n        print(\"Impossible\")\n    else:\n        print(max_total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.43795895576477}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        \n        # Count consecutive '<' from the start and consecutive '>' from the end\n        left_count = 0\n        while left_count < n and s[left_count] == '<':\n            left_count += 1\n        \n        right_count = 0\n        while right_count < n and s[n - 1 - right_count] == '>':\n            right_count += 1\n        \n        # Minimum deletions needed is the smaller of these two counts\n        min_deletions = min(left_count, right_count)\n        results.append(str(min_deletions))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.216851472854614}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X) / 2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    # Check if Y - 2X is non-negative and divisible by 2\n    if (Y - 2 * X) >= 0 and (Y - 2 * X) % 2 == 0:\n        t = (Y - 2 * X) // 2\n        c = X - t\n        if c >= 0 and t >= 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.538846731185913}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = []\n    idx = 1\n    for _ in range(n):\n        grid.append(data[idx])\n        idx += 1\n    \n    # Check if any row is completely evil\n    for i in range(n):\n        if all(c == 'E' for c in grid[i]):\n            # Check if there's any column with a non-evil cell in that row\n            possible = False\n            for j in range(n):\n                if grid[i][j] == '.':\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    # Check if any column is completely evil\n    for j in range(n):\n        col_all_evil = True\n        for i in range(n):\n            if grid[i][j] == '.':\n                col_all_evil = False\n                break\n        if col_all_evil:\n            # Check if there's any row with a non-evil cell in that column\n            possible = False\n            for i in range(n):\n                if grid[i][j] == '.':\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    # Strategy: Try to cast spells on rows first\n    row_solution = []\n    purified_rows = [False] * n\n    purified_cols = [False] * n\n    \n    # First, purify all rows that have at least one non-evil cell\n    for i in range(n):\n        if not purified_rows[i]:\n            # Find a non-evil cell in this row\n            for j in range(n):\n                if grid[i][j] == '.':\n                    row_solution.append((i+1, j+1))\n                    purified_rows[i] = True\n                    purified_cols[j] = True\n                    break\n    \n    # Now purify remaining columns\n    for j in range(n):\n        if not purified_cols[j]:\n            # Find a non-evil cell in this column\n            for i in range(n):\n                if grid[i][j] == '.':\n                    row_solution.append((i+1, j+1))\n                    purified_cols[j] = True\n                    break\n    \n    # Verify all cells are purified\n    all_purified = True\n    for i in range(n):\n        for j in range(n):\n            if not (purified_rows[i] or purified_cols[j]):\n                all_purified = False\n                break\n        if not all_purified:\n            break\n    \n    if all_purified and len(row_solution) <= n:\n        for r, c in row_solution:\n            print(f\"{r} {c}\")\n        return\n    \n    # If row-first approach didn't work, try column-first approach\n    col_solution = []\n    purified_rows = [False] * n\n    purified_cols = [False] * n\n    \n    # First, purify all columns that have at least one non-evil cell\n    for j in range(n):\n        if not purified_cols[j]:\n            # Find a non-evil cell in this column\n            for i in range(n):\n                if grid[i][j] == '.':\n                    col_solution.append((i+1, j+1))\n                    purified_cols[j] = True\n                    purified_rows[i] = True\n                    break\n    \n    # Now purify remaining rows\n    for i in range(n):\n        if not purified_rows[i]:\n            # Find a non-evil cell in this row\n            for j in range(n):\n                if grid[i][j] == '.':\n                    col_solution.append((i+1, j+1))\n                    purified_rows[i] = True\n                    break\n    \n    # Verify all cells are purified\n    all_purified = True\n    for i in range(n):\n        for j in range(n):\n            if not (purified_rows[i] or purified_cols[j]):\n                all_purified = False\n                break\n        if not all_purified:\n            break\n    \n    if all_purified and len(col_solution) <= n:\n        for r, c in col_solution:\n            print(f\"{r} {c}\")\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 53.12124252319336}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    print(0)\n    sys.exit(0)\n\n# Parse strings\nstrings = list(map(int, input_data[:6]))\n\n# Parse notes\nidx = 6\nn = int(input_data[idx])\nidx += 1\nnotes = list(map(int, input_data[idx:idx + n]))\n\n# For each note, compute possible frets on each string\npossible_frets = []\nfor note in notes:\n    frets_for_note = []\n    for a in strings:\n        if note > a:\n            fret = note - a\n            frets_for_note.append(fret)\n    possible_frets.append(frets_for_note)\n\n# Flatten all possible frets and sort\nall_frets = []\nfor i, frets in enumerate(possible_frets):\n    for fret in frets:\n        all_frets.append((fret, i))\nall_frets.sort()\n\n# Two-pointer sliding window\nleft = 0\nfret_count = [0] * n\ncovered_notes = 0\nmin_diff = float('inf')\n\nfor right in range(len(all_frets)):\n    fret_val, note_idx = all_frets[right]\n    if fret_count[note_idx] == 0:\n        covered_notes += 1\n    fret_count[note_idx] += 1\n    \n    # Try to shrink window from left while covering all notes\n    while covered_notes == n:\n        min_diff = min(min_diff, fret_val - all_frets[left][0])\n        left_fret_val, left_note_idx = all_frets[left]\n        fret_count[left_note_idx] -= 1\n        if fret_count[left_note_idx] == 0:\n            covered_notes -= 1\n        left += 1\n\nprint(min_diff)", "runtime_sec": 28.383012771606445}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    R = int(data)\n    \n    # Calculate circumference: C = 2 *  * R\n    circumference = 2 * math.pi * R\n    \n    # Print with sufficient precision to meet error tolerance\n    print(f\"{circumference:.10f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 13.521570920944214}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = [0] * (n + 1)\n    for i in range(2, n + 1):\n        p[i] = int(data[i - 1])\n    \n    # Step 1: Compute depth of each node\n    depth = [0] * (n + 1)\n    for i in range(2, n + 1):\n        depth[i] = depth[p[i]] + 1\n    \n    # Step 2: Count nodes at each depth\n    max_depth = max(depth)\n    cnt = [0] * (max_depth + 1)\n    for i in range(1, n + 1):\n        cnt[depth[i]] += 1\n    \n    # Step 3: Count apples collected\n    ans = 0\n    for d in range(max_depth + 1):\n        ans += cnt[d] % 2  # Only odd counts contribute\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.878658771514893}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    count = 0\n    while b > 0:\n        count += a // b\n        a, b = b, a % b\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.244117498397827}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    \n    # If N is even, the smallest number divisible by both 2 and N is N itself\n    # If N is odd, we need N * 2 to make it divisible by 2\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(N * 2)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 15.803815364837646}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.467909812927246}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Precompute factorials up to 50\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i\n    \n    # DP to count permutations with maximum f(p)\n    # dp[k] = number of permutations of length k with maximum f(p)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for k in range(2, n + 1):\n        # For maximum f(p), the permutation must be unimodal:\n        # increasing then decreasing, with 1 at one end\n        # The count is 2^(k-1) for k >= 2\n        dp[k] = 1 << (k - 1)\n    \n    # Construct the m-th permutation in lex order\n    result = []\n    remaining = list(range(1, n + 1))\n    \n    # Determine if we start with increasing or decreasing pattern\n    # For maximum f(p), the permutation must have 1 at position 1 or n\n    # Lex order favors putting 1 at position 1 first\n    \n    # We'll build by deciding at each step whether to put smallest or largest remaining number\n    # This corresponds to building a unimodal permutation\n    \n    # We need to handle m (1-indexed) within dp[n]\n    idx = m - 1  # Convert to 0-indexed\n    \n    # Direction: True for increasing (put smallest), False for decreasing (put largest)\n    # Start with increasing to get lex smallest permutations\n    direction = True\n    \n    for k in range(n, 0, -1):\n        # Number of permutations if we choose current direction\n        count_if_direction = dp[k-1] if k > 1 else 1\n        \n        if idx < count_if_direction:\n            # Stay in current direction\n            if direction:\n                result.append(remaining.pop(0))  # Take smallest\n            else:\n                result.append(remaining.pop())    # Take largest\n        else:\n            # Switch direction\n            idx -= count_if_direction\n            direction = not direction\n            if direction:\n                result.append(remaining.pop(0))  # Take smallest\n            else:\n                result.append(remaining.pop())    # Take largest\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 32.44560885429382}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 12.926034688949585}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.400349378585815}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.41776251792908}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [int(next(it)) for _ in range(n)]\n    v = [int(next(it)) for _ in range(n)]\n    \n    # Combine points into list of (x, v) and sort by x\n    points = sorted(zip(x, v))\n    \n    # Sort speeds for prefix sums\n    speeds = [v for _, v in points]\n    speeds.sort()\n    \n    # Prefix sums of speeds\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + speeds[i]\n    \n    total = 0\n    # For each point, compute contribution\n    for i in range(n):\n        xi, vi = points[i]\n        # Find position of vi in sorted speeds\n        pos = bisect_left(speeds, vi)\n        # Contribution from points to the right\n        right_sum = prefix[n] - prefix[pos + 1]\n        right_count = n - (pos + 1)\n        total += (right_count * xi - (right_sum * xi))\n        # Contribution from points to the left\n        left_sum = prefix[pos]\n        left_count = pos\n        total += (left_sum * xi - (left_count * xi))\n    \n    # The total currently is sum of (xi - xj) * sign(vi - vj) for i < j\n    # We need absolute minimum distance, which is |xi - xj| if vi != vj, else 0\n    # But we computed signed differences, so we need to take absolute values\n    # Actually, d(i,j) = |xi - xj| if vi != vj, else 0\n    # So we need to sum |xi - xj| over all pairs where vi != vj\n    \n    # Recompute correctly: sort points by x, then for each i, sum (xi - xj) for j < i where vj < vi\n    # and sum (xj - xi) for j < i where vj > vi\n    # This gives sum of (xi - xj) * sign(vi - vj) for j < i\n    # Then total over all i gives sum over all pairs (i,j) with i > j of (xi - xj) * sign(vi - vj)\n    # But we need sum over all pairs of |xi - xj| if vi != vj\n    # Note: sign(vi - vj) can be -1, 0, 1. If 0, contribution should be 0.\n    # So we need to handle vi = vj separately.\n    \n    # Let's implement with Fenwick tree for speed counting and sum\n    class Fenwick:\n        def __init__(self, n):\n            self.n = n\n            self.bit_count = [0] * (n + 1)\n            self.bit_sum = [0] * (n + 1)\n        \n        def update(self, idx, delta_count, delta_sum):\n            i = idx + 1\n            while i <= self.n:\n                self.bit_count[i] += delta_count\n                self.bit_sum[i] += delta_sum\n                i += i & -i\n        \n        def query(self, idx):\n            i = idx + 1\n            count = 0\n            sum_val = 0\n            while i > 0:\n                count += self.bit_count[i]\n                sum_val += self.bit_sum[i]\n                i -= i & -i\n            return count, sum_val\n    \n    # Coordinate compression for speeds\n    speed_vals = sorted(set(v))\n    speed_to_idx = {val: i for i, val in enumerate(speed_vals)}\n    m = len(speed_vals)\n    \n    ft = Fenwick(m)\n    total = 0\n    points_sorted = sorted(zip(x, v))\n    for xi, vi in points_sorted:\n        idx = speed_to_idx[vi]\n        # Query for speeds less than vi\n        count_less, sum_less = ft.query(idx - 1)\n        total += count_less * xi - sum_less\n        # Query for speeds greater than vi\n        count_all, sum_all = ft.query(m - 1)\n        count_greater = count_all - count_less\n        sum_greater = sum_all - sum_less\n        total += sum_greater - count_greater * xi\n        # Update Fenwick tree\n        ft.update(idx, 1, xi)\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 52.32604217529297}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 54.82349252700806}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.94519352912903}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    # Initialize count array with zeros for each member (1-indexed)\n    subordinates = [0] * (n + 1)\n    # Process each A_i from input (starting from index 2)\n    for i in range(2, n + 1):\n        boss = int(data[i - 1])  # A_i is the immediate boss of member i\n        subordinates[boss] += 1\n    # Output results for members 1 through n\n    for i in range(1, n + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.920177936553955}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef can_achieve(ans, N, K, A):\n    \"\"\"Check if we can partition the circular array into K segments with AND >= ans.\"\"\"\n    # Duplicate array to handle circular nature\n    arr = A + A\n    n = len(arr)\n    \n    # dp[i] = maximum segments we can get ending at position i with AND >= ans\n    dp = [0] * (n + 1)\n    # pref_or[i] = OR from last segment start to i-1\n    pref_or = [0] * (n + 1)\n    \n    # For each position, try to extend segments\n    for i in range(1, n + 1):\n        # Start new segment at i\n        current_or = arr[i-1]\n        # If current element alone doesn't have all required bits, skip\n        if (current_or & ans) != ans:\n            dp[i] = -1\n            pref_or[i] = 0\n            continue\n        \n        # Try to extend from previous positions\n        best = -1\n        best_or = 0\n        for j in range(i-1, max(0, i-N), -1):\n            if dp[j] == -1:\n                continue\n            # Extend segment from j to i\n            extended_or = pref_or[j] | current_or\n            if (extended_or & ans) == ans:\n                if dp[j] + 1 > best:\n                    best = dp[j] + 1\n                    best_or = extended_or\n            # If we can't extend, break since OR only increases\n            if (pref_or[j] & ans) != ans:\n                break\n        \n        dp[i] = best\n        pref_or[i] = best_or if best != -1 else 0\n    \n    # Check if we can get K segments within first N elements (circular wrap)\n    for i in range(N, n + 1):\n        if dp[i] >= K:\n            # Verify the segments cover exactly N elements circularly\n            # This is simplified check; actual implementation needs careful wrap handling\n            return True\n    return False\n\ndef solve():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Binary search on answer from highest possible bit down to 0\n    ans = 0\n    for bit in range(30, -1, -1):\n        candidate = ans | (1 << bit)\n        if can_achieve(candidate, N, K, A):\n            ans = candidate\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.001158952713013}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith(\"po\"):\n        return \"FILIPINO\"\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        return \"JAPANESE\"\n    elif sentence.endswith(\"mnida\"):\n        return \"KOREAN\"\n    else:\n        # According to problem statement, this case shouldn't occur\n        # but adding fallback for safety\n        return \"UNKNOWN\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        if i < len(data):\n            sentence = data[i].strip()\n            language = detect_language(sentence)\n            results.append(language)\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 24.652634620666504}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    trains = []\n    for _ in range(N-1):\n        C, S, F = map(int, input().split())\n        trains.append((C, S, F))\n    \n    results = [0] * N\n    \n    for start in range(N-1):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait for next train\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results[start] = current_time\n    \n    # Station N itself\n    results[N-1] = 0\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.933640956878662}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nit = iter(input_data)\nn = int(next(it))\nm = int(next(it))\nk = int(next(it))\n\n# Read ore and coal cells\nore_cells = [int(next(it)) for _ in range(m)]\ncoal_cells = [int(next(it)) for _ in range(k)]\n\n# Build adjacency list\ngraph = [[] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    a = int(next(it))\n    for _ in range(a):\n        b = int(next(it))\n        graph[i].append(b)\n\n# BFS to compute distances from start (cell 1)\ndef bfs(start):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    queue = [start]\n    for u in queue:\n        for v in graph[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                queue.append(v)\n    return dist\n\ndist_from_start = bfs(1)\n\n# Reverse graph for backward BFS\nrev_graph = [[] for _ in range(n + 1)]\nfor u in range(1, n + 1):\n    for v in graph[u]:\n        rev_graph[v].append(u)\n\n# BFS on reverse graph to compute distances to start\ndef rev_bfs(start):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    queue = [start]\n    for u in queue:\n        for v in rev_graph[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                queue.append(v)\n    return dist\n\n# Compute distances from each ore cell to start via reverse BFS\nore_to_start = [rev_bfs(ore) for ore in ore_cells]\n# Compute distances from each coal cell to start via reverse BFS\ncoal_to_start = [rev_bfs(coal) for coal in coal_cells]\n\n# Find minimum settlers\nmin_settlers = float('inf')\n\n# Try all pairs of ore and coal cells\nfor i, ore in enumerate(ore_cells):\n    for j, coal in enumerate(coal_cells):\n        # Distance from start to ore\n        d1 = dist_from_start[ore]\n        # Distance from ore to start (via reverse graph)\n        d2 = ore_to_start[i][coal]\n        # Distance from coal to start (via reverse graph)\n        d3 = coal_to_start[j][ore]\n        \n        # Check if all paths exist\n        if d1 != -1 and d2 != -1 and d3 != -1:\n            # Path: start -> ore -> coal -> start\n            settlers1 = d1 + d2\n            # Path: start -> coal -> ore -> start\n            settlers2 = dist_from_start[coal] + d3\n            min_settlers = min(min_settlers, settlers1, settlers2)\n\n# Output result\nif min_settlers == float('inf'):\n    print(\"impossible\")\nelse:\n    print(min_settlers)", "runtime_sec": 45.91214442253113}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    sizes = list(map(int, data[1:1+n]))\n    \n    # Check if reassembly is possible\n    # Each set must be consecutive sizes from 1 to m\n    # So we need to partition into intervals where sizes form a permutation of 1..m\n    # First, check if total counts match\n    from collections import Counter\n    cnt = Counter(sizes)\n    max_size = max(sizes)\n    \n    # For each size from 1 to max_size, there should be at least one occurrence\n    # and the counts should be non-increasing as size increases\n    for sz in range(1, max_size+1):\n        if cnt[sz] == 0:\n            print(\"impossible\")\n            return\n    \n    # DP approach: dp[l][r] = min openings to combine dolls[l..r] into valid sets\n    INF = 10**9\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Initialize for single dolls\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # Precompute prefix sums for quick range max queries\n    # We'll need to know the maximum size in a range\n    from math import log2\n    LOG = 9  # since n <= 500, log2(500) < 9\n    st = [[0]*n for _ in range(LOG+1)]\n    for i in range(n):\n        st[0][i] = sizes[i]\n    \n    for k in range(1, LOG+1):\n        length = 1 << k\n        half = 1 << (k-1)\n        for i in range(n - length + 1):\n            st[k][i] = max(st[k-1][i], st[k-1][i+half])\n    \n    def range_max(l, r):\n        length = r - l + 1\n        k = int(log2(length))\n        return max(st[k][l], st[k][r - (1<<k) + 1])\n    \n    # Fill DP for increasing lengths\n    for length in range(2, n+1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            \n            # Check if this interval can form valid sets\n            # It must contain consecutive sizes from 1 to m where m is max in interval\n            seen = [False] * (max_size + 1)\n            max_in_range = 0\n            valid_interval = True\n            for i in range(l, r+1):\n                sz = sizes[i]\n                if sz > max_in_range:\n                    max_in_range = sz\n                if sz > max_size or seen[sz]:\n                    valid_interval = False\n                    break\n                seen[sz] = True\n            \n            # Check if we have all sizes from 1 to max_in_range\n            if valid_interval:\n                for sz in range(1, max_in_range+1):\n                    if not seen[sz]:\n                        valid_interval = False\n                        break\n            \n            if not valid_interval:\n                continue\n            \n            # Try all split points\n            best = INF\n            for k in range(l, r):\n                if dp[l][k] < INF and dp[k+1][r] < INF:\n                    # Cost to combine two groups = sum of sizes > min_size_in_other_group?\n                    # Actually: openings needed = sum of sizes in both groups except the largest doll\n                    # Wait, need to think carefully\n                    \n                    # When combining two groups, we need to open all dolls except\n                    # the largest one that will remain as the outermost\n                    # The largest doll overall doesn't need to be opened\n                    \n                    max_left = range_max(l, k)\n                    max_right = range_max(k+1, r)\n                    max_total = max(max_left, max_right)\n                    \n                    # All dolls except the one with size max_total need to be opened\n                    # Count how many dolls have size < max_total\n                    count_smaller = 0\n                    for i in range(l, r+1):\n                        if sizes[i] < max_total:\n                            count_smaller += 1\n                    \n                    cost = dp[l][k] + dp[k+1][r] + count_smaller\n                    best = min(best, cost)\n            \n            if best < INF:\n                dp[l][r] = best\n    \n    if dp[0][n-1] < INF:\n        print(dp[0][n-1])\n    else:\n        print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 50.78191828727722}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    H, W = map(int, data[0].split())\n    grid = data[1:1+H]\n    \n    # Directions for 8 adjacent cells\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1),  (1, 0), (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n            else:\n                count = 0\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                        count += 1\n                row_chars.append(str(count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.583643913269043}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 58.753604888916016}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Initialize p as a copy of a (or b)\n    p = a[:]\n    \n    # Track which numbers are used in p\n    used = [False] * (n + 1)\n    for val in p:\n        used[val] = True\n    \n    # Find missing number (the one not used yet)\n    missing = -1\n    for i in range(1, n + 1):\n        if not used[i]:\n            missing = i\n            break\n    \n    # If there's exactly one differing position, we need to handle carefully\n    if len(diff_positions) == 1:\n        pos = diff_positions[0]\n        # Try both possibilities\n        original = p[pos]\n        # Try setting to b[pos]\n        p[pos] = b[pos]\n        # Check if this creates a valid permutation\n        temp_used = [False] * (n + 1)\n        valid = True\n        for val in p:\n            if temp_used[val]:\n                valid = False\n                break\n            temp_used[val] = True\n        if not valid:\n            # Try the missing number instead\n            p[pos] = missing\n    else:\n        # Multiple differing positions\n        # We need to ensure exactly one mismatch with a and one with b\n        # Count mismatches with a and b\n        mismatch_a = []\n        mismatch_b = []\n        for i in range(n):\n            if p[i] != a[i]:\n                mismatch_a.append(i)\n            if p[i] != b[i]:\n                mismatch_b.append(i)\n        \n        # If we have more than one mismatch with either, adjust\n        if len(mismatch_a) > 1 or len(mismatch_b) > 1:\n            # Try swapping values at differing positions\n            # We'll try all combinations of assigning missing to one of diff_positions\n            found = False\n            for i in diff_positions:\n                for j in diff_positions:\n                    if i == j:\n                        continue\n                    # Create candidate\n                    candidate = a[:]\n                    candidate[i] = missing\n                    # Check mismatches\n                    ma = sum(1 for k in range(n) if candidate[k] != a[k])\n                    mb = sum(1 for k in range(n) if candidate[k] != b[k])\n                    if ma == 1 and mb == 1:\n                        p = candidate\n                        found = True\n                        break\n                if found:\n                    break\n            \n            if not found:\n                # Try another approach: start with b and adjust\n                candidate = b[:]\n                for i in diff_positions:\n                    for j in diff_positions:\n                        if i == j:\n                            continue\n                        candidate[i] = missing\n                        ma = sum(1 for k in range(n) if candidate[k] != a[k])\n                        mb = sum(1 for k in range(n) if candidate[k] != b[k])\n                        if ma == 1 and mb == 1:\n                            p = candidate\n                            found = True\n                            break\n                    if found:\n                        break\n    \n    # Final validation (should always pass due to problem guarantee)\n    # Ensure it's a permutation\n    seen = set()\n    for val in p:\n        if val < 1 or val > n or val in seen:\n            # Fallback: generate simple permutation 1..n\n            p = list(range(1, n + 1))\n            break\n        seen.add(val)\n    \n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 44.693708658218384}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    idx = 0\n    q = int(input_data[idx]); idx += 1\n    results = []\n    \n    for _ in range(q):\n        s = input_data[idx]; idx += 1\n        m = int(input_data[idx]); idx += 1\n        b = list(map(int, input_data[idx:idx+m])); idx += m\n        \n        # Count frequency of each character in s\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n        \n        # Build t from right to left\n        t = [''] * m\n        used = [False] * m\n        \n        # Process positions from largest character to smallest\n        for char_val in range(25, -1, -1):\n            # Find positions where b[i] == 0 and not used\n            zero_positions = []\n            for i in range(m):\n                if b[i] == 0 and not used[i]:\n                    zero_positions.append(i)\n            \n            # We need exactly as many positions as we have this character available\n            # But we might have more zero positions than needed\n            # We'll assign the largest available character to these positions\n            if zero_positions:\n                # How many of this character can we place?\n                count_to_place = min(freq[char_val], len(zero_positions))\n                if count_to_place > 0:\n                    # Place this character at the first count_to_place zero positions\n                    for pos in zero_positions[:count_to_place]:\n                        t[pos] = chr(ord('a') + char_val)\n                        used[pos] = True\n                        # Update b values for positions to the left\n                        for j in range(m):\n                            if not used[j] and j < pos:\n                                b[j] -= (pos - j)\n                    freq[char_val] -= count_to_place\n        \n        # Fill any remaining positions (shouldn't happen with valid input)\n        for i in range(m):\n            if t[i] == '':\n                # Find any available character\n                for c in range(26):\n                    if freq[c] > 0:\n                        t[i] = chr(ord('a') + c)\n                        freq[c] -= 1\n                        break\n        \n        results.append(''.join(t))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 32.51668906211853}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import re\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel according to the problem rules.\"\"\"\n    return c in 'AEIOUY'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the problem rules.\"\"\"\n    # Extract alphabetic part for syllable counting\n    alphabetic = ''.join(ch for ch in word if ch.isalpha())\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has at least 1 syllable\n    \n    alphabetic = alphabetic.upper()\n    n = len(alphabetic)\n    \n    # Apply silent E rule\n    if n >= 2 and alphabetic[-1] == 'E':\n        if not (n >= 3 and alphabetic[-2] == 'L' and not is_vowel(alphabetic[-3])):\n            alphabetic = alphabetic[:-1]\n            n -= 1\n    \n    # Apply ES rule\n    if n >= 3 and alphabetic.endswith('ES'):\n        # Check if preceded by two or more consonants\n        if n >= 4 and not is_vowel(alphabetic[-3]) and not is_vowel(alphabetic[-4]):\n            pass  # Keep ES for syllable\n        else:\n            alphabetic = alphabetic[:-2]\n            n -= 2\n    \n    # Count syllables based on vowel-consonant patterns\n    syllables = 0\n    i = 0\n    while i < n:\n        # Handle QU as single consonant\n        if i + 1 < n and alphabetic[i:i+2] == 'QU':\n            i += 2\n            continue\n        \n        # Y is consonant if followed by another vowel\n        if alphabetic[i] == 'Y' and i + 1 < n and is_vowel(alphabetic[i+1]):\n            i += 1\n            continue\n        \n        if is_vowel(alphabetic[i]):\n            syllables += 1\n            # Skip consecutive vowels (they belong to same syllable)\n            while i < n and is_vowel(alphabetic[i]):\n                i += 1\n        else:\n            i += 1\n    \n    return max(1, syllables)\n\ndef split_haiku(words, syllables):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Try all possible splits\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if sum(syllables[:i]) == 5 and sum(syllables[i:j]) == 7 and sum(syllables[j:]) == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    return None\n\ndef main():\n    line = input().strip()\n    if not line:\n        print(line)\n        return\n    \n    # Split into words while preserving punctuation\n    words = []\n    current = ''\n    for ch in line:\n        if ch == ' ':\n            if current:\n                words.append(current)\n                current = ''\n            continue\n        current += ch\n    if current:\n        words.append(current)\n    \n    # Count syllables for each word\n    syllables = [count_syllables(word) for word in words]\n    total = sum(syllables)\n    \n    # Check if total syllables match haiku\n    if total != 17:\n        print(line)\n        return\n    \n    # Try to split into haiku\n    result = split_haiku(words, syllables)\n    if result:\n        for line in result:\n            print(line)\n    else:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 43.012659311294556}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.235000133514404}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Special case: 1 is the strongest, then 13, 12, ..., 2\n    # So we map 1 to 14 for comparison\n    a_strength = 14 if A == 1 else A\n    b_strength = 14 if B == 1 else B\n    \n    if a_strength > b_strength:\n        print(\"Alice\")\n    elif a_strength < b_strength:\n        print(\"Bob\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.832793951034546}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass FenwickTree:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 2)\n    \n    def update(self, idx, delta):\n        i = idx + 1\n        while i <= self.n + 1:\n            self.bit[i] += delta\n            i += i & -i\n    \n    def query(self, idx):\n        res = 0\n        i = idx + 1\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    values = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        v = int(next(it))\n        p = int(next(it))\n        values[i] = v\n        parent[i] = p\n        if p > 0:\n            children[p].append(i)\n    \n    # Coordinate compression for values\n    all_vals = sorted(set(values[1:]))\n    val_to_idx = {v: i for i, v in enumerate(all_vals)}\n    compressed = [0] * (n + 1)\n    for i in range(1, n + 1):\n        compressed[i] = val_to_idx[values[i]]\n    \n    # DFS order\n    tin = [0] * (n + 1)\n    tout = [0] * (n + 1)\n    timer = 0\n    stack = [(1, 0)]  # (node, state)\n    order = []\n    \n    while stack:\n        u, state = stack.pop()\n        if state == 0:\n            timer += 1\n            tin[u] = timer\n            order.append(u)\n            stack.append((u, 1))\n            for v in reversed(children[u]):\n                stack.append((v, 0))\n        else:\n            tout[u] = timer\n    \n    # Process nodes in decreasing value order\n    nodes_by_val = sorted(range(1, n + 1), key=lambda x: values[x], reverse=True)\n    ft = FenwickTree(n)\n    dp = [0] * (n + 1)\n    \n    for u in nodes_by_val:\n        # Count how many selected nodes in subtree of u with value > values[u]\n        # Since we process in decreasing order, all processed nodes have >= current value\n        # We need strictly greater ancestors, so we query for values strictly greater\n        cnt = ft.query(tout[u]) - ft.query(tin[u] - 1)\n        # dp[u] = 1 + max(dp[children]) where we can take at most one child's chain\n        best_child = 0\n        for v in children[u]:\n            best_child = max(best_child, dp[v])\n        dp[u] = 1 + best_child - cnt\n        if dp[u] > 0:\n            ft.update(tin[u], 1)\n    \n    # Answer is max dp value\n    ans = max(dp[1:])\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 41.02005648612976}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        s = input_data[idx]\n        idx += 1\n        \n        # Find first occurrence of different consecutive characters\n        start = 0\n        while start < n and s[start] == s[0]:\n            start += 1\n        \n        if start == n:\n            # All characters are the same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rotate string so it starts with the first change\n        s_rotated = s[start:] + s[:start]\n        \n        count = 0\n        current_len = 1\n        \n        for i in range(1, n):\n            if s_rotated[i] == s_rotated[i-1]:\n                current_len += 1\n            else:\n                count += current_len // 3\n                current_len = 1\n        \n        count += current_len // 3\n        results.append(count)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.203722953796387}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    # Read the input line and split into integers\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    values = list(map(int, data))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # After Snuke sets one variable to 0, we compare each position\n    for i in range(5):\n        if values[i] == 0:\n            # If we find a 0, that's the variable Snuke changed\n            print(i + 1)\n            return\n    \n    # If no 0 is found (shouldn't happen per constraints),\n    # find the variable that doesn't match its initial value\n    for i in range(5):\n        if values[i] != i + 1:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.17826533317566}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 59.82571339607239}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef count_ways(n):\n    \"\"\"Count number of ways to fill parking lot with exactly n successive cars of same make.\"\"\"\n    # Total parking spaces: 2n - 2\n    total_spaces = 2 * n - 2\n    \n    # For each position where the block of n identical cars can start\n    # The block can start at positions 0 through (total_spaces - n)\n    positions = total_spaces - n + 1\n    \n    # For each position, we need to count valid arrangements\n    # We'll use dynamic programming\n    \n    # dp[i][j] = number of ways to fill first i spaces with j being the state\n    # State encoding:\n    # 0: no block of n identical cars yet, last car different from current\n    # 1: no block yet, last car same as current (but less than n consecutive)\n    # 2: already have a block of n identical cars somewhere\n    \n    # Initialize DP\n    dp = [[0, 0, 0] for _ in range(total_spaces + 1)]\n    \n    # Base case: 0 spaces filled\n    # We start with state 0 (no cars yet)\n    dp[0][0] = 1\n    \n    for i in range(total_spaces):\n        for state in range(3):\n            if dp[i][state] == 0:\n                continue\n            \n            current_ways = dp[i][state]\n            \n            # Choose next car from 4 makes\n            for _ in range(4):\n                if state == 0:\n                    # Last car was different or this is first car\n                    # Next car can be any of 4, but we're starting a new run\n                    # 3 choices for different car, 1 choice for same car\n                    dp[i + 1][1] += current_ways  # Same car (run length 2)\n                    dp[i + 1][0] += current_ways * 3  # Different car\n                elif state == 1:\n                    # We have a run of at least 2 same cars\n                    # We need to track if this run reaches length n\n                    # For positions before reaching n:\n                    if i + 1 < n:\n                        # Run continues but hasn't reached n yet\n                        dp[i + 1][1] += current_ways  # Same car continues run\n                        dp[i + 1][0] += current_ways * 3  # Different car breaks run\n                    else:\n                        # Check if adding this car completes a run of n\n                        # The run started at position i - (n-1) + 1?\n                        # Actually we need to track run length precisely\n                        # Let's use a different approach\n                        pass\n                else:  # state == 2\n                    # Already have a block of n identical cars\n                    # Any car is fine now\n                    dp[i + 1][2] += current_ways * 4\n    \n    # The above DP is incomplete. Let's use inclusion-exclusion instead.\n    # Total arrangements without restriction: 4^(2n-2)\n    # Subtract arrangements with NO block of n consecutive identical cars\n    \n    # Count arrangements with NO block of n consecutive identical cars\n    # Using DP that tracks last car and run length\n    \n    # dp_no[i][j][k] = ways to fill i spaces with last car j (0-3) and run length k\n    # But k only goes up to n-1\n    \n    # Initialize\n    dp_no = [[[0] * n for _ in range(4)] for _ in range(total_spaces + 1)]\n    \n    # First car: 4 choices, run length 1\n    for car in range(4):\n        dp_no[1][car][1] = 1\n    \n    for i in range(1, total_spaces):\n        for last_car in range(4):\n            for run_len in range(1, n):  # run_len < n\n                ways = dp_no[i][last_car][run_len]\n                if ways == 0:\n                    continue\n                \n                # Next car choices\n                for next_car in range(4):\n                    if next_car == last_car:\n                        new_run_len = run_len + 1\n                        if new_run_len < n:\n                            dp_no[i + 1][next_car][new_run_len] += ways\n                    else:\n                        # Different car, run length resets to 1\n                        dp_no[i + 1][next_car][1] += ways\n    \n    # Sum all arrangements with no block of n consecutive identical cars\n    no_block_total = 0\n    for last_car in range(4):\n        for run_len in range(1, n):\n            no_block_total += dp_no[total_spaces][last_car][run_len]\n    \n    # Total arrangements: 4^(2n-2)\n    total_arrangements = 4 ** total_spaces\n    \n    # Arrangements with at least one block: total - no_block\n    result = total_arrangements - no_block_total\n    \n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_ways(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 55.4850492477417}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each value\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Check if any value appears more than 2 times\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Separate values that appear once vs twice\n    inc_vals = []\n    dec_vals = []\n    \n    # Sort unique values\n    unique_vals = sorted(freq.keys())\n    \n    for val in unique_vals:\n        count = freq[val]\n        if count == 1:\n            # Can go to either sequence, but we need to maintain monotonicity\n            # We'll put it in increasing sequence if possible, else decreasing\n            if not inc_vals or val > inc_vals[-1]:\n                inc_vals.append(val)\n            elif not dec_vals or val < dec_vals[-1]:\n                dec_vals.append(val)\n            else:\n                # Can't fit in either sequence\n                print(\"NO\")\n                return\n        else:  # count == 2\n            # Must go to both sequences\n            inc_vals.append(val)\n            dec_vals.append(val)\n    \n    # Check if sequences are valid\n    # Increasing sequence should be strictly increasing\n    for i in range(1, len(inc_vals)):\n        if inc_vals[i] <= inc_vals[i-1]:\n            print(\"NO\")\n            return\n    \n    # Decreasing sequence should be strictly decreasing\n    for i in range(1, len(dec_vals)):\n        if dec_vals[i] >= dec_vals[i-1]:\n            print(\"NO\")\n            return\n    \n    # Output the result\n    print(\"YES\")\n    print(len(inc_vals))\n    if inc_vals:\n        print(' '.join(map(str, inc_vals)))\n    else:\n        print()\n    \n    print(len(dec_vals))\n    if dec_vals:\n        # Output decreasing sequence in decreasing order\n        dec_vals_sorted = sorted(dec_vals, reverse=True)\n        print(' '.join(map(str, dec_vals_sorted)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.475085973739624}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    M = int(next(it))\n    N = int(next(it))\n    \n    # Initialize net balances\n    balance = [0] * M\n    \n    # Process receipts\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        p = int(next(it))\n        balance[a] -= p  # payer loses money\n        balance[b] += p  # receiver gains money\n    \n    # Filter out people with zero balance\n    debts = [bal for bal in balance if bal != 0]\n    n = len(debts)\n    \n    # If no debts, no transactions needed\n    if n == 0:\n        print(0)\n        return\n    \n    # DP over subsets\n    dp = [float('inf')] * (1 << n)\n    dp[0] = 0\n    \n    # Precompute subset sums\n    subset_sum = [0] * (1 << n)\n    for mask in range(1 << n):\n        s = 0\n        for i in range(n):\n            if mask & (1 << i):\n                s += debts[i]\n        subset_sum[mask] = s\n    \n    # Iterate over all masks\n    for mask in range(1 << n):\n        if dp[mask] == float('inf'):\n            continue\n        # Find complement of current mask\n        complement = ((1 << n) - 1) ^ mask\n        sub = complement\n        # Iterate over all non-empty subsets of complement\n        while sub:\n            if subset_sum[sub] == 0:\n                new_mask = mask | sub\n                dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n            sub = (sub - 1) & complement\n    \n    print(dp[(1 << n) - 1])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.619795560836792}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Convert to absolute values and sort\n    abs_arr = sorted(abs(x) for x in arr)\n    \n    # Count pairs where the condition holds\n    # Condition: max(|x|, |y|) <= |x+y| and min(|x|, |y|) >= |x-y|\n    # Since we're working with absolute values, let a = |x|, b = |y| with a <= b\n    # Then condition becomes: b <= a+b (always true) and a >= |a-b| = b-a\n    # So a >= b-a => 2a >= b => b <= 2a\n    # Also need to ensure the intervals work correctly:\n    # Arrayland: [a, b]\n    # Vectorland: [|x-y|, |x+y|] = [b-a, a+b]\n    # For Arrayland to be inside Vectorland: a >= b-a and b <= a+b\n    # b <= a+b is always true since a >= 0\n    # So condition reduces to: a >= b-a => b <= 2a\n    \n    # Count pairs (i, j) with i < j where abs_arr[j] <= 2*abs_arr[i]\n    count = 0\n    j = 0\n    for i in range(n):\n        # Find first j where abs_arr[j] > 2*abs_arr[i]\n        while j < n and abs_arr[j] <= 2 * abs_arr[i]:\n            j += 1\n        # All indices from i+1 to j-1 satisfy the condition\n        count += (j - i - 1)\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 28.696228981018066}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Minimum possible sum: start with 1, each day at least +1\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum possible sum: start with 1, each day at most *2\n    # Geometric series: 1 + 2 + 4 + ... + 2^(k-1) = 2^k - 1\n    # But careful with overflow: use min with n for comparison\n    max_sum = 0\n    val = 1\n    for _ in range(k):\n        max_sum += val\n        if max_sum > n:  # Early stop if already exceeds n\n            max_sum = n + 1\n            break\n        val *= 2\n        if val > n:  # Cap to avoid overflow\n            val = n + 1\n    \n    if n > max_sum:\n        print(\"NO\")\n        return\n    \n    # Binary search for the starting value a1\n    left, right = 1, n\n    best_start = -1\n    while left <= right:\n        mid = (left + right) // 2\n        # Calculate min and max sum starting with mid\n        cur = mid\n        total_min = mid\n        total_max = mid\n        possible = True\n        for i in range(1, k):\n            next_min = cur + 1\n            next_max = 2 * cur\n            if next_min > next_max:\n                possible = False\n                break\n            # To minimize sum, take next_min\n            total_min += next_min\n            # To maximize sum, take next_max\n            total_max += next_max\n            cur = next_min  # For next iteration's bounds\n        \n        if not possible:\n            left = mid + 1\n            continue\n        \n        if total_min <= n <= total_max:\n            best_start = mid\n            break\n        elif n < total_min:\n            right = mid - 1\n        else:  # n > total_max\n            left = mid + 1\n    \n    if best_start == -1:\n        print(\"NO\")\n        return\n    \n    # Construct the sequence\n    a = [0] * k\n    a[0] = best_start\n    remaining = n - best_start\n    for i in range(1, k):\n        # We need to choose a[i] such that:\n        # a[i-1] < a[i] <= 2*a[i-1]\n        # And the remaining sum can be achieved with future days\n        low = a[i-1] + 1\n        high = 2 * a[i-1]\n        # Future days: from i+1 to k-1\n        future_days = k - i - 1\n        # Minimum future sum if we choose current = low\n        min_future = future_days * (low + 1 + low + future_days) // 2\n        # Maximum future sum if we choose current = high\n        max_future = 0\n        val = high\n        for _ in range(future_days):\n            max_future += val\n            val *= 2\n            if val > remaining:  # Cap\n                val = remaining + 1\n        \n        # Binary search for current value\n        l, r = low, high\n        chosen = -1\n        while l <= r:\n            m = (l + r) // 2\n            # Calculate min and max future sums with current = m\n            min_fut = future_days * (m + 1 + m + future_days) // 2\n            max_fut = 0\n            v = m\n            for _ in range(future_days):\n                max_fut += v\n                v *= 2\n                if v > remaining:\n                    v = remaining + 1\n            \n            if remaining - m >= min_fut and remaining - m <= max_fut:\n                chosen = m\n                break\n            elif remaining - m < min_fut:\n                r = m - 1\n            else:  # remaining - m > max_fut\n                l = m + 1\n        \n        if chosen == -1:\n            # Fallback: choose the smallest possible that doesn't break future\n            chosen = low\n        \n        a[i] = chosen\n        remaining -= chosen\n    \n    # Verify sum\n    if sum(a) != n:\n        print(\"NO\")\n        return\n    \n    # Verify constraints\n    for i in range(k):\n        if a[i] <= 0:\n            print(\"NO\")\n            return\n    for i in range(k-1):\n        if not (a[i] < a[i+1] <= 2*a[i]):\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 51.27926778793335}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if K > N:\n        print(0)\n        return\n    \n    a.sort()\n    \n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    total = 0\n    for i in range(N):\n        if i >= K - 1:\n            comb = nCr_mod(i, K - 1, MOD, fact, inv_fact)\n            total = (total + a[i] * comb) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 24.0323486328125}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r = int(data[0])\n    c = int(data[1])\n    grid = data[2:2 + r]\n    \n    # Count rows without 'S'\n    safe_rows = 0\n    for i in range(r):\n        if 'S' not in grid[i]:\n            safe_rows += 1\n    \n    # Count columns without 'S'\n    safe_cols = 0\n    for j in range(c):\n        col_has_s = False\n        for i in range(r):\n            if grid[i][j] == 'S':\n                col_has_s = True\n                break\n        if not col_has_s:\n            safe_cols += 1\n    \n    # Calculate total cells from safe rows and columns\n    total = safe_rows * c + safe_cols * r - safe_rows * safe_cols\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.212412357330322}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    # Replace first 4 characters with '2018'\n    result = '2018' + S[4:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 11.320155143737793}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach: at each step, try to put the largest possible digit at the current position\n    for i in range(length):\n        if k == 0:\n            break\n        # Find the maximum digit from i+1 to end\n        max_digit = n[i]\n        max_index = i\n        for j in range(i+1, length):\n            if n[j] > max_digit:\n                max_digit = n[j]\n                max_index = j\n        # If we found a larger digit, swap it to position i\n        if max_index != i:\n            # Check if swapping would cause leading zero\n            if i == 0 and n[max_index] == '0':\n                continue\n            # Perform the swap\n            n[i], n[max_index] = n[max_index], n[i]\n            k -= 1\n    \n    # If we have swaps left, we can perform additional swaps\n    # Since we want exactly k swaps, we might need to waste swaps\n    # If k is odd, we might need to swap two equal digits at the end\n    if k > 0:\n        # If there are at least two positions with the same digit, we can waste swaps\n        # by swapping them back and forth\n        digit_count = {}\n        for digit in n:\n            digit_count[digit] = digit_count.get(digit, 0) + 1\n        \n        has_duplicate = any(count > 1 for count in digit_count.values())\n        \n        # If no duplicates and k is odd, we need to waste one swap\n        # by swapping two digits and then swapping back\n        if k % 2 == 1 and not has_duplicate and length >= 2:\n            # Swap last two digits (if they're different)\n            if n[-1] != n[-2]:\n                n[-1], n[-2] = n[-2], n[-1]\n            # Then swap back (this uses 2 swaps, so k should be odd)\n            # Actually, we need to handle this carefully\n            # Since we want exactly k swaps, and k is odd, we can waste\n            # one swap by swapping two digits and then swapping back\n            # This uses 2 swaps, so k must be at least 2\n            # But if k=1 and no duplicates, we can't waste it\n            # So we need to check if k=1\n            if k == 1:\n                # We can't waste a single swap without changing the number\n                # So we need to find two positions to swap that don't create leading zero\n                # and don't decrease the number\n                found = False\n                for i in range(length):\n                    for j in range(i+1, length):\n                        if i == 0 and n[j] == '0':\n                            continue\n                        # Swap and check if it's still the same or larger\n                        n[i], n[j] = n[j], n[i]\n                        if int(''.join(n)) >= int(''.join(n_str)):\n                            found = True\n                            break\n                        else:\n                            # Swap back\n                            n[i], n[j] = n[j], n[i]\n                    if found:\n                        break\n                if not found:\n                    # If no such swap exists, we have to accept a smaller number\n                    # But according to problem, we must perform exactly k swaps\n                    # So we need to find any valid swap\n                    for i in range(length):\n                        for j in range(i+1, length):\n                            if i == 0 and n[j] == '0':\n                                continue\n                            n[i], n[j] = n[j], n[i]\n                            break\n                        break\n    \n    print(''.join(n))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 43.127753019332886}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 30.665387392044067}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    a = [0] * (N + 1)\n    for i in range(1, N + 1):\n        a[i] = int(input().strip())\n    \n    visited = [False] * (N + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.952667474746704}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nimport heapq\n\ndef angle_between(v1, v2):\n    \"\"\"Calculate angle between two vectors in degrees\"\"\"\n    dot = v1[0]*v2[0] + v1[1]*v2[1]\n    norm1 = math.hypot(v1[0], v1[1])\n    norm2 = math.hypot(v2[0], v2[1])\n    \n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    \n    cos_theta = dot / (norm1 * norm2)\n    cos_theta = max(-1.0, min(1.0, cos_theta))\n    return math.degrees(math.acos(cos_theta))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    J = int(next(it))\n    R = int(next(it))\n    D = int(next(it))\n    \n    coords = []\n    for _ in range(J):\n        x = int(next(it))\n        y = int(next(it))\n        coords.append((x, y))\n    \n    roads = []\n    for _ in range(R):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        roads.append((a, b))\n    \n    # Build adjacency list with vectors\n    adj = [[] for _ in range(J)]\n    for a, b in roads:\n        dx = coords[b][0] - coords[a][0]\n        dy = coords[b][1] - coords[a][1]\n        dist = math.hypot(dx, dy)\n        adj[a].append((b, (dx, dy), dist))\n    \n    # Binary search on maximum turning angle\n    EPS = 1e-9\n    left, right = 0.0, 180.0\n    answer = None\n    \n    for _ in range(60):  # Enough iterations for 1e-9 precision\n        mid = (left + right) / 2\n        \n        # Dijkstra-like search with angle constraint\n        dist = [float('inf')] * J\n        dist[0] = 0.0\n        pq = [(0.0, 0, None)]  # (distance, node, incoming_vector)\n        \n        while pq:\n            d, u, prev_vec = heapq.heappop(pq)\n            if d > dist[u] + EPS:\n                continue\n            \n            if u == J - 1:\n                break\n            \n            for v, vec, road_dist in adj[u]:\n                new_dist = d + road_dist\n                if new_dist > D * (1 + 1e-6) + EPS:\n                    continue\n                \n                angle = 0.0\n                if prev_vec is not None:\n                    angle = angle_between(prev_vec, vec)\n                \n                if angle <= mid + EPS and new_dist < dist[v] - EPS:\n                    dist[v] = new_dist\n                    heapq.heappush(pq, (new_dist, v, vec))\n        \n        if dist[J - 1] <= D * (1 + 1e-6) + EPS:\n            answer = mid\n            right = mid\n        else:\n            left = mid\n    \n    if answer is None:\n        print(\"Impossible\")\n    else:\n        print(f\"{answer:.8f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 37.648234844207764}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef sum_arithmetic_progression(first, last, count):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    if count == 0:\n        return 0\n    total = (first + last) % MOD\n    total = (total * count) % MOD\n    # Multiply by modular inverse of 2\n    return (total * 500000004) % MOD  # 500000004 is modular inverse of 2 mod MOD\n\ndef get_block_info(n):\n    \"\"\"Return (block_index, position_in_block, block_size, is_odd_block) for position n.\"\"\"\n    block_index = 0\n    block_size = 1\n    total_so_far = 0\n    \n    while True:\n        if total_so_far + block_size >= n:\n            position_in_block = n - total_so_far\n            is_odd_block = (block_index % 2 == 0)\n            return block_index, position_in_block, block_size, is_odd_block\n        total_so_far += block_size\n        block_size *= 2\n        block_index += 1\n\ndef sum_in_block(block_index, start_pos, end_pos):\n    \"\"\"Return sum of numbers from start_pos to end_pos (1-based within block).\"\"\"\n    if start_pos > end_pos:\n        return 0\n    \n    block_size = 1 << block_index  # 2^block_index\n    is_odd_block = (block_index % 2 == 0)\n    \n    # Calculate starting number in this block\n    if is_odd_block:\n        # Odd block: numbers are 1, 3, 5, ...\n        # Count how many odd numbers were written before this block\n        odd_numbers_before = 0\n        for i in range(0, block_index, 2):\n            odd_numbers_before += (1 << i)  # 2^i\n        first_number = 2 * odd_numbers_before + 1\n    else:\n        # Even block: numbers are 2, 4, 6, ...\n        # Count how many even numbers were written before this block\n        even_numbers_before = 0\n        for i in range(1, block_index, 2):\n            even_numbers_before += (1 << i)  # 2^i\n        first_number = 2 * (even_numbers_before + 1)\n    \n    # Adjust for 1-based positions\n    first_pos_number = first_number + 2 * (start_pos - 1)\n    last_pos_number = first_number + 2 * (end_pos - 1)\n    count = end_pos - start_pos + 1\n    \n    return sum_arithmetic_progression(first_pos_number, last_pos_number, count)\n\ndef sum_range(l, r):\n    \"\"\"Return sum of numbers from position l to r (1-based).\"\"\"\n    if l > r:\n        return 0\n    \n    # Get block information for l and r\n    l_block_idx, l_pos, l_size, l_odd = get_block_info(l)\n    r_block_idx, r_pos, r_size, r_odd = get_block_info(r)\n    \n    # Case 1: l and r are in the same block\n    if l_block_idx == r_block_idx:\n        return sum_in_block(l_block_idx, l_pos, r_pos)\n    \n    # Case 2: l and r are in different blocks\n    total = 0\n    \n    # Sum from l to end of its block\n    total = (total + sum_in_block(l_block_idx, l_pos, l_size)) % MOD\n    \n    # Sum complete blocks between l and r\n    for block_idx in range(l_block_idx + 1, r_block_idx):\n        total = (total + sum_in_block(block_idx, 1, 1 << block_idx)) % MOD\n    \n    # Sum from start of r's block to r\n    total = (total + sum_in_block(r_block_idx, 1, r_pos)) % MOD\n    \n    return total\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    result = sum_range(l, r)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 49.41669416427612}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    xs = list(map(int, data[1:1+n]))\n    \n    # Since coordinates are between 1 and 100, we can brute force all possible meeting points\n    min_stamina = float('inf')\n    \n    # Check all integer coordinates from min(xs) to max(xs)\n    # Actually, since the function is convex, the optimal P is near the mean,\n    # but with constraints small, we can check all possible positions from 1 to 100\n    for p in range(1, 101):\n        total = 0\n        for x in xs:\n            diff = x - p\n            total += diff * diff\n        if total < min_stamina:\n            min_stamina = total\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.95051074028015}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**9 + 7\nEPS = 1e-12\n\ndef mat_mul(A, B):\n    n = len(A)\n    m = len(B[0])\n    k = len(B)\n    C = [[0.0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            s = 0.0\n            for t in range(k):\n                s += A[i][t] * B[t][j]\n            C[i][j] = s\n    return C\n\ndef mat_pow(M, power):\n    n = len(M)\n    result = [[0.0] * n for _ in range(n)]\n    for i in range(n):\n        result[i][i] = 1.0\n    while power > 0:\n        if power & 1:\n            result = mat_mul(result, M)\n        M = mat_mul(M, M)\n        power >>= 1\n    return result\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    L = int(next(it))\n    \n    # Read adjacency matrix\n    adj = []\n    for i in range(N):\n        row = []\n        for j in range(N):\n            row.append(int(next(it)))\n        adj.append(row)\n    \n    # Build transition probability matrix\n    P = [[0.0] * N for _ in range(N)]\n    for i in range(N):\n        total = sum(adj[i])\n        if total == 0:\n            # For B-ville (node N-1), it's an absorbing state\n            P[i][i] = 1.0\n        else:\n            for j in range(N):\n                P[i][j] = adj[i][j] / total\n    \n    # Initial state vector: probability 1 at node 0 (A-town)\n    state = [[0.0] for _ in range(N)]\n    state[0][0] = 1.0\n    \n    # Check each T in [L, L+9]\n    for T in range(L, L + 10):\n        # Compute P^T\n        P_pow = mat_pow(P, T)\n        # Compute probability at node N-1 (B-ville)\n        prob = 0.0\n        for i in range(N):\n            prob += state[i][0] * P_pow[i][N-1]\n        \n        # Check if probability is exactly 95% (within floating point tolerance)\n        if abs(prob - 0.95) < EPS:\n            print(T)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.98611545562744}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "from collections import deque\n\ndef bfs_water(R, C, grid, water_queue):\n    water_time = [[-1] * C for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '*':\n                water_queue.append((i, j))\n                water_time[i][j] = 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    while water_queue:\n        x, y = water_queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if water_time[nx][ny] == -1 and grid[nx][ny] == '.':\n                    water_time[nx][ny] = water_time[x][y] + 1\n                    water_queue.append((nx, ny))\n    return water_time\n\ndef bfs_hedgehogs(R, C, grid, start, den, water_time):\n    visited = [[False] * C for _ in range(R)]\n    queue = deque()\n    queue.append((start[0], start[1], 0))\n    visited[start[0]][start[1]] = True\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    while queue:\n        x, y, time = queue.popleft()\n        if (x, y) == den:\n            return time\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if not visited[nx][ny] and grid[nx][ny] != 'X' and grid[nx][ny] != '*':\n                    # Check if the cell is safe to move into\n                    # The hedgehogs cannot move into a cell that is flooded at the same time or earlier\n                    # Also, water cannot flood the den, so water_time[den] is -1\n                    water_t = water_time[nx][ny]\n                    if water_t == -1 or water_t > time + 1:\n                        visited[nx][ny] = True\n                        queue.append((nx, ny, time + 1))\n    return -1\n\ndef main():\n    R, C = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(R)]\n    \n    start = None\n    den = None\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                grid[i][j] = '.'  # Treat start as empty for water expansion\n            elif grid[i][j] == 'D':\n                den = (i, j)\n    \n    water_queue = deque()\n    water_time = bfs_water(R, C, grid, water_queue)\n    \n    result = bfs_hedgehogs(R, C, grid, start, den, water_time)\n    \n    if result == -1:\n        print(\"KAKTUS\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 41.162899017333984}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, w = map(int, data)\n    \n    # Check if possible: min weight = l*1, max weight = l*26\n    if w < l or w > l * 26:\n        print(\"impossible\")\n        return\n    \n    # Start with all 'a's (weight = l)\n    result = ['a'] * l\n    current_weight = l\n    \n    # Distribute remaining weight from the end\n    remaining = w - current_weight\n    for i in range(l - 1, -1, -1):\n        if remaining <= 0:\n            break\n        # Add as much as possible to this position, max 'z' (26)\n        add = min(remaining, 25)  # 25 because 'a' already has weight 1\n        result[i] = chr(ord('a') + add)\n        remaining -= add\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.765188694000244}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.29048299789429}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.99096131324768}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            xr, yr = yr, xr\n        self.parent[yr] = xr\n        if self.rank[xr] == self.rank[yr]:\n            self.rank[xr] += 1\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for i in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v, i))\n    \n    edges.sort()\n    \n    dsu = DSU(n)\n    mst_edges = []\n    mst_cost = 0\n    \n    i = 0\n    while i < m:\n        j = i\n        while j < m and edges[j][0] == edges[i][0]:\n            j += 1\n        \n        same_weight_edges = edges[i:j]\n        \n        for w, u, v, idx in same_weight_edges:\n            if dsu.find(u) != dsu.find(v):\n                mst_edges.append((w, u, v, idx))\n        \n        for w, u, v, idx in same_weight_edges:\n            if dsu.union(u, v):\n                mst_cost += w\n        \n        i = j\n    \n    dsu2 = DSU(n)\n    operations = 0\n    \n    i = 0\n    while i < len(mst_edges):\n        j = i\n        while j < len(mst_edges) and mst_edges[j][0] == mst_edges[i][0]:\n            j += 1\n        \n        same_weight_mst = mst_edges[i:j]\n        \n        component_edges = {}\n        for w, u, v, idx in same_weight_mst:\n            ru = dsu2.find(u)\n            rv = dsu2.find(v)\n            if ru > rv:\n                ru, rv = rv, ru\n            key = (ru, rv)\n            if key not in component_edges:\n                component_edges[key] = 0\n            component_edges[key] += 1\n        \n        for count in component_edges.values():\n            if count > 1:\n                operations += 1\n        \n        for w, u, v, idx in same_weight_mst:\n            dsu2.union(u, v)\n        \n        i = j\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 35.835712909698486}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\n\nit = iter(lines)\nn = int(next(it))\nL = int(next(it))\nW = int(next(it))\n\n# Read positions of trees on left side\npositions = [int(next(it)) for _ in range(n)]\n\n# Sort positions\npositions.sort()\n\n# Precompute distances for dynamic programming\n# dp[i][j] = minimum total distance to pair first i trees on left with first j trees on right\n# We need to pair n/2 trees on each side\nhalf_n = n // 2\n\n# Initialize DP table with infinity\nINF = float('inf')\ndp = [[INF] * (half_n + 1) for _ in range(half_n + 1)]\ndp[0][0] = 0.0\n\n# Precompute target positions for left and right sides\n# Left side trees should be at positions: 0, 2*d, 4*d, ..., L\n# Right side trees should be at positions: 0, 2*d, 4*d, ..., L\n# where d = L / (n - 2) ??? Wait, let's think carefully\n# Actually, with N trees total (N even), we need N/2 pairs\n# The pairs are at positions: start, start + spacing, start + 2*spacing, ..., end\n# Since first and last trees are at beginning and end of road:\n# spacing = L / (N/2 - 1) = L / (n/2 - 1)\n# But wait, if we have N/2 pairs, the positions are: 0, s, 2s, ..., L where s = L / (N/2 - 1)\n# However, the problem says \"first trees at very beginning\" and \"last trees at very end\"\n# So yes, spacing between consecutive pairs = L / (n/2 - 1)\n\nif n == 2:\n    # Special case: only 2 trees, one on each side at position 0\n    # But problem says N >= 4, so we don't need this\n    spacing = 0\nelse:\n    spacing = L / (n/2 - 1)\n\n# Target positions for left and right sides are the same\n# But trees on right side need to be moved across road width\n# A tree at position p on left needs to go to:\n# - Left target position: same as right target position\n# - But with additional horizontal movement of W meters to cross the road\n# Actually, Euclidean distance = sqrt((target_x - p)^2 + W^2) if moving to right side\n# Or sqrt((target_x - p)^2) if staying on left side\n\n# However, we need to assign which trees go to left side and which to right side\n# We have n trees initially all on left side\n# We need to choose n/2 to stay on left, n/2 to move to right\n# And assign them to target positions\n\n# Let's create target positions array\ntargets = [i * spacing for i in range(n//2)]  # n/2 target positions on each side\n\n# Dynamic programming\nfor i in range(half_n + 1):  # i trees assigned to left targets\n    for j in range(half_n + 1):  # j trees assigned to right targets\n        if i == 0 and j == 0:\n            continue\n        \n        idx = i + j - 1  # Current tree index in sorted positions\n        current_pos = positions[idx]\n        \n        # Option 1: assign current tree to next left target\n        if i > 0:\n            target_pos = targets[i-1]\n            dist = abs(current_pos - target_pos)  # Euclidean distance without crossing road\n            dp[i][j] = min(dp[i][j], dp[i-1][j] + dist)\n        \n        # Option 2: assign current tree to next right target\n        if j > 0:\n            target_pos = targets[j-1]\n            # Euclidean distance with horizontal movement W\n            dist = math.sqrt((current_pos - target_pos)**2 + W**2)\n            dp[i][j] = min(dp[i][j], dp[i][j-1] + dist)\n\n# Answer is dp[half_n][half_n]\nanswer = dp[half_n][half_n]\n\n# Output with sufficient precision\nprint(f\"{answer:.10f}\")", "runtime_sec": 48.80682826042175}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef get_hand(player_idx, n, s):\n    \"\"\"Get the favorite hand of player at index i.\"\"\"\n    return s[player_idx % n]\n\ndef match_result(hand1, hand2):\n    \"\"\"Return the winner's hand in a match between hand1 and hand2.\n    If draw, return hand1.\n    \"\"\"\n    if hand1 == hand2:\n        return hand1\n    if (hand1 == 'R' and hand2 == 'S') or (hand1 == 'P' and hand2 == 'R') or (hand1 == 'S' and hand2 == 'P'):\n        return hand1\n    return hand2\n\ndef tournament_winner(l, r, n, s):\n    \"\"\"Recursively compute the winner's hand for players in [l, r-1].\"\"\"\n    if r - l == 1:\n        return get_hand(l, n, s)\n    m = (l + r) // 2\n    winner_left = tournament_winner(l, m, n, s)\n    winner_right = tournament_winner(m, r, n, s)\n    return match_result(winner_left, winner_right)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    total_players = 1 << k  # 2^k\n    result = tournament_winner(0, total_players, n, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 28.52425456047058}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    t = int(input().strip())\n    results = []\n    \n    for _ in range(t):\n        n = int(input().strip())\n        \n        # Check for impossible cases\n        if n == 2 or n == 3:\n            results.append(\"-1\")\n            continue\n        \n        # Build permutation\n        perm = []\n        \n        # Start with odd numbers in descending order\n        odd_start = n if n % 2 == 1 else n - 1\n        for i in range(odd_start, 0, -2):\n            perm.append(i)\n        \n        # Add even numbers in specific pattern\n        # After last odd number, add 4, 2, then remaining evens\n        if n >= 4:\n            perm.append(4)\n            perm.append(2)\n            \n            # Add remaining even numbers\n            for i in range(6, n + 1, 2):\n                perm.append(i)\n        \n        # Verify the permutation meets constraints\n        valid = True\n        for i in range(n - 1):\n            diff = abs(perm[i] - perm[i + 1])\n            if diff < 2 or diff > 4:\n                valid = False\n                break\n        \n        if not valid:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, perm)))\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.272218942642212}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    \n    # Count frequency of each value\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all unique values\n    values = list(freq.keys())\n    \n    total = 0\n    \n    # Case 1: a_i = a_j = a_k/2 (when a_k is even)\n    for val in values:\n        if val % 2 == 0:\n            half = val // 2\n            if half in freq:\n                # Choose 2 indices for half, 1 index for val\n                # C(freq[half], 2) * freq[val]\n                if freq[half] >= 2:\n                    total += (freq[half] * (freq[half] - 1) // 2) * freq[val]\n    \n    # Case 2: a_i != a_j\n    # For each pair of distinct values (x, y) where x + y exists in array\n    m = len(values)\n    for i in range(m):\n        x = values[i]\n        for j in range(i + 1, m):\n            y = values[j]\n            target = x + y\n            if target in freq:\n                # Choose 1 index for x, 1 index for y, 1 index for target\n                total += freq[x] * freq[y] * freq[target]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.91976761817932}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    H = int(next(it))\n    W = int(next(it))\n    K = int(next(it))\n    x1 = int(next(it)) - 1\n    y1 = int(next(it)) - 1\n    x2 = int(next(it)) - 1\n    y2 = int(next(it)) - 1\n    \n    grid = []\n    for _ in range(H):\n        row = list(next(it))\n        grid.append(row)\n    \n    # BFS with 0-1 BFS optimization for K moves\n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # Directions: north, east, south, west\n    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Deque for 0-1 BFS: append left for same stroke, right for new stroke\n    dq = deque()\n    dq.append((x1, y1))\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        if x == x2 and y == y2:\n            print(current_dist)\n            return\n        \n        for dx, dy in dirs:\n            # Try moving 1 to K steps in this direction\n            for step in range(1, K + 1):\n                nx, ny = x + dx * step, y + dy * step\n                \n                # Check bounds and obstacles\n                if not (0 <= nx < H and 0 <= ny < W):\n                    break\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    dq.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # No need to continue in this direction if distance is not improving\n                    break\n            \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 32.23109292984009}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    shares = 0\n    avg_cost = 0.0\n    total_profit = 0.0\n    \n    for line in data:\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == \"buy\":\n            x = int(parts[1])\n            y = int(parts[2])\n            avg_cost = (shares * avg_cost + x * y) / (shares + x)\n            shares += x\n            \n        elif cmd == \"sell\":\n            x = int(parts[1])\n            y = int(parts[2])\n            profit = x * (y - avg_cost)\n            if profit > 0:\n                total_profit += profit\n            shares -= x\n            \n        elif cmd == \"split\":\n            x = int(parts[1])\n            shares *= x\n            avg_cost /= x\n            \n        elif cmd == \"merge\":\n            x = int(parts[1])\n            new_shares = shares // x\n            remainder = shares % x\n            \n            if remainder > 0:\n                profit = remainder * (avg_cost - avg_cost)\n                if profit > 0:\n                    total_profit += profit\n                \n            shares = new_shares\n            avg_cost *= x\n            \n        elif cmd == \"die\":\n            y = int(parts[1])\n            profit = shares * (y - avg_cost)\n            if profit > 0:\n                total_profit += profit\n            \n            tax = total_profit * 0.3\n            final_amount = shares * y - tax\n            print(f\"{final_amount:.10f}\")\n            return\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 23.894194841384888}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        u = int(next(it))\n        op = next(it)\n        v = int(next(it))\n        \n        if op == '=':\n            dsu.union(u, v)\n        else:\n            edges.append((u, v))\n    \n    adj = [[] for _ in range(N)]\n    for u, v in edges:\n        ru, rv = dsu.find(u), dsu.find(v)\n        if ru == rv:\n            print(\"inconsistent\")\n            return\n        adj[ru].append(rv)\n    \n    visited = [0] * N\n    \n    def dfs(node):\n        visited[node] = 1\n        for nei in adj[node]:\n            rnei = dsu.find(nei)\n            if visited[rnei] == 1:\n                return True\n            if visited[rnei] == 0:\n                if dfs(rnei):\n                    return True\n        visited[node] = 2\n        return False\n    \n    for i in range(N):\n        ri = dsu.find(i)\n        if visited[ri] == 0:\n            if dfs(ri):\n                print(\"inconsistent\")\n                return\n    \n    print(\"consistent\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 30.37496519088745}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    s = list(data[idx]); idx += 1\n    \n    for _ in range(m):\n        l = int(data[idx]) - 1; idx += 1\n        r = int(data[idx]) - 1; idx += 1\n        c1 = data[idx]; idx += 1\n        c2 = data[idx]; idx += 1\n        \n        for i in range(l, r + 1):\n            if s[i] == c1:\n                s[i] = c2\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.9350745677948}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_k_periodic(s, k):\n    \"\"\"Check if string s is k-periodic.\"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    # First substring\n    prev = s[:k]\n    \n    # Check each subsequent substring\n    for i in range(k, n, k):\n        curr = s[i:i+k]\n        # Check if curr is right-rotation of prev\n        if curr != prev[-1] + prev[:-1]:\n            return False\n        prev = curr\n    \n    return True\n\ndef main():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if is_k_periodic(s, k):\n            print(k)\n            return\n    \n    # Should never reach here since k=n always works\n    print(n)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 20.098311185836792}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    b = int(data[0])\n    d = int(data[1])\n    \n    # Check if b  1 (mod d) or b  -1 (mod d)\n    if (b % d == 1) or (b % d == d - 1):\n        print(\"yes\")\n        return\n    \n    # Check if b^m  1 (mod d) for some m\n    # Since d is prime, by Fermat's little theorem, b^(d-1)  1 (mod d) if b not divisible by d\n    if b % d == 0:\n        print(\"no\")\n        return\n    \n    # We need to find smallest m such that b^m  1 (mod d)\n    # This m must divide d-1\n    # Check all divisors of d-1\n    n = d - 1\n    divisors = []\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    \n    for m in divisors:\n        if pow(b, m, d) == 1:\n            print(\"yes\")\n            return\n    \n    print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.260421752929688}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nclass FenwickTree:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n    \n    def update(self, idx, delta):\n        i = idx + 1  # Fenwick tree uses 1-based indexing\n        while i <= self.n:\n            self.bit[i] += delta\n            i += i & -i\n    \n    def query(self, idx):\n        # Query prefix sum up to idx-1 (0 to idx-1 inclusive)\n        i = idx  # idx is already the right boundary for prefix sum\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    ft = FenwickTree(n)\n    output_lines = []\n    \n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            ft.update(i, delta)\n        else:  # op == '?'\n            i = int(next(it))\n            # Query prefix sum from 0 to i-1\n            result = ft.query(i)\n            output_lines.append(str(result))\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 23.61551523208618}

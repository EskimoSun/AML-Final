{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 64.10521650314331}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 64.21819233894348}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    a = int(input().strip())\n    # Check if the number is prime\n    if a < 2:\n        print(0)\n        return\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            print(0)\n            return\n    # Check if the sum of digits is prime\n    digit_sum = sum(int(d) for d in str(a))\n    if digit_sum < 2:\n        print(0)\n        return\n    for i in range(2, int(digit_sum**0.5) + 1):\n        if digit_sum % i == 0:\n            print(0)\n            return\n    print(1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.167131900787354}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    seq = list(map(int, data[1:1+n]))\n    \n    # BST node structure\n    class Node:\n        __slots__ = ('val', 'left', 'right')\n        def __init__(self, val):\n            self.val = val\n            self.left = None\n            self.right = None\n    \n    root = None\n    total_depth = 0\n    out_lines = []\n    \n    # Insert each number and accumulate depths\n    for num in seq:\n        depth = 0\n        if root is None:\n            root = Node(num)\n        else:\n            curr = root\n            while True:\n                depth += 1\n                if num < curr.val:\n                    if curr.left is None:\n                        curr.left = Node(num)\n                        break\n                    else:\n                        curr = curr.left\n                else:  # num > curr.val (since distinct)\n                    if curr.right is None:\n                        curr.right = Node(num)\n                        break\n                    else:\n                        curr = curr.right\n        total_depth += depth\n        out_lines.append(str(total_depth))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 25.15330958366394}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We need to count how many powers of 2 are missing to make the sum 2^v - 1\n    # The sum of 2^a_i can be thought of as a binary number where each a_i is a set bit\n    # Since a_i can be huge (up to 2e9), we can't store the actual binary number\n    # Instead, we process frequencies of each exponent\n    \n    # Count frequencies of each a_i\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Process from smallest exponent to largest\n    exponents = sorted(freq.keys())\n    \n    # We'll simulate binary addition with carries\n    # Start with the smallest exponent\n    current_exp = 0\n    if exponents:\n        current_exp = exponents[0]\n    \n    # We'll maintain a dictionary of counts at each exponent\n    counts = {}\n    for exp in exponents:\n        counts[exp] = freq[exp]\n    \n    # Also track the maximum exponent we've seen\n    max_exp = 0\n    if exponents:\n        max_exp = max(exponents)\n    \n    # Process all exponents up to max_exp\n    added = 0\n    exp = 0\n    while exp <= max_exp or (exp in counts and counts[exp] > 0):\n        # Get current count at this exponent\n        current_count = counts.get(exp, 0)\n        \n        # If count is 0 or 1, we don't need to do anything special\n        # If count >= 2, we need to handle carries\n        if current_count >= 2:\n            # Each pair of 2^exp combines to form 2^(exp+1)\n            pairs = current_count // 2\n            remainder = current_count % 2\n            \n            # Update count at current exponent\n            counts[exp] = remainder\n            \n            # Add the carries to next exponent\n            next_exp = exp + 1\n            counts[next_exp] = counts.get(next_exp, 0) + pairs\n            \n            # Update max_exp if needed\n            if next_exp > max_exp:\n                max_exp = next_exp\n        \n        # Move to next exponent\n        exp += 1\n    \n    # Now counts contains the binary representation of the sum\n    # We need to add numbers to make it of form 2^v - 1\n    # That means we need all bits from 0 to v-1 set to 1\n    \n    # Find the highest exponent where count > 0\n    highest_exp = 0\n    for exp in counts:\n        if counts[exp] > 0 and exp > highest_exp:\n            highest_exp = exp\n    \n    # If highest_exp is 0 and count[0] is 0, then sum is 0\n    # 0 = 2^0 - 1, so we need 0 additional numbers\n    if highest_exp == 0 and counts.get(0, 0) == 0:\n        print(0)\n        return\n    \n    # We need to fill all bits from 0 to highest_exp\n    # The number of missing bits is (highest_exp + 1) - number_of_set_bits\n    total_bits_needed = highest_exp + 1\n    set_bits = 0\n    for exp in range(highest_exp + 1):\n        if counts.get(exp, 0) > 0:\n            set_bits += 1\n    \n    missing_bits = total_bits_needed - set_bits\n    print(missing_bits)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 51.04887771606445}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy one cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    # Integer division gives number of donuts\n    donuts_count = remaining // B\n    \n    # Calculate remaining money after buying donuts\n    result = remaining - (donuts_count * B)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.62662386894226}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 62.507046699523926}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Preprocess: for each k, find the optimal subsequence indices\n# Strategy: For each k, take the k largest elements, and among ties, prefer earlier indices for lexicographic minimality\n# We'll process all k from 1 to n efficiently\n\n# Create list of (value, -index) for sorting\nitems = [(a[i], -i) for i in range(n)]\n# Sort by value descending, then index ascending (since we stored negative indices)\nitems.sort(reverse=True)\n\n# For each k, we need to know which indices are selected\n# We'll store for each k the sorted list of selected indices\nselected_indices_by_k = [[] for _ in range(n + 1)]\n\n# Process in increasing k\ncurrent_selected = []  # min-heap of selected indices (we want to keep them sorted)\nfor k in range(1, n + 1):\n    # Add the k-th largest element's index\n    # items[k-1] is the k-th largest (0-indexed)\n    _, neg_idx = items[k - 1]\n    idx_val = -neg_idx\n    heapq.heappush(current_selected, idx_val)\n    # Store a copy of the sorted indices for this k\n    selected_indices_by_k[k] = sorted(current_selected)\n\n# Answer queries\nanswers = []\nfor k, pos in queries:\n    # The optimal subsequence for k is formed by the indices in selected_indices_by_k[k]\n    # The values in the subsequence are a[idx] for idx in selected_indices_by_k[k]\n    # We need the pos-th element (1-indexed)\n    idx_in_subseq = selected_indices_by_k[k][pos - 1]\n    answers.append(a[idx_in_subseq])\n\nprint('\\n'.join(map(str, answers)))", "runtime_sec": 36.734211921691895}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Check if solution exists\n    if k == 1 or n > k * (k - 1):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using two sequences\n    # Men: 1,2,3,...,k,1,2,... (ensuring consecutive differ)\n    # Women: shift by 1, then 2, then 3,... to avoid same pair and b_i != g_i\n    men = []\n    women = []\n    \n    # Build first k*(k-1) pairs systematically\n    for offset in range(1, k):\n        for start in range(1, k + 1):\n            man = start\n            woman = (start + offset - 1) % k + 1\n            if man != woman:\n                men.append(man)\n                women.append(woman)\n                if len(men) == n:\n                    break\n        if len(men) == n:\n            break\n    \n    # Output the pairs\n    for i in range(n):\n        print(men[i], women[i])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 32.20385551452637}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    guests = []\n    idx = 1\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        idx += 2\n        guests.append((l, r))\n    \n    # Sort guests by (l_i - r_i) descending\n    guests.sort(key=lambda x: x[1] - x[0])\n    \n    total_chairs = 0\n    # For each guest, add max(l_i, r_i) + 1 for themselves\n    for i in range(n):\n        l_i, r_i = guests[i]\n        total_chairs += max(l_i, r_i) + 1\n    \n    # Adjust for overlaps between consecutive guests in sorted order\n    for i in range(1, n):\n        l_prev, r_prev = guests[i-1]\n        l_curr, r_curr = guests[i]\n        # Overlap reduction is min(r_prev, l_curr)\n        overlap = min(r_prev, l_curr)\n        total_chairs -= overlap\n    \n    print(total_chairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.999590158462524}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef prime_factors(n):\n    \"\"\"Return prime factorization of n as dict {prime: exponent}\"\"\"\n    factors = defaultdict(int)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1 if d == 2 else 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Factorize all numbers\n    total_factors = defaultdict(int)\n    for num in arr:\n        pf = prime_factors(num)\n        for p, exp in pf.items():\n            total_factors[p] += exp\n    \n    # Step 2: Determine maximum possible GCD\n    max_gcd = 1\n    for p, total_exp in total_factors.items():\n        # Each prime p can contribute p^k to GCD where k = floor(total_exp / n)\n        k = total_exp // n\n        if k > 0:\n            max_gcd *= p ** k\n    \n    # Step 3: Calculate minimal operations\n    operations = 0\n    for num in arr:\n        pf = prime_factors(num)\n        for p, exp in pf.items():\n            target_exp = total_factors[p] // n\n            if exp > target_exp:\n                operations += exp - target_exp\n    \n    print(f\"{max_gcd} {operations}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 29.576024532318115}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    f = list(map(int, data[1:1+n]))\n    \n    # Determine who is already assigned to give to whom\n    give_to = [-1] * n  # f[i] after filling zeros\n    receive_from = [-1] * n  # who gives to i\n    \n    for i in range(n):\n        if f[i] != 0:\n            give_to[i] = f[i] - 1  # convert to 0-index\n            receive_from[f[i] - 1] = i\n    \n    # Lists of people who don't give and don't receive\n    no_give = [i for i in range(n) if give_to[i] == -1]\n    no_receive = [i for i in range(n) if receive_from[i] == -1]\n    \n    # They should be the same set, but we'll process them\n    # Create chains from no_give to no_receive\n    # We'll match them avoiding self-loops\n    \n    # Simple approach: match no_give to no_receive in order\n    # But need to avoid i giving to itself\n    # We'll rotate the no_receive list if needed\n    \n    m = len(no_give)\n    # If only one person in both lists, we need to handle specially\n    # But problem guarantees at least two zeros, so m >= 2\n    \n    # Create a copy of no_receive to match\n    target = no_receive[:]\n    \n    # Rotate target to avoid self-giving\n    # Find a rotation where no_give[i] != target[i]\n    for shift in range(m):\n        ok = True\n        for i in range(m):\n            if no_give[i] == target[(i + shift) % m]:\n                ok = False\n                break\n        if ok:\n            # Apply this rotation\n            target = [target[(i + shift) % m] for i in range(m)]\n            break\n    \n    # Assign the matches\n    for i in range(m):\n        give_to[no_give[i]] = target[i]\n        receive_from[target[i]] = no_give[i]\n    \n    # Output\n    result = [str(give_to[i] + 1) for i in range(n)]\n    sys.stdout.write(' '.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.52280235290527}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef max_polygon_area(segments):\n    \"\"\"Return maximum area polygon that can be formed from given segments.\"\"\"\n    n = len(segments)\n    total = sum(segments)\n    \n    # Sort segments in descending order for greedy selection\n    segments.sort(reverse=True)\n    \n    # Try to form polygons with different numbers of sides\n    max_area = 0.0\n    \n    # We need at least 3 sides for a polygon\n    for k in range(3, n + 1):\n        # Select the k longest segments\n        selected = segments[:k]\n        sum_selected = sum(selected)\n        \n        # Check polygon inequality: longest side < sum of other sides\n        if selected[0] >= sum_selected - selected[0]:\n            continue\n        \n        # For regular polygon approximation\n        # Using formula: area = (n * s^2) / (4 * tan(pi/n))\n        # But we have different side lengths, so we approximate\n        # by using average side length\n        avg_side = sum_selected / k\n        \n        # Calculate area of regular polygon with k sides and perimeter sum_selected\n        # Perimeter = k * s, so s = sum_selected / k\n        s = sum_selected / k\n        \n        # Area of regular k-gon: (k * s^2) / (4 * tan(pi/k))\n        if k == 3:\n            # For triangle, use Heron's formula with sides as close to equal as possible\n            # We'll try to make it as equilateral as possible\n            a, b, c = selected[0], selected[1], selected[2]\n            # Check triangle inequality\n            if a < b + c and b < a + c and c < a + b:\n                s_tri = (a + b + c) / 2\n                area = math.sqrt(s_tri * (s_tri - a) * (s_tri - b) * (s_tri - c))\n                max_area = max(max_area, area)\n        else:\n            # For k > 3, use regular polygon approximation\n            # This is an approximation since we have different side lengths\n            try:\n                area = (k * s * s) / (4 * math.tan(math.pi / k))\n                max_area = max(max_area, area)\n            except:\n                continue\n    \n    return max_area\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    segments = list(map(int, data[1:1+n]))\n    \n    result = max_polygon_area(segments)\n    \n    # Format output with appropriate precision\n    print(f\"{result:.3f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 40.42123055458069}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd_value] = minimal cost to achieve that gcd\n    INF = 10**18\n    dp = defaultdict(lambda: INF)\n    dp[0] = 0  # Starting with gcd 0 (which is neutral)\n    \n    for i in range(n):\n        li, ci = l[i], c[i]\n        # Need to iterate over a copy because we modify dp during iteration\n        items = list(dp.items())\n        for g_val, cost in items:\n            new_g = math.gcd(g_val, li)\n            if cost + ci < dp[new_g]:\n                dp[new_g] = cost + ci\n    \n    ans = dp.get(1, INF)\n    print(ans if ans < INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.21487832069397}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Calculate required time to travel D meters at speed S\n    # Since all values are integers, we can compare D <= T * S\n    # This avoids floating point comparison\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.100024223327637}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nsys.setrecursionlimit(200000)\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    it = iter(data)\\r\\n    k = int(next(it))\\r\\n    n = int(next(it))\\r\\n    \\r\\n    adj = [[] for _ in range(n)]\\r\\n    for i in range(n):\\r\\n        d = int(next(it))\\r\\n        for _ in range(d):\\r\\n            neighbor = int(next(it)) - 1  # convert to 0‑based\\r\\n            adj[i].append(neighbor)\\r\\n    \\r\\n    # DP on tree (forest) using bipartite coloring\\r\\n    # dp[node][color] = max drones in subtree rooted at node, with node colored color\\r\\n    # color 0 = no drone, color 1 = drone\\r\\n    dp0 = [0]*n\\r\\n    dp1 = [0]*n\\r\\n    visited = [False]*n\\r\\n    \\r\\n    def dfs(u, parent):\\r\\n        visited[u] = True\\r\\n        # base: leaf (in tree sense)\\r\\n        dp0[u] = 0\\r\\n        dp1[u] = 1  # we can place a drone here\\r\\n        \\r\\n        for v in adj[u]:\\r\\n            if v == parent:\\r\\n                continue\\r\\n            dfs(v, u)\\r\\n            # if u has no drone, children can have either\\r\\n            dp0[u] += max(dp0[v], dp1[v])\\r\\n            # if u has a drone, children must have no drone\\r\\n            dp1[u] += dp0[v]\\r\\n    \\r\\n    total_max = 0\\r\\n    for i in range(n):\\r\\n        if not visited[i]:\\r\\n            dfs(i, -1)\\r\\n            total_max += max(dp0[i], dp1[i])\\r\\n    \\r\\n    # Check if k is between min and max possible\\r\\n    # Minimum independent set size: we can always take 0 drones\\r\\n    # Maximum is total_max computed above\\r\\n    if 0 <= k <= total_max:\\r\\n        print(\"possible\")\\r\\n    else:\\r\\n        print(\"impossible\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 380, 381, 'illegal multibyte sequence')", "runtime_sec": 44.660308837890625}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\nn = int(lines[0])\nc = list(map(int, lines[1:1+n]))\n\n# Total number of people\nP = sum(c)\n\n# Validate input constraints\nif P > 365:\n    # If total people exceed 365, probability is 0 (log10(0) = -inf)\n    # But since P <= 100*365, we handle it numerically\n    print(\"-inf\")\n    sys.exit(0)\n\n# Number of distinct birthdays\nk = n\n\n# Step 1: Choose which k days out of 365 have birthdays\n# C(365, k) ways\nlog_choose = 0.0\nfor i in range(k):\n    log_choose += math.log10(365 - i) - math.log10(i + 1)\n\n# Step 2: Arrange P people into groups of sizes c1, c2, ..., ck\n# Multinomial coefficient: P! / (c1! * c2! * ... * ck!)\nlog_multinomial = math.lgamma(P + 1) / math.log(10)  # log10(P!)\nfor ci in c:\n    log_multinomial -= math.lgamma(ci + 1) / math.log(10)  # subtract log10(ci!)\n\n# Step 3: Probability for each arrangement\n# Each person has probability 1/365 for their birthday\n# For k distinct days, probability = (1/365)^P\nlog_prob_arrangement = P * math.log10(1.0 / 365.0)\n\n# Step 4: Total probability\nlog_total = log_choose + log_multinomial + log_prob_arrangement\n\n# Output\nprint(f\"{log_total:.15f}\")", "runtime_sec": 30.728732585906982}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find player start\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Mark unsafe squares (adjacent to traps)\n    unsafe = [[False]*W for _ in range(H)]\n    dirs = [(-1,0), (1,0), (0,-1), (0,1)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'T':\n                for di, dj in dirs:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < H and 0 <= nj < W:\n                        unsafe[ni][nj] = True\n    \n    # BFS to explore reachable safe squares\n    visited = [[False]*W for _ in range(H)]\n    q = deque([start])\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while q:\n        i, j = q.popleft()\n        if grid[i][j] == 'G':\n            gold_count += 1\n        \n        for di, dj in dirs:\n            ni, nj = i+di, j+dj\n            if 0 <= ni < H and 0 <= nj < W and not visited[ni][nj]:\n                # Only move if not a wall and not unsafe\n                if grid[ni][nj] != '#' and not unsafe[ni][nj]:\n                    visited[ni][nj] = True\n                    q.append((ni, nj))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.23890995979309}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 65.54078125953674}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    # Find maximum k such that sum_{i=1}^{k} i <= a + b\n    total_hours = a + b\n    k = 0\n    low, high = 0, int(2e9)  # Upper bound for k\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * (mid + 1) // 2 <= total_hours:\n            k = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Generate all notes from 1 to k\n    all_notes = list(range(1, k + 1))\n    \n    # Greedy assignment: try to assign largest notes to first day\n    day1 = []\n    day2 = []\n    remaining_a = a\n    \n    for note in reversed(all_notes):\n        if note <= remaining_a:\n            day1.append(note)\n            remaining_a -= note\n        else:\n            day2.append(note)\n    \n    # Output\n    print(len(day1))\n    if day1:\n        print(' '.join(map(str, day1)))\n    else:\n        print()\n    \n    print(len(day2))\n    if day2:\n        print(' '.join(map(str, day2)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 32.773932456970215}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # The game is equivalent to a Nim game where each branch piece\n    # corresponds to a pile with Grundy number equal to its length.\n    # For a piece of length x, the Grundy number g(x) = x.\n    # The XOR of all pieces' Grundy numbers determines the winner.\n    # Initially, there's one piece of length n, so XOR = n.\n    \n    if n % 2 == 0:\n        # Alice wins for even n\n        print(\"Alice\")\n        # Winning move: break into (1, n-1)\n        # This gives XOR = 1 XOR (n-1) = 0 (since n is even, n-1 is odd)\n        print(1)\n    else:\n        # Bob wins for odd n\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 26.16259264945984}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    Q = int(data[0])\n    idx = 1\n    \n    # BIT (Fenwick Tree) for prefix sums\n    class BIT:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 2)\n        \n        def update(self, i, delta):\n            while i <= self.n:\n                self.bit[i] += delta\n                i += i & -i\n        \n        def query(self, i):\n            s = 0\n            while i > 0:\n                s += self.bit[i]\n                i -= i & -i\n            return s\n        \n        def find_kth(self, k):\n            # find smallest i such that prefix sum >= k\n            pos = 0\n            bit_mask = 1 << (self.n.bit_length() - 1)\n            while bit_mask:\n                next_pos = pos + bit_mask\n                if next_pos <= self.n and self.bit[next_pos] < k:\n                    k -= self.bit[next_pos]\n                    pos = next_pos\n                bit_mask >>= 1\n            return pos + 1\n    \n    # We'll maintain two structures:\n    # 1. BIT to track empty positions in plot order\n    # 2. Array to store creation indices at plot positions\n    \n    # Maximum possible movies: Q (since each query can add at most 1 movie)\n    max_n = Q\n    bit = BIT(max_n)\n    \n    # Initially all positions are empty (1 means empty)\n    for i in range(1, max_n + 1):\n        bit.update(i, 1)\n    \n    # Array to store creation index at each plot position\n    # 0 means position is empty\n    plot_to_creation = [0] * (max_n + 1)\n    \n    creation_counter = 1\n    output_lines = []\n    \n    for _ in range(Q):\n        q = int(data[idx]); idx += 1\n        x = int(data[idx]); idx += 1\n        \n        if q == 1:\n            # Insert movie with plot index x\n            # Find the x-th empty position\n            pos = bit.find_kth(x)\n            # Mark position as occupied\n            bit.update(pos, -1)\n            # Store creation index\n            plot_to_creation[pos] = creation_counter\n            creation_counter += 1\n        else:  # q == 2\n            # Query creation index of movie at plot index x\n            # We need to find the x-th occupied position\n            # Binary search for position where prefix sum of occupied = x\n            # occupied = total - empty\n            # We can binary search using BIT's prefix sums\n            \n            lo, hi = 1, max_n\n            while lo < hi:\n                mid = (lo + hi) // 2\n                # Number of occupied positions up to mid\n                occupied = mid - bit.query(mid)\n                if occupied >= x:\n                    hi = mid\n                else:\n                    lo = mid + 1\n            \n            output_lines.append(str(plot_to_creation[lo]))\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 41.87750291824341}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Use difference array for efficient range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            needed = target - current_height\n            days_used += needed\n            if days_used > m:\n                return False\n            \n            # Water w flowers starting from i\n            current += needed\n            end = min(i + w, n)\n            diff[end] -= needed\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3+n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(high)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 26.75783681869507}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.79265069961548}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 61.77711820602417}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef insertion_sort_swaps(arr):\n    \"\"\"Return number of swaps performed by insertion sort on array.\"\"\"\n    n = len(arr)\n    swaps = 0\n    for i in range(1, n):\n        j = i\n        while j > 0 and arr[j] < arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            swaps += 1\n            j -= 1\n    return swaps\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    perm = list(map(int, data[1:1 + n]))\n    \n    # Step 1: Compute original swaps\n    original_arr = perm[:]\n    original_swaps = insertion_sort_swaps(original_arr)\n    \n    # Step 2: Try all swaps (i, j) where i < j\n    min_swaps = float('inf')\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a copy and swap elements at i and j\n            arr_copy = perm[:]\n            arr_copy[i], arr_copy[j] = arr_copy[j], arr_copy[i]\n            \n            # Compute swaps after this swap\n            current_swaps = insertion_sort_swaps(arr_copy)\n            \n            if current_swaps < min_swaps:\n                min_swaps = current_swaps\n                count = 1\n            elif current_swaps == min_swaps:\n                count += 1\n    \n    print(f\"{min_swaps} {count}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.508899450302124}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    idx = 1\n    total = 0.0\n    \n    for _ in range(n):\n        x_str = data[idx]\n        u = data[idx + 1]\n        idx += 2\n        \n        if u == \"JPY\":\n            total += int(x_str)\n        else:  # BTC\n            total += float(x_str) * 380000.0\n    \n    print(f\"{total:.10f}\".rstrip('0').rstrip('.'))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 20.878999948501587}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245066 tokens (243466 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 15.761154890060425}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = list(map(int, data[:4]))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1 << 4):\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.334125518798828}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    seen = set()\n    result = []\n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.322006940841675}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**6 + 7\n\ndef modinv(a, mod=MOD):\n    return pow(a, mod-2, mod)\n\ndef nCr_mod(n, r, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n-r)\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n-i)) % mod\n        denominator = (denominator * (i+1)) % mod\n    return (numerator * modinv(denominator, mod)) % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, M, K = map(int, data[:3])\n    \n    # If K > N*M, impossible\n    if K > N * M:\n        print(0)\n        return\n    \n    # Using inclusion-exclusion principle\n    result = 0\n    for i in range(N+1):\n        term = nCr_mod(N, i) * nCr_mod(K - i*(M+1) + N - 1, N - 1)\n        if i % 2 == 0:\n            result = (result + term) % MOD\n        else:\n            result = (result - term) % MOD\n    \n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.860877752304077}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to compute final score given fifth time\n    def compute_final(fifth):\n        all_times = times + [fifth]\n        all_times.sort()\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Case 1: Check if already winning with worst possible fifth time (20.00)\n    if compute_final(20.00) <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 2: Check if impossible even with best possible fifth time (1.00)\n    if compute_final(1.00) > target:\n        print(\"impossible\")\n        return\n    \n    # Case 3: Binary search for worst fifth time that still meets target\n    lo, hi = 1.00, 20.00\n    for _ in range(100):  # Sufficient precision for 2 decimal places\n        mid = (lo + hi) / 2.0\n        if compute_final(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round down to worst time that still works (since we want worst possible)\n    # We need to handle floating point precision carefully\n    worst_time = lo\n    # Verify slightly above and below to ensure correctness\n    if compute_final(worst_time + 0.005) <= target:\n        # If time slightly higher still works, adjust upward\n        worst_time = min(20.00, worst_time + 0.005)\n    elif compute_final(worst_time - 0.005) > target:\n        # If time slightly lower fails, adjust upward\n        worst_time = min(20.00, worst_time + 0.005)\n    \n    # Format to exactly two decimal places\n    print(f\"{worst_time:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 39.75856041908264}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.967167139053345}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # If n < 3, no valid x exists (since 2*x+1 ≤ n)\n    if n < 3:\n        print(-1)\n        return\n    \n    # We need to find minimum moves to reduce all a[i] to 0\n    # Each move with x affects positions x, 2*x, 2*x+1\n    # This is essentially a system of linear equations over non-negative integers\n    # We can solve via greedy from bottom up\n    \n    moves = 0\n    # Process from largest x to smallest\n    for x in range(n//2, 0, -1):\n        if 2*x + 1 > n:\n            continue\n        # Take as many moves as needed for chest 2*x+1\n        needed = a[2*x]  # chest 2*x+1 is at index 2*x (0-indexed)\n        if needed > 0:\n            moves += needed\n            a[x-1] = max(0, a[x-1] - needed)  # chest x\n            a[2*x-1] = max(0, a[2*x-1] - needed)  # chest 2*x\n            a[2*x] = 0  # chest 2*x+1\n    \n    # After processing, check if all chests are empty\n    if all(v == 0 for v in a):\n        print(moves)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.897385597229004}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            sys.stdout.write(s)\n            break\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 22.382007837295532}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    # Total cost = train fare + half of bus fare\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.294461250305176}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    lines = data[1:]\n    \n    # Stack to track events that have happened (not dreams)\n    event_stack = []\n    # Set of events that have happened in current reality\n    happened = set()\n    # List to store results\n    results = []\n    \n    for line in lines:\n        parts = line.split()\n        if not parts:\n            continue\n        \n        if parts[0] == 'E':\n            # Event happens\n            event = parts[1]\n            event_stack.append(event)\n            happened.add(event)\n            \n        elif parts[0] == 'D':\n            # Dream: remove last r events\n            r = int(parts[1])\n            for _ in range(r):\n                if event_stack:\n                    event = event_stack.pop()\n                    happened.remove(event)\n            \n        elif parts[0] == 'S':\n            # Scenario\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current reality\n            consistent = True\n            for event_spec in scenario_events:\n                if event_spec.startswith('!'):\n                    event = event_spec[1:]\n                    if event in happened:\n                        consistent = False\n                        break\n                else:\n                    if event_spec not in happened:\n                        consistent = False\n                        break\n            \n            if consistent:\n                results.append(\"Yes\")\n                continue\n            \n            # If not consistent, check if adding a dream before scenario makes it consistent\n            # We need to find smallest r such that removing last r events makes scenario consistent\n            min_r = None\n            \n            # Try all possible r from 1 to len(event_stack)\n            for r in range(1, len(event_stack) + 1):\n                # Temporarily remove last r events\n                temp_happened = happened.copy()\n                temp_stack = event_stack.copy()\n                \n                for _ in range(r):\n                    if temp_stack:\n                        event = temp_stack.pop()\n                        temp_happened.remove(event)\n                \n                # Check consistency with this temporary state\n                temp_consistent = True\n                for event_spec in scenario_events:\n                    if event_spec.startswith('!'):\n                        event = event_spec[1:]\n                        if event in temp_happened:\n                            temp_consistent = False\n                            break\n                    else:\n                        if event_spec not in temp_happened:\n                            temp_consistent = False\n                            break\n                \n                if temp_consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                results.append(f\"{min_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 41.874473333358765}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213643 tokens (212043 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 15.672630548477173}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    P, Q, R = map(int, input().split())\n    # The route involves exactly two flights between three airports\n    # The possible sums are: P+Q, Q+R, R+P\n    # We need the minimum of these three sums\n    result = min(P+Q, Q+R, R+P)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 19.911454916000366}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import Counter\n\nMOD = 10**9 + 9\n\ndef modinv(x, mod=MOD):\n    return pow(x, mod-2, mod)\n\ndef factorial(n, mod=MOD):\n    fact = [1] * (n+1)\n    for i in range(1, n+1):\n        fact[i] = fact[i-1] * i % mod\n    return fact\n\ndef nCr(n, r, fact, inv_fact, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n-r] % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies\n    freq = Counter(arr)\n    sorted_keys = sorted(freq.keys())\n    m = len(sorted_keys)\n    \n    # Precompute factorials and inverse factorials\n    fact = factorial(n, MOD)\n    inv_fact = [1] * (n+1)\n    inv_fact[n] = modinv(fact[n], MOD)\n    for i in range(n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # DP array: dp[i][j] = number of ways to arrange first i distinct values\n    # with j positions occupied by sorted elements\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    dp[0][0] = 1\n    \n    total_placed = 0\n    for i in range(1, m+1):\n        val = sorted_keys[i-1]\n        cnt = freq[val]\n        \n        # For current value, we can place 0 to cnt sorted elements\n        # But we need to ensure we don't create sorted elements\n        # A sorted element for value val must be placed such that:\n        # - All smaller values are to its left\n        # - All larger values are to its right\n        # So sorted elements of val must be placed in the \"middle\" positions\n        # between already placed smaller values and remaining positions\n        \n        for j in range(n+1):  # j = number of sorted elements so far\n            if dp[i-1][j] == 0:\n                continue\n            \n            # Positions available for current value\n            # total_placed positions are already occupied by previous values\n            # We have n - total_placed positions left\n            available = n - total_placed\n            \n            # We need to place cnt elements of current value\n            # Some of them can be sorted (k), some unsorted (cnt - k)\n            for k in range(min(cnt, available) + 1):\n                # k sorted elements of current value\n                # They must be placed in specific positions:\n                # After all smaller values and before all larger values\n                # This means they must occupy positions total_placed+1 to total_placed+k\n                # in the final sequence\n                \n                # Number of ways to choose which k of cnt elements are sorted\n                ways_choose_sorted = nCr(cnt, k, fact, inv_fact, MOD)\n                \n                # Number of ways to place the remaining (cnt - k) unsorted elements\n                # They can go in any of the remaining positions\n                # After placing k sorted elements, we have:\n                # - total_placed + k positions occupied\n                # - n - (total_placed + k) positions left\n                remaining_positions = n - (total_placed + k)\n                if cnt - k > remaining_positions:\n                    continue\n                \n                # Choose positions for unsorted elements\n                ways_place_unsorted = nCr(remaining_positions, cnt - k, fact, inv_fact, MOD)\n                \n                # Multiply by factorial for arrangement of unsorted elements\n                ways_arrange_unsorted = fact[cnt - k]\n                \n                total_ways = dp[i-1][j] * ways_choose_sorted % MOD\n                total_ways = total_ways * ways_place_unsorted % MOD\n                total_ways = total_ways * ways_arrange_unsorted % MOD\n                \n                dp[i][j + k] = (dp[i][j + k] + total_ways) % MOD\n        \n        total_placed += cnt\n    \n    # Answer is dp[m][0] (0 sorted elements in total)\n    print(dp[m][0] % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 60.66475701332092}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    boys = list(map(int, data[1:1+N]))\n    A = int(data[1+N])\n    B = int(data[2+N])\n    \n    # Sort boys for binary search\n    boys.sort()\n    \n    # Helper: find closest boy distance for a candidate X\n    def min_distance(x):\n        from bisect import bisect_left\n        idx = bisect_left(boys, x)\n        best = float('inf')\n        if idx < N:\n            best = min(best, abs(boys[idx] - x))\n        if idx > 0:\n            best = min(best, abs(boys[idx-1] - x))\n        return best\n    \n    best_x = -1\n    best_dist = -1\n    \n    # Check all odd numbers in [A, B]\n    # Ensure we start with an odd number\n    start = A if A % 2 == 1 else A + 1\n    for x in range(start, B + 1, 2):\n        d = min_distance(x)\n        if d > best_dist:\n            best_dist = d\n            best_x = x\n    \n    print(best_x)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.819875478744507}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        a = [int(next(it)) for _ in range(n)]\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        out_lines.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.439125299453735}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, A, B = map(int, data)\n    \n    # Check necessary condition: A * B >= N and A + B <= N + 1\n    if A * B < N or A + B > N + 1:\n        print(-1)\n        return\n    \n    # Construct sequence\n    result = []\n    # Create B decreasing blocks of size at most A\n    remaining = N\n    for i in range(B):\n        block_size = min(A, remaining - (B - i - 1))\n        start = remaining - block_size + 1\n        result.extend(range(start, remaining + 1))\n        remaining -= block_size\n    \n    # Reverse to get increasing LIS of length A\n    result.reverse()\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.5743465423584}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    # Handle negative coordinates by working with absolute values\n    sign_x = 1 if X >= 0 else -1\n    sign_y = 1 if Y >= 0 else -1\n    x = abs(X)\n    y = abs(Y)\n    \n    # Total Manhattan distance to target\n    total_dist = x + y\n    \n    # Check if impossible\n    if K % 2 == 0 and total_dist % 2 == 1:\n        print(-1)\n        return\n    \n    # Determine minimum number of strokes\n    strokes = (total_dist + K - 1) // K  # ceil division\n    \n    # Adjust if parity doesn't match\n    while (strokes * K - total_dist) % 2 != 0:\n        strokes += 1\n    \n    # Generate path\n    path = []\n    cur_x, cur_y = 0, 0\n    remaining = strokes * K - total_dist  # extra distance to distribute\n    \n    for i in range(strokes):\n        # Determine target for this stroke\n        target_x = x\n        target_y = y\n        \n        # Move towards target, but may need to overshoot\n        move_x = min(K, target_x - cur_x)\n        if move_x < 0:\n            move_x = 0\n        \n        move_y = K - move_x\n        \n        # Adjust if we need to use extra distance\n        if remaining > 0:\n            if move_x < K:\n                # Can add extra to x movement\n                extra = min(remaining, K - move_x)\n                move_x += extra\n                remaining -= extra\n                move_y = K - move_x\n            elif move_y < K:\n                # Can add extra to y movement\n                extra = min(remaining, K - move_y)\n                move_y += extra\n                remaining -= extra\n                move_x = K - move_y\n        \n        # Apply movement with signs\n        cur_x += move_x\n        cur_y += move_y\n        \n        # Add to path with original signs\n        path.append((cur_x * sign_x, cur_y * sign_y))\n        \n        # Update remaining distance to target\n        x = max(0, x - move_x)\n        y = max(0, y - move_y)\n    \n    # Output\n    print(strokes)\n    for px, py in path:\n        print(f\"{px} {py}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 40.60223054885864}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(data[idx]); idx += 1\n        # Count days participant eats chocolate: day 1, A+1, 2A+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A\n    \n    # Total prepared = eaten + remaining\n    result = total_eaten + X\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.974007606506348}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.size[xr] < self.size[yr]:\n            xr, yr = yr, xr\n        self.parent[yr] = xr\n        self.size[xr] += self.size[yr]\n        self.components -= 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    capacities = [int(next(it)) for _ in range(n)]\n    \n    dsu = DSU(n)\n    degree = [0] * n\n    \n    # Process existing edges\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        degree[u] += 1\n        degree[v] += 1\n        dsu.union(u, v)\n    \n    # Check capacity constraints\n    for i in range(n):\n        if degree[i] > capacities[i]:\n            print(\"no\")\n            return\n    \n    # Calculate needed edits\n    needed_removals = 0\n    for i in range(n):\n        if degree[i] < capacities[i]:\n            needed_removals += capacities[i] - degree[i]\n    \n    # Each removal frees capacity for new connections\n    # We need to connect all components into one\n    needed_connections = dsu.components - 1\n    \n    # Total edits needed = removals + connections\n    total_needed = needed_removals + needed_connections\n    \n    # Check if possible within k edits\n    if total_needed <= k:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.12155818939209}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Total possible pairs without restrictions\n    total_pairs = m * m\n    \n    # Subtract pairs where robots would meet\n    # Robots meet if first robot's stop position >= second robot's stop position\n    # This happens when the first occurrence of p from left is at or after \n    # the first occurrence of q from right\n    \n    # Precompute first occurrence from left for each number\n    first_left = {}\n    for i, num in enumerate(arr):\n        if num not in first_left:\n            first_left[num] = i\n    \n    # Precompute first occurrence from right for each number\n    first_right = {}\n    for i in range(n-1, -1, -1):\n        num = arr[i]\n        if num not in first_right:\n            first_right[num] = i\n    \n    # Count bad pairs\n    bad_pairs = 0\n    for p in distinct_nums:\n        for q in distinct_nums:\n            if first_left[p] >= first_right[q]:\n                bad_pairs += 1\n    \n    result = total_pairs - bad_pairs\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.58838653564453}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = list(map(int, data[2:2+n]))\n    \n    # Count frequencies of each element in s\n    freq = {}\n    for x in s:\n        freq[x] = freq.get(x, 0) + 1\n    \n    # We need to choose k elements (with repetitions allowed) to maximize\n    # the number of complete copies we can cut.\n    # For a given element x, if we include it c times in t, then each copy\n    # consumes c of x from s. So the number of copies we can cut is at most floor(freq[x] / c).\n    # We want to maximize min over all chosen elements of floor(freq[x] / c).\n    # This is equivalent to: we want to maximize m such that for each chosen element x,\n    # we have freq[x] >= m * c, i.e., c <= freq[x] / m.\n    # Since we need sum of c over all chosen elements = k.\n    # We can binary search on m (the number of copies).\n    \n    # Binary search on the maximum number of copies\n    low = 0\n    high = n // k  # at most this many copies\n    best_m = 0\n    best_counts = {}\n    \n    while low <= high:\n        mid = (low + high) // 2\n        # Check if we can achieve at least mid copies\n        total_available = 0\n        counts = {}\n        for x, cnt in freq.items():\n            # For element x, we can use at most floor(cnt / mid) times in t\n            max_c = cnt // mid if mid > 0 else k  # if mid=0, we can use up to k (but we want m>0)\n            if max_c > 0:\n                counts[x] = max_c\n                total_available += max_c\n        # If we can pick at least k elements in total, then mid is feasible\n        if total_available >= k:\n            best_m = mid\n            best_counts = counts\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Now construct t using best_counts\n    t = []\n    # We need exactly k elements\n    remaining = k\n    for x, max_c in best_counts.items():\n        # Take as many as possible, but not more than remaining\n        take = min(max_c, remaining)\n        t.extend([x] * take)\n        remaining -= take\n        if remaining == 0:\n            break\n    # If we still have remaining (should not happen if best_m>0, but just in case)\n    # Fill with any element that has frequency > 0\n    if remaining > 0:\n        for x in freq:\n            t.extend([x] * remaining)\n            break\n    \n    # Output t\n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 43.04216694831848}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 63.29118299484253}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.698551416397095}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    res = []\n    for x in arr:\n        if x % 2 == 0:\n            res.append(x - 1)\n        else:\n            res.append(x)\n    \n    print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 15.368560075759888}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    target = \"ThoreHusfeldt\"\n    target_index = names.index(target)\n    \n    # Check if ThoreHusfeldt is first\n    if target_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check for ThoreHusfeld prefix above\n    above_names = names[:target_index]\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    for length in range(1, len(target) + 1):\n        prefix = target[:length]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Should never reach here given problem constraints\n    print(target)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 20.562628030776978}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef count_pairs_less_equal(mid, arr, n):\n    \"\"\"Count number of pairs with product <= mid\"\"\"\n    count = 0\n    # Split array into negative and non-negative parts\n    neg = [x for x in arr if x < 0]\n    non_neg = [x for x in arr if x >= 0]\n    \n    # Sort both parts\n    neg.sort()\n    non_neg.sort()\n    \n    # Count pairs where both are non-negative\n    if non_neg:\n        j = len(non_neg) - 1\n        for i in range(len(non_neg)):\n            while j > i and non_neg[i] * non_neg[j] > mid:\n                j -= 1\n            if j > i:\n                count += (j - i)\n    \n    # Count pairs where both are negative\n    if neg:\n        j = 0\n        for i in range(len(neg)-1, -1, -1):\n            while j < i and neg[i] * neg[j] > mid:\n                j += 1\n            if j < i:\n                count += (i - j)\n    \n    # Count pairs with one negative and one non-negative\n    if neg and non_neg:\n        # For each negative, find non-negatives where product <= mid\n        for x in neg:\n            if x == 0:\n                # 0 * any non-negative = 0\n                if mid >= 0:\n                    count += len(non_neg)\n            else:\n                # x is negative\n                if mid >= 0:\n                    # All non-negatives work when mid >= 0\n                    count += len(non_neg)\n                else:\n                    # Need non_neg >= ceil(mid/x) since x < 0\n                    # Since mid < 0 and x < 0, mid/x is positive\n                    threshold = (mid + x + 1) // x  # ceil division for negative x\n                    idx = bisect.bisect_left(non_neg, threshold)\n                    count += (len(non_neg) - idx)\n    \n    return count\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    n = int(input_data[0])\n    k = int(input_data[1])\n    arr = list(map(int, input_data[2:2+n]))\n    \n    # Binary search for the K-th smallest product\n    min_val = -10**18\n    max_val = 10**18\n    \n    while min_val < max_val:\n        mid = (min_val + max_val) // 2\n        count = count_pairs_less_equal(mid, arr, n)\n        \n        if count < k:\n            min_val = mid + 1\n        else:\n            max_val = mid\n    \n    print(min_val)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 31.974868059158325}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    INF = 10**9\n    ans = INF\n    \n    # For divisibility by 25, last two digits must be 00, 25, 50, or 75\n    targets = [('0', '0'), ('2', '5'), ('5', '0'), ('7', '5')]\n    \n    for d1, d2 in targets:\n        # Find positions of d1 and d2 from right to left\n        pos1 = -1\n        pos2 = -1\n        \n        # First find d2 (rightmost digit)\n        for i in range(n-1, -1, -1):\n            if s[i] == d2:\n                pos2 = i\n                break\n        if pos2 == -1:\n            continue\n        \n        # Then find d1 (second from right), to the left of pos2\n        for i in range(pos2-1, -1, -1):\n            if s[i] == d1:\n                pos1 = i\n                break\n        if pos1 == -1:\n            continue\n        \n        # Calculate moves to bring these digits to last two positions\n        # Moves for d2 to become last digit: (n-1 - pos2)\n        # Moves for d1 to become second last digit: (n-2 - pos1)\n        # But if pos1 > pos2, after moving d2, pos1 might shift right by 1\n        moves = (n-1 - pos2) + (n-2 - pos1)\n        if pos1 > pos2:\n            moves -= 1  # adjustment because d1 was originally to the right of d2\n        \n        # Check for leading zero after swaps\n        # We need to ensure first digit is not '0'\n        # Create a list to simulate\n        lst = list(s)\n        # Remove d1 and d2 from their positions\n        d1_char = lst.pop(pos1)\n        # Adjust pos2 if pos1 was before pos2\n        if pos1 < pos2:\n            pos2 -= 1\n        d2_char = lst.pop(pos2)\n        # Insert at end\n        lst.append(d1_char)\n        lst.append(d2_char)\n        \n        # Check if first digit is '0'\n        if lst[0] == '0':\n            # Try to find a non-zero digit to swap to front\n            # Count swaps needed to bring first non-zero to front\n            first_non_zero = -1\n            for i in range(len(lst)-2):  # exclude last two digits we fixed\n                if lst[i] != '0':\n                    first_non_zero = i\n                    break\n            if first_non_zero == -1:\n                continue  # all remaining digits are zero, leading zero unavoidable\n            moves += first_non_zero\n        \n        ans = min(ans, moves)\n    \n    print(-1 if ans == INF else ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.70646262168884}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef cross(o, a, b):\n    \"\"\"Cross product (a-o) x (b-o)\"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    \"\"\"Andrew's monotone chain algorithm\"\"\"\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef collinear(a, b, c):\n    \"\"\"Check if three points are collinear\"\"\"\n    return cross(a, b, c) == 0\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    points = []\n    for i in range(n):\n        x = int(data[2*i + 1])\n        y = int(data[2*i + 2])\n        points.append((x, y))\n    \n    # Since points are on convex polygon boundary, convex hull gives the order\n    hull = convex_hull(points)\n    m = len(hull)\n    \n    # DP for minimum lines covering convex polygon vertices\n    # dp[i][j] = min lines to cover vertices from i to j (inclusive) in circular order\n    INF = 10**9\n    dp = [[INF] * m for _ in range(m)]\n    \n    # Initialize for single points and adjacent pairs\n    for i in range(m):\n        dp[i][i] = 1\n        nxt = (i + 1) % m\n        # Check if i and nxt are collinear with any other point on hull\n        # Actually for adjacent vertices on convex hull, they're always on same edge\n        # So they can be covered by 1 line if the entire edge is straight\n        # But we need to check if all points between them are collinear\n        # Since hull vertices are in order, check if all points from i to nxt are collinear\n        # For now, set to 1 (they're on same polygon edge)\n        dp[i][nxt] = 1\n    \n    # Fill DP for longer chains\n    for length in range(2, m):\n        for i in range(m):\n            j = (i + length) % m\n            # Try all possible splits\n            for k in range(i, i + length):\n                k_mod = k % m\n                nxt_k = (k_mod + 1) % m\n                if nxt_k == j:\n                    continue\n                dp[i][j] = min(dp[i][j], dp[i][k_mod] + dp[nxt_k][j])\n            \n            # Check if all points from i to j can be covered by single line\n            # This happens if they're all collinear\n            all_collinear = True\n            for k in range(i, i + length + 1):\n                k1 = k % m\n                k2 = (k + 1) % m\n                k3 = (k + 2) % m\n                if k3 == i:\n                    break\n                if not collinear(hull[k1], hull[k2], hull[k3]):\n                    all_collinear = False\n                    break\n            if all_collinear:\n                dp[i][j] = 1\n    \n    # Answer is minimum over all starting points\n    ans = INF\n    for i in range(m):\n        j = (i + m - 1) % m  # previous vertex\n        ans = min(ans, dp[i][j])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 46.797752380371094}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); x = int(data[idx+1]); y = int(data[idx+2])\n        idx += 3\n        \n        # Nikolay's total score\n        total = x + y\n        \n        # Minimum possible place: 1 if total <= n+1, else total - n\n        min_place = 1 if total <= n + 1 else total - n\n        \n        # Maximum possible place: min(n, total - 1) if total - 1 >= 1 else n\n        max_place = min(n, total - 1) if total - 1 >= 1 else n\n        \n        # Ensure bounds\n        min_place = max(1, min_place)\n        max_place = min(n, max_place)\n        \n        results.append(f\"{min_place} {max_place}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.625617027282715}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    \"\"\"Find the largest bus number ≤ m.\"\"\"\n    if m < 1729:\n        return None\n    \n    # Dictionary to store count of ways for each sum\n    ways_count = {}\n    \n    # Upper bound for i: cube root of m\n    max_i = int(m ** (1/3)) + 1\n    \n    # Generate all sums of two positive cubes ≤ m\n    for i in range(1, max_i + 1):\n        i_cube = i * i * i\n        if i_cube > m:\n            break\n        \n        for j in range(i, max_i + 1):\n            j_cube = j * j * j\n            sum_cubes = i_cube + j_cube\n            \n            if sum_cubes > m:\n                break\n            \n            # Count this representation\n            ways_count[sum_cubes] = ways_count.get(sum_cubes, 0) + 1\n    \n    # Find the largest number with at least 2 representations\n    largest_bus = None\n    for num in sorted(ways_count.keys(), reverse=True):\n        if ways_count[num] >= 2:\n            largest_bus = num\n            break\n    \n    return largest_bus\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    \n    result = find_largest_bus_number(m)\n    \n    if result is None:\n        print(\"none\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 22.548009157180786}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\nMOD = 1000003\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        print(\"begin repairs\")\n        return\n    \n    # Parse first line\n    first_line = data[0].split()\n    Y = int(first_line[0])\n    X = int(first_line[1])\n    x_init = int(first_line[2])\n    \n    # Read grid\n    grid = data[1:1+Y]\n    \n    # Find castle position\n    castle_y = -1\n    castle_x = -1\n    for y in range(Y):\n        for x in range(X):\n            if grid[y][x] == '@':\n                castle_y = y\n                castle_x = x\n                break\n        if castle_y != -1:\n            break\n    \n    # DP table: dp[y][x] = number of ways to reach (y, x)\n    dp = [[0] * X for _ in range(Y)]\n    \n    # Start position\n    start_y = Y - 1\n    start_x = x_init\n    \n    # Check if start is valid\n    if grid[start_y][start_x] == '#':\n        print(\"begin repairs\")\n        return\n    \n    dp[start_y][start_x] = 1\n    \n    # Process from bottom to top (since we can only move north)\n    for y in range(Y-1, -1, -1):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            cell = grid[y][x]\n            \n            # If current cell is castle, we don't move from it\n            if cell == '@':\n                continue\n            \n            # Move north (lower sails)\n            if y > 0 and grid[y-1][x] != '#':\n                dp[y-1][x] = (dp[y-1][x] + dp[y][x]) % MOD\n            \n            # Move according to current\n            if cell == '>':\n                nx = x + 1\n                if nx < X and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n            elif cell == '<':\n                nx = x - 1\n                if nx >= 0 and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n            elif cell == '~':\n                # On open sea, can move east or west by retracting sails\n                # East\n                nx = x + 1\n                if nx < X and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n                # West\n                nx = x - 1\n                if nx >= 0 and grid[y][nx] != '#':\n                    dp[y][nx] = (dp[y][nx] + dp[y][x]) % MOD\n    \n    result = dp[castle_y][castle_x] % MOD\n    if result == 0:\n        print(\"begin repairs\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.089972496032715}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.069953203201294}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive_time, calm_time):\n    \"\"\"Return True if dog is aggressive at arrival minute.\"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival % cycle_length\n    # Aggressive during first aggressive_time minutes of cycle\n    return 0 < position_in_cycle <= aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    arrivals = [P, M, G]\n    results = []\n    \n    for arrival in arrivals:\n        dog1 = is_aggressive(arrival, A, B)\n        dog2 = is_aggressive(arrival, C, D)\n        \n        if dog1 and dog2:\n            results.append(\"both\")\n        elif dog1 or dog2:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 20.070653676986694}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if word matches its mirror reflection.\"\"\"\n    # Define mirror mapping for capital letters\n    mirror_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O',\n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',\n        'Y': 'Y',\n        # Letters that are not mirror-symmetric\n        'B': None, 'C': None, 'D': None, 'E': None, 'F': None,\n        'G': None, 'J': None, 'K': None, 'L': None, 'N': None,\n        'P': None, 'Q': None, 'R': None, 'S': None, 'Z': None\n    }\n    \n    n = len(word)\n    for i in range((n + 1) // 2):  # Check up to middle\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Check if left character has a mirror mapping\n        if left_char not in mirror_map:\n            return False\n        \n        # Check if right character is the mirror of left character\n        if mirror_map[left_char] != right_char:\n            return False\n    \n    return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    result = 'YES' if is_mirror_word(data) else 'NO'\n    sys.stdout.write(result)\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 28.90273141860962}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    vectors = []\n    idx = 1\n    for i in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        idx += 2\n        vectors.append((x, y, i+1))  # store with original index\n    \n    # compute angle for each vector using atan2, result in [-pi, pi]\n    angles = []\n    for x, y, idx in vectors:\n        angle = math.atan2(y, x)  # returns angle in radians\n        angles.append((angle, idx))\n    \n    # sort by angle\n    angles.sort(key=lambda t: t[0])\n    \n    # find minimal difference between consecutive angles in sorted order\n    # also check the wrap-around between first and last\n    min_diff = float('inf')\n    best_pair = (0, 0)\n    m = len(angles)\n    for i in range(m):\n        j = (i + 1) % m\n        diff = angles[j][0] - angles[i][0]\n        if diff < 0:\n            diff += 2 * math.pi  # wrap around\n        # non-oriented angle is min(diff, 2*pi - diff), but since diff is in [0, 2*pi),\n        # and we want angle in [0, pi], we take min(diff, 2*pi - diff)\n        angle = diff\n        if angle > math.pi:\n            angle = 2 * math.pi - angle\n        if angle < min_diff:\n            min_diff = angle\n            best_pair = (angles[i][1], angles[j][1])\n    \n    # output the pair in any order\n    print(f\"{best_pair[0]} {best_pair[1]}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 25.600014448165894}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef winner(record):\n    a_score = 0\n    b_score = 0\n    \n    i = 0\n    while i < len(record):\n        player = record[i]\n        points = int(record[i+1])\n        \n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        \n        # Check win conditions\n        if a_score >= 11 and a_score - b_score >= 2:\n            return 'A'\n        if b_score >= 11 and b_score - a_score >= 2:\n            return 'B'\n        \n        # Special case: 10-10 tie\n        if a_score >= 10 and b_score >= 10:\n            if a_score - b_score >= 2:\n                return 'A'\n            if b_score - a_score >= 2:\n                return 'B'\n        \n        i += 2\n    \n    # Should never reach here for valid input\n    return None\n\ndef main():\n    record = sys.stdin.readline().strip()\n    print(winner(record))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.629647731781006}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(400000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    \n    # Build tree\n    children = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(next(it))\n        children[parent].append(i)\n    \n    # DP arrays\n    # dp_up[node] = max marks in subtree rooted at node when node is NOT marked\n    # dp_down[node] = max marks in subtree rooted at node when node IS marked\n    dp_up = [0] * N\n    dp_down = [0] * N\n    \n    # We'll compute distances to nearest marked descendant\n    # dist[node] = distance to nearest marked node in subtree (or INF if none)\n    INF = 10**9\n    dist = [INF] * N\n    \n    def dfs(u):\n        # Process children first\n        for v in children[u]:\n            dfs(v)\n        \n        # Case 1: u is not marked\n        # We can take best from each child independently\n        sum_up = 0\n        for v in children[u]:\n            sum_up += max(dp_up[v], dp_down[v])\n        dp_up[u] = sum_up\n        \n        # Update dist for unmarked case\n        if children[u]:\n            dist_u = min(dist[v] + 1 for v in children[u])\n        else:\n            dist_u = INF\n        \n        # Case 2: u is marked\n        # We need to ensure no marked descendant within D-1 distance\n        # Check if we can mark u\n        can_mark = (dist_u >= D)\n        \n        if can_mark:\n            # If we mark u, we cannot mark any descendant within D-1 distance\n            # So for each child, if its nearest marked is at distance >= D-1,\n            # we can take its best; otherwise we must take dp_up[child]\n            best = 1  # mark u itself\n            for v in children[u]:\n                if dist[v] + 1 >= D:\n                    best += max(dp_up[v], dp_down[v])\n                else:\n                    best += dp_up[v]\n            dp_down[u] = best\n            dist[u] = 0  # u is marked\n        else:\n            dp_down[u] = -INF  # cannot mark u\n            dist[u] = dist_u\n    \n    dfs(0)\n    print(max(dp_up[0], dp_down[0]))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.853078842163086}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.818917512893677}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Map values to indices for easier counting\n    order = {4:0, 8:1, 15:2, 16:3, 23:4, 42:5}\n    \n    # Count how many complete sequences we can form\n    # We need to track how many of each position we have available\n    counts = [0, 0, 0, 0, 0, 0]\n    \n    for num in a:\n        idx = order[num]\n        if idx == 0:\n            # Start of a new sequence\n            counts[0] += 1\n        else:\n            # Can only add to this position if we have enough of the previous position\n            if counts[idx-1] > 0:\n                counts[idx-1] -= 1\n                counts[idx] += 1\n    \n    # The number of complete sequences is counts[5]\n    complete_sequences = counts[5]\n    \n    # Total elements in good array = complete_sequences * 6\n    good_elements = complete_sequences * 6\n    \n    # Elements to remove = total elements - good elements\n    result = n - good_elements\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.11289620399475}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123811 tokens (2122211 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 18.90106439590454}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.861002922058105}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    it = iter(input_data)\n    t = int(next(it))\n    out_lines = []\n    \n    for _ in range(t):\n        n = int(next(it))\n        k = int(next(it))\n        xs = [int(next(it)) for _ in range(n)]\n        ys = [int(next(it)) for _ in range(n)]\n        \n        # Sort points by x-coordinate\n        points = sorted(zip(xs, ys))\n        xs_sorted = [p[0] for p in points]\n        \n        # Precompute max points that can be covered by a single platform\n        # ending at or before each point\n        pref_max = [0] * n\n        j = 0\n        for i in range(n):\n            while xs_sorted[i] - xs_sorted[j] > k:\n                j += 1\n            pref_max[i] = i - j + 1\n        \n        # Compute prefix maximum of pref_max\n        prefix_best = [0] * n\n        prefix_best[0] = pref_max[0]\n        for i in range(1, n):\n            prefix_best[i] = max(prefix_best[i-1], pref_max[i])\n        \n        # Compute max points that can be covered by a single platform\n        # starting at or after each point\n        suff_max = [0] * n\n        j = n - 1\n        for i in range(n-1, -1, -1):\n            while xs_sorted[j] - xs_sorted[i] > k:\n                j -= 1\n            suff_max[i] = j - i + 1\n        \n        # Compute suffix maximum of suff_max\n        suffix_best = [0] * n\n        suffix_best[n-1] = suff_max[n-1]\n        for i in range(n-2, -1, -1):\n            suffix_best[i] = max(suffix_best[i+1], suff_max[i])\n        \n        # Try all splits between two platforms\n        ans = 0\n        for i in range(n-1):\n            ans = max(ans, prefix_best[i] + suffix_best[i+1])\n        ans = max(ans, prefix_best[n-1])  # Case where only one platform is used\n        ans = max(ans, suffix_best[0])    # Case where only one platform is used\n        \n        out_lines.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.62776446342468}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 54.60813903808594}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef factorize(m):\n    factors = {}\n    d = 2\n    while d * d <= m:\n        while m % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            m //= d\n        d += 1 if d == 2 else 2\n    if m > 1:\n        factors[m] = factors.get(m, 0) + 1\n    return factors\n\ndef nCr(n, r, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    N = int(input_data[0])\n    M = int(input_data[1])\n    \n    if M == 1:\n        print(1)\n        return\n    \n    factors = factorize(M)\n    \n    max_exp = max(factors.values()) if factors else 0\n    max_n = N + max_exp\n    \n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    result = 1\n    for exp in factors.values():\n        ways = nCr(N + exp - 1, exp, fact, inv_fact)\n        result = result * ways % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 29.28119993209839}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Since moving by 2 is free, chips can be moved to any coordinate with same parity\n    # without cost. Only moving between different parity costs 1 coin per chip.\n    # So we need to choose target parity (even or odd) that minimizes total coins.\n    # For each chip, cost to move to target parity is 0 if chip parity matches target,\n    # else 1.\n    \n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller count of chips that need to change parity\n    result = min(even_count, odd_count)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 18.582027912139893}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.51730251312256}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # water[i] stores current water in vessel i+1\n    water = [0] * n\n    \n    out_lines = []\n    for _ in range(m):\n        query_type = int(next(it))\n        if query_type == 1:\n            p = int(next(it)) - 1  # 0-indexed\n            x = int(next(it))\n            # Pour water into vessel p\n            while p < n and x > 0:\n                can_add = min(x, capacities[p] - water[p])\n                water[p] += can_add\n                x -= can_add\n                p += 1  # overflow to next vessel\n        else:  # type 2\n            k = int(next(it)) - 1  # 0-indexed\n            out_lines.append(str(water[k]))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.87786364555359}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = int(data[1])\n    e = list(map(int, data[2:2+n]))\n    \n    # Sort Finni's fleet sizes in ascending order\n    e.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy_ships in e:\n        # Minimum ships needed to win this battle\n        needed = enemy_ships + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            # Cannot win more battles with remaining ships\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 15.94238805770874}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split('\\n')\n    if len(data) < 2:\n        print(\"corrupted\")\n        return\n    \n    I = data[0].strip()\n    O = data[1].strip()\n    \n    # Find all positions of + and - in I\n    plus_positions = [i for i, ch in enumerate(I) if ch == '+']\n    minus_positions = [i for i, ch in enumerate(I) if ch == '-']\n    \n    # If no + or - in I, check if I == O\n    if not plus_positions and not minus_positions:\n        if I == O:\n            print(\"<any> <any>\")\n        else:\n            print(\"corrupted\")\n        return\n    \n    # Generate all possible encodings\n    results = []\n    \n    # Try all possible substrings for + encoding\n    plus_options = set()\n    minus_options = set()\n    \n    # For each + position, find what substring in O corresponds to it\n    for p_pos in plus_positions:\n        # Find the segment in O that corresponds to this +\n        # We need to match the rest of the string around the +\n        \n        # Split I into parts around +\n        left_part = I[:p_pos]\n        right_part = I[p_pos+1:]\n        \n        # Find where left_part matches in O\n        left_match = O.find(left_part)\n        if left_match == -1:\n            continue\n        \n        # The + encoding starts after left_part\n        plus_start = left_match + len(left_part)\n        \n        # Find where right_part matches after the + encoding\n        # We need to try all possible positions\n        for i in range(plus_start, len(O) + 1):\n            potential_plus_encoding = O[plus_start:i]\n            \n            # Check if right_part matches after this encoding\n            if O[i:].startswith(right_part):\n                plus_options.add(potential_plus_encoding)\n    \n    # For each - position, find what substring in O corresponds to it\n    for m_pos in minus_positions:\n        # Find the segment in O that corresponds to this -\n        left_part = I[:m_pos]\n        right_part = I[m_pos+1:]\n        \n        # Find where left_part matches in O\n        left_match = O.find(left_part)\n        if left_match == -1:\n            continue\n        \n        # The - encoding starts after left_part\n        minus_start = left_match + len(left_part)\n        \n        # Find where right_part matches after the - encoding\n        for i in range(minus_start, len(O) + 1):\n            potential_minus_encoding = O[minus_start:i]\n            \n            # Check if right_part matches after this encoding\n            if O[i:].startswith(right_part):\n                minus_options.add(potential_minus_encoding)\n    \n    # If we found no options for either symbol, check special cases\n    if not plus_options and not minus_options:\n        # Check if all + and - were removed (encoded as empty)\n        # Remove all + and - from I and see if it matches O\n        I_no_symbols = I.replace('+', '').replace('-', '')\n        if I_no_symbols == O:\n            print(\"<empty> <empty>\")\n            return\n        else:\n            print(\"corrupted\")\n            return\n    \n    # Handle special cases for empty and any\n    plus_final = []\n    minus_final = []\n    \n    if not plus_options:\n        # Check if + can be anything\n        # This happens when there are no + in I\n        if not plus_positions:\n            plus_final.append(\"<any>\")\n        else:\n            # Try empty encoding\n            # Check if removing all + from I gives O\n            test_I = I\n            for p_pos in reversed(plus_positions):\n                test_I = test_I[:p_pos] + test_I[p_pos+1:]\n            if test_I == O:\n                plus_final.append(\"<empty>\")\n    else:\n        plus_final = list(plus_options)\n    \n    if not minus_options:\n        if not minus_positions:\n            minus_final.append(\"<any>\")\n        else:\n            test_I = I\n            for m_pos in reversed(minus_positions):\n                test_I = test_I[:m_pos] + test_I[m_pos+1:]\n            if test_I == O:\n                minus_final.append(\"<empty>\")\n    else:\n        minus_final = list(minus_options)\n    \n    # Generate all combinations\n    if not plus_final or not minus_final:\n        print(\"corrupted\")\n        return\n    \n    # Output all combinations\n    for p_enc in plus_final:\n        for m_enc in minus_final:\n            p_out = p_enc if p_enc != \"\" else \"<empty>\"\n            m_out = m_enc if m_enc != \"\" else \"<empty>\"\n            print(f\"{p_out} {m_out}\")\n\ndef main():\n    solve()\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 50.701432943344116}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b.\n    # Since a and b are integers, k * b must be integer and within [l, r].\n    # b ranges from x to y inclusive.\n    for b in range(x, y + 1):\n        a = k * b\n        if l <= a <= r:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.456115007400513}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+n]]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # First pass: place 'E' on land cells that have no adjacent 'E' and ensure coverage\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if this cell already has an adjacent 'E'\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        has_adjacent_E = True\n                        break\n                \n                # If no adjacent 'E', place one here if possible\n                if not has_adjacent_E:\n                    # Check that placing 'E' here doesn't violate adjacency with other 'E's\n                    can_place = True\n                    for di, dj in dirs:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                            can_place = False\n                            break\n                    \n                    if can_place:\n                        grid[i][j] = 'E'\n    \n    # Second pass: ensure all land cells are covered\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if this cell has an adjacent 'E'\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        has_adjacent_E = True\n                        break\n                \n                # If not covered, place 'E' in one of its adjacent land cells\n                if not has_adjacent_E:\n                    placed = False\n                    for di, dj in dirs:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':\n                            # Check that placing 'E' at (ni, nj) doesn't create adjacency issues\n                            valid = True\n                            for ddi, ddj in dirs:\n                                nni, nnj = ni + ddi, nj + ddj\n                                if 0 <= nni < n and 0 <= nnj < m and grid[nni][nnj] == 'E':\n                                    valid = False\n                                    break\n                            if valid:\n                                grid[ni][nj] = 'E'\n                                placed = True\n                                break\n                    \n                    # If couldn't place in adjacent, place on current cell (must be valid)\n                    if not placed:\n                        grid[i][j] = 'E'\n    \n    # Output the result\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 34.87152338027954}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s: str) -> int:\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev, cur = suffix[i-1], suffix[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            cur_key = (rank[cur], rank[cur + k] if cur + k < n else -1)\n            tmp[cur] = tmp[prev] + (prev_key != cur_key)\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # LCP array construction using Kasai's algorithm\n    lcp = [0] * n\n    inv_suffix = [0] * n\n    for i in range(n):\n        inv_suffix[suffix[i]] = i\n    \n    k = 0\n    for i in range(n):\n        if inv_suffix[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv_suffix[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_suffix[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # Longest repeated substring length is max LCP value\n    return max(lcp) if lcp else 0\n\ndef main() -> None:\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    L = int(data[0].strip())\n    s = data[1].strip()\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 26.798158884048462}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples(n):\n    count = 0\n    # Iterate over possible values of a and b\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):  # b >= a\n            # Calculate c^2\n            c_squared = a * a + b * b\n            # Check if c is an integer and within bounds\n            c = int(c_squared ** 0.5)\n            if c * c == c_squared and b <= c <= n:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    result = count_pythagorean_triples(n)\n    print(result)", "runtime_sec": 19.352967500686646}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    \n    # Days from best-by date when eaten\n    days_from_best_by = B - A\n    \n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Within X days after best-by date\n        print(\"safe\")\n    else:\n        # More than X days after best-by date\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 13.167876482009888}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Calculate distance from origin to line\n    # Line through (x1,y1) and (x2,y2)\n    # Distance from (0,0) to line: |Ax0 + By0 + C| / sqrt(A^2 + B^2)\n    # where line: (y2-y1)x - (x2-x1)y + (x2*y1 - x1*y2) = 0\n    A = y2 - y1\n    B = -(x2 - x1)\n    C = x2 * y1 - x1 * y2\n    \n    # Distance from origin to line\n    d = abs(C) / math.sqrt(A*A + B*B)\n    \n    # The dog can cover area on one side of the wall\n    # The accessible area is a circular segment of radius r\n    # Area = r^2 * (θ - sinθ)/2, where θ = 2*arccos(d/r)\n    # We need area >= L\n    \n    # Binary search for minimal integer r\n    low = 0\n    high = 20000  # Upper bound: sqrt(L/pi)*2 + d, but safe bound\n    \n    def area_with_radius(r):\n        if r <= d:\n            # Dog cannot reach beyond wall\n            return 0.0\n        # Angle of circular segment\n        theta = 2 * math.acos(d / r)\n        # Area of circular segment\n        return r * r * (theta - math.sin(theta)) / 2\n    \n    while high - low > 1e-9:\n        mid = (low + high) / 2\n        if area_with_radius(mid) >= L:\n            high = mid\n        else:\n            low = mid\n    \n    # Round up to nearest integer\n    result = math.ceil(high - 1e-9)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.350836992263794}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:]]\n    \n    # Find all white pixel positions\n    whites = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                whites.append((i, j))\n    \n    if not whites:\n        print(-1)\n        return\n    \n    # Find bounding box of whites\n    min_r = min(w[0] for w in whites)\n    max_r = max(w[0] for w in whites)\n    min_c = min(w[1] for w in whites)\n    max_c = max(w[1] for w in whites)\n    \n    # Determine possible square frame size\n    width = max(max_r - min_r, max_c - min_c) + 1\n    \n    # Check if all whites can fit on a frame of this size\n    # The frame must be a square of size width, and all whites must be on its border\n    best_frame = None\n    best_size = float('inf')\n    \n    # Try all possible top-left corners for the frame\n    for r in range(n - width + 1):\n        for c in range(m - width + 1):\n            # Check if all whites are on the border of this square\n            valid = True\n            for wr, wc in whites:\n                if not (wr == r or wr == r + width - 1 or wc == c or wc == c + width - 1):\n                    valid = False\n                    break\n                # Also ensure the white pixel is within the square\n                if not (r <= wr <= r + width - 1 and c <= wc <= c + width - 1):\n                    valid = False\n                    break\n            if valid:\n                # Check that no white is missing from the border (all border positions that are white in grid must be 'w')\n                # Actually, the condition only requires all existing whites to be on the frame,\n                # not that all frame positions must be white. So this is fine.\n                if width < best_size:\n                    best_size = width\n                    best_frame = (r, c, width)\n    \n    if best_frame is None:\n        print(-1)\n        return\n    \n    # Apply the frame to the output\n    r, c, width = best_frame\n    result = [list(row) for row in grid]\n    for i in range(r, r + width):\n        for j in range(c, c + width):\n            if i == r or i == r + width - 1 or j == c or j == c + width - 1:\n                if result[i][j] == '.':\n                    result[i][j] = '+'\n    \n    # Output\n    for row in result:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 43.19078063964844}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    result = A * B\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 8.683472156524658}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count triples (a,b,c) with 1 <= a <= b <= n-1, 1 <= c <= n-1 such that a^2 + b^2 ≡ c^2 (mod n).\"\"\"\n    # Precompute squares modulo n\n    squares = [0] * n\n    for i in range(n):\n        squares[i] = (i * i) % n\n    \n    # Count frequencies of each square value\n    freq = [0] * n\n    for i in range(1, n):\n        freq[squares[i]] += 1\n    \n    # For each pair (a,b) with a <= b, count how many c satisfy the congruence\n    count = 0\n    for a in range(1, n):\n        sa = squares[a]\n        for b in range(a, n):\n            target = (sa + squares[b]) % n\n            count += freq[target]\n    \n    return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 20.401036500930786}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    S = data[0]\n    Q = int(data[1])\n    \n    # Use two deques to represent the string efficiently\n    from collections import deque\n    front = deque()\n    back = deque(S)\n    \n    reversed_flag = False  # False means normal order, True means reversed\n    \n    idx = 2\n    for _ in range(Q):\n        T = data[idx]\n        idx += 1\n        \n        if T == '1':\n            # Reverse operation\n            reversed_flag = not reversed_flag\n        else:  # T == '2'\n            F = data[idx]\n            C = data[idx+1]\n            idx += 2\n            \n            if F == '1':\n                # Add to beginning\n                if not reversed_flag:\n                    front.appendleft(C)\n                else:\n                    back.append(C)\n            else:  # F == '2'\n                # Add to end\n                if not reversed_flag:\n                    back.append(C)\n                else:\n                    front.appendleft(C)\n    \n    # Construct final string\n    front_str = ''.join(front)\n    back_str = ''.join(back)\n    \n    if not reversed_flag:\n        result = front_str + back_str\n    else:\n        result = front_str + back_str[::-1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.013166904449463}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef polygon_area(points):\n    \"\"\"Calculate area of polygon using shoelace formula.\"\"\"\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    return abs(area) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    \n    original_points = []\n    for _ in range(N):\n        x = float(data[idx]); idx += 1\n        y = float(data[idx]); idx += 1\n        original_points.append((x, y))\n    \n    A = float(data[idx]); idx += 1\n    \n    # Calculate original area\n    original_area = polygon_area(original_points)\n    \n    # Calculate scaling factor\n    # new_area = original_area * scale^2\n    # scale = sqrt(new_area / original_area)\n    scale = math.sqrt(A / original_area)\n    \n    # Scale the polygon\n    scaled_points = []\n    for x, y in original_points:\n        scaled_points.append((x * scale, y * scale))\n    \n    # Find min x and min y of scaled polygon\n    min_x = min(x for x, y in scaled_points)\n    min_y = min(y for x, y in scaled_points)\n    \n    # Translate so min_x = 0 and min_y = 0\n    final_points = []\n    for x, y in scaled_points:\n        final_points.append((x - min_x, y - min_y))\n    \n    # Output results\n    for x, y in final_points:\n        print(f\"{x:.10f} {y:.10f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 24.47783374786377}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    cards = list(map(int, data[1:1+N]))\n    \n    # Represent state as differences: 1 for face-up, 0 for face-down\n    # We only care about positions where state changes\n    diff = [0] * (N + 1)  # extra element for boundary\n    diff[0] = cards[0] % 2  # first card state\n    for i in range(1, N):\n        diff[i] = (cards[i] - cards[i-1]) % 2\n    diff[N] = (10**7 + 1 - cards[-1]) % 2  # after last card\n    \n    # Count segments of consecutive 1's in diff\n    ans = 0\n    cnt = 0\n    for d in diff:\n        if d == 1:\n            cnt += 1\n        else:\n            if cnt > 0:\n                ans += 1\n                cnt = 0\n    \n    # Each segment requires at least one operation\n    # But we can combine operations if segment length allows\n    # Actually, each segment of consecutive face-up cards requires at least one operation\n    # And we can flip any prime-length segment (>=3) that covers part of it\n    # The minimal operations equals number of segments\n    # Because each operation flips a prime-length segment, which can cover multiple segments\n    # But we need to consider parity: flipping a segment toggles both ends\n    # The diff array tracks parity changes, and each '1' in diff is an endpoint of a face-up segment\n    # Each operation toggles two endpoints (if length is odd, which primes >=3 are)\n    # So we need to pair up these endpoints\n    # The minimal operations is ceil(number_of_1s / 2)\n    ones = sum(diff)\n    ans = (ones + 1) // 2\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.00850772857666}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        need = a - b\n        # Sleep gained per cycle (c - d minutes)\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        \n        # Total time = first alarm + cycles * c\n        total = b + cycles * c\n        results.append(str(total))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 20.576194047927856}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Initialize sieve\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    crossed_out = []\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # Cross out p itself (it's prime but gets crossed out in step 3)\n            if not is_prime[p]:  # Already crossed out? shouldn't happen\n                continue\n            is_prime[p] = False\n            crossed_out.append(p)\n            \n            # Cross out multiples of p\n            for multiple in range(p * 2, N + 1, p):\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out.append(multiple)\n    \n    # Output K-th crossed out number (1-indexed)\n    print(crossed_out[K - 1])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 19.56255602836609}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, enemy kills one gnome per turn regardless of grouping\n    if k == 1:\n        # Sum of arithmetic series from n down to 1\n        total = n * (n + 1) // 2\n        print(total)\n        return\n    \n    # If m is large enough to make each group size <= k\n    # Enemy can kill entire groups each turn\n    if m * k >= n:\n        # We can make groups of size at most k\n        # Enemy kills one group per turn\n        # Damage is sum of remaining gnomes each turn\n        groups = (n + k - 1) // k  # ceil(n/k)\n        if groups > m:\n            groups = m\n        \n        # Distribute gnomes to minimize turns\n        # Make as many groups of size k as possible\n        full_groups = n // k\n        if full_groups > m:\n            full_groups = m\n        remaining = n - full_groups * k\n        \n        # Calculate damage\n        total = 0\n        current = n\n        \n        # First phase: kill full groups\n        for _ in range(full_groups):\n            total += current\n            current -= k\n        \n        # Second phase: kill remaining gnomes in small groups\n        if remaining > 0:\n            # Create one more group with remaining gnomes\n            # Enemy kills them in ceil(remaining/k) turns\n            turns = (remaining + k - 1) // k\n            for i in range(turns):\n                total += current\n                kill = min(k, current)\n                current -= kill\n        \n        print(total)\n        return\n    \n    # General case: m * k < n\n    # We need to create groups larger than k\n    # Enemy will chip away at large groups\n    \n    # Optimal strategy: create m-1 groups of size 1\n    # and one large group with remaining gnomes\n    # This forces enemy to attack the large group repeatedly\n    \n    large_group_size = n - (m - 1)\n    if large_group_size <= 0:\n        # Should not happen since m <= n typically\n        large_group_size = n\n    \n    total = 0\n    current = n\n    \n    # First phase: reduce large group\n    turns_large = (large_group_size + k - 1) // k\n    for _ in range(turns_large):\n        total += current\n        # Enemy kills k from large group\n        current -= k\n    \n    # After large group is gone, we have m-1 groups of size 1\n    # Enemy kills one per turn\n    remaining_small = m - 1\n    for _ in range(remaining_small):\n        total += current\n        current -= 1\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 39.86753535270691}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.45989966392517}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, score, i))\n        idx += 2\n    \n    # Sort: first by city lexicographically, then by score descending\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 13.062783479690552}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs(grid, start, state_id, n, m):\n    \"\"\"BFS to find distances from state cells to all '.' cells\"\"\"\n    dist = [[-1] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state_id:\n                dist[i][j] = 0\n                q.append((i, j))\n    \n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    while q:\n        x, y = q.popleft()\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                if dist[nx][ny] == -1:\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Find distances from each state to all '.' cells\n    dist1 = bfs(grid, '1', '1', n, m)\n    dist2 = bfs(grid, '2', '2', n, m)\n    dist3 = bfs(grid, '3', '3', n, m)\n    \n    # Find minimum sum of distances for connecting via a common '.' cell\n    INF = 10**9\n    ans = INF\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if dist1[i][j] != -1 and dist2[i][j] != -1 and dist3[i][j] != -1:\n                    total = dist1[i][j] + dist2[i][j] + dist3[i][j] - 2  # Subtract 2 because the common cell is counted in each distance\n                    ans = min(ans, total)\n    \n    # Also consider direct connections between states without intermediate '.'\n    # Check if states are already connected\n    # We need to check all pairs: 1-2, 1-3, 2-3\n    # For each pair, find minimum distance via '.' cells\n    pair12 = INF\n    pair13 = INF\n    pair23 = INF\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if dist1[i][j] != -1 and dist2[i][j] != -1:\n                    pair12 = min(pair12, dist1[i][j] + dist2[i][j] - 1)\n                if dist1[i][j] != -1 and dist3[i][j] != -1:\n                    pair13 = min(pair13, dist1[i][j] + dist3[i][j] - 1)\n                if dist2[i][j] != -1 and dist3[i][j] != -1:\n                    pair23 = min(pair23, dist2[i][j] + dist3[i][j] - 1)\n    \n    # Also check direct adjacency between states\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] in '123':\n                for dx, dy in dirs:\n                    ni, nj = i + dx, j + dy\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] in '123' and grid[ni][nj] != grid[i][j]:\n                        # Direct connection between different states\n                        if grid[i][j] == '1' and grid[ni][nj] == '2':\n                            pair12 = 0\n                        elif grid[i][j] == '1' and grid[ni][nj] == '3':\n                            pair13 = 0\n                        elif grid[i][j] == '2' and grid[ni][nj] == '3':\n                            pair23 = 0\n                        elif grid[i][j] == '2' and grid[ni][nj] == '1':\n                            pair12 = 0\n                        elif grid[i][j] == '3' and grid[ni][nj] == '1':\n                            pair13 = 0\n                        elif grid[i][j] == '3' and grid[ni][nj] == '2':\n                            pair23 = 0\n    \n    # Calculate minimum connection via two paths\n    via_two_paths = min(pair12 + pair13, pair12 + pair23, pair13 + pair23)\n    \n    # Final answer is minimum of three methods\n    ans = min(ans, via_two_paths)\n    \n    # Check if any state is completely isolated (no reachable '.' cells and not adjacent to other states)\n    # This is already handled by the INF values\n    \n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 55.93247056007385}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.16482496261597}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    increase = []\n    decrease = []\n    for a, b in projects:\n        if b >= 0:\n            increase.append((a, b))\n        else:\n            decrease.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    increase.sort(key=lambda x: x[0])\n    \n    # Process increasing projects first\n    for a, b in increase:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # This is equivalent to sorting by (a + b) descending\n    decrease.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process decreasing projects\n    for a, b in decrease:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.860924005508423}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.638200521469116}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track number of distinct difficulties currently in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty from pool\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 20.570032835006714}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    ans = 0\n    for a in range(1, N + 1):\n        max_b = N // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.708787441253662}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    roads = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx]); b = int(data[idx+1])\n        roads.append((a, b))\n        idx += 2\n    \n    # Count how many times each city appears as endpoint\n    degree = [0] * (n + 1)\n    for a, b in roads:\n        degree[a] += 1\n        degree[b] += 1\n    \n    # For each road, assign it to the city with smaller degree\n    # If equal, assign to the first city\n    result = []\n    for a, b in roads:\n        if degree[a] < degree[b]:\n            result.append(f\"{a} {b}\")\n        elif degree[a] > degree[b]:\n            result.append(f\"{b} {a}\")\n        else:\n            # If degrees are equal, assign to the smaller city number\n            if a < b:\n                result.append(f\"{a} {b}\")\n            else:\n                result.append(f\"{b} {a}\")\n    \n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.449721813201904}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Ensure we move from smaller to larger index for simplicity\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    # Check if positions are congruent modulo k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Check all intermediate cells at steps of k\n    pos = g_pos\n    while pos < t_pos:\n        pos += k\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.258089780807495}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    r, c = map(int, data[0].split())\n    grid = [list(row.strip()) for row in data[1:1+r]]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Mark all water cells as visited initially\n    visited = [[False]*c for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'W':\n                visited[i][j] = True\n    \n    def dfs(i, j):\n        stack = [(i, j)]\n        visited[i][j] = True\n        while stack:\n            x, y = stack.pop()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny]:\n                    # Only traverse through land or cloud cells\n                    if grid[nx][ny] != 'W':\n                        visited[nx][ny] = True\n                        stack.append((nx, ny))\n    \n    islands = 0\n    for i in range(r):\n        for j in range(c):\n            if not visited[i][j]:\n                # Start a new island from this unvisited cell\n                islands += 1\n                dfs(i, j)\n    \n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.03132653236389}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_points():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return []\n    n = int(data[0])\n    points = []\n    idx = 1\n    for _ in range(n):\n        x = int(data[idx])\n        y = int(data[idx + 1])\n        points.append((x, y))\n        idx += 2\n    return points\n\ndef polygon_area(points):\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    return abs(area) / 2.0\n\ndef expected_distance(points):\n    n = len(points)\n    area = polygon_area(points)\n    if area == 0:\n        return 0.0\n    \n    # Precompute sums for x and y coordinates\n    sum_x = 0.0\n    sum_y = 0.0\n    sum_x2 = 0.0\n    sum_y2 = 0.0\n    sum_xy = 0.0\n    \n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        cross = x1 * y2 - x2 * y1\n        sum_x += (x1 + x2) * cross\n        sum_y += (y1 + y2) * cross\n        sum_x2 += (x1 * x1 + x1 * x2 + x2 * x2) * cross\n        sum_y2 += (y1 * y1 + y1 * y2 + y2 * y2) * cross\n        sum_xy += (2 * x1 * y1 + x1 * y2 + x2 * y1 + 2 * x2 * y2) * cross\n    \n    # Compute integrals\n    I_x = sum_x / 6.0\n    I_y = sum_y / 6.0\n    I_x2 = sum_x2 / 12.0\n    I_y2 = sum_y2 / 12.0\n    I_xy = sum_xy / 24.0\n    \n    # Expected distance formula for Manhattan metric\n    # E[|x1-x2| + |y1-y2|] = 2*(E[|x1-x2|] + E[|y1-y2|]) / 2\n    # But we can compute directly using:\n    # E[|x1-x2|] = (2/area^2) * (area * I_x2 - I_x^2)\n    # Similarly for y, and note that cross terms cancel for Manhattan\n    \n    # For Manhattan distance, the expectation separates:\n    # E[|x1-x2|] = (2/area^2) * (area * I_x2 - I_x * I_x)\n    # E[|y1-y2|] = (2/area^2) * (area * I_y2 - I_y * I_y)\n    # Then E[total] = E[|x1-x2|] + E[|y1-y2|]\n    \n    factor = 2.0 / (area * area)\n    expected_x = factor * (area * I_x2 - I_x * I_x)\n    expected_y = factor * (area * I_y2 - I_y * I_y)\n    expected_total = expected_x + expected_y\n    \n    return expected_total\n\ndef main():\n    points = read_points()\n    if not points:\n        return\n    result = expected_distance(points)\n    # Print with sufficient precision\n    print(f\"{result:.15f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 40.64406609535217}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_ways(n):\n    \"\"\"Count number of valid quadruples (a, k) where a > 0, k > 1,\n    and a*k^3 <= n.\"\"\"\n    ways = 0\n    # For each possible first thief amount a\n    max_a = int(n ** (1/4))  # Rough upper bound since a*k^3 <= n and k >= 2\n    for a in range(1, max_a + 1):\n        # For each possible multiplier k\n        max_k = int((n // a) ** (1/3))\n        for k in range(2, max_k + 1):\n            if a * k * k * k <= n:\n                ways += 1\n    return ways\n\ndef solve():\n    m = int(sys.stdin.readline().strip())\n    \n    # Binary search for smallest n with exactly m ways\n    low, high = 1, 10**18  # Upper bound large enough\n    answer = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        ways = count_ways(mid)\n        \n        if ways == m:\n            answer = mid\n            high = mid - 1  # Try smaller n\n        elif ways < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.550845623016357}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite string pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We need to check all possible starting positions for the substring of length k\n        # For each starting position, we need to check alignment with the infinite pattern\n        # starting with 'R', 'G', or 'B' at that position\n        min_changes = float('inf')\n        \n        # For each possible start of the k-length window\n        for start in range(n - k + 1):\n            # For each possible starting character in the pattern\n            for offset in range(3):\n                changes = 0\n                # Check each character in the window\n                for i in range(k):\n                    expected_char = pattern[(offset + i) % 3]\n                    if s[start + i] != expected_char:\n                        changes += 1\n                min_changes = min(min_changes, changes)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.581878662109375}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    words = data[1:1+n]\n    start, end = words[0], words[1]\n    dictionary = set(words)\n    \n    # If start and end are same, no steps needed\n    if start == end:\n        print(\"0\\n0\")\n        return\n    \n    word_len = len(start)\n    \n    # BFS without any added word\n    def bfs(available_words):\n        if start not in available_words or end not in available_words:\n            return float('inf')\n        q = deque([(start, 0)])\n        visited = {start}\n        while q:\n            word, dist = q.popleft()\n            if word == end:\n                return dist\n            # Generate neighbors\n            for i in range(word_len):\n                for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in available_words and new_word not in visited:\n                        visited.add(new_word)\n                        q.append((new_word, dist + 1))\n        return float('inf')\n    \n    original_dist = bfs(dictionary)\n    \n    # If already reachable, check if we can improve\n    best_word = \"0\"\n    best_dist = original_dist\n    \n    # Consider all possible words of same length\n    # Generate candidate words that differ by one letter from any word in dictionary\n    # or from start/end, and are not already in dictionary\n    candidates = set()\n    for word in dictionary:\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if c == word[i]:\n                    continue\n                cand = word[:i] + c + word[i+1:]\n                if cand not in dictionary:\n                    candidates.add(cand)\n    \n    # Also consider words that differ by one from start or end if not in dictionary\n    for word in [start, end]:\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMOPQRSTUVWXYZ':\n                if c == word[i]:\n                    continue\n                cand = word[:i] + c + word[i+1:]\n                if cand not in dictionary:\n                    candidates.add(cand)\n    \n    # Evaluate each candidate\n    for cand in sorted(candidates):  # sorted for alphabetical tie-breaking\n        new_dict = dictionary | {cand}\n        dist = bfs(new_dict)\n        if dist < best_dist:\n            best_dist = dist\n            best_word = cand\n            # If we found distance 1 (direct connection), we can stop early\n            if best_dist == 1:\n                break\n    \n    # Output\n    if best_word == \"0\":\n        if original_dist == float('inf'):\n            print(\"0\\n-1\")\n        else:\n            print(f\"0\\n{original_dist}\")\n    else:\n        print(f\"{best_word}\\n{best_dist}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 38.351993560791016}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    # Track whether we've seen the first sock of each pair\n    seen = [False] * (n + 1)\n    current_on_table = 0\n    max_on_table = 0\n    \n    for sock in socks:\n        if not seen[sock]:\n            # First sock of this pair\n            seen[sock] = True\n            current_on_table += 1\n        else:\n            # Second sock of this pair\n            current_on_table -= 1\n        \n        # Update maximum\n        if current_on_table > max_on_table:\n            max_on_table = current_on_table\n    \n    print(max_on_table)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.22337770462036}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2, solve for R2\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 10.570008039474487}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef days_in_month(month):\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    return days[month - 1]\n\ndef date_to_days(d, m):\n    total = 0\n    for month in range(1, m):\n        total += days_in_month(month)\n    total += d\n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    equations = []\n    for _ in range(N):\n        d1 = int(data[idx]); idx += 1\n        m1 = int(data[idx]); idx += 1\n        d2 = int(data[idx]); idx += 1\n        m2 = int(data[idx]); idx += 1\n        \n        start = date_to_days(d1, m1)\n        end = date_to_days(d2, m2)\n        if end < start:\n            end += 365\n        duration = end - start + 1\n        \n        coeffs = []\n        for i in range(M):\n            coeffs.append(int(data[idx])); idx += 1\n        equations.append((duration, coeffs))\n    \n    # Try all possible durations from 1 to 365\n    solutions = []\n    for guess in range(1, 366):\n        valid = True\n        for dur, coeffs in equations:\n            total = 0\n            for i in range(M):\n                total += coeffs[i] * guess\n            if total != dur:\n                valid = False\n                break\n        if valid:\n            solutions.append([guess] * M)\n            break\n    \n    if not solutions:\n        print(-1)\n    else:\n        print(' '.join(map(str, solutions[0])))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 24.194321393966675}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.83550572395325}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    max_count = 0\n    # For each possible value, consider it as X and count how many elements\n    # can be made equal to X with at most +/-1 adjustments\n    for val in set(arr):\n        # Count elements that are val, val-1, or val+1\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.613115310668945}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.98994517326355}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 13.67247223854065}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        lcm_val = lcm_val // math.gcd(lcm_val, t) * t\n        # Early exit if LCM exceeds 10^18 (though constraints say answer ≤ 10^18)\n        if lcm_val > 10**18:\n            # In practice, this shouldn't happen given constraints\n            break\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 16.402423858642578}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.25950241088867}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    denominations = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [int(next(it)) for _ in range(q)]\n    \n    # Precompute all possible sums using at most k bills of at most two denominations\n    possible = set()\n    # Single denomination\n    for d in denominations:\n        for count in range(1, k + 1):\n            possible.add(d * count)\n    # Two denominations\n    for i in range(n):\n        d1 = denominations[i]\n        for j in range(i + 1, n):\n            d2 = denominations[j]\n            for c1 in range(1, k):  # at least 1 of each\n                for c2 in range(1, k - c1 + 1):\n                    possible.add(d1 * c1 + d2 * c2)\n    \n    # For each query, find minimum bills\n    result = []\n    for x in queries:\n        min_bills = float('inf')\n        # Check all combinations of at most k bills\n        # Single denomination\n        for d in denominations:\n            if x % d == 0:\n                count = x // d\n                if 1 <= count <= k:\n                    min_bills = min(min_bills, count)\n        # Two denominations\n        for i in range(n):\n            d1 = denominations[i]\n            for c1 in range(1, k):\n                rem = x - d1 * c1\n                if rem <= 0:\n                    continue\n                for j in range(n):\n                    if i == j:\n                        continue\n                    d2 = denominations[j]\n                    if rem % d2 == 0:\n                        c2 = rem // d2\n                        if 1 <= c2 <= k - c1:\n                            min_bills = min(min_bills, c1 + c2)\n        \n        if min_bills == float('inf'):\n            result.append(\"-1\")\n        else:\n            result.append(str(min_bills))\n    \n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.92515468597412}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count residues modulo k\n    cnt = [0] * k\n    for val in d:\n        cnt[val % k] += 1\n    \n    ans = 0\n    # Pair residues that sum to 0 or k\n    # Handle residue 0 separately\n    ans += (cnt[0] // 2) * 2\n    \n    if k % 2 == 0:\n        # For even k, residue k/2 pairs with itself\n        ans += (cnt[k // 2] // 2) * 2\n        \n    # Pair complementary residues\n    for r in range(1, (k + 1) // 2):\n        if r != k - r:\n            ans += min(cnt[r], cnt[k - r]) * 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.823092460632324}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    k, d, t = map(int, data)\n    \n    # If k is multiple of d, stove is always on after first turn-on\n    if k % d == 0:\n        print(float(t))\n        return\n    \n    # One full cycle: stove on for k minutes, then off until next Julia visit\n    # The off period is (d - k % d) minutes\n    cycle_on = k\n    cycle_off = d - (k % d)\n    cycle_len = cycle_on + cycle_off\n    \n    # Cooking progress per cycle\n    # When on: 1/t per minute, when off: 1/(2t) per minute\n    progress_per_cycle = cycle_on / t + cycle_off / (2 * t)\n    \n    # Number of full cycles needed\n    full_cycles = math.floor(1.0 / progress_per_cycle)\n    remaining_progress = 1.0 - full_cycles * progress_per_cycle\n    \n    # Time for full cycles\n    total_time = full_cycles * cycle_len\n    \n    # Remaining cooking time\n    if remaining_progress <= cycle_on / t:\n        # Can finish while stove is on\n        total_time += remaining_progress * t\n    else:\n        # Need some on time and some off time\n        total_time += cycle_on  # Use all on time in this partial cycle\n        remaining_progress -= cycle_on / t\n        # Remaining progress is done while stove is off\n        total_time += remaining_progress * (2 * t)\n    \n    # Output with sufficient precision\n    print(f\"{total_time:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 26.91970992088318}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Build adjacency list for the required reachability constraints\n    adj = [[] for _ in range(n + 1)]\n    indeg = [0] * (n + 1)\n    \n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        indeg[b] += 1\n    \n    # Topological sort using Kahn's algorithm\n    from collections import deque\n    q = deque()\n    for i in range(1, n + 1):\n        if indeg[i] == 0:\n            q.append(i)\n    \n    topo_order = []\n    while q:\n        u = q.popleft()\n        topo_order.append(u)\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    # If there's a cycle, we need to break it by adding edges\n    # The minimum number of edges needed is the number of nodes with indegree 0\n    # after considering the SCC condensation graph\n    # But here we can compute directly: answer = max(1, number of nodes with indegree 0)\n    # However, we need to ensure all required paths exist.\n    # Actually, the answer is the number of nodes with indegree 0 in the condensation DAG.\n    # Since we don't have SCC condensation, we can think differently:\n    # The minimum edges to make the graph satisfy all constraints is n - (length of longest path in terms of required edges)\n    # But simpler: answer = max(1, number of nodes with indegree 0)\n    # Let's compute indegree again for clarity\n    indeg2 = [0] * (n + 1)\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            indeg2[v] += 1\n    \n    zero_indeg = sum(1 for i in range(1, n + 1) if indeg2[i] == 0)\n    answer = max(1, zero_indeg)\n    \n    # But wait, the examples: first has zero_indeg = 1 (only node 1), answer=1? But expected 3.\n    # So that's wrong. Let's think differently.\n    # We need to add edges to make the graph have a Hamiltonian path covering all nodes?\n    # Actually, the constraints require certain directed paths.\n    # The minimal number of edges to satisfy all constraints is n - (number of nodes that can be sources in a DAG)\n    # But we need to compute the condensation graph.\n    \n    # Let's implement SCC (Tarjan) and then compute zero indegree in condensation DAG.\n    index = 0\n    stack = []\n    on_stack = [False] * (n + 1)\n    indices = [-1] * (n + 1)\n    lowlink = [-1] * (n + 1)\n    scc_id = [0] * (n + 1)\n    scc_count = 0\n    \n    def strongconnect(v):\n        nonlocal index, scc_count\n        indices[v] = index\n        lowlink[v] = index\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n        \n        for w in adj[v]:\n            if indices[w] == -1:\n                strongconnect(w)\n                lowlink[v] = min(lowlink[v], lowlink[w])\n            elif on_stack[w]:\n                lowlink[v] = min(lowlink[v], indices[w])\n        \n        if lowlink[v] == indices[v]:\n            while True:\n                w = stack.pop()\n                on_stack[w] = False\n                scc_id[w] = scc_count\n                if w == v:\n                    break\n            scc_count += 1\n    \n    for v in range(1, n + 1):\n        if indices[v] == -1:\n            strongconnect(v)\n    \n    # Build condensation graph\n    cond_adj = [set() for _ in range(scc_count)]\n    cond_indeg = [0] * scc_count\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if scc_id[u] != scc_id[v]:\n                if scc_id[v] not in cond_adj[scc_id[u]]:\n                    cond_adj[scc_id[u]].add(scc_id[v])\n                    cond_indeg[scc_id[v]] += 1\n    \n    # Count SCCs with indegree 0 in condensation graph\n    zero_cond = sum(1 for i in range(scc_count) if cond_indeg[i] == 0)\n    answer = max(1, zero_cond)\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 52.917311668395996}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    s = int(input().strip())\n    seen = {}\n    current = s\n    idx = 1\n    \n    while True:\n        if current in seen:\n            print(idx)\n            return\n        seen[current] = idx\n        \n        if current % 2 == 0:\n            current //= 2\n        else:\n            current = 3 * current + 1\n        idx += 1\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 11.26605772972107}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.23834753036499}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open+1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close-1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between first_colon and last_colon\n    pipe_count = 0\n    for i in range(first_colon+1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length: '[' + ':' + pipes + ':' + ']' = 4 + pipe_count\n    result = 4 + pipe_count\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 49.921817779541016}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    arr = list(map(int, data[idx:idx+n]))\n    idx += n\n    \n    freq = collections.Counter(arr)\n    \n    # Count frequencies of frequencies\n    freq_of_freq = collections.Counter(freq.values())\n    \n    # Get all distinct frequencies\n    distinct_freqs = sorted(freq_of_freq.keys())\n    \n    max_x = 0\n    \n    # Try each possible frequency as candidate for second team\n    for f in distinct_freqs:\n        # Number of distinct skills available for first team\n        distinct_count = len(freq)\n        \n        # If we use frequency f for second team, we need at least f students\n        # with the same skill. We can take min(f, distinct_count-1) as size\n        # (minus 1 because if we use a skill for second team, \n        # we can't use it in first team)\n        \n        # Actually, we need to consider how many skills have frequency >= f\n        skills_with_freq_at_least_f = 0\n        for freq_val in distinct_freqs:\n            if freq_val >= f:\n                skills_with_freq_at_least_f += freq_of_freq[freq_val]\n        \n        # We can form second team of size f using one skill\n        # First team needs f distinct skills\n        # We have distinct_count distinct skills total\n        # If we use one skill for second team, we have distinct_count-1 left for first team\n        \n        # The size is limited by:\n        # 1. f (size of second team)\n        # 2. distinct_count-1 (if we use one skill for second team)\n        # 3. But we might have multiple skills with frequency >= f\n        #    We can choose which skill to use for second team\n        \n        # Actually, the optimal is:\n        # Let k = number of skills with frequency >= f\n        # We can use one of these for second team\n        # First team needs f distinct skills from the remaining\n        # We have distinct_count total distinct skills\n        # After using one for second team, we have distinct_count-1 left\n        # But we need at least f of them\n        \n        # So possible size = min(f, distinct_count-1)\n        # But wait, we also need to ensure we have enough students\n        # with the chosen skill for second team\n        \n        # Actually simpler: For a given f, the maximum possible x is:\n        # x = min(f, distinct_count-1) if distinct_count-1 >= 1 else 0\n        # But we also need at least one skill with frequency >= f\n        \n        if skills_with_freq_at_least_f > 0:\n            # We can form second team of size up to f\n            # First team needs x distinct skills\n            # We have distinct_count distinct skills total\n            # If we use one skill for second team, we have distinct_count-1 for first team\n            \n            # The maximum x is limited by:\n            # 1. f (second team size)\n            # 2. distinct_count-1 (available distinct skills for first team after using one for second team)\n            \n            x = min(f, distinct_count-1)\n            \n            # But wait, what if distinct_count-1 < f?\n            # Then we can reduce second team size\n            # Actually x should be min(f, distinct_count-1)\n            \n            # Also, we need to check if we can actually get f students for second team\n            # We have skills_with_freq_at_least_f skills with frequency >= f\n            # So we can definitely form second team of size f\n            \n            max_x = max(max_x, x)\n    \n    results.append(str(max_x))\n\nprint('\\n'.join(results))", "runtime_sec": 41.919546365737915}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Compute gcd of all numbers\n    g = arr[0]\n    for x in arr[1:]:\n        g = math.gcd(g, x)\n    \n    # For each number, divide by gcd and check if it's of form 2^a * 3^b\n    for x in arr:\n        x //= g\n        while x % 2 == 0:\n            x //= 2\n        while x % 3 == 0:\n            x //= 3\n        if x != 1:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 19.60413122177124}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_float():\n    return float(sys.stdin.readline().strip())\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef calculate_tax(income, bands, P):\n    \"\"\"Calculate tax for given income using tax bands and final percentage.\"\"\"\n    tax = 0.0\n    remaining = income\n    \n    # Apply tax bands\n    for s, p in bands:\n        if remaining <= 0:\n            break\n        taxable = min(s, remaining)\n        tax += taxable * (p / 100.0)\n        remaining -= taxable\n    \n    # Apply final percentage to remaining income\n    if remaining > 0:\n        tax += remaining * (P / 100.0)\n    \n    return tax\n\ndef find_pre_tax_amount(target_after_tax, earned, bands, P):\n    \"\"\"Find pre-tax amount needed to get target after-tax amount.\"\"\"\n    # We need to solve: target = (pre_tax + earned) - tax(pre_tax + earned)\n    # Let total = pre_tax + earned\n    # We need total - tax(total) = target\n    # Since tax(total) is piecewise linear, we can use binary search\n    \n    # Lower bound: target (since tax >= 0)\n    low = target_after_tax\n    # Upper bound: target + max possible tax\n    # Worst case: all income taxed at max rate\n    max_rate = max([p for _, p in bands] + [P])\n    high = target_after_tax / (1 - max_rate / 100.0) if max_rate < 100 else target_after_tax * 2\n    high = max(high, target_after_tax * 2)  # Ensure upper bound is sufficient\n    \n    # Binary search for required precision\n    for _ in range(100):  # Enough iterations for 1e-6 precision\n        mid = (low + high) / 2.0\n        total_income = mid + earned\n        tax = calculate_tax(total_income, bands, P)\n        after_tax = total_income - tax\n        \n        if after_tax < target_after_tax:\n            low = mid\n        else:\n            high = mid\n    \n    return (low + high) / 2.0\n\ndef main():\n    # Read number of tax bands\n    B = read_int()\n    \n    # Read tax bands\n    bands = []\n    for _ in range(B):\n        s, p = map(float, sys.stdin.readline().split())\n        bands.append((s, p))\n    \n    # Read final percentage\n    P = read_float()\n    \n    # Read number of friends\n    F = read_int()\n    \n    results = []\n    for _ in range(F):\n        earned, target = map(float, sys.stdin.readline().split())\n        pre_tax = find_pre_tax_amount(target, earned, bands, P)\n        results.append(f\"{pre_tax:.6f}\")\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 37.69957137107849}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n        edges.append((x, y, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dist_from = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dist_from[i] = dijkstra(n, adj, i)\n    \n    # Compute base total cost without any zero road\n    base_total = 0\n    for a, b in routes:\n        base_total += dist_from[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # Temporarily set this edge weight to 0\n        # We need to compute new distances efficiently\n        # For each route, new distance = min(original, path through zero edge)\n        # For route (a,b): new_dist = min(dist[a][b], dist[a][x] + dist[y][b], dist[a][y] + dist[x][b])\n        improvement = 0\n        for a, b in routes:\n            original = dist_from[a][b]\n            through_zero = min(dist_from[a][x] + dist_from[y][b], dist_from[a][y] + dist_from[x][b])\n            new_dist = min(original, through_zero)\n            improvement += (original - new_dist)\n        new_total = base_total - improvement\n        if new_total < best:\n            best = new_total\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 32.80199313163757}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(200000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank, size, diameter):\n    x_root = find(x, parent)\n    y_root = find(y, parent)\n    if x_root == y_root:\n        return\n    if rank[x_root] < rank[y_root]:\n        x_root, y_root = y_root, x_root\n    parent[y_root] = x_root\n    if rank[x_root] == rank[y_root]:\n        rank[x_root] += 1\n    # Merge diameters: new diameter is max of three possibilities\n    new_diameter = max(diameter[x_root], diameter[y_root],\n                       (diameter[x_root] + 1) // 2 + (diameter[y_root] + 1) // 2 + 1)\n    diameter[x_root] = new_diameter\n    size[x_root] += size[y_root]\n\ndef bfs(start, adj, visited, component_nodes):\n    from collections import deque\n    queue = deque([start])\n    visited[start] = True\n    farthest_node = start\n    max_dist = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adj[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                component_nodes.append(neighbor)\n    # Find farthest node from start\n    dist = [-1] * len(adj)\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in adj[current]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[current] + 1\n                queue.append(neighbor)\n                if dist[neighbor] > max_dist:\n                    max_dist = dist[neighbor]\n                    farthest_node = neighbor\n    # Find diameter from farthest_node\n    dist2 = [-1] * len(adj)\n    dist2[farthest_node] = 0\n    queue = deque([farthest_node])\n    diameter = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adj[current]:\n            if dist2[neighbor] == -1:\n                dist2[neighbor] = dist2[current] + 1\n                queue.append(neighbor)\n                diameter = max(diameter, dist2[neighbor])\n    return diameter\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    c = int(next(it))\n    l = int(next(it))\n    adj = [[] for _ in range(c)]\n    for _ in range(l):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Find connected components and their diameters\n    visited = [False] * c\n    components = []  # list of (root, diameter, size)\n    parent = list(range(c))\n    rank = [0] * c\n    size = [1] * c\n    diameter = [0] * c\n    \n    for i in range(c):\n        if not visited[i]:\n            component_nodes = [i]\n            comp_diameter = bfs(i, adj, visited, component_nodes)\n            # Union all nodes in component\n            root = component_nodes[0]\n            for node in component_nodes[1:]:\n                union(root, node, parent, rank, size, diameter)\n            # Update diameter for the root\n            diameter[find(root, parent)] = comp_diameter\n            components.append((find(root, parent), comp_diameter, size[find(root, parent)]))\n    \n    # Sort components by diameter descending\n    components.sort(key=lambda x: x[1], reverse=True)\n    \n    # Connect all components with minimum cables (components-1 cables)\n    # Strategy: connect all components to the component with largest diameter\n    # The new diameter becomes max(original_max_diameter, \n    #                              ceil(d1/2) + ceil(d2/2) + 1, ...)\n    if len(components) == 1:\n        print(components[0][1])\n        return\n    \n    # Calculate new maximum diameter after connecting all components\n    # Connect all other components to the first (largest diameter) component\n    max_diameter = components[0][1]\n    for i in range(1, len(components)):\n        d1 = max_diameter\n        d2 = components[i][1]\n        new_connection_diameter = (d1 + 1) // 2 + (d2 + 1) // 2 + 1\n        max_diameter = max(max_diameter, new_connection_diameter)\n    \n    print(max_diameter)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 52.208362102508545}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef possible(s, t, seq):\n    \"\"\"Check if given s and t are valid for the sequence.\"\"\"\n    p1_wins = 0\n    p2_wins = 0\n    p1_points = 0\n    p2_points = 0\n    \n    for winner in seq:\n        if winner == 1:\n            p1_points += 1\n        else:\n            p2_points += 1\n        \n        if p1_points >= t or p2_points >= t:\n            if p1_points > p2_points:\n                p1_wins += 1\n            else:\n                p2_wins += 1\n            \n            if p1_wins == s or p2_wins == s:\n                # Check if this is the last serve\n                return p1_wins == s and p2_wins < s and p1_points > p2_points or \\\n                       p2_wins == s and p1_wins < s and p2_points > p1_points\n            \n            p1_points = 0\n            p2_points = 0\n    \n    return False\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    seq = list(map(int, data[1:1+n]))\n    \n    total_wins_1 = seq.count(1)\n    total_wins_2 = seq.count(2)\n    \n    results = []\n    \n    # Try all possible t values\n    for t in range(1, n+1):\n        # Quick check: total points must allow at least one set\n        if total_wins_1 < t and total_wins_2 < t:\n            continue\n        \n        # Simulate to find s\n        p1_wins = 0\n        p2_wins = 0\n        p1_points = 0\n        p2_points = 0\n        last_winner = 0\n        \n        for winner in seq:\n            if winner == 1:\n                p1_points += 1\n            else:\n                p2_points += 1\n            \n            if p1_points >= t or p2_points >= t:\n                if p1_points > p2_points:\n                    p1_wins += 1\n                    last_winner = 1\n                else:\n                    p2_wins += 1\n                    last_winner = 2\n                \n                if p1_wins == p2_wins:\n                    # Can't have equal wins when match ends\n                    break\n                \n                if p1_wins > p2_wins:\n                    s = p1_wins\n                else:\n                    s = p2_wins\n                \n                # Check if this could be the end\n                if (p1_wins == s or p2_wins == s) and (p1_points != 0 or p2_points != 0):\n                    # Not at the end of sequence\n                    break\n                \n                p1_points = 0\n                p2_points = 0\n        \n        # Check if simulation completed successfully\n        if p1_points == 0 and p2_points == 0 and p1_wins != p2_wins:\n            s = max(p1_wins, p2_wins)\n            if possible(s, t, seq):\n                results.append((s, t))\n    \n    # Remove duplicates and sort\n    results = sorted(set(results))\n    \n    print(len(results))\n    for s, t in results:\n        print(f\"{s} {t}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 37.62424302101135}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B, C, D, E, F = map(int, sys.stdin.read().split())\n    \n    # Maximum water mass we can have (in grams)\n    max_water = F\n    \n    # Generate all possible water amounts using operations 1 and 2\n    water_amounts = set()\n    for i in range(max_water // (100 * A) + 1):\n        for j in range((max_water - i * 100 * A) // (100 * B) + 1):\n            water = i * 100 * A + j * 100 * B\n            if water <= max_water and water > 0:\n                water_amounts.add(water)\n    \n    # Generate all possible sugar amounts using operations 3 and 4\n    max_sugar = F\n    sugar_amounts = set()\n    for i in range(max_sugar // C + 1):\n        for j in range((max_sugar - i * C) // D + 1):\n            sugar = i * C + j * D\n            if sugar <= max_sugar:\n                sugar_amounts.add(sugar)\n    \n    best_total = 100 * A  # Start with minimum water amount\n    best_sugar = 0\n    best_density = -1.0\n    \n    # Try all combinations of water and sugar\n    for water in water_amounts:\n        max_dissolved_sugar = (water // 100) * E\n        for sugar in sugar_amounts:\n            total = water + sugar\n            if total > F:\n                continue\n            if sugar > max_dissolved_sugar:\n                continue\n            if total == 0:\n                continue\n            \n            density = (100 * sugar) / total\n            if density > best_density:\n                best_density = density\n                best_total = total\n                best_sugar = sugar\n            elif abs(density - best_density) < 1e-12 and total > best_total:\n                # If densities are equal, choose larger total mass\n                best_total = total\n                best_sugar = sugar\n    \n    print(f\"{best_total} {best_sugar}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.673652410507202}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    p = int(data[0])\n    seq = list(map(int, data[1:1+p]))\n    return p, seq\n\ndef find_triple_correlation(p, seq):\n    min_threshold = (p + 39) // 40 + 1  # ceil(p/40) + 1\n    best = None  # (a, n, b, m, c, first_occurrence)\n    \n    # Try all possible a, b, c from 0 to 9\n    for a in range(10):\n        for b in range(10):\n            for c in range(10):\n                # Try all possible n, m where positions are valid\n                for n in range(1, p):  # n >= 1\n                    for m in range(1, p - n):  # m >= 1, and b position < p\n                        count = 0\n                        first_occurrence = None\n                        \n                        # Check all starting positions i for a\n                        for i in range(p - (n + m)):\n                            if seq[i] == a:\n                                j = i + n\n                                if j < p and seq[j] == b:\n                                    k = j + m\n                                    if k < p and seq[k] == c:\n                                        # Found a full triple\n                                        if first_occurrence is None:\n                                            first_occurrence = i\n                                        count += 1\n                        \n                        # Check if correlation meets threshold\n                        if count >= min_threshold:\n                            # Verify the three conditions\n                            valid = True\n                            \n                            # Condition 1: a followed n later by b => c m after b\n                            for i in range(p - n):\n                                if seq[i] == a and i + n < p and seq[i + n] == b:\n                                    if i + n + m >= p or seq[i + n + m] != c:\n                                        valid = False\n                                        break\n                            if not valid:\n                                continue\n                            \n                            # Condition 2: b followed m later by c => a n before b\n                            for j in range(p - m):\n                                if seq[j] == b and j + m < p and seq[j + m] == c:\n                                    if j - n < 0 or seq[j - n] != a:\n                                        valid = False\n                                        break\n                            if not valid:\n                                continue\n                            \n                            # Condition 3: a followed n+m later by c => b n after a\n                            for i in range(p - (n + m)):\n                                if seq[i] == a and i + n + m < p and seq[i + n + m] == c:\n                                    if i + n >= p or seq[i + n] != b:\n                                        valid = False\n                                        break\n                            if not valid:\n                                continue\n                            \n                            # All conditions satisfied, store if better\n                            candidate = (a, n, b, m, c, first_occurrence)\n                            if best is None:\n                                best = candidate\n                            else:\n                                # Compare: earlier first occurrence\n                                if first_occurrence < best[5]:\n                                    best = candidate\n                                elif first_occurrence == best[5]:\n                                    # Smaller n\n                                    if n < best[1]:\n                                        best = candidate\n                                    elif n == best[1]:\n                                        # Smaller m\n                                        if m < best[3]:\n                                            best = candidate\n    \n    return best\n\ndef main():\n    p, seq = read_input()\n    result = find_triple_correlation(p, seq)\n    \n    if result is None:\n        print(\"random sequence\")\n    else:\n        a, n, b, m, c, _ = result\n        print(f\"triple correlation {a}({n}){b}({m}){c} found\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 42.83173656463623}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.252947092056274}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import Counter\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1 + n*n]))\n    \n    # Count frequencies\n    freq = Counter(arr)\n    \n    # Initialize matrix\n    mat = [[0] * n for _ in range(n)]\n    \n    # Determine positions based on symmetry\n    # For palindromic matrix, positions are symmetric across rows and columns\n    # We can fill positions in groups: center (if n odd), rows/columns symmetric pairs\n    \n    # Helper to fill symmetric positions\n    def fill_symmetric(value, i, j):\n        mat[i][j] = value\n        mat[n-1-i][j] = value  # row symmetry\n        mat[i][n-1-j] = value  # column symmetry\n        mat[n-1-i][n-1-j] = value  # both symmetries\n    \n    # Process values by frequency\n    values = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Fill matrix\n    idx = 0\n    for i in range((n+1)//2):\n        for j in range((n+1)//2):\n            if idx >= len(values):\n                print(\"NO\")\n                return\n            val, count = values[idx]\n            # Determine required count for this symmetric group\n            required = 1\n            if i != n-1-i:\n                required *= 2\n            if j != n-1-j:\n                required *= 2\n            if count < required:\n                print(\"NO\")\n                return\n            fill_symmetric(val, i, j)\n            values[idx] = (val, count - required)\n            if values[idx][1] == 0:\n                idx += 1\n    \n    # Check if all values used\n    if any(count > 0 for _, count in values[idx:]):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for row in mat:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 31.211111783981323}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Special case: N=1\n    if N == 1:\n        if A == 1 or B == 1:\n            print(1)\n        else:\n            print(-1)\n        return\n    \n    # Ensure A <= B for easier handling\n    if A > B:\n        A, B = B, A\n    \n    # Check if solution exists\n    # We need to partition N into cycles of lengths that are divisors of A or B\n    # Actually, each cycle length must divide either A or B\n    # And all cycle lengths must sum to N\n    \n    # Find all possible cycle lengths that divide A or B\n    possible_lengths = set()\n    for d in range(1, int(math.sqrt(A)) + 1):\n        if A % d == 0:\n            possible_lengths.add(d)\n            possible_lengths.add(A // d)\n    for d in range(1, int(math.sqrt(B)) + 1):\n        if B % d == 0:\n            possible_lengths.add(d)\n            possible_lengths.add(B // d)\n    \n    # Filter lengths <= N\n    possible_lengths = [l for l in possible_lengths if 1 <= l <= N]\n    possible_lengths.sort()\n    \n    # DP to check if we can partition N using these lengths\n    # dp[x] = whether we can achieve sum x\n    dp = [False] * (N + 1)\n    dp[0] = True\n    \n    for length in possible_lengths:\n        for x in range(length, N + 1):\n            if dp[x - length]:\n                dp[x] = True\n    \n    if not dp[N]:\n        print(-1)\n        return\n    \n    # Reconstruct the partition\n    remaining = N\n    cycles = []\n    \n    # Sort lengths in descending order for greedy reconstruction\n    possible_lengths.sort(reverse=True)\n    \n    while remaining > 0:\n        for length in possible_lengths:\n            if length <= remaining and dp[remaining - length]:\n                cycles.append(length)\n                remaining -= length\n                break\n    \n    # Build the permutation\n    P = [0] * (N + 1)\n    current = 1\n    \n    for cycle_len in cycles:\n        # Create a cycle of length cycle_len\n        for i in range(cycle_len):\n            if i == cycle_len - 1:\n                P[current + i] = current\n            else:\n                P[current + i] = current + i + 1\n        current += cycle_len\n    \n    # Output the permutation (1-based to 1-based)\n    result = ' '.join(str(P[i]) for i in range(1, N + 1))\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.998135566711426}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(x, y, n, m):\n    \"\"\"Rotate point (x, y) 90 degrees clockwise in an n x m matrix.\"\"\"\n    return y, n - x + 1\n\ndef rotate_90_counterclockwise(x, y, n, m):\n    \"\"\"Rotate point (x, y) 90 degrees counterclockwise in an n x m matrix.\"\"\"\n    return m - y + 1, x\n\ndef horizontal_flip(x, y, n, m):\n    \"\"\"Flip point (x, y) horizontally (mirror across vertical axis).\"\"\"\n    return x, m - y + 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = 360 degrees\n    x %= 4\n    z %= 4\n    # Horizontal flips: even number of flips cancel out\n    y %= 2\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        curr_n, curr_m = n, m\n        \n        # Apply x clockwise rotations\n        for _ in range(x):\n            xi, yi = rotate_90_clockwise(xi, yi, curr_n, curr_m)\n            curr_n, curr_m = curr_m, curr_n  # Dimensions swap after rotation\n        \n        # Apply y horizontal flips\n        if y:\n            xi, yi = horizontal_flip(xi, yi, curr_n, curr_m)\n        \n        # Apply z counterclockwise rotations\n        for _ in range(z):\n            xi, yi = rotate_90_counterclockwise(xi, yi, curr_n, curr_m)\n            curr_n, curr_m = curr_m, curr_n  # Dimensions swap after rotation\n        \n        results.append(f\"{xi} {yi}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 36.45167636871338}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # Each character has N choices, 3 characters\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 9.33100175857544}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L1 = int(data[0])\n    L2 = int(data[1])\n    N = int(data[2])\n    tubes = list(map(int, data[3:3+N]))\n    \n    # Step 1: Generate all possible sums of two tubes\n    two_sums = []\n    for i in range(N):\n        for j in range(i+1, N):\n            two_sums.append(tubes[i] + tubes[j])\n    two_sums.sort()\n    \n    # Step 2: For each L, find the maximum sum ≤ L\n    def max_sum_at_most_L(sums, L):\n        # Binary search for the largest sum ≤ L\n        lo, hi = 0, len(sums)-1\n        best = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if sums[mid] <= L:\n                best = sums[mid]\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return best\n    \n    # Step 3: Try all possible splits of four tubes into two pairs\n    # We need to ensure all four tubes are distinct.\n    # Approach: For each pair (i,j), consider remaining tubes for the other pair.\n    # To avoid O(N^4), we precompute best pair for each L constraint.\n    \n    # Precompute best pair sum for each possible sum ≤ max(L1, L2)\n    max_L = max(L1, L2)\n    best_for_sum = [-1] * (max_L + 1)\n    for s in two_sums:\n        if s <= max_L:\n            best_for_sum[s] = s\n    # Fill gaps: for each length, take the best previous\n    for i in range(1, max_L+1):\n        if best_for_sum[i] < best_for_sum[i-1]:\n            best_for_sum[i] = best_for_sum[i-1]\n    \n    # Step 4: Try all possible first pair sums that fit in L1\n    # For each, find best second pair that fits in L2 using remaining tubes.\n    # To ensure distinct tubes, we need to track indices.\n    # Since N ≤ 2000, O(N^3) might be too slow (8e9). Need smarter.\n    \n    # Alternative: Generate all pairs with their indices.\n    pairs = []  # (sum, i, j)\n    for i in range(N):\n        for j in range(i+1, N):\n            pairs.append((tubes[i] + tubes[j], i, j))\n    pairs.sort(key=lambda x: x[0])  # sort by sum\n    \n    # For each pair as first, find best non-overlapping pair as second.\n    # Use two pointers: for each first pair, find best second pair with sum ≤ L2\n    # and no index overlap.\n    # Since pairs are sorted, we can use a suffix max array for quick lookup.\n    \n    m = len(pairs)\n    suffix_max = [0] * m  # suffix_max[i] = max sum from i to end\n    suffix_max[m-1] = pairs[m-1][0]\n    for i in range(m-2, -1, -1):\n        suffix_max[i] = max(pairs[i][0], suffix_max[i+1])\n    \n    best_total = -1\n    for idx1 in range(m):\n        s1, i1, j1 = pairs[idx1]\n        if s1 > L1:\n            break  # since pairs are sorted by sum\n        \n        # Binary search for the largest index idx2 where pairs[idx2].sum ≤ L2\n        # and idx2 > idx1 to avoid duplicate counting (though indices might still overlap)\n        lo, hi = idx1+1, m-1\n        best_idx2 = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if pairs[mid][0] <= L2:\n                best_idx2 = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        if best_idx2 != -1:\n            # Now we need to find a pair in [idx1+1, best_idx2] that doesn't share indices with (i1,j1)\n            # Since we want maximum sum, check from best_idx2 downwards.\n            for idx2 in range(best_idx2, idx1, -1):\n                s2, i2, j2 = pairs[idx2]\n                if {i1, j1}.isdisjoint({i2, j2}):\n                    total = s1 + s2\n                    if total > best_total:\n                        best_total = total\n                    break  # since we're going downwards, first found is max for this idx1\n    \n    if best_total == -1:\n        print(\"Impossible\")\n    else:\n        print(best_total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 53.395350217819214}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        # Count consecutive '<' from left and consecutive '>' from right\n        left_count = 0\n        while left_count < n and s[left_count] == '<':\n            left_count += 1\n        right_count = 0\n        while right_count < n and s[n - 1 - right_count] == '>':\n            right_count += 1\n        # Minimum deletions needed is the smaller of these two counts\n        min_deletions = min(left_count, right_count)\n        results.append(str(min_deletions))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.087337017059326}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: t = (Y - 2X) / 2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    numerator = Y - 2 * X\n    if numerator < 0:\n        print(\"No\")\n        return\n    \n    if numerator % 2 != 0:\n        print(\"No\")\n        return\n    \n    t = numerator // 2\n    c = X - t\n    \n    if c >= 0 and t >= 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.565129041671753}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if any row or column is completely evil\n    for i in range(n):\n        if all(grid[i][j] == 'E' for j in range(n)):\n            print(-1)\n            return\n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            print(-1)\n            return\n    \n    # Strategy: find n cells such that each row and column has at least one selected cell\n    # We can select cells that are not 'E'\n    selected = []\n    \n    # First try to select from each row\n    row_selected = [False] * n\n    col_selected = [False] * n\n    \n    # Try to find a valid selection\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '.' and not row_selected[i] and not col_selected[j]:\n                selected.append((i+1, j+1))\n                row_selected[i] = True\n                col_selected[j] = True\n                break\n    \n    # If we didn't get n selections, try alternative approach\n    if len(selected) < n:\n        selected = []\n        # Try selecting by columns first\n        row_selected = [False] * n\n        col_selected = [False] * n\n        for j in range(n):\n            for i in range(n):\n                if grid[i][j] == '.' and not row_selected[i] and not col_selected[j]:\n                    selected.append((i+1, j+1))\n                    row_selected[i] = True\n                    col_selected[j] = True\n                    break\n    \n    # If still not enough, try greedy fill\n    if len(selected) < n:\n        # Fill missing rows\n        for i in range(n):\n            if not row_selected[i]:\n                for j in range(n):\n                    if grid[i][j] == '.':\n                        selected.append((i+1, j+1))\n                        row_selected[i] = True\n                        col_selected[j] = True\n                        break\n        # Fill missing columns\n        for j in range(n):\n            if not col_selected[j]:\n                for i in range(n):\n                    if grid[i][j] == '.':\n                        selected.append((i+1, j+1))\n                        row_selected[i] = True\n                        col_selected[j] = True\n                        break\n    \n    # Verify we have exactly n selections and all rows/columns covered\n    if len(selected) == n:\n        for r, c in selected:\n            print(f\"{r} {c}\")\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.855140686035156}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Read inputs\n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute possible frets on each string\n    possible_frets = []\n    for note in b:\n        frets_for_note = []\n        for string_val in a:\n            if note > string_val:\n                fret = note - string_val\n                frets_for_note.append(fret)\n        # Sort frets for this note\n        frets_for_note.sort()\n        possible_frets.append(frets_for_note)\n    \n    # Sliding window approach\n    # We'll maintain a list of current frets being used for each note\n    # Each position in the window corresponds to one note\n    # We need to pick one fret per note from its possible frets\n    \n    # Create a list of all (fret, note_index) pairs\n    all_pairs = []\n    for i, frets in enumerate(possible_frets):\n        for fret in frets:\n            all_pairs.append((fret, i))\n    \n    # Sort by fret value\n    all_pairs.sort(key=lambda x: x[0])\n    \n    # Sliding window\n    m = len(all_pairs)\n    left = 0\n    count = [0] * n  # how many notes have a selected fret in current window\n    notes_in_window = 0\n    min_diff = float('inf')\n    \n    for right in range(m):\n        fret_val, note_idx = all_pairs[right]\n        if count[note_idx] == 0:\n            notes_in_window += 1\n        count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while notes_in_window == n:\n            min_diff = min(min_diff, fret_val - all_pairs[left][0])\n            left_fret, left_note = all_pairs[left]\n            count[left_note] -= 1\n            if count[left_note] == 0:\n                notes_in_window -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.81849932670593}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nR = int(sys.stdin.readline().strip())\n\n# Calculate circumference: C = 2 * π * R\ncircumference = 2 * math.pi * R\n\n# Print with sufficient precision to meet error tolerance\nprint(circumference)", "runtime_sec": 11.75537371635437}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.028056383132935}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    count = 0\n    while b > 0:\n        count += a // b\n        a, b = b, a % b\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.006577014923096}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # The smallest positive integer divisible by both 2 and N is LCM(2, N)\n    # Since 2 is prime, LCM(2, N) = 2 * N / gcd(2, N)\n    # If N is even, gcd(2, N) = 2, so answer = N\n    # If N is odd, gcd(2, N) = 1, so answer = 2 * N\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.010108947753906}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 54.97077465057373}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Precompute factorials up to 50\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i\n    \n    # DP to count permutations with maximum f(p)\n    # dp[i] = number of permutations of length i with maximum f(p)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        # For length i, we can choose the maximum element (i) to be at position k (1-indexed)\n        # Then left part has length k-1, right part has length i-k\n        # Both parts must also be permutations with maximum f(p)\n        for k in range(1, i + 1):\n            left_ways = dp[k-1]\n            right_ways = dp[i-k]\n            # Number of ways to interleave left and right parts\n            interleave = fact[i-1] // (fact[k-1] * fact[i-k])\n            dp[i] += left_ways * right_ways * interleave\n    \n    # Now construct the m-th permutation\n    result = []\n    remaining = list(range(1, n + 1))\n    \n    def construct(length, order):\n        if length == 0:\n            return []\n        if length == 1:\n            return [remaining.pop()]\n        \n        # Try placing the maximum element at each position\n        for pos in range(1, length + 1):\n            left_count = dp[pos-1]\n            right_count = dp[length-pos]\n            # Number of permutations with max at this position\n            ways = left_count * right_count * (fact[length-1] // (fact[pos-1] * fact[length-pos]))\n            \n            if order <= ways:\n                # Max element goes at position pos\n                max_elem = remaining.pop()\n                # Determine which part gets processed first\n                left_permutations = left_count * (fact[length-1] // (fact[pos-1] * fact[length-pos]))\n                \n                if order <= left_permutations:\n                    # The order is within permutations where left part determines order\n                    left_order = (order - 1) // (right_count) + 1\n                    right_order = (order - 1) % right_count + 1\n                    left_result = construct(pos-1, left_order)\n                    right_result = construct(length-pos, right_order)\n                    return left_result + [max_elem] + right_result\n                else:\n                    # The order is within permutations where right part determines order\n                    order -= left_permutations\n                    right_order = (order - 1) // left_count + 1\n                    left_order = (order - 1) % left_count + 1\n                    left_result = construct(pos-1, left_order)\n                    right_result = construct(length-pos, right_order)\n                    return left_result + [max_elem] + right_result\n            else:\n                order -= ways\n        \n        # Should not reach here\n        return []\n    \n    result = construct(n, m)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 40.30662393569946}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    # Parse first line\n    first_line = data[0].split()\n    m = int(first_line[0])  # number of clauses\n    n = int(first_line[1])  # number of variables\n    \n    # Check if m >= 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 11.778678894042969}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.47766375541687}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_solved(cube):\n    \"\"\"Check if cube is solved (each face has same color).\"\"\"\n    # Faces indices (0-based from input sequence)\n    faces = [\n        [0, 1, 2, 3],    # Front\n        [4, 5, 6, 7],    # Back\n        [8, 9, 10, 11],  # Left\n        [12, 13, 14, 15],# Right\n        [16, 17, 18, 19],# Up\n        [20, 21, 22, 23] # Down\n    ]\n    for face in faces:\n        if not all(cube[i] == cube[face[0]] for i in face):\n            return False\n    return True\n\ndef rotate_face(cube, face_indices, clockwise=True):\n    \"\"\"Rotate a face (4 squares) clockwise or counter-clockwise.\"\"\"\n    # Copy cube\n    new_cube = cube[:]\n    a, b, c, d = face_indices\n    if clockwise:\n        new_cube[a], new_cube[b], new_cube[c], new_cube[d] = cube[b], cube[d], cube[a], cube[c]\n    else:\n        new_cube[a], new_cube[b], new_cube[c], new_cube[d] = cube[c], cube[a], cube[d], cube[b]\n    return new_cube\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    cube = list(map(int, data))\n    \n    # If already solved\n    if is_solved(cube):\n        print(\"YES\")\n        return\n    \n    # Define all possible face rotations for 2x2x2 cube\n    # Each face has 4 squares, indices from 0 to 23\n    # Based on standard cube numbering\n    faces_to_rotate = [\n        [0, 1, 2, 3],    # Front face\n        [4, 5, 6, 7],    # Back face\n        [8, 9, 10, 11],  # Left face\n        [12, 13, 14, 15],# Right face\n        [16, 17, 18, 19],# Up face\n        [20, 21, 22, 23] # Down face\n    ]\n    \n    # Try all possible single rotations\n    for face in faces_to_rotate:\n        # Try clockwise\n        rotated = rotate_face(cube, face, clockwise=True)\n        if is_solved(rotated):\n            print(\"YES\")\n            return\n        # Try counter-clockwise\n        rotated = rotate_face(cube, face, clockwise=False)\n        if is_solved(rotated):\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.21034359931946}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [int(next(it)) for _ in range(n)]\n    v = [int(next(it)) for _ in range(n)]\n    \n    # Pair points by (x, v) and sort by x\n    points = sorted(zip(x, v))\n    \n    # For each point, we need to compute contributions from points with smaller x\n    # The minimum distance d(i,j) = 0 if v_i <= v_j (since they can meet or diverge)\n    # Otherwise, d(i,j) = (x_j - x_i) * (v_i - v_j) / (v_i - v_j) = x_j - x_i\n    # Wait, that's not correct. Let's derive properly.\n    # Distance at time t: |(x_i + v_i*t) - (x_j + v_j*t)| = |(x_i - x_j) + (v_i - v_j)*t|\n    # This is linear in t. Minimum occurs at endpoints or when derivative zero.\n    # Since it's absolute value of linear function, minimum is 0 if signs of (x_i-x_j) and (v_i-v_j) differ,\n    # otherwise min is |x_i - x_j|.\n    # More precisely: min_t |A + B*t| where A = x_i - x_j, B = v_i - v_j.\n    # If B == 0: distance constant = |A|.\n    # If B != 0: linear function crosses zero at t = -A/B if that's finite.\n    # So minimum is 0 if A*B <= 0 (i.e., they have opposite signs or one zero).\n    # Because then we can choose t such that A + B*t = 0.\n    # If A*B > 0 (same sign), minimum is |A| (at t=0).\n    # So d(i,j) = 0 if (x_i - x_j)*(v_i - v_j) <= 0, else |x_i - x_j|.\n    \n    # We need sum over i<j. Sort by x to handle absolute difference.\n    # For each i, consider j>i (x_j > x_i). Then x_j - x_i > 0.\n    # So condition becomes: if (v_i - v_j) <= 0, then d=0, else d = x_j - x_i.\n    # Because (x_i - x_j) is negative, so product <=0 when v_i - v_j >=0.\n    # Wait: (x_i - x_j) < 0, so (x_i-x_j)*(v_i-v_j) <= 0  <=> (v_i - v_j) >= 0.\n    # Yes, because negative * positive <=0, negative * negative >0.\n    # So for i<j (x_i < x_j), d(i,j) = 0 if v_i >= v_j, else x_j - x_i.\n    \n    # Now we need sum_{i<j} [v_i < v_j] * (x_j - x_i).\n    # We can process sorted points and use Fenwick tree to count how many previous points have v < current v,\n    # and sum of their x values.\n    \n    # Coordinate compress v values\n    v_vals = sorted(set(v))\n    v_to_idx = {val: i+1 for i, val in enumerate(v_vals)}  # 1-indexed for Fenwick\n    m = len(v_vals)\n    \n    # Fenwick trees for count and sum_x\n    bit_count = [0]*(m+2)\n    bit_sum_x = [0]*(m+2)\n    \n    def update(bit, idx, val):\n        while idx <= m:\n            bit[idx] += val\n            idx += idx & -idx\n    \n    def query(bit, idx):\n        s = 0\n        while idx > 0:\n            s += bit[idx]\n            idx -= idx & -idx\n        return s\n    \n    total = 0\n    for x_i, v_i in points:\n        idx = v_to_idx[v_i]\n        # Count of previous points with v < v_i\n        cnt = query(bit_count, idx-1)\n        # Sum of x of those points\n        sum_x = query(bit_sum_x, idx-1)\n        total += cnt * x_i - sum_x\n        update(bit_count, idx, 1)\n        update(bit_sum_x, idx, x_i)\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 50.18394160270691}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', \"import sys\\r\\nimport math\\r\\n\\r\\n# ---------- Segment Tree Node ----------\\r\\nclass Node:\\r\\n    __slots__ = ('len', 'first', 'last', 'prefix', 'suffix', 'best')\\r\\n    def __init__(self, len=0, first=0, last=0, prefix=0, suffix=0, best=0):\\r\\n        self.len = len          # length of segment\\r\\n        self.first = first      # first value in segment\\r\\n        self.last = last        # last value in segment\\r\\n        self.prefix = prefix    # longest magical prefix length\\r\\n        self.suffix = suffix    # longest magical suffix length\\r\\n        self.best = best        # longest magical subarray length\\r\\n\\r\\n# ---------- Segment Tree ----------\\r\\nclass SegmentTree:\\r\\n    def __init__(self, arr):\\r\\n        n = len(arr)\\r\\n        self.n = n\\r\\n        self.tree = [Node() for _ in range(4 * n)]\\r\\n        self.build(1, 0, n - 1, arr)\\r\\n    \\r\\n    def build(self, idx, l, r, arr):\\r\\n        if l == r:\\r\\n            self.tree[idx] = Node(1, arr[l], arr[l], 1, 1, 1)\\r\\n            return\\r\\n        mid = (l + r) // 2\\r\\n        self.build(idx * 2, l, mid, arr)\\r\\n        self.build(idx * 2 + 1, mid + 1, r, arr)\\r\\n        self.tree[idx] = self.merge(self.tree[idx * 2], self.tree[idx * 2 + 1])\\r\\n    \\r\\n    def merge(self, left, right):\\r\\n        res = Node()\\r\\n        res.len = left.len + right.len\\r\\n        res.first = left.first\\r\\n        res.last = right.last\\r\\n        \\r\\n        # prefix\\r\\n        if left.prefix == left.len and (left.last <= right.first <= left.first or left.first <= right.first <= left.last):\\r\\n            res.prefix = left.len + right.prefix\\r\\n        else:\\r\\n            res.prefix = left.prefix\\r\\n        \\r\\n        # suffix\\r\\n        if right.suffix == right.len and (right.first <= left.last <= right.last or right.last <= left.last <= right.first):\\r\\n            res.suffix = right.len + left.suffix\\r\\n        else:\\r\\n            res.suffix = right.suffix\\r\\n        \\r\\n        # best\\r\\n        res.best = max(left.best, right.best)\\r\\n        # check middle crossing\\r\\n        if left.last <= right.first <= left.first or left.first <= right.first <= left.last:\\r\\n            res.best = max(res.best, left.suffix + right.prefix)\\r\\n        \\r\\n        return res\\r\\n    \\r\\n    def query(self, idx, l, r, ql, qr):\\r\\n        if ql <= l and r <= qr:\\r\\n            return self.tree[idx]\\r\\n        mid = (l + r) // 2\\r\\n        if qr <= mid:\\r\\n            return self.query(idx * 2, l, mid, ql, qr)\\r\\n        if ql > mid:\\r\\n            return self.query(idx * 2 + 1, mid + 1, r, ql, qr)\\r\\n        left_res = self.query(idx * 2, l, mid, ql, qr)\\r\\n        right_res = self.query(idx * 2 + 1, mid + 1, r, ql, qr)\\r\\n        return self.merge(left_res, right_res)\\r\\n    \\r\\n    def get_answer(self, l, r):\\r\\n        # convert to 0‑based\\r\\n        node = self.query(1, 0, self.n - 1, l - 1, r - 1)\\r\\n        return node.best\\r\\n\\r\\n# ---------- Main ----------\\r\\ndef main():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    it = iter(data)\\r\\n    n = int(next(it))\\r\\n    arr = [int(next(it)) for _ in range(n)]\\r\\n    q = int(next(it))\\r\\n    \\r\\n    segtree = SegmentTree(arr)\\r\\n    out_lines = []\\r\\n    for _ in range(q):\\r\\n        l = int(next(it))\\r\\n        r = int(next(it))\\r\\n        ans = segtree.get_answer(l, r)\\r\\n        out_lines.append(str(ans))\\r\\n    sys.stdout.write('\\\\n'.join(out_lines))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()\", 2678, 2679, 'illegal multibyte sequence')", "runtime_sec": 43.254066705703735}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.83738446235657}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize subordinates count array\n    subordinates = [0] * (N + 1)  # 1-indexed\n    \n    # Count immediate subordinates\n    for boss in A:\n        subordinates[boss] += 1\n    \n    # Output results for members 1 to N\n    for i in range(1, N + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 13.62170147895813}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # Duplicate array to handle circular wrap-around\n    A_extended = A + A\n    \n    # Precompute prefix ORs for quick range OR queries\n    prefix_or = [0] * (2 * N + 1)\n    for i in range(2 * N):\n        prefix_or[i + 1] = prefix_or[i] | A_extended[i]\n    \n    def range_or(l, r):\n        # OR of A_extended[l:r] (0-indexed, r exclusive)\n        return prefix_or[r] ^ prefix_or[l]\n    \n    # Binary search on the answer\n    low, high = 0, (1 << 31) - 1  # up to 2^31-1 since A_i <= 1e9 < 2^30\n    ans = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        # Check if we can partition into at least K sections with OR >= mid\n        # Actually we need exactly K sections, but we can check for at least K\n        # because if we can get more than K, we can merge sections to get exactly K\n        \n        # DP: dp[i] = maximum number of sections we can get ending at position i\n        # with each section's OR having all bits of mid\n        dp = [-10**9] * (2 * N + 1)\n        dp[0] = 0\n        \n        # For each i, find the earliest j such that range_or(j, i) has all bits of mid\n        # Then dp[i] = max(dp[i-1], dp[j] + 1)\n        \n        # We'll use two pointers\n        j = 0\n        current_or = 0\n        \n        for i in range(1, 2 * N + 1):\n            # Extend window to include A_extended[i-1]\n            current_or |= A_extended[i-1]\n            \n            # Shrink window from left until current_or has all bits of mid\n            while j < i and (current_or & mid) == mid:\n                # Now range_or(j, i) has all bits of mid\n                dp[i] = max(dp[i], dp[j] + 1)\n                # Remove A_extended[j] from current_or\n                # To do this properly, we need to recompute OR, but that's O(N^2)\n                # Instead, we'll use a different approach\n                break\n            \n            # Fallback: if we can't make current_or have all bits of mid, dp[i] = dp[i-1]\n            if dp[i] == -10**9:\n                dp[i] = dp[i-1]\n        \n        # Actually the above approach is flawed. Let's use a greedy approach instead.\n        # We'll try to see if we can get at least K sections in the circular array.\n        # We can break the circle at each position and check linearly.\n        \n        max_sections = 0\n        for start in range(N):\n            cnt = 0\n            i = start\n            while i < start + N:\n                cur_or = 0\n                # Extend as far as possible while cur_or has all bits of mid\n                j = i\n                while j < start + N:\n                    cur_or |= A_extended[j]\n                    if (cur_or & mid) == mid:\n                        cnt += 1\n                        i = j + 1\n                        break\n                    j += 1\n                else:\n                    # Could not make a section with OR having all bits of mid\n                    break\n            if cnt >= K:\n                max_sections = K\n                break\n        \n        if max_sections >= K:\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 45.30217957496643}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith(\"po\"):\n        return \"FILIPINO\"\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        return \"JAPANESE\"\n    elif sentence.endswith(\"mnida\"):\n        return \"KOREAN\"\n    else:\n        # According to problem statement, this case shouldn't happen\n        # but included for completeness\n        return \"UNKNOWN\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i].strip()\n        results.append(detect_language(sentence))\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 18.728360414505005}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N = int(data[idx]); idx += 1\n    C = [0] * (N-1)\n    S = [0] * (N-1)\n    F = [0] * (N-1)\n    for i in range(N-1):\n        C[i] = int(data[idx]); idx += 1\n        S[i] = int(data[idx]); idx += 1\n        F[i] = int(data[idx]); idx += 1\n    \n    results = [0] * N\n    results[N-1] = 0\n    \n    for start in range(N-2, -1, -1):\n        current_time = 0\n        for station in range(start, N-1):\n            if current_time <= S[station]:\n                current_time = S[station]\n            else:\n                remainder = current_time % F[station]\n                if remainder != 0:\n                    current_time += F[station] - remainder\n            current_time += C[station]\n        results[start] = current_time\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 21.33001136779785}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    iron = set()\n    for _ in range(m):\n        iron.add(int(next(it)))\n    coal = set()\n    for _ in range(k):\n        coal.add(int(next(it)))\n    \n    adj = [[] for _ in range(n+1)]\n    for i in range(1, n+1):\n        a = int(next(it))\n        for _ in range(a):\n            b = int(next(it))\n            adj[i].append(b)\n    \n    INF = 10**9\n    dist_from_start = [INF]*(n+1)\n    dist_from_start[1] = 0\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist_from_start[u]:\n            continue\n        for v in adj[u]:\n            nd = d + 1\n            if nd < dist_from_start[v]:\n                dist_from_start[v] = nd\n                heapq.heappush(pq, (nd, v))\n    \n    rev_adj = [[] for _ in range(n+1)]\n    for u in range(1, n+1):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n    \n    dist_to_iron = [INF]*(n+1)\n    pq = []\n    for node in iron:\n        dist_to_iron[node] = 0\n        heapq.heappush(pq, (0, node))\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist_to_iron[u]:\n            continue\n        for v in rev_adj[u]:\n            nd = d + 1\n            if nd < dist_to_iron[v]:\n                dist_to_iron[v] = nd\n                heapq.heappush(pq, (nd, v))\n    \n    dist_to_coal = [INF]*(n+1)\n    pq = []\n    for node in coal:\n        dist_to_coal[node] = 0\n        heapq.heappush(pq, (0, node))\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist_to_coal[u]:\n            continue\n        for v in rev_adj[u]:\n            nd = d + 1\n            if nd < dist_to_coal[v]:\n                dist_to_coal[v] = nd\n                heapq.heappush(pq, (nd, v))\n    \n    ans = INF\n    for node in range(1, n+1):\n        if dist_from_start[node] < INF and dist_to_iron[node] < INF and dist_to_coal[node] < INF:\n            total = dist_from_start[node] + dist_to_iron[node] + dist_to_coal[node]\n            if total < ans:\n                ans = total\n    \n    if ans == INF:\n        print(\"impossible\")\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 42.54109477996826}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    sizes = list(map(int, data[1:1+n]))\n    \n    # Precompute prefix sums for quick sum queries\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i+1] = prefix[i] + sizes[i]\n    \n    # DP table: dp[l][r] = min openings to combine dolls from l to r into one group\n    # Initialize with INF\n    INF = 10**9\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Base case: single doll requires 0 openings\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # Fill DP for increasing lengths\n    for length in range(2, n + 1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            # Try all possible split points\n            for k in range(l, r):\n                # Check if the two parts can be valid groups\n                # A valid group must be a consecutive sequence of sizes from 1 to m\n                # We'll check this later when computing final answer\n                # For now, just compute cost of merging two groups\n                cost = dp[l][k] + dp[k+1][r] + (prefix[r+1] - prefix[l])\n                dp[l][r] = min(dp[l][r], cost)\n    \n    # Now we need to partition the entire sequence into valid matryoshka sets\n    # Each set must be a consecutive sequence of sizes from 1 to m\n    # We'll use another DP to find minimum openings for partitioning\n    \n    # First, precompute which intervals are valid matryoshka sets\n    valid = [[False] * n for _ in range(n)]\n    for l in range(n):\n        seen = set()\n        max_size = 0\n        for r in range(l, n):\n            size = sizes[r]\n            if size in seen:\n                break  # Duplicate size in a set is invalid\n            seen.add(size)\n            max_size = max(max_size, size)\n            # Check if we have all sizes from 1 to max_size\n            if len(seen) == max_size:\n                valid[l][r] = True\n    \n    # DP for partitioning: part_dp[i] = min openings to combine first i dolls\n    part_dp = [INF] * (n + 1)\n    part_dp[0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if valid[j][i-1]:\n                part_dp[i] = min(part_dp[i], part_dp[j] + dp[j][i-1])\n    \n    result = part_dp[n]\n    if result >= INF:\n        print(\"impossible\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.814863443374634}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    H, W = map(int, data[0].split())\n    grid = data[1:1+H]\n    \n    # Directions: 8 adjacent positions (row, col)\n    directions = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),           (0, 1),\n        (1, -1),  (1, 0),  (1, 1)\n    ]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n            else:\n                count = 0\n                for dr, dc in directions:\n                    ni, nj = i + dr, j + dc\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                        count += 1\n                row_chars.append(str(count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.952188968658447}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.379475593566895}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Count occurrences of each value in a and b\n    count_a = [0] * (n + 1)\n    count_b = [0] * (n + 1)\n    for val in a:\n        count_a[val] += 1\n    for val in b:\n        count_b[val] += 1\n    \n    # Start with a as base permutation\n    p = a[:]\n    \n    # If there's exactly one differing position\n    if len(diff_positions) == 1:\n        pos = diff_positions[0]\n        # Find missing value (1..n not in p)\n        used = [False] * (n + 1)\n        for val in p:\n            used[val] = True\n        missing = [i for i in range(1, n+1) if not used[i]][0]\n        p[pos] = missing\n    else:\n        # Multiple differing positions\n        # Try each differing position to be the mismatch for a\n        for pos in diff_positions:\n            # Save original value\n            original = p[pos]\n            # Try setting it to b[pos]\n            p[pos] = b[pos]\n            \n            # Check if this creates a valid permutation\n            used = [False] * (n + 1)\n            valid = True\n            for val in p:\n                if used[val]:\n                    valid = False\n                    break\n                used[val] = True\n            \n            # Also check that a and b each have exactly n-1 matches with p\n            matches_a = sum(1 for i in range(n) if a[i] == p[i])\n            matches_b = sum(1 for i in range(n) if b[i] == p[i])\n            \n            if valid and matches_a == n-1 and matches_b == n-1:\n                break\n            \n            # Restore and try next position\n            p[pos] = original\n        \n        # If still not valid (shouldn't happen per problem statement)\n        # Try the other approach: start with b and fix one position\n        if not valid:\n            p = b[:]\n            for pos in diff_positions:\n                original = p[pos]\n                p[pos] = a[pos]\n                \n                used = [False] * (n + 1)\n                valid = True\n                for val in p:\n                    if used[val]:\n                        valid = False\n                        break\n                    used[val] = True\n                \n                matches_a = sum(1 for i in range(n) if a[i] == p[i])\n                matches_b = sum(1 for i in range(n) if b[i] == p[i])\n                \n                if valid and matches_a == n-1 and matches_b == n-1:\n                    break\n                \n                p[pos] = original\n    \n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 39.51984882354736}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    q = int(next(it))\n    results = []\n    for _ in range(q):\n        s = next(it)\n        m = int(next(it))\n        b = [int(next(it)) for _ in range(m)]\n        \n        # Count frequencies of letters in s\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n        \n        # Build t from right to left\n        t = [''] * m\n        used = [False] * m\n        \n        # Process positions where b[i] == 0\n        while True:\n            zero_positions = [i for i in range(m) if not used[i] and b[i] == 0]\n            if not zero_positions:\n                break\n            \n            # Find the largest available letter that can be placed at these positions\n            # We need to check which letters are available in sufficient quantity\n            # to cover all zero positions in this round\n            needed = len(zero_positions)\n            # Find the largest letter with frequency >= needed\n            chosen_letter = -1\n            for letter in range(25, -1, -1):\n                if freq[letter] >= needed:\n                    chosen_letter = letter\n                    break\n            \n            # Place this letter at all zero positions\n            for pos in zero_positions:\n                t[pos] = chr(ord('a') + chosen_letter)\n                used[pos] = True\n                # Update b values for positions to the left and right\n                for j in range(m):\n                    if not used[j]:\n                        b[j] -= abs(pos - j)\n            \n            # Reduce frequency of chosen letter\n            freq[chosen_letter] -= needed\n        \n        results.append(''.join(t))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.14254403114319}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import re\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel according to the rules.\"\"\"\n    return c.upper() in 'AEIOUY'\n\ndef is_consonant(c):\n    \"\"\"Return True if c is a consonant.\"\"\"\n    return c.isalpha() and not is_vowel(c)\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the given rules.\"\"\"\n    # Extract alphabetic part\n    alphabetic = ''.join(ch for ch in word if ch.isalpha())\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    # Convert to uppercase for processing\n    upper = alphabetic.upper()\n    n = len(upper)\n    \n    # Apply silent E rule\n    silent_e = False\n    if n >= 1 and upper[-1] == 'E':\n        if n >= 3 and upper[-2] == 'L' and is_consonant(upper[-3]):\n            # 'able' case - E is not silent\n            silent_e = False\n        else:\n            silent_e = True\n    \n    # Apply ES rule\n    es_silent = False\n    if n >= 2 and upper[-2:] == 'ES':\n        if n >= 3 and is_consonant(upper[-3]):\n            # Check if preceded by two or more consonants\n            cons_count = 0\n            i = n - 3\n            while i >= 0 and is_consonant(upper[i]):\n                cons_count += 1\n                i -= 1\n            if cons_count >= 2:\n                es_silent = False  # 'witches', 'verses'\n            else:\n                es_silent = True   # 'ales', 'pales'\n        else:\n            es_silent = True\n    \n    # Process characters with special rules\n    chars = list(upper)\n    # Handle QU sequence\n    i = 0\n    while i < len(chars) - 1:\n        if chars[i] == 'Q' and chars[i+1] == 'U':\n            chars[i] = 'QU'\n            del chars[i+1]\n        i += 1\n    \n    # Handle Y as consonant when followed by another vowel\n    for i in range(len(chars) - 1):\n        if chars[i] == 'Y' and is_vowel(chars[i+1]) and chars[i+1] != 'Y':\n            chars[i] = 'C'  # Mark as consonant\n    \n    # Mark vowels and consonants\n    vowel_positions = []\n    for i, ch in enumerate(chars):\n        if ch in 'AEIOU' or (ch == 'Y' and (i == len(chars)-1 or not is_vowel(chars[i+1]))):\n            vowel_positions.append(i)\n    \n    if not vowel_positions:\n        return 1\n    \n    # Count syllables based on vowel groups\n    syllables = 1\n    for i in range(1, len(vowel_positions)):\n        prev = vowel_positions[i-1]\n        curr = vowel_positions[i]\n        # Check if there's at least one consonant between them\n        has_consonant = False\n        for j in range(prev+1, curr):\n            if chars[j] not in 'AEIOUY':\n                has_consonant = True\n                break\n        if has_consonant:\n            syllables += 1\n    \n    # Adjust for silent E\n    if silent_e and syllables > 1:\n        syllables -= 1\n    \n    # Adjust for silent ES\n    if es_silent and syllables > 1:\n        syllables -= 1\n    \n    return max(1, syllables)\n\ndef split_haiku(words):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Precompute syllable counts\n    syllable_counts = [count_syllables(w) for w in words]\n    total_syllables = sum(syllable_counts)\n    \n    if total_syllables != 17:\n        return None\n    \n    # Try all possible splits\n    for i in range(1, n):\n        for j in range(i+1, n):\n            line1 = sum(syllable_counts[:i])\n            line2 = sum(syllable_counts[i:j])\n            line3 = sum(syllable_counts[j:])\n            \n            if line1 == 5 and line2 == 7 and line3 == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    \n    return None\n\ndef main():\n    import sys\n    \n    # Read input\n    line = sys.stdin.read().rstrip('\\n')\n    \n    # Split into words using the definition\n    words = []\n    current = ''\n    for ch in line:\n        if ch == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += ch\n    if current:\n        words.append(current)\n    \n    # Try to form haiku\n    result = split_haiku(words)\n    \n    if result:\n        print(result[0])\n        print(result[1])\n        print(result[2])\n    else:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 56.54932236671448}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.603715896606445}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Special case: 1 is the strongest\n    if A == 1 and B != 1:\n        print(\"Alice\")\n    elif B == 1 and A != 1:\n        print(\"Bob\")\n    elif A == B:\n        print(\"Draw\")\n    elif A > B:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.88622522354126}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    values = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        v = int(next(it))\n        p = int(next(it))\n        values[i] = v\n        parent[i] = p\n        if p != 0:\n            children[p].append(i)\n    \n    # DP: dp[node] = size of largest valid subset in subtree rooted at node\n    # that includes node itself\n    dp = [0] * (n + 1)\n    \n    def dfs(u):\n        # For each child, we can either take its best subset that respects\n        # the heap property relative to u, or skip it entirely.\n        # Since we must have v_u > v_child for any child in the subset,\n        # we only consider children with values < values[u].\n        total = 1  # include u itself\n        for v in children[u]:\n            dfs(v)\n            if values[v] < values[u]:\n                total += dp[v]\n        dp[u] = total\n    \n    dfs(1)\n    \n    # The answer is the maximum dp value over all nodes\n    ans = max(dp[1:])\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 23.052112579345703}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    t = int(data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        \n        # Find first position where s[i] != s[(i+1)%n]\n        start = 0\n        while start < n and s[start] == s[(start + 1) % n]:\n            start += 1\n        \n        if start == n:\n            # All characters are same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rearrange string to start at first change\n        s_rotated = s[start:] + s[:start]\n        \n        ans = 0\n        cnt = 1\n        \n        for i in range(1, n):\n            if s_rotated[i] == s_rotated[i - 1]:\n                cnt += 1\n            else:\n                ans += cnt // 3\n                cnt = 1\n        \n        ans += cnt // 3\n        results.append(ans)\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 20.49506974220276}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # Snuke changed exactly one of them to 0\n    # So we look for the position where x[i] != i+1\n    # Since all other values remain unchanged, the changed one will be 0\n    \n    for i in range(5):\n        if x[i] == 0:\n            # Found the zero, output the 1-based index\n            print(i + 1)\n            return\n    \n    # Alternative approach: find where value doesn't match expected\n    # This handles cases where input might not have 0 (though constraints say it will)\n    for i in range(5):\n        if x[i] != i + 1:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 17.33398938179016}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m, k = map(int, data)\n    \n    # The maximum number of bags is (2k+1)^m\n    # Since k can be up to 1e6, we need to compute (2k+1)^m mod MOD efficiently\n    base = (2 * k + 1) % MOD\n    result = pow(base, m, MOD)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 22.435879468917847}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    \n    # Total parking spaces\n    total_spaces = 2 * n - 2\n    \n    # We need exactly n successive cars of the same make\n    # The block of n identical cars can start at positions 0 to total_spaces - n\n    # For each starting position, we have:\n    # 1. Choose the make for the block: 4 choices\n    # 2. The block itself: exactly n cars of that make (1 way)\n    # 3. Remaining spaces: total_spaces - n spaces\n    #    Each remaining space can be filled with any of the 3 other makes\n    #    (since we already used one make for the block)\n    #    So: 3^(remaining_spaces) ways\n    \n    ways = 0\n    remaining_spaces = total_spaces - n\n    for start in range(total_spaces - n + 1):\n        ways += 4 * (3 ** remaining_spaces)\n    \n    print(ways)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 19.708510637283325}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each value\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Check if any value appears more than twice\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Separate values that appear once vs twice\n    once = []\n    twice = []\n    for val, count in sorted(freq.items()):\n        if count == 1:\n            once.append(val)\n        else:  # count == 2\n            twice.append(val)\n    \n    # Build increasing sequence: all once values + first copy of each twice value\n    inc = once[:]  # start with once values\n    for val in twice:\n        inc.append(val)\n    inc.sort()\n    \n    # Build decreasing sequence: second copy of each twice value\n    dec = twice[:]\n    dec.sort(reverse=True)\n    \n    # Verify sequences are strictly monotonic\n    for i in range(1, len(inc)):\n        if inc[i] <= inc[i-1]:\n            print(\"NO\")\n            return\n    for i in range(1, len(dec)):\n        if dec[i] >= dec[i-1]:\n            print(\"NO\")\n            return\n    \n    # Output\n    print(\"YES\")\n    print(len(inc))\n    if inc:\n        print(' '.join(map(str, inc)))\n    else:\n        print()\n    print(len(dec))\n    if dec:\n        print(' '.join(map(str, dec)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.694988012313843}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    M = int(next(it))\n    N = int(next(it))\n    \n    balance = [0] * M\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        p = int(next(it))\n        balance[a] -= p\n        balance[b] += p\n    \n    debts = [x for x in balance if x != 0]\n    if not debts:\n        print(0)\n        return\n    \n    n = len(debts)\n    best = n  # worst case: each debt settled individually\n    \n    # try all subsets of debts that sum to 0\n    for mask in range(1, 1 << n):\n        subset_sum = 0\n        size = 0\n        for i in range(n):\n            if mask & (1 << i):\n                subset_sum += debts[i]\n                size += 1\n        if subset_sum == 0:\n            # this subset can be settled internally with size-1 transactions\n            remaining = n - size\n            transactions = (size - 1) + remaining\n            if transactions < best:\n                best = transactions\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 19.274477005004883}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.525309324264526}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Minimum possible sum: 1 + 2 + 3 + ... + k = k*(k+1)//2\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimal strictly increasing sequence: 1, 2, 3, ..., k\n    a = list(range(1, k + 1))\n    total = min_sum\n    \n    # Distribute the remaining problems (n - total) while maintaining constraints\n    remaining = n - total\n    \n    # We can increase each day's count, but must respect a[i] < a[i+1] <= 2*a[i]\n    # To maximize flexibility, increase from the last day backwards\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] without violating constraints with previous day\n        # For day i (0-indexed), we need a[i] < a[i+1] <= 2*a[i] for i < k-1\n        # When increasing a[i], we must ensure a[i] doesn't exceed floor(a[i+1]/2) for i < k-1\n        # But since we're going backwards, we adjust based on next day's value\n        \n        if i == k - 1:\n            # Last day: no upper bound from next day, only need to keep it positive\n            max_add = remaining\n        else:\n            # For day i, we need a[i] < a[i+1] <= 2*a[i]\n            # So a[i] must be at least ceil(a[i+1]/2) and less than a[i+1]\n            # Actually from a[i] < a[i+1] <= 2*a[i], we get:\n            # a[i] >= ceil(a[i+1]/2) and a[i] < a[i+1]\n            # When increasing a[i], we must ensure a[i] <= a[i+1] - 1\n            # Also, after increase, we need a[i-1] (if exists) to satisfy its constraint with new a[i]\n            # But since we go backwards, we only need to worry about next day's constraint\n            \n            # Maximum a[i] can be is a[i+1] - 1 (to maintain a[i] < a[i+1])\n            max_val = a[i + 1] - 1\n            # Also need a[i+1] <= 2*a[i] => a[i] >= ceil(a[i+1]/2)\n            min_val = (a[i + 1] + 1) // 2  # ceil(a[i+1]/2)\n            \n            # Current a[i] already satisfies min_val <= a[i] < a[i+1]\n            # We can increase up to max_val\n            max_add = max_val - a[i]\n            if max_add < 0:\n                max_add = 0\n        \n        # Add as much as possible\n        add = min(remaining, max_add)\n        a[i] += add\n        remaining -= add\n        \n        if remaining == 0:\n            break\n    \n    # Check if we distributed all remaining problems\n    if remaining > 0:\n        print(\"NO\")\n        return\n    \n    # Verify constraints (should be satisfied by construction)\n    # Double-check sum\n    if sum(a) != n:\n        print(\"NO\")\n        return\n    \n    # Check all constraints\n    for i in range(k):\n        if a[i] <= 0:\n            print(\"NO\")\n            return\n        if i < k - 1:\n            if not (a[i] < a[i + 1] <= 2 * a[i]):\n                print(\"NO\")\n                return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 46.35312080383301}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(x, n, mod):\n    result = 1\n    x %= mod\n    while n > 0:\n        if n & 1:\n            result = (result * x) % mod\n        x = (x * x) % mod\n        n >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Sort values\n    a.sort()\n    \n    total = 0\n    # For each element as maximum in combination\n    for i in range(K-1, N):\n        # Number of ways to choose K-1 smaller elements from i elements\n        ways = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + ways * a[i]) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 29.3017475605011}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Mark rows and columns that contain 'S'\n    row_has_S = [False] * r\n    col_has_S = [False] * c\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                row_has_S[i] = True\n                col_has_S[j] = True\n    \n    # Count rows without S\n    safe_rows = 0\n    for i in range(r):\n        if not row_has_S[i]:\n            safe_rows += 1\n    \n    # Count columns without S\n    safe_cols = 0\n    for j in range(c):\n        if not col_has_S[j]:\n            safe_cols += 1\n    \n    # Total cells from safe rows and columns\n    total = safe_rows * c + safe_cols * r\n    \n    # Subtract double-counted cells (intersections of safe rows and columns)\n    # but only if they are actually '.' (not 'S')\n    double_counted = 0\n    for i in range(r):\n        if not row_has_S[i]:\n            for j in range(c):\n                if not col_has_S[j]:\n                    double_counted += 1\n    \n    result = total - double_counted\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 29.37787175178528}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "runtime_sec": 8.467786073684692}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Helper to check if swapping leads to leading zero\n    def valid_swap(i, j):\n        if i == 0 and n[j] == '0':\n            return False\n        if j == 0 and n[i] == '0':\n            return False\n        return True\n    \n    # Greedy approach with backtracking for exactly k swaps\n    def backtrack(pos, swaps_used):\n        if swaps_used == k or pos == length:\n            return\n        # Find the largest digit from pos+1 to end that can be swapped\n        max_digit = n[pos]\n        max_idx = pos\n        for i in range(pos + 1, length):\n            if n[i] > max_digit and valid_swap(pos, i):\n                max_digit = n[i]\n                max_idx = i\n        if max_idx != pos:\n            # Swap\n            n[pos], n[max_idx] = n[max_idx], n[pos]\n            backtrack(pos + 1, swaps_used + 1)\n            # If we didn't use all swaps, we might need to backtrack\n            if swaps_used + 1 < k:\n                # Try not swapping this position to use swaps later\n                n[pos], n[max_idx] = n[max_idx], n[pos]\n                backtrack(pos + 1, swaps_used)\n        else:\n            backtrack(pos + 1, swaps_used)\n    \n    backtrack(0, 0)\n    # If we have remaining swaps, they must be used (swap same digits if possible)\n    swaps_used = 0\n    # Count swaps made\n    for i in range(length):\n        for j in range(i + 1, length):\n            if n[i] < n[j] and valid_swap(i, j):\n                swaps_used += 1\n    remaining = k - swaps_used\n    # If remaining swaps are odd and we have at least two same digits, we can waste swaps\n    if remaining % 2 == 1:\n        # Check if there's any duplicate digit to waste a swap\n        seen = set()\n        for digit in n:\n            if digit in seen:\n                # We can swap two same digits to waste a swap\n                remaining = 0\n                break\n            seen.add(digit)\n    # If remaining is still odd and >0, we need to adjust\n    if remaining % 2 == 1 and remaining > 0:\n        # Swap last two digits if valid (to use one more swap)\n        if length >= 2 and valid_swap(length - 2, length - 1):\n            n[-1], n[-2] = n[-2], n[-1]\n            remaining -= 1\n    \n    print(''.join(n))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 35.06400990486145}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 30.55525255203247}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    a = [0] + [int(data[i]) for i in range(1, N+1)]  # 1-indexed\n    \n    visited = [False] * (N + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 11.856883764266968}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nimport heapq\n\ndef angle_between(v1, v2):\n    \"\"\"Return angle in degrees between vectors v1 and v2.\"\"\"\n    dot = v1[0]*v2[0] + v1[1]*v2[1]\n    norm1 = math.hypot(v1[0], v1[1])\n    norm2 = math.hypot(v2[0], v2[1])\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    cos_theta = dot / (norm1 * norm2)\n    cos_theta = max(-1.0, min(1.0, cos_theta))\n    return math.degrees(math.acos(cos_theta))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    J = int(next(it))\n    R = int(next(it))\n    D = int(next(it))\n    \n    coords = []\n    for _ in range(J):\n        x = int(next(it))\n        y = int(next(it))\n        coords.append((x, y))\n    \n    adj = [[] for _ in range(J)]\n    for _ in range(R):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n    \n    # Precompute distances between junctions\n    dist_mat = [[0.0]*J for _ in range(J)]\n    for i in range(J):\n        xi, yi = coords[i]\n        for j in range(J):\n            xj, yj = coords[j]\n            dist_mat[i][j] = math.hypot(xi - xj, yi - yj)\n    \n    # Binary search on maximum turning angle\n    EPS = 1e-9\n    low, high = 0.0, 180.0\n    best = None\n    \n    for _ in range(60):  # enough for 1e-18 precision\n        mid = (low + high) / 2\n        # Dijkstra-like BFS with angle constraint\n        INF = float('inf')\n        dist = [INF] * J\n        dist[0] = 0.0\n        pq = [(0.0, 0, -1)]  # (distance, node, prev_node)\n        \n        while pq:\n            d, u, prev = heapq.heappop(pq)\n            if d > dist[u] + EPS:\n                continue\n            if u == J-1 and d <= D + EPS:\n                break\n            for v in adj[u]:\n                new_dist = d + dist_mat[u][v]\n                if new_dist > D + EPS:\n                    continue\n                if prev != -1:\n                    # Compute turning angle\n                    vec1 = (coords[prev][0] - coords[u][0], coords[prev][1] - coords[u][1])\n                    vec2 = (coords[v][0] - coords[u][0], coords[v][1] - coords[u][1])\n                    ang = angle_between(vec1, vec2)\n                    if ang > mid + EPS:\n                        continue\n                if new_dist < dist[v] - EPS:\n                    dist[v] = new_dist\n                    heapq.heappush(pq, (new_dist, v, u))\n        \n        if dist[J-1] <= D + EPS:\n            best = mid\n            high = mid\n        else:\n            low = mid\n    \n    if best is None:\n        print(\"Impossible\")\n    else:\n        print(f\"{best:.8f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 39.18267869949341}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic(a, n, d):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    # sum = n/2 * (2*a + (n-1)*d)\n    n_mod = n % MOD\n    a_mod = a % MOD\n    d_mod = d % MOD\n    term1 = (2 * a_mod + (n_mod - 1) * d_mod) % MOD\n    term2 = n_mod * term1 % MOD\n    # Since n can be odd, multiply by modular inverse of 2\n    inv2 = (MOD + 1) // 2  # 500000004\n    return term2 * inv2 % MOD\n\ndef sum_range(l, r):\n    \"\"\"Return sum of numbers from index l to r (1-based) modulo MOD.\"\"\"\n    def prefix_sum(x):\n        if x == 0:\n            return 0\n        total = 0\n        stage = 1\n        count = 1  # numbers written in current stage\n        start_odd = 1  # first odd number to write\n        start_even = 2  # first even number to write\n        written = 0  # total numbers written so far\n        \n        while written < x:\n            # numbers to write in this stage\n            to_write = min(count, x - written)\n            if stage % 2 == 1:  # odd stage\n                total = (total + sum_arithmetic(start_odd, to_write, 2)) % MOD\n                start_odd += 2 * to_write\n            else:  # even stage\n                total = (total + sum_arithmetic(start_even, to_write, 2)) % MOD\n                start_even += 2 * to_write\n            \n            written += to_write\n            if written < x:\n                # move to next stage\n                count *= 2\n                stage += 1\n        return total\n    \n    return (prefix_sum(r) - prefix_sum(l - 1)) % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    result = sum_range(l, r)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 32.544541120529175}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    min_x = min(x)\n    max_x = max(x)\n    \n    min_total = float('inf')\n    for p in range(min_x, max_x + 1):\n        total = 0\n        for xi in x:\n            diff = xi - p\n            total += diff * diff\n        if total < min_total:\n            min_total = total\n    \n    print(min_total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.718350172042847}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport numpy as np\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return -1\n    it = iter(data)\n    N = int(next(it))\n    L = int(next(it))\n    \n    # Read adjacency matrix\n    adj = []\n    for i in range(N):\n        row = []\n        for j in range(N):\n            row.append(int(next(it)))\n        adj.append(row)\n    \n    # Compute total outgoing connections for each node\n    total_out = [0] * N\n    for i in range(N):\n        total_out[i] = sum(adj[i])\n    \n    # Build transition matrix P\n    P = [[0.0] * N for _ in range(N)]\n    for i in range(N):\n        if total_out[i] > 0:\n            for j in range(N):\n                P[i][j] = adj[i][j] / total_out[i]\n    \n    # Initial state: probability 1 at node 1 (index 0)\n    prob = [0.0] * N\n    prob[0] = 1.0\n    \n    # Check days from L to L+9\n    for T in range(L, L + 10):\n        # Compute probability after T days\n        # Using matrix exponentiation by repeated multiplication\n        # since N <= 100 and T up to 1e6+9, we need efficient method\n        # We'll use exponentiation by squaring on the transition matrix\n        \n        # Convert to numpy for efficient matrix operations\n        P_np = np.array(P, dtype=np.float64)\n        prob_np = np.array(prob, dtype=np.float64)\n        \n        # Matrix exponentiation\n        result = np.eye(N, dtype=np.float64)\n        power = T\n        base = P_np.copy()\n        \n        while power > 0:\n            if power & 1:\n                result = result @ base\n            base = base @ base\n            power >>= 1\n        \n        final_prob = prob_np @ result\n        \n        # Probability at B-ville (node N-1)\n        p_B = final_prob[N-1]\n        \n        # Check if probability is exactly 95% (within floating point tolerance)\n        if abs(p_B - 0.95) < 1e-12:\n            return T\n    \n    return -1\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "runtime_sec": 30.03106951713562}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "from collections import deque\n\ndef bfs_water(R, C, grid, water_queue):\n    water_time = [[-1] * C for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '*':\n                water_queue.append((i, j))\n                water_time[i][j] = 0\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while water_queue:\n        x, y = water_queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if water_time[nx][ny] == -1 and grid[nx][ny] == '.':\n                    water_time[nx][ny] = water_time[x][y] + 1\n                    water_queue.append((nx, ny))\n    return water_time\n\ndef bfs_hedgehog(R, C, grid, start, den, water_time):\n    queue = deque([(start[0], start[1], 0)])\n    visited = [[False] * C for _ in range(R)]\n    visited[start[0]][start[1]] = True\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y, time = queue.popleft()\n        if (x, y) == den:\n            return time\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if not visited[nx][ny] and grid[nx][ny] != 'X' and grid[nx][ny] != '*':\n                    # Check if water reaches this cell at time+1 or later\n                    water_arrival = water_time[nx][ny]\n                    if water_arrival == -1 or water_arrival > time + 1:\n                        visited[nx][ny] = True\n                        queue.append((nx, ny, time + 1))\n    return -1\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip().splitlines()\n    if not input_data:\n        return\n    \n    R, C = map(int, input_data[0].split())\n    grid = [list(line.strip()) for line in input_data[1:1+R]]\n    \n    # Find start and den positions\n    start = None\n    den = None\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                grid[i][j] = '.'  # Treat as empty for water BFS\n            elif grid[i][j] == 'D':\n                den = (i, j)\n    \n    # BFS for water expansion\n    water_queue = deque()\n    water_time = bfs_water(R, C, grid, water_queue)\n    \n    # BFS for hedgehog movement\n    result = bfs_hedgehog(R, C, grid, start, den, water_time)\n    \n    if result == -1:\n        print(\"KAKTUS\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 36.174057960510254}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, w = map(int, data)\n    \n    # Check if possible: min weight = l*1, max weight = l*26\n    if w < l or w > l * 26:\n        print(\"impossible\")\n        return\n    \n    # Start with all 'a's (weight = l)\n    result = ['a'] * l\n    current_weight = l\n    \n    # Distribute extra weight from the end\n    extra = w - l\n    for i in range(l-1, -1, -1):\n        if extra == 0:\n            break\n        # Add as much as possible to this position, max 'z' (26)\n        add = min(extra, 25)  # 25 because 'a' already gives 1\n        result[i] = chr(ord('a') + add)\n        extra -= add\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 16.680362939834595}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 56.30694103240967}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 57.35391306877136}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 55.957900285720825}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    N = int(data[0])\n    L = int(data[1])\n    W = int(data[2])\n    positions = list(map(int, data[3:3+N]))\n    return N, L, W, positions\n\n# Compute minimal total movement\ndef solve():\n    data = read_input()\n    if data is None:\n        return\n    N, L, W, positions = data\n    \n    # Sort positions along left side\n    positions.sort()\n    \n    # Number of pairs\n    M = N // 2\n    \n    # Precompute target positions for left and right sides\n    # Left side: positions 0, 2, ..., N-2 (even indices after sorting)\n    # Right side: positions 1, 3, ..., N-1 (odd indices after sorting)\n    # Target positions along road length\n    spacing = L / (M - 1) if M > 1 else 0\n    target_left = [i * spacing for i in range(M)]\n    target_right = [i * spacing for i in range(M)]\n    \n    # DP table: dp[i][j] = min cost to assign first i left trees to first j left targets\n    # and first (i-j) right trees to first (i-j) right targets\n    INF = float('inf')\n    dp = [[INF] * (M + 1) for _ in range(M + 1)]\n    dp[0][0] = 0.0\n    \n    for i in range(1, N + 1):\n        # Current tree index (0-based in sorted positions)\n        tree_idx = i - 1\n        x = positions[tree_idx]\n        \n        # New DP table for current i\n        new_dp = [[INF] * (M + 1) for _ in range(M + 1)]\n        \n        for left_assigned in range(min(i, M) + 1):\n            right_assigned = i - left_assigned\n            if right_assigned > M:\n                continue\n            \n            # Option 1: assign current tree to left side\n            if left_assigned > 0:\n                target_x = target_left[left_assigned - 1]\n                dist = math.hypot(x - target_x, 0)  # Euclidean distance\n                new_dp[left_assigned][right_assigned] = min(new_dp[left_assigned][right_assigned], \n                                                           dp[left_assigned - 1][right_assigned] + dist)\n            \n            # Option 2: assign current tree to right side\n            if right_assigned > 0:\n                target_x = target_right[right_assigned - 1]\n                dist = math.hypot(x - target_x, W)  # Euclidean distance with road width\n                new_dp[left_assigned][right_assigned] = min(new_dp[left_assigned][right_assigned], \n                                                           dp[left_assigned][right_assigned - 1] + dist)\n        \n        dp = new_dp\n    \n    # Result is dp[M][M] after processing all N trees\n    result = dp[M][M]\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 41.71529841423035}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef get_hand(player_idx, n, s):\n    \"\"\"Return the hand of player at index player_idx\"\"\"\n    return s[player_idx % n]\n\ndef match_winner(hand1, hand2):\n    \"\"\"Return winning hand between hand1 and hand2, or hand1 if draw\"\"\"\n    if hand1 == hand2:\n        return hand1\n    if (hand1 == 'R' and hand2 == 'S') or (hand1 == 'P' and hand2 == 'R') or (hand1 == 'S' and hand2 == 'P'):\n        return hand1\n    return hand2\n\ndef tournament_winner(l, r, n, s):\n    \"\"\"Recursively compute winner's hand for players in range [l, r)\"\"\"\n    if r - l == 1:\n        return get_hand(l, n, s)\n    m = (l + r) // 2\n    left_winner = tournament_winner(l, m, n, s)\n    right_winner = tournament_winner(m, r, n, s)\n    return match_winner(left_winner, right_winner)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    total_players = 1 << k  # 2^k\n    result = tournament_winner(0, total_players, n, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 42.40686058998108}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        \n        # Check for impossible cases\n        if n == 2 or n == 3:\n            out_lines.append(\"-1\")\n            continue\n        \n        # Build permutation\n        perm = []\n        # Start with odd numbers in descending order\n        for i in range(n, 0, -1):\n            if i % 2 == 1:\n                perm.append(i)\n        # Then even numbers in descending order\n        for i in range(n, 0, -1):\n            if i % 2 == 0:\n                perm.append(i)\n        \n        # Verify the permutation satisfies constraints\n        valid = True\n        for i in range(n - 1):\n            diff = abs(perm[i] - perm[i + 1])\n            if diff < 2 or diff > 4:\n                valid = False\n                break\n        \n        if not valid:\n            # Fallback pattern for n >= 4\n            perm = []\n            # Pattern: 2, 4, 1, 3, 6, 8, 5, 7, 10, 12, 9, 11, ...\n            # This works for n >= 4\n            for i in range(2, n + 1, 2):\n                perm.append(i)\n            for i in range(1, n + 1, 2):\n                perm.append(i)\n            \n            # One more verification\n            for i in range(n - 1):\n                diff = abs(perm[i] - perm[i + 1])\n                if diff < 2 or diff > 4:\n                    # This shouldn't happen for n >= 4\n                    out_lines.append(\"-1\")\n                    continue\n        \n        out_lines.append(\" \".join(map(str, perm)))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 27.372117042541504}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each value\n    freq = {}\n    for x in arr:\n        freq[x] = freq.get(x, 0) + 1\n    \n    # Get all unique values\n    values = list(freq.keys())\n    m = len(values)\n    \n    total = 0\n    \n    # Case 1: a_i = a_j = a_k/2 (i.e., a_i + a_i = a_k)\n    for val in values:\n        cnt = freq[val]\n        if cnt >= 2:\n            target = 2 * val\n            if target in freq:\n                # Choose 2 indices for i,j from cnt, and 1 index for k from freq[target]\n                # But i,j must be distinct, so C(cnt,2) * freq[target]\n                ways = (cnt * (cnt - 1) // 2) * freq[target]\n                total += ways\n    \n    # Case 2: a_i != a_j\n    # For each pair of distinct values (val1, val2) where val1 < val2\n    for i in range(m):\n        val1 = values[i]\n        cnt1 = freq[val1]\n        for j in range(i+1, m):\n            val2 = values[j]\n            cnt2 = freq[val2]\n            target = val1 + val2\n            if target in freq:\n                # Choose 1 index for i from cnt1, 1 index for j from cnt2, and 1 index for k from freq[target]\n                ways = cnt1 * cnt2 * freq[target]\n                total += ways\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 28.581469297409058}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x1 -= 1; y1 -= 1; x2 -= 1; y2 -= 1\n    \n    grid = [input().strip() for _ in range(H)]\n    \n    if x1 == x2 and y1 == y2:\n        print(0)\n        return\n    \n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # BFS with direction optimization\n    # For each direction, we can move up to K steps without increasing stroke count\n    # We'll use 4 queues for each direction\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # east, south, west, north\n    \n    # We'll use a single queue but track direction separately\n    q = collections.deque()\n    q.append((x1, y1))\n    \n    while q:\n        x, y = q.popleft()\n        current_dist = dist[x][y]\n        \n        # Try all 4 directions\n        for dx, dy in dirs:\n            # Move up to K steps in this direction\n            for step in range(1, K + 1):\n                nx, ny = x + dx * step, y + dy * step\n                \n                # Check bounds\n                if not (0 <= nx < H and 0 <= ny < W):\n                    break\n                \n                # Check for lotus leaf\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    q.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # If the distance is already better, we can stop in this direction\n                    # because further cells in this direction would have been reached\n                    # with equal or better distance\n                    break\n            \n    result = dist[x2][y2]\n    print(-1 if result == INF else result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 33.366798877716064}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    shares = 0\n    avg_cost = 0.0\n    total_profit = 0.0\n    \n    for line in data:\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == \"buy\":\n            x = int(parts[1])\n            y = int(parts[2])\n            # Update average cost using weighted average\n            total_cost = shares * avg_cost + x * y\n            shares += x\n            avg_cost = total_cost / shares if shares > 0 else 0.0\n            \n        elif cmd == \"sell\":\n            x = int(parts[1])\n            y = int(parts[2])\n            # Calculate profit from sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                total_profit += x * profit_per_share\n            shares -= x\n            # Average cost remains unchanged after sale\n            \n        elif cmd == \"split\":\n            x = int(parts[1])\n            shares *= x\n            avg_cost /= x\n            \n        elif cmd == \"merge\":\n            x = int(parts[1])\n            # Calculate how many shares can be merged\n            merged_shares = shares // x\n            remainder = shares % x\n            \n            # Sell remainder shares at current average cost\n            if remainder > 0:\n                profit_per_share = avg_cost - avg_cost  # Always 0 since selling at avg_cost\n                # No profit/loss when selling at average cost\n                shares -= remainder\n            \n            # Perform merge on remaining shares\n            shares = merged_shares\n            avg_cost *= x\n            \n        elif cmd == \"die\":\n            y = int(parts[1])\n            # Calculate profit from final sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                total_profit += shares * profit_per_share\n            \n            # Calculate final amount after taxes\n            tax = total_profit * 0.3\n            final_amount = shares * y - tax\n            print(f\"{final_amount:.10f}\")\n            return\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 27.012874841690063}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank):\n    rx, ry = find(x, parent), find(y, parent)\n    if rx == ry:\n        return\n    if rank[rx] < rank[ry]:\n        parent[rx] = ry\n    elif rank[rx] > rank[ry]:\n        parent[ry] = rx\n    else:\n        parent[ry] = rx\n        rank[rx] += 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N, M = int(data[idx]), int(data[idx+1])\n    idx += 2\n    \n    parent = list(range(N))\n    rank = [0] * N\n    edges = []\n    \n    for _ in range(M):\n        a = int(data[idx]); idx += 1\n        op = data[idx]; idx += 1\n        b = int(data[idx]); idx += 1\n        if op == '=':\n            union(a, b, parent, rank)\n        else:  # '>'\n            edges.append((a, b))\n    \n    # compress all parents after unions\n    for i in range(N):\n        find(i, parent)\n    \n    # build adjacency list for DAG\n    adj = [[] for _ in range(N)]\n    indeg = [0] * N\n    for a, b in edges:\n        ra, rb = find(a, parent), find(b, parent)\n        if ra == rb:\n            print(\"inconsistent\")\n            return\n        adj[ra].append(rb)\n        indeg[rb] += 1\n    \n    # topological sort to detect cycle\n    from collections import deque\n    q = deque([i for i in range(N) if indeg[i] == 0 and parent[i] == i])\n    processed = 0\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    # count distinct roots that were in the graph\n    roots_in_graph = set()\n    for a, b in edges:\n        roots_in_graph.add(find(a, parent))\n        roots_in_graph.add(find(b, parent))\n    \n    if processed == len(roots_in_graph):\n        print(\"consistent\")\n    else:\n        print(\"inconsistent\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 30.83866572380066}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = list(data[2])\n    \n    idx = 3\n    for _ in range(m):\n        l = int(data[idx]) - 1\n        r = int(data[idx + 1]) - 1\n        c1 = data[idx + 2]\n        c2 = data[idx + 3]\n        idx += 4\n        \n        for i in range(l, r + 1):\n            if s[i] == c1:\n                s[i] = c2\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 14.975606918334961}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def is_k_periodic(s, k):\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    # First substring\n    prev = s[:k]\n    \n    # Check each subsequent block\n    for i in range(k, n, k):\n        current = s[i:i+k]\n        # Check if current is right-rotation of prev\n        if current != prev[-1] + prev[:-1]:\n            return False\n        prev = current\n    \n    return True\n\ndef main():\n    s = input().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if is_k_periodic(s, k):\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 15.589527130126953}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    b = int(data[0])\n    d = int(data[1])\n    \n    # Since d is prime, we need to check if there exists m such that:\n    # b^m ≡ 1 (mod d) OR b^m ≡ -1 (mod d)\n    # This is because the alternating sum corresponds to evaluating n mod (b^m + 1) or (b^m - 1)\n    # For the hack to work for all n, we need d to divide either (b^m - 1) or (b^m + 1)\n    \n    # Check small m up to a reasonable limit (since d < 2^63, we can check up to d)\n    # Actually, by Fermat's little theorem, b^(d-1) ≡ 1 (mod d) if gcd(b,d)=1\n    # Since d is prime and b>1, gcd(b,d)=1 unless d divides b\n    \n    if b % d == 0:\n        # If d divides b, then only m=1 might work? Let's analyze:\n        # For m=1, f = a0 - a1 + a2 - a3 + ... = n mod (b+1) if alternating signs\n        # Actually when d divides b, we need to check if d divides (b^m ± 1) for some m\n        # Since d divides b, b ≡ 0 mod d, so b^m ≡ 0 mod d for m≥1\n        # Then b^m ± 1 ≡ ±1 mod d, which is never 0 mod d since d>1\n        # So no m works\n        print(\"no\")\n        return\n    \n    # Use modular exponentiation to check m from 1 to d-1\n    # Actually by Lagrange's theorem, the multiplicative order of b mod d divides d-1\n    # So we only need to check divisors of d-1\n    \n    # Find all divisors of d-1\n    divisors = []\n    limit = int(math.isqrt(d-1))\n    for i in range(1, limit+1):\n        if (d-1) % i == 0:\n            divisors.append(i)\n            if i != (d-1)//i:\n                divisors.append((d-1)//i)\n    divisors.sort()\n    \n    # Check each divisor as potential m\n    for m in divisors:\n        # Compute b^m mod d\n        pow_mod = pow(b, m, d)\n        if pow_mod == 1 or pow_mod == d-1:  # d-1 ≡ -1 mod d\n            print(\"yes\")\n            return\n    \n    # Also need to check m that are not divisors of d-1?\n    # Actually if b^m ≡ ±1 mod d, then the order of b divides 2m\n    # And the order divides d-1 (since d is prime)\n    # So m must be such that either:\n    # 1. b^m ≡ 1 mod d → order of b divides m\n    # 2. b^m ≡ -1 mod d → order of b divides 2m but not m\n    # In either case, the order divides 2m, and since order divides d-1,\n    # we have that some divisor of d-1 must work\n    \n    # One more check: m could be a multiple of the order\n    # But if order divides m, then b^m ≡ 1 mod d\n    # So we've already checked all divisors of d-1, which includes the order\n    \n    print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 44.13994288444519}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef fenwick_update(tree, idx, delta, n):\n    \"\"\"Update Fenwick tree: add delta to element at idx (0-based).\"\"\"\n    i = idx + 1  # convert to 1-based index for Fenwick tree\n    while i <= n:\n        tree[i] += delta\n        i += i & -i\n\ndef fenwick_query(tree, idx):\n    \"\"\"Query prefix sum up to idx (0-based, exclusive).\"\"\"\n    if idx <= 0:\n        return 0\n    i = idx  # idx is already exclusive upper bound\n    res = 0\n    while i > 0:\n        res += tree[i]\n        i -= i & -i\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    # Fenwick tree (1-indexed, size n+1)\n    tree = [0] * (n + 1)\n    out_lines = []\n    \n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            fenwick_update(tree, i, delta, n)\n        else:  # op == '?'\n            i = int(next(it))\n            # query prefix sum up to i (exclusive)\n            res = fenwick_query(tree, i)\n            out_lines.append(str(res))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 22.187064170837402}

{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.78446531295776}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build the string\n    s = []\n    # Track current character\n    cur_char = 'a'\n    # We'll process from length n down to 1\n    # For each length i, we need to ensure exactly c[i-1] substrings of length i\n    # We can think of it as: we need to create runs of identical characters\n    # The number of runs of length >= i contributes to c[i-1]\n    # Specifically, if we have a run of length L, it contributes L-i+1 substrings of length i\n    # So we need to arrange runs such that sum over runs of max(0, L-i+1) = c[i-1]\n    # We'll build runs greedily from the end\n    \n    # We'll maintain how many runs of each length we need to create\n    # Actually, we can work backwards: for i from n down to 1\n    # Let needed = c[i-1]\n    # Subtract contributions from already placed runs\n    # Then create new runs to satisfy the remaining needed\n    \n    # We'll store runs as (length, char)\n    runs = []\n    \n    # Process from longest substring length to shortest\n    for i in range(n, 0, -1):\n        needed = c[i-1]\n        # Subtract contributions from existing runs\n        for length, _ in runs:\n            if length >= i:\n                needed -= (length - i + 1)\n        # If needed > 0, we need to create new runs\n        while needed > 0:\n            # Create a run of length i\n            runs.append((i, cur_char))\n            needed -= 1\n            # Move to next character\n            cur_char = chr(ord(cur_char) + 1)\n            if cur_char > 'z':\n                cur_char = 'a'  # Wrap around if needed, though unlikely with n<=2000\n    \n    # Now we have runs, but they might be in wrong order\n    # We need to arrange them to satisfy all c[i]\n    # Actually, the order doesn't matter for the count of substrings of same letters\n    # Because substrings are counted regardless of position\n    # So we can just concatenate all runs\n    \n    # But wait: we need to verify that with these runs, all c[i] are satisfied\n    # Let's compute c from runs and compare\n    # This is for verification only\n    computed_c = [0]*n\n    for length, _ in runs:\n        for i in range(1, length+1):\n            computed_c[i-1] += (length - i + 1)\n    \n    # If verification fails, we might need to adjust\n    # But problem guarantees answer exists\n    # Our greedy approach should work\n    \n    # Build the string by concatenating runs\n    result = []\n    for length, char in runs:\n        result.append(char * length)\n    s = ''.join(result)\n    \n    # If length is not n, pad with distinct characters\n    # This shouldn't happen with our construction\n    while len(s) < n:\n        s += cur_char\n        cur_char = chr(ord(cur_char) + 1)\n        if cur_char > 'z':\n            cur_char = 'a'\n    \n    # Trim if longer (shouldn't happen)\n    s = s[:n]\n    \n    print(s)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.01801300048828}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 48.22927927970886}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    seq = list(map(int, data[1:1+n]))\n    \n    # Node structure: (value, left_index, right_index, depth)\n    # Using arrays for O(1) access\n    values = [0] * (n + 1)\n    left = [-1] * (n + 1)\n    right = [-1] * (n + 1)\n    depths = [0] * (n + 1)\n    \n    root = -1\n    total_depth = 0\n    results = []\n    \n    for i, val in enumerate(seq):\n        if root == -1:\n            root = i\n            values[i] = val\n            depths[i] = 0\n            results.append(total_depth)\n            continue\n        \n        # Traverse to find insertion point\n        current = root\n        depth = 0\n        while True:\n            depth += 1\n            if val < values[current]:\n                if left[current] == -1:\n                    left[current] = i\n                    values[i] = val\n                    depths[i] = depth\n                    total_depth += depth\n                    break\n                else:\n                    current = left[current]\n            else:  # val > values[current]\n                if right[current] == -1:\n                    right[current] = i\n                    values[i] = val\n                    depths[i] = depth\n                    total_depth += depth\n                    break\n                else:\n                    current = right[current]\n        \n        results.append(total_depth)\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.004729986190796}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "TLE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.5640573501587}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy one cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining // B\n    remaining -= donuts_count * B\n    \n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.315757036209106}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.68917679786682}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\n\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Preprocess: sort indices by value descending, then by index ascending\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))\n\n# For each k, compute the optimal subsequence indices\n# We need to answer queries for different k values\n# Strategy: for each k, take first k indices from sorted list, then sort them by original position\n# But we need to answer many queries efficiently\n\n# Precompute for all possible k (1..n)\n# Store for each k: list of indices in the optimal subsequence (sorted by original position)\n# But storing all would be O(n^2) memory - too much\n\n# Instead, we can process queries offline sorted by k\n# Build the optimal subsequence incrementally as k increases\n\n# Sort queries by k\nsorted_queries = sorted(enumerate(queries), key=lambda x: x[1][0])\nanswers = [0] * m\n\n# We'll maintain a min-heap of selected indices (by original position)\n# And a max-heap of candidate indices (by value, then index)\n# Actually simpler: we can build the optimal subsequence for each k\n# by taking the k largest values, and for ties, take the earliest indices\n\n# Precompute: for each index i, store its rank when sorted by (-value, index)\n# The optimal subsequence for k consists of the first k elements in this sorted order,\n# then sorted by original index\n\n# Let's create an array that tells us for each position in original array,\n# whether it's selected for a given k\n# We can process k from 1 to n incrementally\n\n# First, sort indices by (-value, index)\nsorted_by_value = sorted(range(n), key=lambda i: (-a[i], i))\n\n# selected[i] = True if a[i] is in optimal subsequence for current k\nselected = [False] * n\n# We'll maintain a list of selected indices in original order\nselected_indices = []\n\n# We'll use a Fenwick tree or similar to answer \"k-th selected\" queries\n# But simpler: we can just maintain a sorted list of selected indices\n# and use binary search to find the pos-th element\n\nimport bisect\n\nquery_idx = 0\nfor k in range(1, n + 1):\n    # Add the k-th element (in sorted_by_value order) to selected\n    new_idx = sorted_by_value[k - 1]\n    selected[new_idx] = True\n    # Insert into selected_indices maintaining sorted order\n    bisect.insort(selected_indices, new_idx)\n    \n    # Answer all queries with this k\n    while query_idx < len(sorted_queries) and sorted_queries[query_idx][1][0] == k:\n        orig_idx, (_, pos) = sorted_queries[query_idx]\n        # pos is 1-based, convert to 0-based\n        selected_pos = selected_indices[pos - 1]\n        answers[orig_idx] = a[selected_pos]\n        query_idx += 1\n\n# Output answers in original order\noutput = '\\n'.join(map(str, answers))\nsys.stdout.write(output)\n", "complexity_estimate": null, "runtime_sec": 73.49657583236694}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data)\n    \n    # Check if solution exists\n    if k == 1:\n        print(\"NO\")\n        return\n    \n    # For n > k*(k-1), impossible because we need distinct pairs with b_i != g_i\n    # Maximum distinct pairs with b_i != g_i is k*(k-1)\n    if n > k * (k - 1):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using two sequences\n    # We'll generate all possible (b, g) pairs with b != g\n    # Then take first n of them in a specific order to satisfy adjacency constraints\n    \n    pairs = []\n    # Generate in a pattern that ensures adjacent pairs differ in both coordinates\n    # We'll use two indices i and j that cycle through colors\n    \n    # First generate base sequence: (1,2), (2,3), ..., (k-1,k), (k,1)\n    # Then offset sequences\n    \n    # We need to generate exactly n pairs\n    count = 0\n    for offset in range(k-1):\n        if count >= n:\n            break\n        for start in range(1, k+1):\n            if count >= n:\n                break\n            b = start\n            g = ((start + offset) % k) + 1\n            if b == g:\n                continue\n            pairs.append((b, g))\n            count += 1\n            if count >= n:\n                break\n    \n    # Output the pairs\n    for b, g in pairs:\n        print(f\"{b} {g}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.412245750427246}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 59.48590397834778}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.03543543815613}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.1517162322998}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 86.81595516204834}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for length in l:\n        g = math.gcd(g, length)\n    \n    # If gcd > 1, impossible to reach all cells\n    if g > 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd_value] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting with gcd 0 (meaning no cards selected yet)\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for current_gcd, cost in dp.items():\n            new_gcd = math.gcd(current_gcd, l[i])\n            new_cost = cost + c[i]\n            if new_cost < new_dp[new_gcd]:\n                new_dp[new_gcd] = new_cost\n        dp = new_dp\n    \n    # The minimal cost to achieve gcd=1\n    result = dp.get(1, float('inf'))\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.897729635238647}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Calculate required time to travel D meters at speed S\n    # Since all values are integers, we compare D <= T * S to avoid floating point\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.2055823802948}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nsys.setrecursionlimit(200000)\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    it = iter(data)\\r\\n    k = int(next(it))\\r\\n    n = int(next(it))\\r\\n    \\r\\n    adj = [[] for _ in range(n)]\\r\\n    for i in range(n):\\r\\n        d = int(next(it))\\r\\n        for _ in range(d):\\r\\n            neighbor = int(next(it)) - 1  # convert to 0‑based\\r\\n            adj[i].append(neighbor)\\r\\n    \\r\\n    # DP on tree (forest) with independent set\\r\\n    # dp[node][0] = max independent set size in subtree when node is NOT taken\\r\\n    # dp[node][1] = max independent set size when node IS taken\\r\\n    dp0 = [0] * n\\r\\n    dp1 = [0] * n\\r\\n    visited = [False] * n\\r\\n    \\r\\n    def dfs(u, parent):\\r\\n        visited[u] = True\\r\\n        dp1[u] = 1  # take u\\r\\n        dp0[u] = 0  # not take u\\r\\n        for v in adj[u]:\\r\\n            if v == parent:\\r\\n                continue\\r\\n            dfs(v, u)\\r\\n            dp0[u] += max(dp0[v], dp1[v])  # u not taken → v free\\r\\n            dp1[u] += dp0[v]               # u taken → v must not be taken\\r\\n    \\r\\n    total_max = 0\\r\\n    for i in range(n):\\r\\n        if not visited[i]:\\r\\n            dfs(i, -1)\\r\\n            total_max += max(dp0[i], dp1[i])\\r\\n    \\r\\n    # Check feasibility\\r\\n    if k <= total_max:\\r\\n        print(\"possible\")\\r\\n    else:\\r\\n        print(\"impossible\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 380, 381, 'illegal multibyte sequence')", "runtime_sec": 29.66732144355774}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.49619817733765}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.94440460205078}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 144.63019323349}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.40232729911804}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.00647068023682}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.9212474822998}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Prefix sum array for efficient range updates\n    prefix = [0] * (n + 1)\n    days_used = 0\n    current_increment = 0\n    \n    for i in range(n):\n        # Apply previous increments to current position\n        current_increment += prefix[i]\n        current_height = heights[i] + current_increment\n        \n        # If current height is below target, need to water\n        if current_height < target:\n            needed = target - current_height\n            days_used += needed\n            if days_used > m:\n                return False\n            \n            # Water w flowers starting from i\n            current_increment += needed\n            end = min(i + w, n)\n            prefix[end] -= needed\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3+n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = min(heights) + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.221245288848877}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.518968105316162}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.81405687332153}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.90485095977783}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 41.77927613258362}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245066 tokens (243466 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 12.65661883354187}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (2^4 - 1)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.141879558563232}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    seen = set()\n    result = []\n    for i in range(n - 1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.613005876541138}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.63131165504456}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper: compute final score given fifth time t5\n    def final_score(t5: float) -> float:\n        all_times = sorted(times + [t5])\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Check if already winning regardless of t5\n    # The worst case for Claire is when t5 is very large, which pushes the largest of the first four into the middle three.\n    # Simulate with t5 = 20.0 (maximum possible) to see if she still wins.\n    if final_score(20.0) <= target:\n        print(\"infinite\")\n        return\n    \n    # Check if impossible to win\n    # The best case for Claire is when t5 is very small, which pushes the smallest of the first four out of the middle three.\n    # Simulate with t5 = 1.0 (minimum possible) to see if she can win.\n    if final_score(1.0) > target:\n        print(\"impossible\")\n        return\n    \n    # Binary search for the maximum t5 that still yields final_score <= target\n    lo, hi = 1.0, 20.0\n    for _ in range(100):  # Sufficient precision for 2 decimal places\n        mid = (lo + hi) / 2.0\n        if final_score(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Output to exactly two decimal places\n    print(f\"{lo:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.88207221031189}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 9.591037273406982}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.5630476474762}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            sys.stdout.write(s)\n            return\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.59501051902771}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data[:2])\n    # Total cost = train fare + half of bus fare\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.309221267700195}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    lines = data[1:]\n    \n    # Stack to track events that have happened (not dreams)\n    event_stack = []\n    # Set of events that have happened in current reality\n    happened = set()\n    # List to store results for scenarios\n    results = []\n    \n    for line in lines:\n        parts = line.split()\n        if not parts:\n            continue\n        \n        if parts[0] == 'E':\n            # Event happens\n            event = parts[1]\n            event_stack.append(event)\n            happened.add(event)\n            \n        elif parts[0] == 'D':\n            # Dream: remove last r events\n            r = int(parts[1])\n            for _ in range(r):\n                if event_stack:\n                    event = event_stack.pop()\n                    happened.remove(event)\n            \n        elif parts[0] == 'S':\n            # Scenario\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current reality\n            consistent_current = True\n            for event_spec in scenario_events:\n                if event_spec.startswith('!'):\n                    # Event should NOT have happened\n                    event_name = event_spec[1:]\n                    if event_name in happened:\n                        consistent_current = False\n                        break\n                else:\n                    # Event should have happened\n                    if event_spec not in happened:\n                        consistent_current = False\n                        break\n            \n            if consistent_current:\n                results.append(\"Yes\")\n                continue\n            \n            # If not consistent with current reality, check if adding a dream makes it consistent\n            # We need to find smallest r such that removing last r events makes scenario consistent\n            min_r = None\n            \n            # Try all possible r from 1 to len(event_stack)\n            for r in range(1, len(event_stack) + 1):\n                # Create temporary sets for checking\n                temp_happened = happened.copy()\n                temp_stack = event_stack.copy()\n                \n                # Remove last r events\n                for _ in range(r):\n                    if temp_stack:\n                        event = temp_stack.pop()\n                        temp_happened.remove(event)\n                \n                # Check if scenario is consistent with this temporary reality\n                consistent = True\n                for event_spec in scenario_events:\n                    if event_spec.startswith('!'):\n                        event_name = event_spec[1:]\n                        if event_name in temp_happened:\n                            consistent = False\n                            break\n                    else:\n                        if event_spec not in temp_happened:\n                            consistent = False\n                            break\n                \n                if consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                results.append(f\"{min_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    # Output all results\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 37.407771587371826}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213643 tokens (212043 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 10.466568946838379}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input values P, Q, R\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data[:3])\n    \n    # The route involves exactly two flights between three airports.\n    # We need to consider all possible ordered pairs of flights that visit all three airports.\n    # Since flights are bidirectional, the order matters for the sum.\n    # The possible sums are:\n    # 1. A->B then B->C: P + Q\n    # 2. A->C then C->B: R + Q\n    # 3. B->A then A->C: P + R\n    # 4. B->C then C->A: Q + R\n    # 5. C->A then A->B: R + P\n    # 6. C->B then B->A: Q + P\n    # Note that some sums are duplicates due to symmetry.\n    # The distinct sums are: P+Q, Q+R, R+P.\n    # Therefore, the minimum is min(P+Q, Q+R, R+P).\n    \n    # Compute the three possible sums\n    sum1 = P + Q\n    sum2 = Q + R\n    sum3 = R + P\n    \n    # Find the minimum\n    result = min(sum1, sum2, sum3)\n    \n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.0030837059021}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.23262405395508}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 68.97607040405273}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        a = [int(next(it)) for _ in range(n)]\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        out_lines.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.117565155029297}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.90399217605591}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.23603320121765}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(data[idx]); idx += 1\n        # Count days when participant eats chocolate\n        # Days: 1, A+1, 2A+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A\n    \n    # Initial chocolate = eaten + remaining\n    initial = total_eaten + X\n    print(initial)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.54886794090271}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        if self.size[x_root] < self.size[y_root]:\n            x_root, y_root = y_root, x_root\n        self.parent[y_root] = x_root\n        self.size[x_root] += self.size[y_root]\n        self.components -= 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    capacities = [int(next(it)) for _ in range(n)]\n    \n    dsu = DSU(n)\n    degree = [0] * n\n    \n    # Process existing edges\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        degree[u] += 1\n        degree[v] += 1\n        dsu.union(u, v)\n    \n    # Check capacity constraints\n    for i in range(n):\n        if degree[i] > capacities[i]:\n            print(\"no\")\n            return\n    \n    # Calculate needed edits\n    needed_edits = 0\n    \n    # 1. Remove edges to free capacity if needed\n    for i in range(n):\n        if degree[i] < capacities[i]:\n            needed_edits += capacities[i] - degree[i]\n    \n    # 2. Connect components\n    needed_edits += max(0, dsu.components - 1)\n    \n    # Check if possible within k edits\n    if needed_edits <= k:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 101.26436758041382}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.25380492210388}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.2874083518982}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.27001929283142}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.394421339035034}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Process each element\n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            # Even numbers: subtract 1\n            result.append(x - 1)\n        else:\n            # Odd numbers: remain unchanged\n            result.append(x)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.47454309463501}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    target = \"ThoreHusfeldt\"\n    target_idx = names.index(target)\n    \n    # Check if ThoreHusfeldt is first\n    if target_idx == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check for ThoreHusfeld prefix above\n    above_names = names[:target_idx]\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    for prefix_len in range(1, len(target) + 1):\n        prefix = target[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Should never reach here given problem constraints\n    print(target)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.661255836486816}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.55693173408508}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.63050413131714}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.90296339988708}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); x = int(data[idx+1]); y = int(data[idx+2])\n        idx += 3\n        \n        # Nikolay's total score\n        total = x + y\n        \n        # Minimum possible place: 1 if total <= n+1, otherwise total - n\n        min_place = max(1, total - n + 1)\n        \n        # Maximum possible place: min(n, total - 1)\n        max_place = min(n, total - 1)\n        \n        # Adjust for edge cases\n        if min_place > n:\n            min_place = n\n        if max_place < 1:\n            max_place = 1\n        \n        results.append(f\"{min_place} {max_place}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.06081986427307}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    \"\"\"Find the largest bus number <= m.\"\"\"\n    # Dictionary to count ways: key = sum of cubes, value = count of ways\n    ways = {}\n    \n    # We only need to consider i and j where i^3 + j^3 <= m\n    # Since i and j are positive, start from 1\n    # Upper bound for i: i^3 <= m => i <= m^(1/3)\n    max_i = int(m ** (1/3)) + 1  # +1 to be safe\n    \n    for i in range(1, max_i + 1):\n        i_cubed = i ** 3\n        # If i^3 already exceeds m, break (but loop condition handles this)\n        if i_cubed > m:\n            break\n        \n        for j in range(i, max_i + 1):  # j starts from i to avoid duplicate pairs\n            sum_cubes = i_cubed + j ** 3\n            if sum_cubes > m:\n                break\n            \n            # Increment count for this sum\n            ways[sum_cubes] = ways.get(sum_cubes, 0) + 1\n    \n    # Find the largest number with count >= 2\n    largest_bus = -1\n    for num, count in ways.items():\n        if count >= 2 and num > largest_bus:\n            largest_bus = num\n    \n    return largest_bus if largest_bus != -1 else None\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    result = find_largest_bus_number(m)\n    if result is None:\n        print(\"none\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.82929229736328}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.40152859687805}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.30463767051697}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive_time, calm_time):\n    \"\"\"Return True if dog is aggressive at arrival minute.\"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival % cycle_length\n    # Aggressive during first aggressive_time minutes of cycle\n    return 0 < position_in_cycle <= aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    arrivals = [P, M, G]\n    results = []\n    \n    for arrival in arrivals:\n        dog1 = is_aggressive(arrival, A, B)\n        dog2 = is_aggressive(arrival, C, D)\n        \n        if dog1 and dog2:\n            results.append('both')\n        elif dog1 or dog2:\n            results.append('one')\n        else:\n            results.append('none')\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 18.42908215522766}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if word matches its mirror reflection.\"\"\"\n    # Define mirror mapping for capital letters\n    mirror_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O',\n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',\n        'Y': 'Y'\n    }\n    \n    n = len(word)\n    # Check each character and its mirror position\n    for i in range((n + 1) // 2):\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Both characters must be mirror-symmetric letters\n        if left_char not in mirror_map or right_char not in mirror_map:\n            return False\n        # Mirror reflection must match\n        if mirror_map[left_char] != right_char:\n            return False\n    \n    return True\n\ndef main():\n    # Read input (strip newline, handle possible trailing spaces)\n    word = sys.stdin.readline().strip()\n    \n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.394338130950928}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.55652713775635}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef determine_winner(record):\n    \"\"\"Determine winner from scoring record.\"\"\"\n    alice_score = 0\n    barbara_score = 0\n    \n    i = 0\n    while i < len(record):\n        player = record[i]\n        points = int(record[i+1])\n        \n        if player == 'A':\n            alice_score += points\n        else:  # player == 'B'\n            barbara_score += points\n        \n        # Check win conditions\n        if alice_score >= 11 and alice_score - barbara_score >= 2:\n            return 'A'\n        if barbara_score >= 11 and barbara_score - alice_score >= 2:\n            return 'B'\n        \n        # Special case: tie at 10-10\n        if alice_score >= 10 and barbara_score >= 10:\n            if alice_score - barbara_score >= 2:\n                return 'A'\n            if barbara_score - alice_score >= 2:\n                return 'B'\n        \n        i += 2\n    \n    # Should never reach here for valid input\n    return None\n\ndef main():\n    record = sys.stdin.readline().strip()\n    winner = determine_winner(record)\n    print(winner)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.609686374664307}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.84646916389465}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    win_first = 0\n    draw = 0\n    win_second = 0\n    \n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        if diff_a < diff_b:\n            win_first += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            win_second += 1\n    \n    print(f\"{win_first} {draw} {win_second}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.499876499176025}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Map each value to its position in the sequence [4,8,15,16,23,42]\n    pos = {4:0, 8:1, 15:2, 16:3, 23:4, 42:5}\n    \n    # Count how many complete sequences we can form\n    # cnt[i] = number of times we have seen the i-th element waiting for the next one\n    cnt = [0]*6\n    \n    for x in a:\n        idx = pos[x]\n        if idx == 0:\n            cnt[0] += 1\n        else:\n            if cnt[idx-1] > 0:\n                cnt[idx-1] -= 1\n                cnt[idx] += 1\n    \n    # cnt[5] contains number of complete sequences\n    complete = cnt[5]\n    total_elements_kept = complete * 6\n    removed = n - total_elements_kept\n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.173973321914673}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123811 tokens (2122211 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 18.06278896331787}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.98945140838623}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.2591016292572}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.61408162117004}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.7640700340271}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Since moving by 2 is free, chips can be moved to any coordinate with same parity\n    # as their original coordinate without paying coins.\n    # So we only need to consider moving chips to either an even or odd coordinate.\n    # For each chip, if its parity matches the target parity, cost is 0.\n    # Otherwise, we need to pay 1 coin to adjust parity by moving 1 step.\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for pos in x if pos % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller of moving all to even or all to odd\n    answer = min(even_count, odd_count)\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.281654119491577}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 51.88636898994446}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # water[i] stores current water in vessel i+1\n    water = [0] * n\n    \n    out_lines = []\n    for _ in range(m):\n        query_type = int(next(it))\n        if query_type == 1:\n            p = int(next(it)) - 1  # 0-indexed\n            x = int(next(it))\n            \n            # Pour water into vessel p\n            while p < n and x > 0:\n                space = capacities[p] - water[p]\n                if x <= space:\n                    water[p] += x\n                    x = 0\n                else:\n                    water[p] = capacities[p]\n                    x -= space\n                    p += 1\n        else:  # query_type == 2\n            k = int(next(it)) - 1  # 0-indexed\n            out_lines.append(str(water[k]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.59715700149536}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = int(data[1])\n    e = list(map(int, data[2:2+n]))\n    \n    # Sort Finni's fleet sizes in ascending order\n    e.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    # Try to win battles with minimal ship expenditure\n    for enemy_ships in e:\n        # Minimum ships needed to win this battle\n        needed = enemy_ships + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            # Can't win more battles\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.966133832931519}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.69227862358093}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    \n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b\n    # Since a and b are integers, k * b must be integer and within [l, r]\n    \n    # Iterate over possible b values\n    for b in range(x, y + 1):\n        a = k * b\n        if l <= a <= r:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.749411582946777}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 140.49617838859558}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s: str) -> int:\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev, curr = suffix[i-1], suffix[i]\n            tmp[curr] = tmp[prev]\n            if (rank[prev], rank[prev + k] if prev + k < n else -1) != \\\n               (rank[curr], rank[curr + k] if curr + k < n else -1):\n                tmp[curr] += 1\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # LCP array construction using Kasai's algorithm\n    lcp = [0] * n\n    inv = [0] * n\n    for i in range(n):\n        inv[suffix[i]] = i\n    k = 0\n    for i in range(n):\n        if inv[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # Longest repeated substring length is max LCP value\n    return max(lcp) if lcp else 0\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    s = data[1]\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.806992053985596}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 59.010210275650024}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    \n    # Days from best-by date to eating\n    days_from_best_by = B - A\n    \n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by date\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by date\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.091637134552002}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.677175283432}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.22793984413147}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    result = A * B\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.568501710891724}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 64.24663281440735}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    S = data[0]\n    Q = int(data[1])\n    queries = data[2:2+Q]\n    \n    # Use two deques to represent the string efficiently\n    from collections import deque\n    front = deque()\n    back = deque(S)\n    \n    reversed_flag = False  # False means normal order, True means reversed\n    \n    for query in queries:\n        parts = query.split()\n        t = int(parts[0])\n        \n        if t == 1:\n            # Reverse operation\n            reversed_flag = not reversed_flag\n        else:  # t == 2\n            f = int(parts[1])\n            c = parts[2]\n            \n            # Determine where to add based on reversed_flag and f\n            if not reversed_flag:\n                # Normal orientation: front is beginning, back is end\n                if f == 1:\n                    front.appendleft(c)\n                else:  # f == 2\n                    back.append(c)\n            else:\n                # Reversed orientation: front is end, back is beginning\n                if f == 1:\n                    back.append(c)\n                else:  # f == 2\n                    front.appendleft(c)\n    \n    # Construct final string\n    if not reversed_flag:\n        result = ''.join(front) + ''.join(back)\n    else:\n        result = ''.join(reversed(back)) + ''.join(reversed(front))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.47460699081421}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.4953362941742}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.0180859565735}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        need = a - b\n        # Sleep gained per cycle after first alarm\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        \n        # Total time = first alarm + cycles * c\n        total_time = b + cycles * c\n        results.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.996891498565674}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Initialize sieve\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    crossed_out = []\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # Cross out p itself\n            if not is_prime[p]:  # Already crossed out? Shouldn't happen for prime p\n                continue\n            is_prime[p] = False\n            crossed_out.append(p)\n            if len(crossed_out) == K:\n                print(p)\n                return\n            \n            # Cross out multiples of p\n            multiple = p * 2\n            while multiple <= N:\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out.append(multiple)\n                    if len(crossed_out) == K:\n                        print(multiple)\n                        return\n                multiple += p\n    \n    # If K is larger than total crossed out numbers (shouldn't happen per constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.483662843704224}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, each lightning bolt kills one gnome from a group\n    # The optimal strategy is to have as many groups as possible (min(m, n))\n    # Damage is sum from n down to 1\n    if k == 1:\n        groups = min(m, n)\n        # Damage = n + (n-1) + ... + (n-groups+1)\n        # This is sum of arithmetic series\n        first = n\n        last = n - groups + 1\n        total = (first + last) * groups // 2\n        print(total)\n        return\n    \n    # For k > 1, we need to consider the optimal grouping\n    # The enemy will always target the largest group to minimize damage\n    # We want to maximize damage by creating groups that force the enemy\n    # to waste lightning bolts on small groups when possible\n    \n    # The optimal strategy is to create one large group and many small groups of size 1\n    # But we need to consider the constraint of m groups\n    \n    # Let x be the size of the large group\n    # We'll have (m-1) groups of size 1 (if possible)\n    # The remaining gnomes go to the large group\n    \n    # Calculate how many groups of size 1 we can have\n    small_groups = min(m - 1, n)\n    large_group = n - small_groups\n    \n    # If large_group <= 0, then all groups are size 1\n    if large_group <= 0:\n        # All groups are size 1, damage is sum from n down to 1\n        groups = min(m, n)\n        first = n\n        last = n - groups + 1\n        total = (first + last) * groups // 2\n        print(total)\n        return\n    \n    # Now simulate the damage calculation\n    total_damage = 0\n    current_gnomes = n\n    \n    # Phase 1: Large group is being reduced\n    while large_group > 0:\n        total_damage += current_gnomes\n        # Enemy attacks the large group\n        large_group -= k\n        if large_group < 0:\n            large_group = 0\n        # Update current gnomes\n        current_gnomes = large_group + small_groups\n    \n    # Phase 2: Only small groups (size 1) remain\n    while small_groups > 0:\n        total_damage += current_gnomes\n        small_groups -= 1\n        current_gnomes = small_groups\n    \n    print(total_damage)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.944512367248535}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.25276851654053}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    restaurants = []\n    idx = 1\n    for i in range(n):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, score, i + 1))\n        idx += 2\n    \n    # Sort: first by city lexicographically, then by score descending\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    for _, _, ident in restaurants:\n        print(ident)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.365779876708984}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs(grid, start, n, m, state):\n    \"\"\"BFS to find distances from start to all cells for a specific state\"\"\"\n    dist = [[float('inf')] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state:\n                dist[i][j] = 0\n                q.append((i, j))\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while q:\n        x, y = q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                new_dist = dist[x][y] + (1 if grid[nx][ny] == '.' else 0)\n                if new_dist < dist[nx][ny]:\n                    dist[nx][ny] = new_dist\n                    q.append((nx, ny))\n    return dist\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Find distances from each state to all cells\n    dist1 = bfs(grid, 0, n, m, '1')\n    dist2 = bfs(grid, 0, n, m, '2')\n    dist3 = bfs(grid, 0, n, m, '3')\n    \n    # Find minimum cost to connect all three states\n    INF = float('inf')\n    ans = INF\n    \n    # Try connecting through a common cell\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                cost = dist1[i][j] + dist2[i][j] + dist3[i][j]\n                if grid[i][j] == '.':\n                    cost -= 2  # Subtract double counting of the common cell\n                ans = min(ans, cost)\n    \n    # Try pairwise connections\n    # Connect 1-2 and 2-3\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                cost12 = dist1[i][j] + dist2[i][j]\n                if grid[i][j] == '.':\n                    cost12 -= 1\n                cost23 = dist2[i][j] + dist3[i][j]\n                if grid[i][j] == '.':\n                    cost23 -= 1\n                ans = min(ans, cost12 + cost23 - dist2[i][j])\n    \n    # Connect 1-3 and 3-2\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                cost13 = dist1[i][j] + dist3[i][j]\n                if grid[i][j] == '.':\n                    cost13 -= 1\n                cost32 = dist3[i][j] + dist2[i][j]\n                if grid[i][j] == '.':\n                    cost32 -= 1\n                ans = min(ans, cost13 + cost32 - dist3[i][j])\n    \n    # Connect 2-1 and 1-3\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                cost21 = dist2[i][j] + dist1[i][j]\n                if grid[i][j] == '.':\n                    cost21 -= 1\n                cost13 = dist1[i][j] + dist3[i][j]\n                if grid[i][j] == '.':\n                    cost13 -= 1\n                ans = min(ans, cost21 + cost13 - dist1[i][j])\n    \n    print(-1 if ans == INF else ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.93330216407776}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.00937604904175}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    increase = []\n    decrease = []\n    for a, b in projects:\n        if b >= 0:\n            increase.append((a, b))\n        else:\n            decrease.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    increase.sort(key=lambda x: x[0])\n    \n    # Process increasing projects first\n    for a, b in increase:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # This is equivalent to sorting by (a + b) descending\n    decrease.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process decreasing projects\n    for a, b in decrease:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.968162775039673}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.373610496521}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track how many distinct difficulties we have in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.517353296279907}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    count = 0\n    \n    # Iterate over all possible A values\n    for A in range(1, N + 1):\n        # For each A, iterate over all possible B values\n        # Since A*B must be less than N (because C = N - A*B > 0)\n        max_B = (N - 1) // A  # A*B <= N-1 to ensure C >= 1\n        \n        # For each B, C is uniquely determined as N - A*B\n        # Count all B from 1 to max_B\n        count += max_B\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.519410848617554}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 67.37801694869995}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Ensure we move from smaller to larger index for simplicity\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    # Check if positions are in the same residue class modulo k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Check all cells between g_pos and t_pos with step k\n    for pos in range(g_pos, t_pos + 1, k):\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 42.21675634384155}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Mark visited cells\n    visited = [[False] * c for _ in range(r)]\n    \n    def dfs(i, j):\n        stack = [(i, j)]\n        visited[i][j] = True\n        while stack:\n            x, y = stack.pop()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and grid[nx][ny] != 'W':\n                    visited[nx][ny] = True\n                    stack.append((nx, ny))\n    \n    islands = 0\n    # Count islands from definite land cells\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'L' and not visited[i][j]:\n                islands += 1\n                dfs(i, j)\n    \n    # For clouds, we can treat them as water to minimize islands\n    # Since we already counted islands from 'L', clouds don't add new islands\n    # because we can always interpret clouds as water when beneficial\n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 40.23371767997742}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.1337010860443}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.58422327041626}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite RGB pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We'll try all possible starting positions for the substring of length k\n        # For each starting position, we need to check alignment with the infinite RGB pattern\n        # There are 3 possible alignments (starting with R, G, or B)\n        min_changes = float('inf')\n        \n        # Precompute prefix sums for each alignment to answer queries in O(1) after O(n) preprocessing\n        # We'll create 3 arrays where arr[j][i] = number of mismatches up to position i for alignment starting with pattern[j]\n        # But since n <= 2000 and sum n <= 2000, we can afford O(n*k) per query\n        # However, we can optimize with sliding window\n        \n        # Try each of the 3 possible starting characters for the pattern\n        for start_char_idx in range(3):\n            # Build expected character for each position in the infinite pattern starting with pattern[start_char_idx]\n            # expected[i] = pattern[(start_char_idx + i) % 3]\n            \n            # Calculate mismatches for first window\n            mismatches = 0\n            for i in range(k):\n                expected = pattern[(start_char_idx + i) % 3]\n                if s[i] != expected:\n                    mismatches += 1\n            \n            min_changes = min(min_changes, mismatches)\n            \n            # Slide the window\n            for i in range(k, n):\n                # Remove leftmost character from window\n                left_expected = pattern[(start_char_idx + (i - k)) % 3]\n                if s[i - k] != left_expected:\n                    mismatches -= 1\n                \n                # Add new character to window\n                right_expected = pattern[(start_char_idx + i) % 3]\n                if s[i] != right_expected:\n                    mismatches += 1\n                \n                min_changes = min(min_changes, mismatches)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 31.42636799812317}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.46112656593323}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    # Track whether each pair is currently on the table\n    on_table = [False] * (n + 1)\n    current_count = 0\n    max_count = 0\n    \n    for sock in socks:\n        if not on_table[sock]:\n            # First sock of the pair: put on table\n            on_table[sock] = True\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            # Second sock of the pair: remove from table\n            on_table[sock] = False\n            current_count -= 1\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.25229787826538}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2, we get R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.174135446548462}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.55235576629639}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.max_node = list(range(n))\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.size[x_root] < self.size[y_root]:\n            x_root, y_root = y_root, x_root\n        self.parent[y_root] = x_root\n        self.size[x_root] += self.size[y_root]\n        self.max_node[x_root] = max(self.max_node[x_root], self.max_node[y_root])\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    dsu = DSU(n)\n    \n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        dsu.union(u, v)\n    \n    edges_to_add = 0\n    i = 0\n    while i < n:\n        root = dsu.find(i)\n        max_in_component = dsu.max_node[root]\n        \n        j = i + 1\n        while j <= max_in_component:\n            if dsu.find(j) != root:\n                dsu.union(i, j)\n                edges_to_add += 1\n                root = dsu.find(i)\n                max_in_component = dsu.max_node[root]\n            j += 1\n        i = max_in_component + 1\n    \n    print(edges_to_add)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.736954927444458}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # For each value, consider it and its neighbors after operations\n    max_count = 0\n    for val in set(arr):\n        # Count for X = val (no change needed)\n        count = freq.get(val, 0)\n        # Count for X = val-1 (needs +1 operation)\n        count += freq.get(val-1, 0)\n        # Count for X = val+1 (needs -1 operation)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.359532117843628}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nxs, ys, ss, ri, rf = map(int, sys.stdin.readline().split())\nxa, ya, sa = map(int, sys.stdin.readline().split())\n\n# Distance from Anthony to safety zone center\ndist = math.hypot(xa - xs, ya - ys)\n\n# If Anthony is already inside the final safety zone, no damage\nif dist <= rf:\n    print(\"0.000000\")\n    sys.exit(0)\n\n# Time when safety zone stops shrinking (when radius reaches rf)\nt_shrink = (ri - rf) / ss if ss > 0 else float('inf')\n\n# Function to compute damage if Anthony runs directly toward center\ndef damage_direct_run():\n    # Anthony runs toward center at speed sa\n    # Relative speed toward center: sa\n    # Distance to cover to reach radius rf: dist - rf\n    time_to_reach = (dist - rf) / sa if sa > 0 else float('inf')\n    \n    # If Anthony can reach before safety zone stops shrinking\n    if time_to_reach <= t_shrink:\n        # Damage occurs while outside shrinking zone\n        # Radius at time t: r(t) = ri - ss*t\n        # Anthony is at distance: dist - sa*t\n        # Damage when distance > r(t)\n        # Solve for when Anthony enters zone: dist - sa*t = ri - ss*t\n        # => t_enter = (dist - ri) / (sa - ss) if sa != ss\n        if sa == ss:\n            # Parallel speeds: if dist > ri, never enters during shrink\n            if dist > ri:\n                return t_shrink  # Damage entire shrink time\n            else:\n                return 0.0\n        else:\n            t_enter = (dist - ri) / (sa - ss)\n            if t_enter <= 0:\n                return 0.0  # Already inside initially\n            if t_enter >= t_shrink:\n                return t_shrink  # Enters after shrink stops\n            return t_enter  # Damage until entry\n    else:\n        # Anthony reaches after shrink stops\n        # Damage during entire shrink period\n        damage_during_shrink = t_shrink\n        # After shrink, radius is rf\n        # Distance Anthony still needs to cover: dist - sa*t_shrink - rf\n        remaining_dist = max(0.0, dist - sa * t_shrink - rf)\n        damage_after_shrink = remaining_dist / sa if sa > 0 else 0.0\n        return damage_during_shrink + damage_after_shrink\n\n# Function to compute damage if Anthony waits then runs\ndef damage_wait_then_run():\n    # Wait until safety zone stops shrinking, then run to rf boundary\n    damage_during_wait = t_shrink  # Damage entire shrink time\n    # After shrink, distance to rf boundary: max(0, dist - rf)\n    remaining = max(0.0, dist - rf)\n    time_to_run = remaining / sa if sa > 0 else float('inf')\n    damage_after_wait = time_to_run  # Damage while running after shrink\n    return damage_during_wait + damage_after_wait\n\n# Function to compute damage if Anthony runs at optimal angle (not directly toward center)\ndef damage_optimal_angle():\n    # This is the general case: Anthony can run in any direction\n    # We need to minimize time outside safety zone\n    # Equivalent to: minimize time when distance > radius\n    \n    # If sa <= ss, Anthony cannot outrun shrinking zone radially\n    # Best is to run directly toward center\n    if sa <= ss:\n        return damage_direct_run()\n    \n    # For sa > ss, we can potentially enter zone earlier\n    # Solve for optimal entry time t\n    # Let Anthony run at angle theta relative to center direction\n    # Using law of cosines: distance^2 = dist^2 + (sa*t)^2 - 2*dist*sa*t*cos(theta)\n    # We want distance = radius at time t: r(t) = ri - ss*t\n    # Minimize t where this holds\n    # This becomes: (dist^2 + (sa*t)^2 - 2*dist*sa*t*cos(theta)) = (ri - ss*t)^2\n    # For optimal theta, cos(theta)=1 (run directly toward center)\n    # Because that minimizes distance fastest\n    # So optimal is actually direct run when sa > ss\n    return damage_direct_run()\n\n# Compute minimum damage\nmin_damage = min(\n    damage_direct_run(),\n    damage_wait_then_run(),\n    damage_optimal_angle()\n)\n\n# Output with required precision\nprint(f\"{min_damage:.6f}\")", "complexity_estimate": null, "runtime_sec": 50.9441339969635}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort jobs by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.616029500961304}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        g = math.gcd(lcm_val, t)\n        lcm_val = (lcm_val // g) * t\n        if lcm_val > 10**18:\n            # Early exit if LCM exceeds the maximum possible answer\n            lcm_val = 10**18 + 1\n            break\n    \n    # Output the LCM if it's within bounds, otherwise output 0 (though constraints guarantee it fits)\n    print(lcm_val if lcm_val <= 10**18 else 0)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 33.12241077423096}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.2685956954956}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.54959464073181}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Pair boxes with remainder 0 with each other\n    pairs = rem_count[0] // 2\n    \n    # For other remainders, pair remainder i with remainder k-i\n    # Special case when k is even: remainder k/2 pairs with itself\n    if k % 2 == 0:\n        pairs += rem_count[k // 2] // 2\n    \n    # Pair i with k-i for i from 1 to (k-1)//2\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        if i != j:\n            pairs += min(rem_count[i], rem_count[j])\n    \n    # Each pair uses 2 boxes\n    print(pairs * 2)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.322144031524658}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.3090877532959}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 139.53584933280945}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    a = s\n    i = 1\n    while True:\n        if a in seen:\n            print(i)\n            return\n        seen[a] = i\n        a = f(a)\n        i += 1\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.18683671951294}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.85153436660767}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find first ':' after first '['\n    first_colon = -1\n    for i in range(first_open + 1, n):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ']'\n    last_close = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1 or last_close <= first_colon:\n        print(-1)\n        return\n    \n    # Find last ':' before last ']'\n    last_colon = -1\n    for i in range(last_close - 1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon + 1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length: '[' + ':' + pipes + ':' + ']' = 4 + pipe_count\n    result = 4 + pipe_count\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 46.07155394554138}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    arr = list(map(int, data[idx:idx+n]))\n    idx += n\n    \n    freq = collections.Counter(arr)\n    max_freq = max(freq.values())\n    distinct = len(freq)\n    \n    # The maximum team size x must satisfy:\n    # 1. x <= distinct (for unique skills in first team)\n    # 2. x <= max_freq (for same skills in second team)\n    # 3. We need to check if we can actually form both teams simultaneously\n    \n    # Try candidate x = min(distinct, max_freq)\n    candidate = min(distinct, max_freq)\n    \n    # If candidate == distinct, we might need to reduce by 1 because\n    # the second team might need one extra distinct skill if max_freq == distinct\n    if candidate == distinct and max_freq == distinct:\n        candidate -= 1\n    \n    # Also, if candidate == max_freq and distinct == max_freq:\n    # similar adjustment needed\n    if candidate == max_freq and distinct == max_freq:\n        candidate -= 1\n    \n    # Ensure candidate is non-negative\n    candidate = max(0, candidate)\n    \n    results.append(str(candidate))\n\nprint('\\n'.join(results))", "complexity_estimate": null, "runtime_sec": 24.421191692352295}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Compute the greatest common divisor of all numbers\n    g = arr[0]\n    for x in arr[1:]:\n        g = math.gcd(g, x)\n    \n    # For each number, divide by gcd and check if it's of the form 2^a * 3^b\n    for x in arr:\n        x //= g\n        # Remove all factors of 2\n        while x % 2 == 0:\n            x //= 2\n        # Remove all factors of 3\n        while x % 3 == 0:\n            x //= 3\n        # If anything else remains, it's not possible\n        if x != 1:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.868046522140503}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.64690780639648}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n        edges.append((x, y, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute shortest distances from each district\n    dist_from = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dist_from[i] = dijkstra(n, adj, i)\n    \n    # Compute original total cost\n    original_total = 0\n    for a, b in routes:\n        original_total += dist_from[a][b]\n    \n    # Try making each road zero\n    best_total = original_total\n    for x, y, w in edges:\n        # Temporarily set this edge weight to 0\n        # We'll compute the benefit of making this edge zero\n        benefit = 0\n        for a, b in routes:\n            # New shortest distance is min of:\n            # 1. Original distance\n            # 2. Distance through the zero edge: dist[a][x] + 0 + dist[y][b]\n            # 3. Distance through the zero edge reversed: dist[a][y] + 0 + dist[x][b]\n            original = dist_from[a][b]\n            through_edge = dist_from[a][x] + dist_from[y][b]\n            through_edge_rev = dist_from[a][y] + dist_from[x][b]\n            new_dist = min(original, through_edge, through_edge_rev)\n            benefit += (original - new_dist)\n        \n        # Total cost if we make this edge zero\n        new_total = original_total - benefit\n        if new_total < best_total:\n            best_total = new_total\n    \n    print(best_total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.77117300033569}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(200000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    x_root = find(x, parent)\n    y_root = find(y, parent)\n    if x_root == y_root:\n        return\n    if size[x_root] < size[y_root]:\n        x_root, y_root = y_root, x_root\n    parent[y_root] = x_root\n    size[x_root] += size[y_root]\n\ndef bfs(start, adj):\n    from collections import deque\n    n = len(adj)\n    dist = [-1] * n\n    q = deque([start])\n    dist[start] = 0\n    farthest = start\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n                if dist[v] > dist[farthest]:\n                    farthest = v\n    return farthest, dist\n\ndef tree_diameter(adj, component_nodes):\n    if not component_nodes:\n        return 0\n    start = next(iter(component_nodes))\n    farthest1, _ = bfs(start, adj)\n    farthest2, dist = bfs(farthest1, adj)\n    return dist[farthest2]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    c = int(next(it))\n    l = int(next(it))\n    \n    adj = [[] for _ in range(c)]\n    parent = list(range(c))\n    size = [1] * c\n    \n    for _ in range(l):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        adj[b].append(a)\n        union(a, b, parent, size)\n    \n    components = {}\n    for i in range(c):\n        root = find(i, parent)\n        if root not in components:\n            components[root] = []\n        components[root].append(i)\n    \n    diameters = []\n    for nodes in components.values():\n        d = tree_diameter(adj, nodes)\n        diameters.append(d)\n    \n    diameters.sort(reverse=True)\n    \n    if len(diameters) == 1:\n        print(diameters[0])\n        return\n    \n    # Connect components to minimize maximum distance\n    # Strategy: connect diameters in order, longest first\n    # The new diameter is max(d1, d2, ceil(d1/2)+ceil(d2/2)+1)\n    # But we need to connect all components into one tree\n    # We'll build the new tree by connecting components one by one\n    current_max = diameters[0]\n    for i in range(1, len(diameters)):\n        d = diameters[i]\n        # When connecting two trees with diameters d1 and d2,\n        # the new diameter is max(d1, d2, ceil(d1/2) + ceil(d2/2) + 1)\n        new_diameter = max(current_max, d, (current_max + 1) // 2 + (d + 1) // 2 + 1)\n        current_max = new_diameter\n    \n    print(current_max)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 40.39500093460083}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 123.30672407150269}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 85.52690196037292}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.9177553653717}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.401322603225708}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 148.3290343284607}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.1111171245575}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees clockwise in n x m matrix.\"\"\"\n    return y, n - x + 1\n\ndef rotate_90_counterclockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees counterclockwise in n x m matrix.\"\"\"\n    return m - y + 1, x\n\ndef horizontal_flip(x, y, n, m):\n    \"\"\"Flip point (x,y) horizontally in n x m matrix.\"\"\"\n    return x, m - y + 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = identity\n    x %= 4\n    z %= 4\n    # Horizontal flips: even number = identity, odd = flip\n    y %= 2\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        cur_n, cur_m = n, m\n        \n        # Apply x clockwise rotations\n        for _ in range(x):\n            xi, yi = rotate_90_clockwise(xi, yi, cur_n, cur_m)\n            cur_n, cur_m = cur_m, cur_n\n        \n        # Apply y horizontal flips\n        if y == 1:\n            xi, yi = horizontal_flip(xi, yi, cur_n, cur_m)\n        \n        # Apply z counterclockwise rotations\n        for _ in range(z):\n            xi, yi = rotate_90_counterclockwise(xi, yi, cur_n, cur_m)\n            cur_n, cur_m = cur_m, cur_n\n        \n        results.append(f\"{xi} {yi}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 29.999916315078735}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # Each character has N possibilities, and there are 3 independent choices\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.104580402374268}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 85.2581958770752}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' from left and consecutive '>' from right\n        left_count = 0\n        for ch in s:\n            if ch == '<':\n                left_count += 1\n            else:\n                break\n        right_count = 0\n        for ch in reversed(s):\n            if ch == '>':\n                right_count += 1\n            else:\n                break\n        # Minimum deletions needed is the smaller of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.110615968704224}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X) / 2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    # Check if (Y - 2X) is divisible by 2 and non-negative\n    if (Y - 2 * X) % 2 != 0:\n        print(\"No\")\n        return\n    \n    t = (Y - 2 * X) // 2\n    c = X - t\n    \n    if c >= 0 and t >= 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.77005386352539}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.83719682693481}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute possible frets on each string\n    frets = []\n    for note in b:\n        note_frets = []\n        for base in a:\n            if note > base:\n                fret = note - base\n                note_frets.append(fret)\n        # Sort frets for this note\n        note_frets.sort()\n        frets.append(note_frets)\n    \n    # Two-pointer sliding window approach\n    # We need to select one fret from each note's list such that max-min is minimized\n    # Combine all frets with their note index\n    all_frets = []\n    for i, note_frets in enumerate(frets):\n        for fret in note_frets:\n            all_frets.append((fret, i))\n    \n    # Sort by fret value\n    all_frets.sort(key=lambda x: x[0])\n    \n    # Sliding window to cover all notes\n    m = len(all_frets)\n    left = 0\n    count = [0] * n\n    covered = 0\n    min_diff = float('inf')\n    \n    for right in range(m):\n        fret_val, note_idx = all_frets[right]\n        if count[note_idx] == 0:\n            covered += 1\n        count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while covered == n:\n            min_diff = min(min_diff, fret_val - all_frets[left][0])\n            left_fret, left_note = all_frets[left]\n            count[left_note] -= 1\n            if count[left_note] == 0:\n                covered -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.726407527923584}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 28.77066659927368}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.48870038986206}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    \"\"\"\n    Count the number of ships Vasya can make using the process:\n    Start with rectangle a x b (a > b).\n    While b > 0:\n      - Make a square of size b x b from the current rectangle.\n      - The remainder becomes (a - b) x b.\n      - Set a = max(a - b, b), b = min(a - b, b).\n    Return the total number of squares (ships) made.\n    \"\"\"\n    ships = 0\n    while b > 0:\n        # Number of squares of size b that can be made from current rectangle\n        ships += a // b\n        # Update a, b for the remainder\n        a, b = b, a % b\n    return ships\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    result = count_ships(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.51238226890564}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # The smallest positive integer divisible by both 2 and N is LCM(2, N)\n    # Since 2 is prime, LCM(2, N) = 2 * N / gcd(2, N)\n    # If N is even, gcd(2, N) = 2, so LCM = N\n    # If N is odd, gcd(2, N) = 1, so LCM = 2 * N\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.05099105834961}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.55789232254028}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.4807517528534}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    m, n = map(int, data[0].split())\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.364253759384155}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.9708867073059}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.981360912323}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.12827515602112}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 153.9719593524933}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = int(data[1])  # Rabbit-Owl\n    b = int(data[2])  # Rabbit-Eeyore\n    c = int(data[3])  # Owl-Eeyore\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # For n >= 2, we need to choose optimal first move and then repeat\n    # The three possible starting moves:\n    # 1. Rabbit -> Owl (cost a)\n    # 2. Rabbit -> Eeyore (cost b)\n    # After first move, we can oscillate between two houses with minimal edge\n    \n    # Minimal edge among the three\n    min_edge = min(a, b, c)\n    \n    # For n=2, just take the minimal first move\n    if n == 2:\n        print(min(a, b))\n        return\n    \n    # For n>=3:\n    # Strategy: Make first move to either Owl or Eeyore (whichever gives smaller first edge),\n    # then oscillate between two houses using the minimal edge among all three\n    # Total distance = first_move + (n-2)*min_edge\n    \n    first_move = min(a, b)\n    total = first_move + (n - 2) * min_edge\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.2647442817688}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    # Initialize count array with zeros for all members (1-indexed)\n    subordinates = [0] * (n + 1)\n    \n    # Process each A_i (starting from index 1 in data for A_2)\n    for i in range(2, n + 1):\n        boss = int(data[i - 1])  # data[1] corresponds to A_2\n        subordinates[boss] += 1\n    \n    # Output results for members 1 through N\n    for i in range(1, n + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.286980628967285}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # Duplicate array to handle circular wrap-around easily\n    A_extended = A + A\n    \n    # Helper function to check if we can achieve at least K sections with AND >= target\n    def can_achieve(target):\n        # We need to find if we can split the circle into at least K contiguous sections\n        # such that each section's OR has all bits of target set.\n        # Since we want exactly K sections, we check if we can get at least K.\n        # Actually, we need exactly K, but we can check if we can get at least K,\n        # and later adjust.\n        # However, for maximizing AND, we can use greedy: take as many sections as possible\n        # with OR having target bits, and see if count >= K.\n        # But we must ensure sections are contiguous in the circle.\n        # We'll try each starting point in the original N positions.\n        best_count = 0\n        for start in range(N):\n            count = 0\n            i = start\n            while i < start + N:\n                # Try to form a section starting at i\n                current_or = 0\n                j = i\n                while j < start + N:\n                    current_or |= A_extended[j]\n                    if (current_or & target) == target:\n                        # This section has all bits of target set\n                        count += 1\n                        i = j + 1\n                        break\n                    j += 1\n                else:\n                    # Could not form a section with target bits from i\n                    break\n            best_count = max(best_count, count)\n            if best_count >= K:\n                return True\n        return False\n    \n    # Binary search on the answer\n    ans = 0\n    for bit in range(30, -1, -1):\n        candidate = ans | (1 << bit)\n        if can_achieve(candidate):\n            ans = candidate\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 92.5774130821228}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith(\"po\"):\n        return \"FILIPINO\"\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        return \"JAPANESE\"\n    elif sentence.endswith(\"mnida\"):\n        return \"KOREAN\"\n    else:\n        # According to problem statement, this should never happen\n        return \"UNKNOWN\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i].strip()\n        results.append(detect_language(sentence))\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.939064979553223}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N = int(data[idx]); idx += 1\n    C = [0] * (N-1)\n    S = [0] * (N-1)\n    F = [0] * (N-1)\n    for i in range(N-1):\n        C[i] = int(data[idx]); idx += 1\n        S[i] = int(data[idx]); idx += 1\n        F[i] = int(data[idx]); idx += 1\n    \n    result = [0] * N\n    for start in range(N-1):\n        time = 0\n        for i in range(start, N-1):\n            if time < S[i]:\n                time = S[i]\n            else:\n                remainder = time % F[i]\n                if remainder != 0:\n                    time += F[i] - remainder\n            time += C[i]\n        result[start] = time\n    result[N-1] = 0\n    \n    print('\\n'.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.00487732887268}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.37243843078613}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.19874358177185}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right, and four diagonals\n    directions = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),           (0, 1),\n        (1, -1),  (1, 0),  (1, 1)\n    ]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                    bomb_count += 1\n            row_chars.append(str(bomb_count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.006553649902344}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.37863731384277}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.17833137512207}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.11404252052307}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import re\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel according to the rules.\"\"\"\n    return c.upper() in 'AEIOUY'\n\ndef is_consonant(c):\n    \"\"\"Return True if c is a consonant.\"\"\"\n    return c.isalpha() and not is_vowel(c)\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the given rules.\"\"\"\n    # Extract alphabetic part\n    alphabetic = ''.join(ch for ch in word if ch.isalpha())\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    # Convert to uppercase for processing\n    upper = alphabetic.upper()\n    n = len(upper)\n    \n    # Apply silent E rule\n    silent_e = False\n    if n >= 1 and upper[-1] == 'E':\n        if n >= 3 and upper[-2] == 'L' and is_consonant(upper[-3]):\n            # 'able' case - E is not silent\n            pass\n        else:\n            silent_e = True\n    \n    # Apply ES rule\n    es_silent = False\n    if n >= 2 and upper[-2:] == 'ES':\n        if n >= 3 and is_consonant(upper[-3]):\n            # Check if preceded by two or more consonants\n            cons_count = 0\n            i = n - 3\n            while i >= 0 and is_consonant(upper[i]):\n                cons_count += 1\n                i -= 1\n            if cons_count < 2:\n                es_silent = True\n        else:\n            es_silent = True\n    \n    # Process characters with special rules\n    chars = list(upper)\n    # Handle QU as single consonant\n    i = 0\n    while i < len(chars) - 1:\n        if chars[i] == 'Q' and chars[i+1] == 'U':\n            chars[i] = 'QU'\n            del chars[i+1]\n        i += 1\n    \n    # Handle Y as consonant when followed by another vowel\n    for i in range(len(chars) - 1):\n        if chars[i] == 'Y' and is_vowel(chars[i+1]) and chars[i+1] != 'Y':\n            chars[i] = 'C'  # Mark as consonant\n    \n    # Mark vowels and consonants\n    vowel_positions = []\n    for i, ch in enumerate(chars):\n        if ch in 'AEIOU' or (ch == 'Y' and (i == len(chars)-1 or not is_vowel(chars[i+1]))):\n            vowel_positions.append(i)\n    \n    if not vowel_positions:\n        return 1  # At least one syllable\n    \n    # Count syllable divisions\n    syllables = 1\n    for i in range(len(vowel_positions) - 1):\n        # Check if there's at least one consonant between vowels\n        has_consonant = False\n        for pos in range(vowel_positions[i] + 1, vowel_positions[i+1]):\n            if chars[pos] not in 'AEIOUY':\n                has_consonant = True\n                break\n        if has_consonant:\n            syllables += 1\n    \n    # Adjust for silent E\n    if silent_e and syllables > 1:\n        syllables -= 1\n    \n    # Adjust for silent ES\n    if es_silent and syllables > 1:\n        syllables -= 1\n    \n    return max(1, syllables)\n\ndef split_haiku(words):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Precompute syllable counts\n    syllable_counts = [count_syllables(word) for word in words]\n    total_syllables = sum(syllable_counts)\n    \n    if total_syllables != 17:\n        return None  # Cannot form haiku\n    \n    # Try all possible splits\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            line1 = sum(syllable_counts[:i])\n            line2 = sum(syllable_counts[i:j])\n            line3 = sum(syllable_counts[j:])\n            \n            if line1 == 5 and line2 == 7 and line3 == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    \n    return None\n\ndef main():\n    import sys\n    \n    # Read input\n    line = sys.stdin.read().rstrip('\\n')\n    \n    # Split into words while preserving punctuation\n    words = []\n    current = ''\n    for ch in line:\n        if ch == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += ch\n    if current:\n        words.append(current)\n    \n    # Try to form haiku\n    result = split_haiku(words)\n    \n    if result:\n        print(result[0])\n        print(result[1])\n        print(result[2])\n    else:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 53.79169678688049}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.01253938674927}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Special case: 1 is the strongest, then 13, 12, ..., 2\n    # Map values so comparison is straightforward\n    def strength(x):\n        return 14 if x == 1 else x  # 1 becomes 14, others stay same\n    \n    a_strength = strength(A)\n    b_strength = strength(B)\n    \n    if a_strength > b_strength:\n        print(\"Alice\")\n    elif a_strength < b_strength:\n        print(\"Bob\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.005867958068848}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.2123258113861}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    t = int(data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        \n        # Find first occurrence of different consecutive characters\n        first_diff = -1\n        for i in range(n):\n            if s[i] != s[(i+1)%n]:\n                first_diff = i\n                break\n        \n        # If all characters are same, answer is ceil(n/3)\n        if first_diff == -1:\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rotate string to start at first_diff+1\n        rotated = s[first_diff+1:] + s[:first_diff+1]\n        \n        # Count consecutive same characters\n        ans = 0\n        cnt = 1\n        for i in range(1, n):\n            if rotated[i] == rotated[i-1]:\n                cnt += 1\n            else:\n                ans += cnt // 3\n                cnt = 1\n        ans += cnt // 3\n        \n        results.append(ans)\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.226590633392334}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # Snuke changed exactly one of them to 0\n    # So we look for the position where x[i] != i+1\n    # Since all other values remain unchanged, the changed one will be 0\n    \n    for i in range(5):\n        if x[i] == 0:\n            # Found the zero - output the 1-based index\n            print(i + 1)\n            return\n    \n    # Alternative approach: find where value doesn't match expected\n    # This handles cases where input might not have 0 (though constraints say it will)\n    for i in range(5):\n        if x[i] != i + 1:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.409353017807007}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.62064862251282}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.40182590484619}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.48339891433716}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 59.4937162399292}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.87187719345093}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.11165165901184}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    MOD = 1000000007\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials\n    max_n = N\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Sort values\n    a.sort()\n    \n    total = 0\n    # For each element as maximum in combination\n    for i in range(K-1, N):\n        # Number of ways to choose K-1 smaller elements from i elements\n        ways = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + ways * a[i]) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.622474670410156}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Identify rows and columns without strawberries\n    safe_rows = [i for i in range(r) if 'S' not in grid[i]]\n    safe_cols = [j for j in range(c) if all(grid[i][j] != 'S' for i in range(r))]\n    \n    # Count cells in safe rows and columns\n    cells_from_rows = len(safe_rows) * c\n    cells_from_cols = len(safe_cols) * r\n    \n    # Subtract double-counted cells (intersection of safe rows and columns)\n    double_counted = len(safe_rows) * len(safe_cols)\n    \n    result = cells_from_rows + cells_from_cols - double_counted\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.419003009796143}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    # Replace first four characters with '2018'\n    result = '2018' + S[4:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.133394241333008}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach: try to put largest digit at earliest position\n    for i in range(length):\n        if k <= 0:\n            break\n        # Find the largest digit from i+1 to end\n        max_digit = n[i]\n        max_index = i\n        for j in range(i+1, length):\n            if n[j] > max_digit:\n                max_digit = n[j]\n                max_index = j\n        # If we found a larger digit, swap it to position i\n        if max_index != i:\n            # Swap\n            n[i], n[max_index] = n[max_index], n[i]\n            k -= 1\n    \n    # If k is odd and length >= 2, we might need to adjust\n    # If we have swaps left, we can swap identical digits or adjust\n    if k > 0 and length >= 2:\n        # If k is odd, we need to make one more swap\n        # We can swap two identical digits if they exist\n        has_duplicate = False\n        for i in range(length):\n            for j in range(i+1, length):\n                if n[i] == n[j]:\n                    has_duplicate = True\n                    break\n            if has_duplicate:\n                break\n        \n        if not has_duplicate and k % 2 == 1:\n            # Swap last two digits if no duplicates\n            n[-1], n[-2] = n[-2], n[-1]\n    \n    result = ''.join(n)\n    # Ensure no leading zero\n    if result[0] == '0':\n        # Find first non-zero digit and swap to front\n        for i in range(1, length):\n            if result[i] != '0':\n                result = list(result)\n                result[0], result[i] = result[i], result[0]\n                result = ''.join(result)\n                break\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.862821578979492}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 24.01061177253723}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return -1\n    N = int(data[0])\n    a = [0] + [int(data[i]) for i in range(1, N+1)]  # 1-indexed\n    \n    visited = [False] * (N + 1)\n    current = 1\n    count = 0\n    \n    while current != 2:\n        if visited[current]:\n            return -1\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "complexity_estimate": null, "runtime_sec": 13.638442277908325}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 103.5233199596405}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic(a, n, d):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    n %= MOD\n    a %= MOD\n    d %= MOD\n    # sum = n/2 * (2a + (n-1)d)\n    term1 = (2 * a + (n - 1) * d) % MOD\n    term2 = n * term1 % MOD\n    # Since n might be odd, multiply by modular inverse of 2\n    inv2 = (MOD + 1) // 2  # 500000004\n    return term2 * inv2 % MOD\n\ndef sum_range(l, r):\n    \"\"\"Return sum of numbers from index l to r (1-based) modulo MOD.\"\"\"\n    def prefix_sum(k):\n        \"\"\"Sum of first k numbers.\"\"\"\n        if k == 0:\n            return 0\n        total = 0\n        stage = 1\n        count = 1  # numbers written in current stage\n        odd_start = 1\n        even_start = 2\n        remaining = k\n        \n        while remaining > 0:\n            take = min(count, remaining)\n            if stage % 2 == 1:  # odd stage\n                total = (total + sum_arithmetic(odd_start, take, 2)) % MOD\n                odd_start += 2 * take\n            else:  # even stage\n                total = (total + sum_arithmetic(even_start, take, 2)) % MOD\n                even_start += 2 * take\n            remaining -= take\n            count *= 2\n            stage += 1\n        return total\n    \n    return (prefix_sum(r) - prefix_sum(l - 1)) % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    result = sum_range(l, r)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 86.67272424697876}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    min_x = min(x)\n    max_x = max(x)\n    \n    min_stamina = float('inf')\n    for p in range(min_x, max_x + 1):\n        stamina = sum((xi - p) ** 2 for xi in x)\n        if stamina < min_stamina:\n            min_stamina = stamina\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.22909426689148}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.63348388671875}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "from collections import deque\n\ndef bfs_flood(R, C, grid):\n    flood_time = [[-1] * C for _ in range(R)]\n    q = deque()\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '*':\n                flood_time[i][j] = 0\n                q.append((i, j))\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while q:\n        x, y = q.popleft()\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if grid[nx][ny] in '.S' and flood_time[nx][ny] == -1:\n                    flood_time[nx][ny] = flood_time[x][y] + 1\n                    q.append((nx, ny))\n    return flood_time\n\ndef bfs_escape(R, C, grid, flood_time):\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            if grid[i][j] == 'D':\n                den = (i, j)\n    visited = [[False] * C for _ in range(R)]\n    q = deque()\n    q.append((start[0], start[1], 0))\n    visited[start[0]][start[1]] = True\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while q:\n        x, y, time = q.popleft()\n        if (x, y) == den:\n            return time\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if grid[nx][ny] == 'X' or visited[nx][ny]:\n                    continue\n                if grid[nx][ny] == 'D':\n                    return time + 1\n                if flood_time[nx][ny] != -1 and flood_time[nx][ny] <= time + 1:\n                    continue\n                visited[nx][ny] = True\n                q.append((nx, ny, time + 1))\n    return -1\n\ndef main():\n    R, C = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(R)]\n    flood_time = bfs_flood(R, C, grid)\n    result = bfs_escape(R, C, grid, flood_time)\n    print(result if result != -1 else \"KAKTUS\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 31.581754684448242}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 48.67414379119873}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 140.80607867240906}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.45507216453552}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.17134833335876}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 103.18686580657959}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.96324372291565}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.4286036491394}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each value\n    freq = {}\n    for x in arr:\n        freq[x] = freq.get(x, 0) + 1\n    \n    # Get all unique values\n    values = list(freq.keys())\n    m = len(values)\n    \n    total = 0\n    \n    # Case 1: a_i = a_j = a_k/2 (i.e., a_i + a_i = a_k)\n    for val in values:\n        cnt = freq[val]\n        if cnt >= 2:\n            target = 2 * val\n            if target in freq:\n                # Choose 2 indices for i,j from cnt, and 1 index for k from freq[target]\n                # But careful: if val == 0, then target = 0, and we need distinct indices\n                if val == 0:\n                    if cnt >= 3:\n                        # Choose 3 distinct indices from cnt zeros: P(cnt,3) = cnt*(cnt-1)*(cnt-2)\n                        total += cnt * (cnt - 1) * (cnt - 2)\n                else:\n                    # i,j distinct from cnt zeros, k from freq[target]\n                    ways_ij = cnt * (cnt - 1)  # ordered pair (i,j) with i != j\n                    total += ways_ij * freq[target]\n    \n    # Case 2: a_i != a_j\n    # For each pair of distinct values (x,y) with x < y, check if x+y exists\n    for i in range(m):\n        x = values[i]\n        cnt_x = freq[x]\n        for j in range(i+1, m):\n            y = values[j]\n            cnt_y = freq[y]\n            target = x + y\n            if target in freq:\n                # Ordered pairs (i,j): cnt_x * cnt_y * 2 (since (x,y) and (y,x) are different)\n                ways_ij = cnt_x * cnt_y * 2\n                total += ways_ij * freq[target]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 40.872169971466064}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    H = int(next(it))\n    W = int(next(it))\n    K = int(next(it))\n    x1 = int(next(it)) - 1\n    y1 = int(next(it)) - 1\n    x2 = int(next(it)) - 1\n    y2 = int(next(it)) - 1\n    \n    grid = []\n    for _ in range(H):\n        row = list(next(it))\n        grid.append(row)\n    \n    if grid[x1][y1] == '@' or grid[x2][y2] == '@':\n        print(-1)\n        return\n    \n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # BFS with direction optimization\n    dq = deque()\n    dq.append((x1, y1))\n    \n    # Precompute row and column obstacles for fast lookup\n    row_obstacles = [[] for _ in range(H)]\n    col_obstacles = [[] for _ in range(W)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '@':\n                row_obstacles[i].append(j)\n                col_obstacles[j].append(i)\n    \n    # Helper to find next obstacle in a direction\n    def next_obstacle_in_row(row, col, direction):\n        obstacles = row_obstacles[row]\n        if direction == 1:  # east\n            # find smallest j > col with obstacle\n            for j in obstacles:\n                if j > col:\n                    return j\n            return W\n        else:  # west\n            # find largest j < col with obstacle\n            best = -1\n            for j in obstacles:\n                if j < col:\n                    best = max(best, j)\n            return best\n    \n    def next_obstacle_in_col(col, row, direction):\n        obstacles = col_obstacles[col]\n        if direction == 1:  # south\n            for i in obstacles:\n                if i > row:\n                    return i\n            return H\n        else:  # north\n            best = -1\n            for i in obstacles:\n                if i < row:\n                    best = max(best, i)\n            return best\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        # Explore four directions\n        for dir_idx, (dx, dy) in enumerate([(0,1),(1,0),(0,-1),(-1,0)]):\n            if dir_idx == 0:  # east\n                obstacle = next_obstacle_in_row(x, y, 1)\n                max_move = min(K, obstacle - y - 1)\n                for step in range(1, max_move + 1):\n                    ny = y + step\n                    if dist[x][ny] > current_dist + 1:\n                        dist[x][ny] = current_dist + 1\n                        dq.append((x, ny))\n            elif dir_idx == 1:  # south\n                obstacle = next_obstacle_in_col(y, x, 1)\n                max_move = min(K, obstacle - x - 1)\n                for step in range(1, max_move + 1):\n                    nx = x + step\n                    if dist[nx][y] > current_dist + 1:\n                        dist[nx][y] = current_dist + 1\n                        dq.append((nx, y))\n            elif dir_idx == 2:  # west\n                obstacle = next_obstacle_in_row(x, y, -1)\n                max_move = min(K, y - obstacle - 1)\n                for step in range(1, max_move + 1):\n                    ny = y - step\n                    if dist[x][ny] > current_dist + 1:\n                        dist[x][ny] = current_dist + 1\n                        dq.append((x, ny))\n            else:  # north\n                obstacle = next_obstacle_in_col(y, x, -1)\n                max_move = min(K, x - obstacle - 1)\n                for step in range(1, max_move + 1):\n                    nx = x - step\n                    if dist[nx][y] > current_dist + 1:\n                        dist[nx][y] = current_dist + 1\n                        dq.append((nx, y))\n    \n    result = dist[x2][y2]\n    print(result if result < INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 47.15649652481079}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.80677890777588}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        u = int(data[idx]); idx += 1\n        op = data[idx]; idx += 1\n        v = int(data[idx]); idx += 1\n        \n        if op == '=':\n            dsu.union(u, v)\n        else:  # op == '>'\n            edges.append((u, v))\n    \n    # Build graph with components as nodes\n    comp_id = [dsu.find(i) for i in range(N)]\n    comp_set = set(comp_id)\n    comp_map = {comp: i for i, comp in enumerate(sorted(comp_set))}\n    comp_count = len(comp_map)\n    \n    # Create adjacency list for the component graph\n    adj = [[] for _ in range(comp_count)]\n    indegree = [0] * comp_count\n    \n    for u, v in edges:\n        cu = comp_map[comp_id[u]]\n        cv = comp_map[comp_id[v]]\n        if cu == cv:\n            # Same component but '>' relation -> inconsistency\n            print(\"inconsistent\")\n            return\n        adj[cu].append(cv)\n        indegree[cv] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    queue = deque([i for i in range(comp_count) if indegree[i] == 0])\n    processed = 0\n    \n    while queue:\n        node = queue.popleft()\n        processed += 1\n        for neighbor in adj[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if processed == comp_count:\n        print(\"consistent\")\n    else:\n        print(\"inconsistent\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.756450176239014}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = list(data[2])\n    \n    idx = 3\n    for _ in range(m):\n        l = int(data[idx]) - 1\n        r = int(data[idx+1]) - 1\n        c1 = data[idx+2]\n        c2 = data[idx+3]\n        idx += 4\n        \n        for i in range(l, r+1):\n            if s[i] == c1:\n                s[i] = c2\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.736945390701294}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_k_periodic(s, k):\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    # First substring of length k\n    prev = s[:k]\n    \n    # Check each subsequent block\n    for i in range(k, n, k):\n        current = s[i:i+k]\n        # Check if current is right-rotation of prev\n        if current != prev[-1] + prev[:-1]:\n            return False\n        prev = current\n    \n    return True\n\ndef main():\n    s = input().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if is_k_periodic(s, k):\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.464393138885498}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.84237909317017}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n    \n    # Fenwick tree (1-indexed internally)\n    bit = [0] * (N + 1)\n    \n    def update(idx, delta):\n        i = idx + 1  # convert to 1-indexed\n        while i <= N:\n            bit[i] += delta\n            i += i & -i\n    \n    def query(idx):\n        # sum of a[0]..a[idx-1]\n        if idx <= 0:\n            return 0\n        i = idx  # already 0-indexed for prefix\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n    \n    out_lines = []\n    for _ in range(Q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            update(i, delta)\n        else:  # op == '?'\n            i = int(next(it))\n            out_lines.append(str(query(i)))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 20.75796866416931}

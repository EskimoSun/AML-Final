{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.36042189598083}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 102.76805877685547}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.84512710571289}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\n\nclass Node:\n    __slots__ = ('val', 'left', 'right', 'depth')\n    def __init__(self, val, depth):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.depth = depth\n\ndef main():\n    n = int(read().strip())\n    seq = [int(read().strip()) for _ in range(n)]\n    \n    # Initialize root\n    root = Node(seq[0], 0)\n    total_depth_sum = 0\n    results = [0]  # First insertion depth is 0\n    \n    # Insert remaining numbers\n    for i in range(1, n):\n        val = seq[i]\n        current = root\n        depth = 0\n        \n        while True:\n            depth += 1\n            if val < current.val:\n                if current.left is None:\n                    current.left = Node(val, depth)\n                    total_depth_sum += depth\n                    results.append(total_depth_sum)\n                    break\n                else:\n                    current = current.left\n            else:  # val > current.val (since distinct)\n                if current.right is None:\n                    current.right = Node(val, depth)\n                    total_depth_sum += depth\n                    results.append(total_depth_sum)\n                    break\n                else:\n                    current = current.right\n    \n    # Output results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 95.63335371017456}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "COMPLEXITY": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.87171506881714}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining // B\n    remaining -= donuts_count * B\n    \n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.445368766784668}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.91662073135376}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.readline\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nqueries = []\nfor _ in range(m):\n    k, pos = map(int, input().split())\n    queries.append((k, pos))\n\n# Preprocess: sort indices by value (descending) and then by index (ascending for lexicographic minimality)\n# We'll store (value, -index) to use max-heap, then convert to min-heap for selection\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))  # Sort by value descending, then index ascending\n\n# For each k, we need to select the first k indices from the sorted list,\n# then sort those indices to maintain original order\n# We'll precompute for all k from 1 to n\nselected_indices = []\n# We'll use a min-heap to keep track of the k largest values while maintaining order\n# Actually, we need to select k indices with largest values, then sort them to get subsequence\n# Better: for each k, take first k from indices sorted by (-value, index),\n# then sort these k indices to get their original order\n# This gives us the optimal subsequence for each k\n\n# Precompute for all k\noptimal_for_k = [[] for _ in range(n + 1)]\n# We'll build incrementally\ncurrent_indices = []\nfor k in range(1, n + 1):\n    # Add the k-th best element (from sorted list)\n    idx = indices[k - 1]\n    # Insert idx into current_indices maintaining sorted order\n    # We'll use bisect for efficient insertion\n    import bisect\n    bisect.insort(current_indices, idx)\n    optimal_for_k[k] = current_indices.copy()\n\n# Now answer queries\nanswers = []\nfor k, pos in queries:\n    # Get the optimal subsequence indices for this k\n    seq_indices = optimal_for_k[k]\n    # The element at position pos (1-indexed) in the subsequence\n    original_idx = seq_indices[pos - 1]\n    answers.append(a[original_idx])\n\n# Output answers\nprint('\\n'.join(map(str, answers)))", "complexity_estimate": null, "runtime_sec": 41.067182540893555}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 131.8163652420044}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ninput = sys.stdin.readline\\r\\n\\r\\ndef solve():\\r\\n    n = int(input().strip())\\r\\n    guests = []\\r\\n    for _ in range(n):\\r\\n        l, r = map(int, input().split())\\r\\n        guests.append((l, r))\\r\\n    \\r\\n    # Sort guests by (l_i + r_i) descending\\r\\n    guests.sort(key=lambda x: x[0] + x[1], reverse=True)\\r\\n    \\r\\n    total_chairs = 0\\r\\n    # Process each guest\\r\\n    for l, r in guests:\\r\\n        # For each guest, we need at least (l + r + 1) chairs in their circle\\r\\n        # But we can merge circles if possible\\r\\n        # The optimal strategy is to put guests in circles where their requirements\\r\\n        # can be satisfied with minimal additional chairs\\r\\n        # Since we sorted by (l+r) descending, we try to satisfy the most demanding first\\r\\n        \\r\\n        # For the first guest in a new circle\\r\\n        if total_chairs == 0:\\r\\n            total_chairs = l + r + 1\\r\\n        else:\\r\\n            # Try to add to existing circles\\r\\n            # The additional chairs needed when adding to an existing circle\\r\\n            # is max(l, r) - min(l, r) if we can arrange properly\\r\\n            # But actually, when adding to a circle, we need to ensure\\r\\n            # both guests\\' requirements are satisfied\\r\\n            # The minimal additional chairs is max(l, r) - existing_space\\r\\n            # where existing_space is the current free chairs in the circle\\r\\n            \\r\\n            # Since we can create new circles arbitrarily, the optimal is to\\r\\n            # put each guest in their own circle or merge when beneficial\\r\\n            # Actually, merging never reduces total chairs because:\\r\\n            # If we have two guests with requirements (l1, r1) and (l2, r2)\\r\\n            # In separate circles: (l1+r1+1) + (l2+r2+1)\\r\\n            # In merged circle: max(l1, r2) + max(r1, l2) + 2\\r\\n            # The merged version is always >= separate version\\r\\n            # So we should never merge!\\r\\n            \\r\\n            # Wait, but the note in problem says merging can be beneficial\\r\\n            # Let me reconsider...\\r\\n            \\r\\n            # Actually, the correct approach:\\r\\n            # For each guest, we need at least (l + r + 1) chairs\\r\\n            # But when we have multiple guests in a circle, the chairs\\r\\n            # between them can serve both guests\\' requirements\\r\\n            # \\r\\n            # The optimal arrangement is to sort guests by l_i descending\\r\\n            # and then by r_i ascending, or vice versa\\r\\n            # Let me implement the known solution pattern\\r\\n            \\r\\n            # After checking known solutions for similar problems:\\r\\n            # The answer is sum(max(l_i, r_i)) + n\\r\\n            # But need to adjust for overlapping when alone\\r\\n            \\r\\n            # Let me test with the examples:\\r\\n            # Example 1: (1,1), (1,1), (1,1)\\r\\n            # sum(max(1,1)) = 3, +3 = 6 âœ“\\r\\n            # \\r\\n            # Example 2: (1,2), (2,1), (3,5), (5,3)\\r\\n            # max values: 2, 2, 5, 5 = 14, +4 = 18 but answer is 15\\r\\n            # So this formula is wrong\\r\\n            \\r\\n            # Let me think differently...\\r\\n            # When we have a circle with k guests, the total chairs needed is\\r\\n            # sum(max(l_i, r_{i+1})) where i+1 wraps around\\r\\n            # We need to find arrangement that minimizes this sum\\r\\n            \\r\\n            # This becomes: minimize sum(max(l_i, r_{permutation[i+1]}))\\r\\n            # over all cyclic permutations\\r\\n            \\r\\n            # Known solution: sort by (l_i - r_i) and arrange in that order\\r\\n            # Then answer = sum(max(l_i, r_{i+1})) + n\\r\\n            \\r\\n            # Let me implement this\\r\\n    \\r\\n    # Re-read input and implement correct solution\\r\\n    n = int(input().strip())\\r\\n    guests = []\\r\\n    for _ in range(n):\\r\\n        l, r = map(int, input().split())\\r\\n        guests.append((l, r))\\r\\n    \\r\\n    if n == 1:\\r\\n        l, r = guests[0]\\r\\n        print(l + r + 1)\\r\\n        return\\r\\n    \\r\\n    # Sort by (l - r)\\r\\n    guests.sort(key=lambda x: x[0] - x[1])\\r\\n    \\r\\n    total = 0\\r\\n    for i in range(n):\\r\\n        l1, r1 = guests[i]\\r\\n        l2, r2 = guests[(i + 1) % n]\\r\\n        total += max(l1, r2)\\r\\n    \\r\\n    total += n  # Add one chair for each guest\\r\\n    print(total)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 2839, 2840, 'illegal multibyte sequence')", "runtime_sec": 92.43798685073853}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.47259140014648}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.54559779167175}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.02099704742432}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for length in l:\n        g = math.gcd(g, length)\n    \n    # If gcd > 1, impossible to reach all cells\n    if g > 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd_value] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting with gcd 0 (which becomes first card's length)\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for current_gcd, cost in dp.items():\n            new_gcd = math.gcd(current_gcd, l[i])\n            new_cost = cost + c[i]\n            if new_cost < new_dp[new_gcd]:\n                new_dp[new_gcd] = new_cost\n        dp = new_dp\n    \n    # Answer is minimal cost to achieve gcd = 1\n    result = dp.get(1, float('inf'))\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.212766647338867}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data[:3])\n    # Calculate time needed: distance / speed\n    # Since all values are integers, we can compare T * S >= D\n    # to avoid floating point operations\n    if T * S >= D:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.045066595077515}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.86359548568726}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.58513879776001}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(line.strip()) for line in data[1:1+H]]\n    \n    # Find player start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to find all reachable safe squares\n    visited = [[False] * W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    \n    gold_count = 0\n    \n    while queue:\n        r, c = queue.pop(0)\n        \n        # Check if current cell has gold\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        has_adjacent_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 'T':\n                has_adjacent_trap = True\n                break\n        \n        # If there's an adjacent trap, we cannot move further from this cell\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc]:\n                # Only move to non-wall, non-trap cells\n                if grid[nr][nc] != '#' and grid[nr][nc] != 'T':\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 32.457090616226196}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.93580293655396}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 78.82115340232849}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # The game is equivalent to a take-away game where the Grundy number\n    # for a branch of length n is n-1 (since you can break into any two integer parts).\n    # Alice wins if n-1 is odd (non-zero), loses if even.\n    # For n=2: Grundy=1 (odd) -> Alice wins, break off 1.\n    # For n=3: Grundy=2 (even) -> Bob wins.\n    # For n=4: Grundy=3 (odd) -> Alice wins, break off 1 or 2.\n    # For n=5: Grundy=4 (even) -> Bob wins.\n    # Pattern: Alice wins for even n, Bob wins for odd n.\n    # Winning move: break off 1 piece of length 1 (always valid for n>=2).\n    \n    if n % 2 == 0:\n        print(\"Alice\")\n        print(1)\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.356220483779907}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.02290439605713}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            needed = target - current_height\n            if needed > m - days_used:\n                return False\n            days_used += needed\n            current += needed\n            # Mark the end of the watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    \n    return days_used <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.87673830986023}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.46561884880066}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.99905943870544}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"TLE": 1}, "first_failure": null, "final_code": "import sys\n\ndef insertion_sort_swaps(arr):\n    \"\"\"Return number of swaps performed by insertion sort on array arr.\"\"\"\n    n = len(arr)\n    arr = arr[:]  # work on copy\n    swaps = 0\n    for i in range(1, n):\n        j = i\n        while j > 0 and arr[j] < arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            swaps += 1\n            j -= 1\n    return swaps\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    perm = list(map(int, data[1:1 + n]))\n    \n    # Step 1: Compute original number of swaps\n    original_swaps = insertion_sort_swaps(perm)\n    \n    # Step 2: Precompute positions array\n    pos = [0] * n\n    for idx, val in enumerate(perm):\n        pos[val] = idx\n    \n    # Step 3: Compute inversions count for each element\n    # inv[i] = number of j < i with perm[j] > perm[i]\n    inv = [0] * n\n    for i in range(n):\n        cnt = 0\n        for j in range(i):\n            if perm[j] > perm[i]:\n                cnt += 1\n        inv[i] = cnt\n    \n    # Step 4: Try all pairs (i, j) with i < j\n    min_swaps = original_swaps\n    count_pairs = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Simulate swapping perm[i] and perm[j]\n            x, y = perm[i], perm[j]\n            if x < y:\n                # For x < y, swapping creates inversion between x and y\n                # and affects elements between their positions\n                delta = 1  # due to new inversion between x and y\n                # Count elements between i and j that are between x and y in value\n                for k in range(i + 1, j):\n                    if x < perm[k] < y:\n                        delta += 2  # each such element creates two additional swaps\n            else:  # x > y\n                # For x > y, swapping removes inversion between x and y\n                delta = -1  # due to removed inversion between x and y\n                # Count elements between i and j that are between y and x in value\n                for k in range(i + 1, j):\n                    if y < perm[k] < x:\n                        delta -= 2  # each such element reduces two swaps\n            \n            new_swaps = original_swaps + delta\n            if new_swaps < min_swaps:\n                min_swaps = new_swaps\n                count_pairs = 1\n            elif new_swaps == min_swaps:\n                count_pairs += 1\n    \n    print(f\"{min_swaps} {count_pairs}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 71.12258458137512}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 43.41529417037964}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 246234 tokens (244634 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 12.320348739624023}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_split_equally(a):\n    \"\"\"Check if we can split 4 bags into two groups with equal sum.\"\"\"\n    total = sum(a)\n    # If total is odd, impossible to split equally\n    if total % 2 != 0:\n        return False\n    \n    target = total // 2\n    \n    # Try all subsets of the 4 bags (2^4 = 16 possibilities)\n    for mask in range(1 << 4):\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            return True\n    return False\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = list(map(int, data[:4]))\n    result = \"YES\" if can_split_equally(a) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.07373595237732}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    seen = set()\n    result = []\n    \n    # Traverse from right to left to keep rightmost occurrences\n    for i in range(n-1, -1, -1):\n        if a[i] not in seen:\n            seen.add(a[i])\n            result.append(a[i])\n    \n    # Reverse to restore original order\n    result.reverse()\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.732688903808594}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.14229607582092}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to compute final score given fifth time\n    def final_score(fifth: float) -> float:\n        all_times = times + [fifth]\n        all_times.sort()\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Case 1: Check if already winning with worst possible fifth time (20.00)\n    if final_score(20.00) <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 2: Check if losing even with best possible fifth time (1.00)\n    if final_score(1.00) > target:\n        print(\"impossible\")\n        return\n    \n    # Case 3: Binary search for worst possible fifth time\n    lo, hi = 1.00, 20.00\n    # Precision: need to 2 decimal places, so search until difference < 1e-4\n    for _ in range(50):  # Enough iterations for required precision\n        mid = (lo + hi) / 2.0\n        if final_score(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to two decimal places (banker's rounding)\n    result = round(lo, 2)\n    # Ensure exactly two decimal places\n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 61.42002034187317}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input as string to easily access digits\n    n_str = input().strip()\n    \n    # Check if the string reads the same forwards and backwards\n    if n_str == n_str[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.018949747085571}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.13414216041565}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Fast I/O\ninput = sys.stdin.readline\n\n# Read N\nN = int(input().strip())\n\n# Read initial strings\nstrings = [input().strip() for _ in range(N)]\n\n# Read operations\noperations = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\n# Track which strings are still active (not emptied)\n# Initially all are active\nactive = [True] * N\n\n# Process operations in order\nfor a, b in operations:\n    # Convert to 0-based indexing\n    a_idx = a - 1\n    b_idx = b - 1\n    \n    # Concatenate a = a + b\n    strings[a_idx] = strings[a_idx] + strings[b_idx]\n    \n    # Empty b\n    strings[b_idx] = \"\"\n    active[b_idx] = False\n\n# Find the only remaining non-empty string\nfor i in range(N):\n    if active[i]:\n        print(strings[i])\n        break", "complexity_estimate": null, "runtime_sec": 22.798720836639404}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    # Total cost = train fare + half of bus fare\n    total_cost = X + Y // 2\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.530140161514282}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    event_set = set()  # set of events that are currently considered to have happened\n    results = []\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        if parts[0] == 'E':\n            event = parts[1]\n            events_stack.append(event)\n            event_set.add(event)\n        elif parts[0] == 'D':\n            r = int(parts[1])\n            for _ in range(r):\n                if events_stack:\n                    event_set.remove(events_stack.pop())\n        elif parts[0] == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            # Check if scenario is consistent with current state\n            consistent = True\n            for e in scenario_events:\n                if e.startswith('!'):\n                    event_name = e[1:]\n                    if event_name in event_set:\n                        consistent = False\n                        break\n                else:\n                    if e not in event_set:\n                        consistent = False\n                        break\n            if consistent:\n                results.append(\"Yes\")\n                continue\n            \n            # If not consistent, check if adding a D r before makes it consistent\n            # We need to find smallest r such that after removing last r events, scenario becomes consistent\n            min_r = None\n            # Simulate removing different numbers of events from the end\n            temp_stack = events_stack.copy()\n            temp_set = set(event_set)  # copy current set\n            for r in range(1, len(temp_stack) + 1):\n                # Remove last r events\n                removed_events = temp_stack[-r:]\n                new_set = temp_set - set(removed_events)\n                # Check consistency with new_set\n                scenario_consistent = True\n                for e in scenario_events:\n                    if e.startswith('!'):\n                        event_name = e[1:]\n                        if event_name in new_set:\n                            scenario_consistent = False\n                            break\n                    else:\n                        if e not in new_set:\n                            scenario_consistent = False\n                            break\n                if scenario_consistent:\n                    min_r = r\n                    break\n                # Prepare for next iteration: actually remove one more event\n                # (we already have removed r events in thought, but for next iteration we need r+1)\n                # This is handled by the loop incrementing r\n            \n            if min_r is not None:\n                results.append(f\"{min_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 74.93767595291138}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 214766 tokens (213166 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 11.55134129524231}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data[:3])\n    # All possible routes with 2 flights (3 airports visited in order)\n    # Since flights are bidirectional, we consider all permutations of 3 airports\n    # But we only need to consider the 3 distinct routes up to symmetry:\n    # A->B->C, B->C->A, C->A->B (and their reverses give same sums)\n    # Actually simpler: we need min of (P+Q), (Q+R), (R+P)\n    # Because any route of 2 flights uses two of the three distances\n    ans = min(P + Q, Q + R, R + P)\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.22167205810547}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.3578178882599}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.49929213523865}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        a = list(map(int, input_data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        moves = 0\n        alice_total = 0\n        bob_total = 0\n        last_eaten = 0\n        current_sum = 0\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            \n            if moves % 2 == 1:  # Alice's turn\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:  # Bob's turn\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            \n            last_eaten = current_sum\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.496211767196655}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 58.27068114280701}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.73840427398682}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A_i = int(data[idx]); idx += 1\n        # Count days when participant eats: day 1, A_i+1, 2A_i+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A_i\n    \n    # Initial pieces = eaten pieces + remaining pieces\n    initial_pieces = total_eaten + X\n    print(initial_pieces)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.026949882507324}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.39380478858948}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Total possible pairs without restrictions\n    total_pairs = m * m\n    \n    # Subtract pairs where robots would meet\n    # For each number x, if it appears at position i from left and j from right\n    # where i + j > n, then giving x to both robots would make them meet\n    # Actually, we need to find for each number x, the first occurrence from left\n    # and first occurrence from right\n    \n    # Find first occurrence from left for each number\n    first_left = {}\n    for i, num in enumerate(arr):\n        if num not in first_left:\n            first_left[num] = i  # 0-based index\n    \n    # Find first occurrence from right for each number\n    first_right = {}\n    for i in range(n-1, -1, -1):\n        num = arr[i]\n        if num not in first_right:\n            first_right[num] = i  # 0-based index\n    \n    # Count pairs (p, q) where robots would meet\n    # Robots meet if the left robot's stopping position >= right robot's stopping position\n    # The left robot stops at first occurrence of p from left\n    # The right robot stops at first occurrence of q from right\n    # They meet if first_left[p] >= first_right[q]\n    \n    # Sort distinct numbers by their first_left position\n    sorted_by_left = sorted(distinct_nums, key=lambda x: first_left[x])\n    \n    # For each q, count how many p have first_left[p] >= first_right[q]\n    meet_pairs = 0\n    \n    # We can use two pointers or binary search\n    # For each q, find the first p in sorted_by_left where first_left[p] >= first_right[q]\n    # All p from that point onward would cause meeting\n    \n    # Since we need to count all pairs (p, q), we iterate through all q\n    for q in distinct_nums:\n        right_pos = first_right[q]\n        \n        # Binary search to find first p with first_left[p] >= right_pos\n        lo, hi = 0, m-1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            p_num = sorted_by_left[mid]\n            if first_left[p_num] >= right_pos:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        # lo is the index of first p with first_left[p] >= right_pos\n        # Number of p that cause meeting with this q is m - lo\n        meet_pairs += (m - lo)\n    \n    # Valid pairs are total_pairs - meet_pairs\n    result = total_pairs - meet_pairs\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 42.100125789642334}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.5285575389862}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.8264422416687}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.053058862686157}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            result.append(x - 1)\n        else:\n            result.append(x)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.548717021942139}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    names = data[1:1+n]\n    \n    thore_index = -1\n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_index = i\n            break\n    \n    # Case 1: Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check names above Thore\n    above_names = names[:thore_index]\n    \n    # Case 2: Check if any name above has prefix \"ThoreHusfeld\" (without trailing 't')\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Case 3: Find smallest unique prefix\n    thore = \"ThoreHusfeldt\"\n    for prefix_len in range(1, len(thore) + 1):\n        prefix = thore[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Fallback: should not happen given constraints\n    print(thore)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 22.96709680557251}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "COMPLEXITY": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.15664076805115}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.61723756790161}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.4436411857605}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.9975917339325}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.21433734893799}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.27724289894104}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.50162839889526}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival_minute, aggressive_time, calm_time):\n    \"\"\"\n    Determine if a dog is aggressive at a given minute.\n    The dog's cycle repeats every (aggressive_time + calm_time) minutes.\n    It's aggressive during the first aggressive_time minutes of each cycle.\n    \"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival_minute % cycle_length\n    # If position_in_cycle is 0, it's at the end of a cycle (calm period)\n    # Aggressive if position_in_cycle is between 1 and aggressive_time inclusive\n    return 1 <= position_in_cycle <= aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    arrivals = [P, M, G]\n    results = []\n    \n    for arrival in arrivals:\n        # Check each dog\n        dog1_aggressive = is_aggressive(arrival, A, B)\n        dog2_aggressive = is_aggressive(arrival, C, D)\n        \n        if dog1_aggressive and dog2_aggressive:\n            results.append(\"both\")\n        elif dog1_aggressive or dog2_aggressive:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.36060667037964}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror-symmetric letters\n    mirror_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'}\n    \n    # Check each character\n    for ch in word:\n        if ch not in mirror_letters:\n            return False\n    \n    # Check if the word is a palindrome\n    return word == word[::-1]\n\ndef main():\n    # Read input efficiently for large strings\n    word = sys.stdin.readline().strip()\n    \n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.086546421051025}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 62.401193141937256}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    record = sys.stdin.readline().strip()\n    a_score = 0\n    b_score = 0\n    \n    i = 0\n    while i < len(record):\n        player = record[i]\n        points = int(record[i + 1])\n        \n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        \n        # Check for win conditions\n        if a_score >= 11 or b_score >= 11:\n            # Regular win (not in tie-break)\n            if abs(a_score - b_score) >= 2:\n                # Game ended\n                if a_score > b_score:\n                    print('A')\n                else:\n                    print('B')\n                return\n            # If scores are 10-10, switch to win-by-2 rule\n            elif a_score == 10 and b_score == 10:\n                # Continue playing until someone leads by 2\n                i += 2\n                while i < len(record):\n                    player = record[i]\n                    points = int(record[i + 1])\n                    \n                    if player == 'A':\n                        a_score += points\n                    else:\n                        b_score += points\n                    \n                    if abs(a_score - b_score) >= 2:\n                        if a_score > b_score:\n                            print('A')\n                        else:\n                            print('B')\n                        return\n                    i += 2\n                # Should not reach here per problem statement\n                return\n        \n        i += 2\n    \n    # Fallback (should not be reached for valid input)\n    if a_score > b_score:\n        print('A')\n    else:\n        print('B')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.28312587738037}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.33215832710266}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for dice in range(1, 7):\n        diff_a = abs(a - dice)\n        diff_b = abs(b - dice)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.298403978347778}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Map values to indices for easier counting\n    order = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Count how many complete sequences we can form\n    count = [0] * 6\n    \n    for num in arr:\n        idx = order[num]\n        if idx == 0:\n            count[0] += 1\n        else:\n            # Can only add to this position if previous position has enough\n            if count[idx-1] > count[idx]:\n                count[idx] += 1\n    \n    # The number of complete sequences is count[5]\n    complete_sequences = count[5]\n    \n    # Minimum elements to remove = total elements - elements in complete sequences\n    return n - (complete_sequences * 6)\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "complexity_estimate": null, "runtime_sec": 20.739214658737183}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2124942 tokens (2123342 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 16.37565302848816}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.97613906860352}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.07772254943848}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.6768832206726}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef factorize(m):\n    \"\"\"Return prime factorization of m as list of (prime, exponent) pairs.\"\"\"\n    factors = []\n    d = 2\n    while d * d <= m:\n        if m % d == 0:\n            cnt = 0\n            while m % d == 0:\n                m //= d\n                cnt += 1\n            factors.append((d, cnt))\n        d += 1 if d == 2 else 2\n    if m > 1:\n        factors.append((m, 1))\n    return factors\n\ndef modinv(a, mod=MOD):\n    \"\"\"Return modular inverse of a modulo mod using Fermat's little theorem.\"\"\"\n    return pow(a, mod-2, mod)\n\ndef nCr(n, r, fact, inv_fact):\n    \"\"\"Return n choose r modulo MOD using precomputed factorials.\"\"\"\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    N = int(input_data[0])\n    M = int(input_data[1])\n    \n    # Factorize M\n    factors = factorize(M)\n    \n    # Precompute factorials up to N + max_exponent\n    max_exp = max((exp for _, exp in factors), default=0)\n    max_n = N + max_exp\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = modinv(fact[max_n])\n    for i in range(max_n, 0, -1):\n        inv_fact[i-1] = inv_fact[i] * i % MOD\n    \n    # For each prime factor, compute number of ways to distribute its exponent across N positions\n    result = 1\n    for _, exp in factors:\n        # Number of nonnegative integer solutions to x1 + x2 + ... + xN = exp\n        # is C(exp + N - 1, N - 1)\n        ways = nCr(exp + N - 1, N - 1, fact, inv_fact)\n        result = result * ways % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 101.87744855880737}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Since moving by 2 is free, we only care about parity of positions\n    # Chips with same parity can be moved together for free\n    # We need to choose target parity that minimizes cost\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for pos in x if pos % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins needed is the smaller count\n    # Because we can move all chips to either all even or all odd positions\n    # Moving a chip from even to odd (or vice versa) costs 1 coin\n    # So we choose the parity that requires moving fewer chips\n    \n    result = min(even_count, odd_count)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.63442087173462}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 154.11552166938782}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nclass VesselSystem:\n    def __init__(self, n, capacities):\n        self.n = n\n        self.capacities = capacities\n        self.water = [0] * (n + 1)  # 1-indexed\n        self.parent = list(range(n + 1))  # Union-Find parent\n        self.next_empty = list(range(1, n + 2))  # Next vessel that can receive overflow\n\n    def find(self, x):\n        # Find with path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        # Union two sets\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n\n    def pour(self, p, x):\n        # Pour x liters into vessel p\n        current = p\n        while x > 0 and current <= self.n:\n            current = self.find(current)\n            if current > self.n:\n                break\n            \n            available = self.capacities[current - 1] - self.water[current]\n            if available >= x:\n                # All water fits in current vessel\n                self.water[current] += x\n                x = 0\n            else:\n                # Fill current vessel and overflow remainder\n                self.water[current] = self.capacities[current - 1]\n                x -= available\n                # Mark this vessel as full and union with next\n                if current < self.n:\n                    self.union(current, current + 1)\n                current += 1\n\n    def query(self, k):\n        # Return water in vessel k\n        return self.water[k]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    capacities = list(map(int, data[idx:idx + n])); idx += n\n    m = int(data[idx]); idx += 1\n    \n    system = VesselSystem(n, capacities)\n    output = []\n    \n    for _ in range(m):\n        query_type = int(data[idx]); idx += 1\n        \n        if query_type == 1:\n            p = int(data[idx]); idx += 1\n            x = int(data[idx]); idx += 1\n            system.pour(p, x)\n        else:  # query_type == 2\n            k = int(data[idx]); idx += 1\n            output.append(str(system.query(k)))\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 33.69785952568054}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    a = int(data[1])\n    enemy_ships = list(map(int, data[2:2+n]))\n    \n    # Sort enemy ships in ascending order\n    enemy_ships.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemy_ships:\n        # To win, Atli needs at least enemy+1 ships\n        required = enemy + 1\n        \n        # Check if we have enough ships remaining\n        if ships_used + required <= a:\n            wins += 1\n            ships_used += required\n        else:\n            # Can't win this battle, break since ships are sorted\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.1197829246521}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split('\\n')\n    if len(data) < 2:\n        print(\"corrupted\")\n        return\n    \n    I = data[0].strip()\n    O = data[1].strip()\n    \n    # Find positions of + and - in input\n    plus_positions = [i for i, ch in enumerate(I) if ch == '+']\n    minus_positions = [i for i, ch in enumerate(I) if ch == '-']\n    \n    # If no + or - in input, check if output matches input\n    if not plus_positions and not minus_positions:\n        if I == O:\n            print(\"<any> <any>\")\n        else:\n            print(\"corrupted\")\n        return\n    \n    # Try to find possible encodings\n    results = []\n    \n    # Generate all possible splits of O based on positions of + and -\n    # We need to match the structure: O = prefix + encoding_of_plus + middle + encoding_of_minus + suffix\n    # where prefix, middle, suffix are parts that match the corresponding parts of I\n    \n    # For each possible encoding length for +\n    for plus_len in range(len(O) + 1):\n        # For each possible encoding length for -\n        for minus_len in range(len(O) + 1):\n            # Try to match the structure\n            valid = True\n            plus_enc = \"\"\n            minus_enc = \"\"\n            \n            # Build expected O based on encodings\n            expected = []\n            i_idx = 0\n            o_idx = 0\n            \n            while i_idx < len(I):\n                if I[i_idx] == '+':\n                    # Consume plus_len characters from O\n                    if o_idx + plus_len > len(O):\n                        valid = False\n                        break\n                    if plus_enc == \"\":\n                        plus_enc = O[o_idx:o_idx + plus_len]\n                    elif O[o_idx:o_idx + plus_len] != plus_enc:\n                        valid = False\n                        break\n                    o_idx += plus_len\n                    i_idx += 1\n                elif I[i_idx] == '-':\n                    # Consume minus_len characters from O\n                    if o_idx + minus_len > len(O):\n                        valid = False\n                        break\n                    if minus_enc == \"\":\n                        minus_enc = O[o_idx:o_idx + minus_len]\n                    elif O[o_idx:o_idx + minus_len] != minus_enc:\n                        valid = False\n                        break\n                    o_idx += minus_len\n                    i_idx += 1\n                else:\n                    # Regular character, must match exactly\n                    if o_idx >= len(O) or O[o_idx] != I[i_idx]:\n                        valid = False\n                        break\n                    o_idx += 1\n                    i_idx += 1\n            \n            # Check if we consumed all of O\n            if valid and o_idx == len(O):\n                # Format the encodings\n                plus_str = plus_enc if plus_enc != \"\" else \"<empty>\"\n                minus_str = minus_enc if minus_enc != \"\" else \"<empty>\"\n                \n                # Handle <any> cases\n                if not plus_positions:\n                    plus_str = \"<any>\"\n                if not minus_positions:\n                    minus_str = \"<any>\"\n                \n                result = f\"{plus_str} {minus_str}\"\n                if result not in results:\n                    results.append(result)\n    \n    if not results:\n        print(\"corrupted\")\n    else:\n        for r in results:\n            print(r)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.133792877197266}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    \n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, which is equivalent to a == k * b\n    # So we need to check if there exists b in [x, y] such that k * b is in [l, r]\n    \n    # Iterate through possible b values\n    for b in range(x, y + 1):\n        a = k * b\n        if l <= a <= r:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.2727313041687}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.17154574394226}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring_length(s: str) -> int:\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Binary search on answer length\n    low, high = 0, n\n    answer = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Check if there exists substring of length mid that appears at least twice\n        seen = set()\n        found = False\n        \n        for i in range(n - mid + 1):\n            substring = s[i:i+mid]\n            if substring in seen:\n                found = True\n                break\n            seen.add(substring)\n        \n        if found:\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return answer\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L = int(data[0])\n    s = data[1]\n    \n    result = longest_repeated_substring_length(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.312342405319214}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ndef count_pythagorean_triangles(n):\\r\\n    \"\"\"Count right-angled triangles with 1 â‰¤ a â‰¤ b â‰¤ c â‰¤ n satisfying aÂ² + bÂ² = cÂ²\"\"\"\\r\\n    count = 0\\r\\n    \\r\\n    # Iterate over possible a values\\r\\n    for a in range(1, n + 1):\\r\\n        # For each a, iterate over possible b values (b â‰¥ a)\\r\\n        for b in range(a, n + 1):\\r\\n            # Calculate cÂ² = aÂ² + bÂ²\\r\\n            c_squared = a * a + b * b\\r\\n            \\r\\n            # Check if c is an integer and within bounds\\r\\n            c = int(c_squared ** 0.5)\\r\\n            if c * c == c_squared and c <= n:\\r\\n                count += 1\\r\\n    \\r\\n    return count\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Read input\\r\\n    data = sys.stdin.read().strip()\\r\\n    if not data:\\r\\n        print(0)\\r\\n    else:\\r\\n        n = int(data)\\r\\n        result = count_pythagorean_triangles(n)\\r\\n        print(result)', 122, 123, 'illegal multibyte sequence')", "runtime_sec": 19.843399047851562}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data[:3])\n    \n    # Days from best-by date to eating\n    days_from_best_by = B - A\n    \n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by date\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by date\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.009076833724976}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport math\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    \\r\\n    L = int(data[0])\\r\\n    x1, y1 = int(data[1]), int(data[2])\\r\\n    x2, y2 = int(data[3]), int(data[4])\\r\\n    \\r\\n    # Calculate distance from origin to the line\\r\\n    # Line through (x1,y1) and (x2,y2)\\r\\n    # Using formula: distance = |Ax0 + By0 + C| / sqrt(A^2 + B^2)\\r\\n    # where line: Ax + By + C = 0\\r\\n    \\r\\n    # Calculate A, B, C for line equation\\r\\n    A = y2 - y1\\r\\n    B = x1 - x2\\r\\n    C = x2*y1 - x1*y2\\r\\n    \\r\\n    # Distance from origin (0,0) to the line\\r\\n    dist = abs(C) / math.sqrt(A*A + B*B)\\r\\n    \\r\\n    # Binary search for minimum chain length R (in meters)\\r\\n    low = 0\\r\\n    high = 20000  # Upper bound: sqrt(L/pi) + dist + some margin\\r\\n    \\r\\n    def area_covered(R):\\r\\n        \"\"\"Calculate area dog can cover with chain length R\"\"\"\\r\\n        if R <= dist:\\r\\n            # Dog is on same side as origin, can cover full circle\\r\\n            return math.pi * R * R\\r\\n        else:\\r\\n            # Dog is on opposite side of wall\\r\\n            # Area = circle area - segment area + segment area on other side\\r\\n            # Actually simpler: area = Ï€RÂ² - (segment area * 2) + segment area?\\r\\n            # Let\\'s compute directly: area = Ï€RÂ² - 2 * segment_area\\r\\n            # where segment_area is area of circular segment cut by wall\\r\\n            \\r\\n            # Angle of the segment: cos(Î¸/2) = dist/R\\r\\n            theta = 2 * math.acos(dist / R)\\r\\n            \\r\\n            # Area of circular segment: RÂ²/2 * (Î¸ - sinÎ¸)\\r\\n            segment_area = 0.5 * R * R * (theta - math.sin(theta))\\r\\n            \\r\\n            # Total area = full circle - 2 * segment_area\\r\\n            return math.pi * R * R - 2 * segment_area\\r\\n    \\r\\n    # Binary search for minimum integer R where area >= L\\r\\n    while low < high:\\r\\n        mid = (low + high) // 2\\r\\n        if area_covered(mid) >= L:\\r\\n            high = mid\\r\\n        else:\\r\\n            low = mid + 1\\r\\n    \\r\\n    print(low)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 1177, 1178, 'illegal multibyte sequence')", "runtime_sec": 92.06414794921875}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.43899965286255}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    print(A * B)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 9.271548748016357}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count all Pythagorean triples modulo n with 1 <= a <= b <= n-1\"\"\"\n    count = 0\n    \n    # Precompute squares modulo n\n    squares_mod = [0] * n\n    for i in range(n):\n        squares_mod[i] = (i * i) % n\n    \n    # Count frequencies of each square residue\n    freq = [0] * n\n    for i in range(1, n):\n        freq[squares_mod[i]] += 1\n    \n    # For each possible a and b, check if (a^2 + b^2) mod n is a square residue\n    for a in range(1, n):\n        a_sq = squares_mod[a]\n        for b in range(a, n):\n            b_sq = squares_mod[b]\n            target = (a_sq + b_sq) % n\n            count += freq[target]\n    \n    return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 61.31215143203735}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    S = data[0]\n    Q = int(data[1])\n    queries = data[2:]\n    \n    # Use two deques to represent the string efficiently\n    from collections import deque\n    front = deque()\n    back = deque()\n    \n    # Initially, all characters are in the back deque\n    for ch in S:\n        back.append(ch)\n    \n    reversed_flag = False\n    \n    for query in queries:\n        parts = query.split()\n        t = int(parts[0])\n        \n        if t == 1:\n            # Reverse operation: just flip the flag\n            reversed_flag = not reversed_flag\n        else:\n            # t == 2\n            f = int(parts[1])\n            c = parts[2]\n            \n            # Determine actual side based on reversed_flag\n            if not reversed_flag:\n                # Normal orientation\n                if f == 1:\n                    front.appendleft(c)\n                else:  # f == 2\n                    back.append(c)\n            else:\n                # Reversed orientation\n                if f == 1:\n                    back.append(c)\n                else:  # f == 2\n                    front.appendleft(c)\n    \n    # Construct the final string\n    if not reversed_flag:\n        result = ''.join(front) + ''.join(back)\n    else:\n        result = ''.join(reversed(back)) + ''.join(reversed(front))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.975761890411377}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.3389823436737}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.29640531539917}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        need = a - b\n        # Sleep gained per cycle after first alarm\n        gain_per_cycle = c - d\n        \n        # Number of full cycles needed (ceil division)\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        \n        # Total time = first alarm + cycles * c\n        total_time = b + cycles * c\n        results.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.199263334274292}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # Initialize sieve array: True means not crossed out (prime or not processed yet)\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    crossed_out = []  # List to store numbers in the order they are crossed out\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # p is prime, cross out p and its multiples\n            # Cross out p itself\n            if p <= N:\n                is_prime[p] = False\n                crossed_out.append(p)\n                if len(crossed_out) == K:\n                    print(p)\n                    return\n            \n            # Cross out multiples of p\n            multiple = p * p  # Start from p^2 (optimization)\n            while multiple <= N:\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out.append(multiple)\n                    if len(crossed_out) == K:\n                        print(multiple)\n                        return\n                multiple += p\n    \n    # If K is larger than total crossed out numbers (should not happen per constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.375821113586426}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 140.45441818237305}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.51262211799622}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    \n    n = int(input[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = input[idx]\n        score = int(input[idx + 1])\n        restaurants.append((city, score, i))\n        idx += 2\n    \n    # Sort: first by city lexicographically, then by score descending\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.394434928894043}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.6753077507019}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.68403601646423}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    \n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    increase = []\n    decrease = []\n    for a, b in projects:\n        if b >= 0:\n            increase.append((a, b))\n        else:\n            decrease.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    increase.sort(key=lambda x: x[0])\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # Equivalent to sorting by (a + b) descending\n    decrease.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process increasing projects first\n    for a, b in increase:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    # Process decreasing projects\n    for a, b in decrease:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.893065690994263}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.3198742866516}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+m]))\n\n# Track count of each difficulty in pool\ncount = [0] * (n + 1)\n# Track how many distinct difficulties we have in pool\ndistinct = 0\nresult = []\n\nfor difficulty in a:\n    # Add problem to pool\n    if count[difficulty] == 0:\n        distinct += 1\n    count[difficulty] += 1\n    \n    # Check if we can hold a round\n    if distinct == n:\n        result.append('1')\n        # Remove one problem of each difficulty\n        for d in range(1, n + 1):\n            count[d] -= 1\n            if count[d] == 0:\n                distinct -= 1\n    else:\n        result.append('0')\n\nprint(''.join(result))", "complexity_estimate": null, "runtime_sec": 20.69528603553772}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 50.90808844566345}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 67.86260652542114}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Check if positions are in same parity group for jumps of length k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Determine direction (left or right)\n    step = k if t_pos > g_pos else -k\n    \n    # Check all cells along the path\n    pos = g_pos\n    while pos != t_pos:\n        pos += step\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.501168966293335}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Mark visited cells\n    visited = [[False] * c for _ in range(r)]\n    \n    def dfs(i, j):\n        stack = [(i, j)]\n        visited[i][j] = True\n        while stack:\n            x, y = stack.pop()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and grid[nx][ny] != 'W':\n                    visited[nx][ny] = True\n                    stack.append((nx, ny))\n    \n    # Count islands from definite land\n    islands = 0\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'L' and not visited[i][j]:\n                islands += 1\n                dfs(i, j)\n    \n    # For clouds, we can treat them as water to minimize islands\n    # Since we already counted islands from definite land,\n    # clouds don't create new islands when treated as water\n    # So no additional processing needed\n    \n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.788917779922485}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.68447685241699}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 78.04220509529114}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    q = int(data[idx]); idx += 1\n    results = []\n    \n    # Precompute the infinite RGB pattern\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); idx += 1\n        k = int(data[idx]); idx += 1\n        s = data[idx]; idx += 1\n        \n        # We need to check all possible starting positions for the substring of length k\n        # For each starting position, we need to check alignment with the infinite RGB pattern\n        # starting with 'R', 'G', or 'B' at position 0 of the pattern\n        \n        min_changes = float('inf')\n        \n        # For each possible starting character in the pattern\n        for start_char_idx in range(3):\n            # Precompute prefix sums of mismatches for this pattern alignment\n            # pattern_char = pattern[(start_char_idx + i) % 3] should match s[i]\n            prefix = [0] * (n + 1)\n            for i in range(n):\n                expected = pattern[(start_char_idx + i) % 3]\n                mismatch = 1 if s[i] != expected else 0\n                prefix[i + 1] = prefix[i] + mismatch\n            \n            # Now check all substrings of length k\n            for i in range(n - k + 1):\n                changes = prefix[i + k] - prefix[i]\n                if changes < min_changes:\n                    min_changes = changes\n        \n        results.append(str(min_changes))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.605987071990967}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.1782262325287}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    table_count = 0\n    max_table = 0\n    seen = set()\n    \n    for sock in socks:\n        if sock in seen:\n            # Pair completed, remove from table\n            table_count -= 1\n            seen.remove(sock)\n        else:\n            # First sock of pair, add to table\n            seen.add(sock)\n            table_count += 1\n            max_table = max(max_table, table_count)\n    \n    print(max_table)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.531813383102417}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2, solve for R2: R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.142310380935669}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 146.06199193000793}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.09374904632568}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # For each value, consider it becoming X, or X-1, or X+1\n    max_count = 0\n    for val in set(a):\n        # Count how many can become val\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n        \n        # Also consider val-1 and val+1 as potential X values\n        # (covered when iterating through all distinct values in a)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.575122833251953}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nxs, ys, ss, ri, rf = map(int, sys.stdin.readline().split())\nxa, ya, sa = map(int, sys.stdin.readline().split())\n\n# Distance from Anthony to the center of the safety zone\ndist = math.hypot(xa - xs, ya - ys)\n\n# If Anthony is already inside the final safety zone, no damage\nif dist <= rf:\n    print(\"0.000000\")\n    sys.exit(0)\n\n# Time for the safety zone to shrink from initial to final radius\nshrink_time = (ri - rf) / ss if ss > 0 else 0\n\n# Function to compute the radius at time t\ndef radius_at_time(t):\n    return max(rf, ri - ss * t)\n\n# Function to compute the distance Anthony can cover in time t\ndef anthony_distance(t):\n    return sa * t\n\n# Binary search for the minimum damage (time outside the zone)\nlow, high = 0.0, 1e18\nfor _ in range(200):  # Sufficient iterations for 1e-6 precision\n    mid = (low + high) / 2\n    # Radius at time mid\n    r = radius_at_time(mid)\n    # Distance Anthony can run in time mid\n    d_run = anthony_distance(mid)\n    # Check if Anthony can reach the safety zone by time mid\n    if dist - d_run <= r:\n        high = mid\n    else:\n        low = mid\n\n# The minimum time Anthony must spend outside is 'low'\n# Damage is 1 per second, so damage = low\nprint(f\"{low:.6f}\")", "complexity_estimate": null, "runtime_sec": 26.290154218673706}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    jobs = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        jobs.append((b, a))  # (deadline, duration)\n    \n    # Sort jobs by deadline\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.259948015213013}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        g = math.gcd(lcm_val, t)\n        lcm_val = (lcm_val // g) * t\n        if lcm_val > 10**18:\n            # Early exit if LCM exceeds the maximum possible answer\n            print(10**18)\n            return\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.39412808418274}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.55818557739258}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.88359379768372}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    remainder_count = [0] * k\n    for candies in d:\n        remainder_count[candies % k] += 1\n    \n    # Count pairs\n    boxes_used = 0\n    \n    # Handle remainder 0: pairs within themselves\n    boxes_used += (remainder_count[0] // 2) * 2\n    \n    # For k even, handle remainder k//2 similarly\n    if k % 2 == 0:\n        boxes_used += (remainder_count[k // 2] // 2) * 2\n    \n    # Pair complementary remainders: i with k-i\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        if i != j:  # Already handled for even k\n            pairs = min(remainder_count[i], remainder_count[j])\n            boxes_used += pairs * 2\n    \n    print(boxes_used)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.45248508453369}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.74792814254761}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.32470726966858}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    s = int(sys.stdin.readline().strip())\n    \n    # Dictionary to store the first occurrence index of each value\n    seen = {}\n    current = s\n    idx = 1\n    \n    while True:\n        # If we've seen this value before, we found a repeat\n        if current in seen:\n            print(idx)\n            return\n        \n        # Record first occurrence of this value\n        seen[current] = idx\n        \n        # Generate next term using the given function\n        if current % 2 == 0:\n            current = current // 2\n        else:\n            current = 3 * current + 1\n        \n        idx += 1\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.073724031448364}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.14817023277283}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open+1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close-1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between first_colon and last_colon\n    pipe_count = 0\n    for i in range(first_colon+1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length: 4 fixed characters + pipe_count\n    result = 4 + pipe_count\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 46.04839253425598}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        skills = list(map(int, input_data[idx:idx+n]))\n        idx += n\n        \n        # Count frequency of each skill\n        freq = collections.Counter(skills)\n        \n        # Find maximum frequency\n        max_freq = max(freq.values()) if freq else 0\n        \n        # Count number of distinct skills\n        distinct_count = len(freq)\n        \n        # The answer is min(max_freq, distinct_count) with adjustment\n        # If max_freq == distinct_count, we need to reduce by 1 because\n        # we need one skill for the second team that's not in the first team\n        if max_freq > distinct_count:\n            ans = distinct_count\n        elif max_freq == distinct_count:\n            ans = distinct_count - 1\n        else:\n            ans = max_freq\n        \n        # Ensure answer is non-negative\n        ans = max(0, ans)\n        results.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.225386142730713}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef can_make_equal(arr):\n    \"\"\"\n    Check if all numbers can be made equal by multiplying by 2 and/or 3.\n    \n    The key insight: For each number, repeatedly divide by 2 and 3 until\n    we get a number that's not divisible by 2 or 3. This gives us the\n    \"core\" value. All numbers must have the same core value.\n    \"\"\"\n    # Get the core value of the first number\n    def get_core(x):\n        while x % 2 == 0:\n            x //= 2\n        while x % 3 == 0:\n            x //= 3\n        return x\n    \n    first_core = get_core(arr[0])\n    \n    # Check if all numbers have the same core\n    for num in arr[1:]:\n        if get_core(num) != first_core:\n            return False\n    return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    if can_make_equal(arr):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 68.54436612129211}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.83610725402832}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\nimport heapq\n\nINF = 10**18\n\ndef dijkstra(start, n, graph):\n    dist = [INF] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        w = int(next(it))\n        edges.append((u, v, w))\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(i, n, graph)\n    \n    # Compute base total cost\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for u, v, w in edges:\n        # For each route, new cost is min(original, using zero road)\n        new_total = 0\n        for a, b in routes:\n            original = dists[a][b]\n            # Path via zero road: a->u + 0 + v->b or a->v + 0 + u->b\n            via_u_v = dists[a][u] + dists[v][b]\n            via_v_u = dists[a][v] + dists[u][b]\n            new_cost = min(original, via_u_v, via_v_u)\n            new_total += new_cost\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 69.14015126228333}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.68698358535767}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.50916838645935}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.27238011360168}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.67795062065125}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    # Function to calculate maximum beauty for a target character\n    def max_beauty_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            # Shrink window if we've used too many changes\n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            # Update maximum length\n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    # Calculate for both 'a' and 'b' and take maximum\n    return max(max_beauty_for_char('a'), max_beauty_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.690861463546753}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 130.91739010810852}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.07368493080139}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(x, y, n, m):\n    \"\"\"Rotate (x, y) 90 degrees clockwise in n x m matrix.\"\"\"\n    return y, n - x + 1\n\ndef rotate_90_counterclockwise(x, y, n, m):\n    \"\"\"Rotate (x, y) 90 degrees counterclockwise in n x m matrix.\"\"\"\n    return m - y + 1, x\n\ndef horizontal_rotate(x, y, n, m):\n    \"\"\"Horizontal rotate (mirror) of (x, y) in n x m matrix.\"\"\"\n    return x, m - y + 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = 360 degrees\n    x %= 4\n    z %= 4\n    # Horizontal rotate twice returns to original, so reduce modulo 2\n    y %= 2\n    \n    results = []\n    for _ in range(p):\n        xk = int(next(it))\n        yk = int(next(it))\n        \n        # Apply transformations in order: x clockwise, y horizontal, z counterclockwise\n        cur_n, cur_m = n, m\n        cur_x, cur_y = xk, yk\n        \n        # x clockwise rotations\n        for _ in range(x):\n            cur_x, cur_y = rotate_90_clockwise(cur_x, cur_y, cur_n, cur_m)\n            # After clockwise rotation, dimensions swap\n            cur_n, cur_m = cur_m, cur_n\n        \n        # y horizontal rotations\n        if y == 1:\n            cur_x, cur_y = horizontal_rotate(cur_x, cur_y, cur_n, cur_m)\n        \n        # z counterclockwise rotations\n        for _ in range(z):\n            cur_x, cur_y = rotate_90_counterclockwise(cur_x, cur_y, cur_n, cur_m)\n            # After counterclockwise rotation, dimensions swap\n            cur_n, cur_m = cur_m, cur_n\n        \n        results.append(f\"{cur_x} {cur_y}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 36.02166819572449}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # Each of the 3 positions can be any digit from 1 to N\n    # Total possibilities = N * N * N = N^3\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.273008823394775}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 124.76154351234436}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' from left and consecutive '>' from right\n        left_count = 0\n        while left_count < n and s[left_count] == '<':\n            left_count += 1\n        right_count = 0\n        while right_count < n and s[n - 1 - right_count] == '>':\n            right_count += 1\n        # Minimum deletions is the smaller of these two counts\n        min_deletions = min(left_count, right_count)\n        results.append(str(min_deletions))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.058109998703003}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X) / 2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    # Check if (Y - 2X) is non-negative and divisible by 2\n    if (Y - 2 * X) >= 0 and (Y - 2 * X) % 2 == 0:\n        t = (Y - 2 * X) // 2\n        c = X - t\n        if c >= 0 and t >= 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.703778982162476}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = []\n    idx = 1\n    for _ in range(n):\n        row = data[idx]\n        idx += 1\n        grid.append(row)\n    \n    # Check if any row is completely evil\n    all_evil_rows = []\n    for i in range(n):\n        if all(c == 'E' for c in grid[i]):\n            all_evil_rows.append(i)\n    \n    # Check if any column is completely evil\n    all_evil_cols = []\n    for j in range(n):\n        col_all_evil = True\n        for i in range(n):\n            if grid[i][j] != 'E':\n                col_all_evil = False\n                break\n        if col_all_evil:\n            all_evil_cols.append(j)\n    \n    # If there's both a completely evil row and completely evil column, impossible\n    if all_evil_rows and all_evil_cols:\n        print(-1)\n        return\n    \n    # Strategy 1: Try to find a solution by selecting one cell from each row\n    solution_by_rows = []\n    possible_by_rows = True\n    for i in range(n):\n        found = False\n        for j in range(n):\n            if grid[i][j] == '.':\n                solution_by_rows.append((i+1, j+1))\n                found = True\n                break\n        if not found:\n            possible_by_rows = False\n            break\n    \n    # Strategy 2: Try to find a solution by selecting one cell from each column\n    solution_by_cols = []\n    possible_by_cols = True\n    for j in range(n):\n        found = False\n        for i in range(n):\n            if grid[i][j] == '.':\n                solution_by_cols.append((i+1, j+1))\n                found = True\n                break\n        if not found:\n            possible_by_cols = False\n            break\n    \n    # Choose the valid solution\n    if possible_by_rows:\n        for r, c in solution_by_rows:\n            print(f\"{r} {c}\")\n    elif possible_by_cols:\n        for r, c in solution_by_cols:\n            print(f\"{r} {c}\")\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 94.21181035041809}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Read inputs\n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute possible frets on each string\n    frets = []\n    for note in b:\n        note_frets = []\n        for string_val in a:\n            if note > string_val:\n                fret = note - string_val\n                note_frets.append(fret)\n        # Sort frets for this note\n        note_frets.sort()\n        frets.append(note_frets)\n    \n    # Two-pointer sliding window approach\n    # We need to pick one fret from each note's list such that max-min is minimized\n    # Create list of all (fret, note_index) pairs\n    all_frets = []\n    for i, note_frets in enumerate(frets):\n        for fret in note_frets:\n            all_frets.append((fret, i))\n    \n    # Sort by fret value\n    all_frets.sort()\n    \n    # Sliding window\n    m = len(all_frets)\n    left = 0\n    count = [0] * n  # how many notes are covered in current window\n    covered = 0  # number of notes with at least one fret in window\n    min_diff = float('inf')\n    \n    for right in range(m):\n        fret_val, note_idx = all_frets[right]\n        if count[note_idx] == 0:\n            covered += 1\n        count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while covered == n:\n            min_diff = min(min_diff, all_frets[right][0] - all_frets[left][0])\n            left_fret, left_note = all_frets[left]\n            count[left_note] -= 1\n            if count[left_note] == 0:\n                covered -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 31.081228256225586}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 40.3175745010376}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = [0] * (n + 1)  # parent array\n    for i in range(2, n + 1):\n        p[i] = int(data[i - 1])\n    \n    # Step 1: Compute depth of each node\n    depth = [0] * (n + 1)\n    for i in range(2, n + 1):\n        depth[i] = depth[p[i]] + 1\n    \n    # Step 2: Count nodes at each depth\n    max_depth = max(depth)\n    cnt = [0] * (max_depth + 1)\n    for i in range(1, n + 1):\n        cnt[depth[i]] += 1\n    \n    # Step 3: Compute answer\n    ans = 0\n    for d in range(max_depth + 1):\n        ans += cnt[d] % 2  # only odd counts contribute\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.908692121505737}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    count = 0\n    while b > 0:\n        count += a // b\n        a, b = b, a % b\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.630420684814453}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    \n    # The minimum positive integer divisible by both 2 and N is LCM(2, N)\n    # Since 2 is prime, LCM(2, N) = 2 * N / GCD(2, N)\n    # If N is even: GCD(2, N) = 2, so LCM = N\n    # If N is odd: GCD(2, N) = 1, so LCM = 2 * N\n    \n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.181732654571533}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 153.13359117507935}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.30016112327576}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Simply check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.528212785720825}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.26614570617676}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.23886370658875}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.64757704734802}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.7430226802826}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.41379976272583}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    # Initialize count array with zeros for members 1..n\n    subordinates = [0] * (n + 1)\n    # Process each A_i from input (indices 2..n)\n    for i in range(2, n + 1):\n        boss = int(data[i - 1])  # data[1] corresponds to A_2\n        subordinates[boss] += 1\n    # Output results for members 1..n\n    for i in range(1, n + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.022300720214844}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.04606056213379}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith(\"po\"):\n        return \"FILIPINO\"\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        return \"JAPANESE\"\n    elif sentence.endswith(\"mnida\"):\n        return \"KOREAN\"\n    else:\n        # According to problem statement, this case shouldn't happen\n        # but we include it for completeness\n        return \"UNKNOWN\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    t = int(data[0].strip())\n    results = []\n    \n    for i in range(1, t + 1):\n        if i >= len(data):\n            break\n        sentence = data[i].strip()\n        language = detect_language(sentence)\n        results.append(language)\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.445042610168457}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    trains = []\n    for _ in range(N-1):\n        C, S, F = map(int, input().split())\n        trains.append((C, S, F))\n    \n    results = [0] * N\n    \n    for start in range(N-1):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait for next train\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results[start] = current_time\n    \n    # Station N itself\n    results[N-1] = 0\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.720041513442993}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.3185520172119}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 131.8677909374237}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    grid = data[2:2+H]\n    \n    # Directions for 8 adjacent cells\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1),  (1, 0), (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n            else:\n                count = 0\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                        count += 1\n                row_chars.append(str(count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.800328254699707}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.5497395992279}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Initialize p as a copy of a (we'll modify it)\n    p = a[:]\n    \n    # Track which numbers are used in p\n    used = [False] * (n + 1)\n    for val in p:\n        used[val] = True\n    \n    # Find missing number (the one not in p yet)\n    missing = -1\n    for num in range(1, n + 1):\n        if not used[num]:\n            missing = num\n            break\n    \n    # If there's exactly one differing position, we need to handle carefully\n    if len(diff_positions) == 1:\n        pos = diff_positions[0]\n        # Try both possibilities\n        original = p[pos]\n        # Try setting to b[pos]\n        p[pos] = b[pos]\n        if len(set(p)) == n:\n            # Valid permutation\n            print(' '.join(map(str, p)))\n            return\n        # Try setting to missing\n        p[pos] = missing\n        if len(set(p)) == n:\n            print(' '.join(map(str, p)))\n            return\n        # Try setting to original (should work by problem guarantee)\n        p[pos] = original\n        print(' '.join(map(str, p)))\n        return\n    \n    # Case with multiple differing positions\n    # We need to change exactly one position in p (from a) to match b's constraint\n    # and ensure p becomes a permutation\n    \n    # Count how many positions differ between p and b\n    diff_count = sum(1 for i in range(n) if p[i] != b[i])\n    \n    if diff_count == 1:\n        # p already differs from b at exactly one position\n        # Check if p is a permutation\n        if len(set(p)) == n:\n            print(' '.join(map(str, p)))\n            return\n        else:\n            # p is not a permutation, need to fix\n            # Find duplicate value\n            seen = set()\n            dup_val = -1\n            for val in p:\n                if val in seen:\n                    dup_val = val\n                    break\n                seen.add(val)\n            \n            # Find position of duplicate that we can change\n            for pos in diff_positions:\n                if p[pos] == dup_val:\n                    p[pos] = missing\n                    if len(set(p)) == n:\n                        print(' '.join(map(str, p)))\n                        return\n    \n    # General case: try changing each differing position to missing\n    for pos in diff_positions:\n        original = p[pos]\n        p[pos] = missing\n        # Check if p differs from b at exactly one position and is permutation\n        diff_from_b = sum(1 for i in range(n) if p[i] != b[i])\n        if diff_from_b == 1 and len(set(p)) == n:\n            print(' '.join(map(str, p)))\n            return\n        p[pos] = original\n    \n    # If above didn't work, try changing to b[pos] at each differing position\n    for pos in diff_positions:\n        original = p[pos]\n        p[pos] = b[pos]\n        diff_from_b = sum(1 for i in range(n) if p[i] != b[i])\n        if diff_from_b == 1 and len(set(p)) == n:\n            print(' '.join(map(str, p)))\n            return\n        p[pos] = original\n    \n    # Last resort: output p as is (should work by problem guarantee)\n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 100.70348644256592}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 78.58697152137756}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport re\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel according to the problem rules.\"\"\"\n    return c in 'AEIOUY'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the problem rules.\"\"\"\n    # Extract alphabetic part for syllable counting\n    alphabetic = ''.join(ch for ch in word if ch.isalpha())\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    alphabetic = alphabetic.upper()\n    n = len(alphabetic)\n    \n    # Apply silent E rule\n    if n >= 1 and alphabetic[-1] == 'E':\n        if n >= 3 and alphabetic[-2] == 'L' and not is_vowel(alphabetic[-3]):\n            # Keep the E (e.g., \"able\")\n            pass\n        else:\n            # Remove silent E\n            alphabetic = alphabetic[:-1]\n            n = len(alphabetic)\n    \n    # Apply ES rule\n    if n >= 2 and alphabetic[-2:] == 'ES':\n        if n >= 3 and not is_vowel(alphabetic[-3]) and (n < 4 or not is_vowel(alphabetic[-4])):\n            # Keep ES (e.g., \"witches\")\n            pass\n        else:\n            # Remove ES\n            alphabetic = alphabetic[:-2]\n            n = len(alphabetic)\n    \n    # Count syllables using vowel groups\n    count = 0\n    i = 0\n    while i < n:\n        # Skip consonants\n        while i < n and not is_vowel(alphabetic[i]):\n            i += 1\n        \n        # If we found a vowel\n        if i < n:\n            count += 1\n            # Skip this vowel and any following vowels (they're part of same syllable)\n            while i < n and is_vowel(alphabetic[i]):\n                # Handle QU exception\n                if i+1 < n and alphabetic[i:i+2] == 'QU':\n                    i += 2\n                else:\n                    i += 1\n            \n            # Handle Y as consonant when followed by vowel\n            if i < n and alphabetic[i] == 'Y' and i+1 < n and is_vowel(alphabetic[i+1]):\n                i += 1  # Skip Y (treat as consonant)\n    \n    return max(1, count)  # At least 1 syllable\n\ndef split_haiku(words, syllables):\n    \"\"\"Try to split words into haiku (5-7-5 syllables). Return split indices or None.\"\"\"\n    n = len(words)\n    \n    # Try all possible splits\n    for i in range(1, n):\n        for j in range(i+1, n):\n            if sum(syllables[:i]) == 5 and sum(syllables[i:j]) == 7 and sum(syllables[j:]) == 5:\n                return (i, j)\n    return None\n\ndef main():\n    # Read input line\n    line = sys.stdin.read().strip('\\n')\n    \n    # Split into words using the problem's definition\n    # Words are: alphabetic chars followed by optional non-alphabetic, non-blank chars\n    words = []\n    i = 0\n    while i < len(line):\n        # Skip spaces\n        while i < len(line) and line[i] == ' ':\n            i += 1\n        if i >= len(line):\n            break\n        \n        # Find alphabetic part\n        start = i\n        while i < len(line) and line[i].isalpha():\n            i += 1\n        \n        # Find trailing non-alphabetic, non-blank characters\n        while i < len(line) and line[i] != ' ' and not line[i].isalpha():\n            i += 1\n        \n        words.append(line[start:i])\n    \n    # Count syllables for each word\n    syllables = [count_syllables(word) for word in words]\n    total_syllables = sum(syllables)\n    \n    # Check if total is 17 (5+7+5)\n    if total_syllables != 17:\n        print(line)\n        return\n    \n    # Try to split into haiku\n    split = split_haiku(words, syllables)\n    if split is None:\n        print(line)\n        return\n    \n    # Output haiku\n    i, j = split\n    print(' '.join(words[:i]))\n    print(' '.join(words[i:j]))\n    print(' '.join(words[j:]))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 152.9694218635559}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.51876759529114}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Special case: 1 is the strongest\n    if A == 1 and B != 1:\n        print(\"Alice\")\n    elif B == 1 and A != 1:\n        print(\"Bob\")\n    elif A == B:\n        print(\"Draw\")\n    elif A > B:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.882038354873657}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 148.70024752616882}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\n\ndef solve() -> None:\n    t = int(input())\n    out_lines = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        \n        # Count consecutive same characters\n        cnt = 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            cnt += (j - i) // 3\n            i = j\n        \n        # Handle the case where the string is all the same character\n        if s == 'L' * n or s == 'R' * n:\n            out_lines.append(str((n + 2) // 3))\n        else:\n            # Check if the first and last segments are the same character\n            if s[0] == s[-1]:\n                # Merge first and last segments\n                first_len = 0\n                while first_len < n and s[first_len] == s[0]:\n                    first_len += 1\n                last_len = 0\n                while last_len < n and s[n - 1 - last_len] == s[-1]:\n                    last_len += 1\n                total_len = first_len + last_len\n                cnt -= first_len // 3\n                cnt -= last_len // 3\n                cnt += total_len // 3\n            \n            out_lines.append(str(cnt))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.358009338378906}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    # Read the input values\n    values = list(map(int, sys.stdin.readline().split()))\n    \n    # Check each position\n    for i in range(5):\n        # If the value at position i is 0, then x_{i+1} was set to 0\n        if values[i] == 0:\n            print(i + 1)\n            return\n    \n    # This case shouldn't happen given constraints, but handle it\n    print(0)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.147528886795044}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.86021137237549}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_ways(n):\n    \"\"\"\n    Count number of ways to fill parking lot with 4 car makes where:\n    - Total parking spaces: 2n - 2\n    - Must contain exactly n successive cars of the same make\n    - All spaces are always occupied (no free spaces)\n    - Even number of cars of each make > parking spaces (so unlimited supply)\n    \"\"\"\n    # Total length of parking lot\n    L = 2 * n - 2\n    \n    # For each position where the block of n identical cars can start\n    # Valid start positions: 0 to L-n\n    positions = L - n + 1\n    \n    # For each position, we need to count valid arrangements of remaining cars\n    # Remaining length: L - n = n - 2\n    remaining = n - 2\n    \n    # For the remaining positions, we need to fill with cars of 4 makes\n    # But we must ensure the block of n identical cars is not extended\n    # So the cars immediately before and after the block must be different from the block's make\n    \n    # Let's count using inclusion-exclusion principle\n    # Total ways without restrictions: 4^remaining\n    total_without_restrictions = 4 ** remaining\n    \n    # Now we need to subtract cases where the block gets extended\n    # The block gets extended if either:\n    # 1. The car immediately before the block has the same make as the block\n    # 2. The car immediately after the block has the same make as the block\n    \n    # But careful: if the block is at position 0, there's no car before\n    # If the block is at position L-n, there's no car after\n    \n    # Let's count for interior positions first (positions 1 to L-n-1)\n    interior_positions = max(0, positions - 2)\n    \n    # For each interior position:\n    # - Choose make for the block: 4 ways\n    # - Choose make for car before: must be different from block make: 3 ways\n    # - Choose make for car after: must be different from block make: 3 ways\n    # - Fill remaining n-4 positions (after accounting for block, before, after):\n    #   total positions to fill = remaining - 2 = n-4\n    #   each can be any of 4 makes: 4^(n-4) ways\n    interior_ways = 0\n    if n >= 4:\n        interior_ways = interior_positions * 4 * 3 * 3 * (4 ** (n - 4))\n    \n    # For edge positions (first and last position of block)\n    # There are 2 edge positions (position 0 and position L-n)\n    edge_positions = min(2, positions)\n    \n    # For each edge position:\n    # If block at position 0:\n    # - Choose make for block: 4 ways\n    # - Choose make for car after: must be different from block make: 3 ways\n    # - Fill remaining n-3 positions: 4^(n-3) ways\n    # If block at position L-n (similar but car before instead of after)\n    edge_ways = 0\n    if n >= 3:\n        edge_ways = edge_positions * 4 * 3 * (4 ** (n - 3))\n    \n    # Total valid arrangements\n    total = interior_ways + edge_ways\n    \n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_ways(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 44.099695444107056}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 95.42838764190674}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.28340554237366}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\n# Read input\nn = int(input().strip())\narr = list(map(int, input().split()))\n\n# Convert to absolute values and sort\nabs_arr = sorted(abs(x) for x in arr)\n\n# Count pairs where the condition holds\ncount = 0\n\n# For each element as the smaller absolute value\nfor i in range(n):\n    # Binary search for the maximum j where abs_arr[j] <= 2 * abs_arr[i]\n    low, high = i + 1, n - 1\n    max_j = i\n    while low <= high:\n        mid = (low + high) // 2\n        if abs_arr[mid] <= 2 * abs_arr[i]:\n            max_j = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    # Add all pairs (i, j) where i < j <= max_j\n    if max_j > i:\n        count += max_j - i\n\nprint(count)", "complexity_estimate": null, "runtime_sec": 97.75842380523682}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 120.67857718467712}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if K > N:\n        print(0)\n        return\n    \n    a.sort()\n    \n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    total = 0\n    for i in range(N):\n        # Count combinations where a[i] is the maximum\n        # Need to choose K-1 smaller elements from the i elements before it\n        comb = nCr_mod(i, K - 1, MOD, fact, inv_fact)\n        total = (total + a[i] * comb) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.113418340682983}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r = int(data[0])\n    c = int(data[1])\n    grid = data[2:]\n    \n    # Mark rows and columns that contain at least one 'S'\n    row_has_S = [False] * r\n    col_has_S = [False] * c\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                row_has_S[i] = True\n                col_has_S[j] = True\n    \n    # Count rows without S\n    safe_rows = 0\n    for i in range(r):\n        if not row_has_S[i]:\n            safe_rows += 1\n    \n    # Count columns without S\n    safe_cols = 0\n    for j in range(c):\n        if not col_has_S[j]:\n            safe_cols += 1\n    \n    # Total cells from safe rows and columns\n    total = safe_rows * c + safe_cols * r\n    \n    # Subtract double-counted cells (intersections of safe rows and safe columns)\n    # that were counted twice\n    double_counted = safe_rows * safe_cols\n    \n    # However, if a cell is in a safe row and safe column, it was counted twice,\n    # but we only want to count it once. So subtract the double-counted amount.\n    result = total - double_counted\n    \n    # Edge case: if a cell has 'S', it cannot be eaten at all.\n    # Our formula already accounts for this because safe rows/cols exclude those with S.\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.68835163116455}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    # Replace first 4 characters with '2018'\n    result = '2018' + S[4:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.118492126464844}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach: at each step, try to put the largest possible digit at the current position\n    for i in range(length):\n        if k <= 0:\n            break\n        # Find the maximum digit from i+1 to end\n        max_digit = n[i]\n        max_index = i\n        for j in range(i+1, length):\n            if n[j] > max_digit:\n                max_digit = n[j]\n                max_index = j\n        # If we found a larger digit, swap it to position i\n        if max_index != i:\n            # Check if swapping would cause leading zero\n            if i == 0 and n[max_index] == '0':\n                continue\n            # Perform the swap\n            n[i], n[max_index] = n[max_index], n[i]\n            k -= 1\n    \n    # If we have swaps left, we might need to use them even if they don't increase the number\n    # But we must avoid leading zeros\n    if k > 0:\n        # If k is odd and length >= 2, we might need to swap two equal digits to consume swaps\n        # Find two positions with same digit to swap without changing the number\n        for i in range(length):\n            if k <= 0:\n                break\n            for j in range(i+1, length):\n                if k <= 0:\n                    break\n                if n[i] == n[j]:\n                    # Swap equal digits - doesn't change the number\n                    n[i], n[j] = n[j], n[i]\n                    k -= 1\n                    if k <= 0:\n                        break\n        \n        # If still have swaps and length >= 2, swap last two digits if it doesn't create leading zero\n        if k > 0 and length >= 2:\n            # Try to swap last two digits\n            if not (length == 2 and n[0] == '0'):\n                n[-1], n[-2] = n[-2], n[-1]\n                k -= 1\n    \n    print(''.join(n))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.764545440673828}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 41.32011437416077}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    a = [0] * (N + 1)\n    for i in range(1, N + 1):\n        a[i] = int(input().strip())\n    \n    visited = [False] * (N + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.001874208450317}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.41632676124573}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef sum_arithmetic(a, n, d):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    # S = n/2 * (2a + (n-1)d)\n    n %= MOD\n    a %= MOD\n    d %= MOD\n    term = (2 * a + (n - 1) * d) % MOD\n    return (n * term % MOD) * pow(2, MOD-2, MOD) % MOD\n\ndef sum_range(l, r):\n    \"\"\"Return sum of numbers from l to r in the sequence modulo MOD.\"\"\"\n    def sum_up_to(k):\n        if k == 0:\n            return 0\n        total = 0\n        stage = 1\n        count = 1  # numbers in current stage\n        start_odd = 1  # first odd number for current stage\n        start_even = 2  # first even number for current stage\n        remaining = k\n        \n        while remaining > 0:\n            take = min(count, remaining)\n            if stage % 2 == 1:  # odd stage\n                total = (total + sum_arithmetic(start_odd, take, 2)) % MOD\n                start_odd += 2 * take\n            else:  # even stage\n                total = (total + sum_arithmetic(start_even, take, 2)) % MOD\n                start_even += 2 * take\n            \n            remaining -= take\n            if remaining > 0:\n                count *= 2\n                stage += 1\n        return total\n    \n    return (sum_up_to(r) - sum_up_to(l-1)) % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    print(sum_range(l, r))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.35415768623352}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Since coordinates are between 1 and 100, we can brute force all possible meeting points\n    min_stamina = float('inf')\n    \n    # Check all integer coordinates from min(x) to max(x) inclusive\n    for p in range(min(x), max(x) + 1):\n        total = 0\n        for xi in x:\n            diff = xi - p\n            total += diff * diff\n        if total < min_stamina:\n            min_stamina = total\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.094541788101196}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.45436906814575}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "from collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    R = int(data[0])\n    C = int(data[1])\n    grid = []\n    idx = 2\n    for _ in range(R):\n        grid.append(list(data[idx]))\n        idx += 1\n    \n    # Find start and den positions\n    start = None\n    den = None\n    water_queue = deque()\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'D':\n                den = (i, j)\n            elif grid[i][j] == '*':\n                water_queue.append((i, j, 0))  # (row, col, time)\n    \n    # BFS for water expansion\n    water_time = [[-1] * C for _ in range(R)]\n    for i, j, t in water_queue:\n        water_time[i][j] = t\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while water_queue:\n        r, c, t = water_queue.popleft()\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if grid[nr][nc] == '.' and water_time[nr][nc] == -1:\n                    water_time[nr][nc] = t + 1\n                    water_queue.append((nr, nc, t + 1))\n    \n    # BFS for painter and hedgehogs\n    visited = [[False] * C for _ in range(R)]\n    queue = deque()\n    queue.append((start[0], start[1], 0))  # (row, col, time)\n    visited[start[0]][start[1]] = True\n    \n    while queue:\n        r, c, t = queue.popleft()\n        if (r, c) == den:\n            print(t)\n            return\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if visited[nr][nc]:\n                    continue\n                if grid[nr][nc] == 'X':\n                    continue\n                if grid[nr][nc] == '*':\n                    continue\n                # Check if cell will be flooded at time t+1\n                # Water cannot flood the den, so den is always safe\n                if grid[nr][nc] != 'D' and water_time[nr][nc] != -1 and water_time[nr][nc] <= t + 1:\n                    continue\n                visited[nr][nc] = True\n                queue.append((nr, nc, t + 1))\n    \n    print(\"KAKTUS\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 32.68646430969238}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 53.14641189575195}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.0916519165039}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.6360785961151}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.295823097229}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 124.93526697158813}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.65932202339172}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 120.90750646591187}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef main():\n    data = input().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each value\n    freq = {}\n    for x in arr:\n        freq[x] = freq.get(x, 0) + 1\n    \n    # Get all unique values\n    values = list(freq.keys())\n    \n    total = 0\n    \n    # Case 1: a_i = a_j = a_k/2 (i.e., a_i = a_j and a_k = 2*a_i)\n    for x in values:\n        cnt = freq[x]\n        if cnt >= 2:\n            # Number of ways to choose i,j from same value x\n            ways_ij = cnt * (cnt - 1)\n            # For each such pair, count k where a_k = 2*x\n            if 2*x in freq:\n                total += ways_ij * freq[2*x]\n    \n    # Case 2: a_i != a_j, and a_k = a_i + a_j\n    # We need to count all ordered pairs (i,j) with i != j and a_i != a_j\n    # For each pair (x,y) with x != y, number of ordered pairs is freq[x]*freq[y]\n    # And for each such pair, we need to count k where a_k = x+y\n    \n    # To avoid double counting, we iterate over all x < y\n    m = len(values)\n    for i in range(m):\n        x = values[i]\n        for j in range(i+1, m):\n            y = values[j]\n            target = x + y\n            if target in freq:\n                total += freq[x] * freq[y] * freq[target] * 2  # *2 because (x,y) and (y,x) are different ordered pairs\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 70.45470809936523}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    idx = 0\n    H = int(input[idx]); idx += 1\n    W = int(input[idx]); idx += 1\n    K = int(input[idx]); idx += 1\n    x1 = int(input[idx]) - 1; idx += 1\n    y1 = int(input[idx]) - 1; idx += 1\n    x2 = int(input[idx]) - 1; idx += 1\n    y2 = int(input[idx]) - 1; idx += 1\n    \n    grid = []\n    for _ in range(H):\n        row = input[idx]; idx += 1\n        grid.append(row)\n    \n    if grid[x1][y1] == '@' or grid[x2][y2] == '@':\n        print(-1)\n        return\n    \n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # BFS with direction optimization\n    # For each direction, we can move up to K steps without increasing stroke count\n    # We'll use 4 deques for each direction to process efficiently\n    \n    # Directions: 0=up, 1=right, 2=down, 3=left\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    \n    # We'll use a single deque for BFS\n    dq = deque()\n    dq.append((x1, y1))\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        # Try all 4 directions\n        for d in range(4):\n            nx, ny = x, y\n            # Move up to K steps in this direction\n            for step in range(1, K + 1):\n                nx += dx[d]\n                ny += dy[d]\n                \n                # Check bounds and obstacles\n                if nx < 0 or nx >= H or ny < 0 or ny >= W:\n                    break\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    dq.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # No need to continue in this direction if we already have a better path\n                    break\n    \n    result = dist[x2][y2]\n    if result == INF:\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 89.020432472229}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.83318018913269}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        rx, ry = self.find(x), self.find(y)\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            self.parent[rx] = ry\n        elif self.rank[rx] > self.rank[ry]:\n            self.parent[ry] = rx\n        else:\n            self.parent[ry] = rx\n            self.rank[rx] += 1\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    uf = UnionFind(n)\n    edges = []\n    \n    for _ in range(m):\n        a = int(next(it))\n        op = next(it)\n        b = int(next(it))\n        if op == '=':\n            uf.union(a, b)\n        else:\n            edges.append((a, b))\n    \n    # Build graph of inequality edges between components\n    comp_graph = [[] for _ in range(n)]\n    indeg = [0] * n\n    \n    for a, b in edges:\n        ra = uf.find(a)\n        rb = uf.find(b)\n        if ra == rb:\n            print(\"inconsistent\")\n            return\n        comp_graph[ra].append(rb)\n        indeg[rb] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    q = deque([i for i in range(n) if indeg[i] == 0 and uf.find(i) == i])\n    processed = 0\n    \n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in comp_graph[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    # Check if all components were processed\n    total_components = len(set(uf.find(i) for i in range(n)))\n    if processed == total_components:\n        print(\"consistent\")\n    else:\n        print(\"inconsistent\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 31.76972723007202}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    s = list(data[idx]); idx += 1\n    \n    for _ in range(m):\n        l = int(data[idx]) - 1; idx += 1\n        r = int(data[idx]) - 1; idx += 1\n        c1 = data[idx]; idx += 1\n        c2 = data[idx]; idx += 1\n        \n        for i in range(l, r + 1):\n            if s[i] == c1:\n                s[i] = c2\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.480424404144287}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_k_periodic(s, k):\n    \"\"\"Check if string s is k-periodic.\"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    # First substring\n    prev = s[:k]\n    \n    # Check each subsequent substring\n    for i in range(k, n, k):\n        curr = s[i:i+k]\n        # Check if curr is right-rotation of prev\n        if curr != prev[-1] + prev[:-1]:\n            return False\n        prev = curr\n    \n    return True\n\ndef main():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if is_k_periodic(s, k):\n            print(k)\n            return\n    \n    # Should never reach here since k=n always works\n    print(n)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.180975914001465}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.70569038391113}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 3, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nclass FenwickTree:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n    \n    def update(self, idx, delta):\n        i = idx + 1  # Fenwick tree uses 1-based indexing\n        while i <= self.n:\n            self.bit[i] += delta\n            i += i & -i\n    \n    def query(self, idx):\n        # Query prefix sum up to idx-1 (0 to idx-1 inclusive)\n        i = idx  # idx is already the right boundary for prefix sum\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    ft = FenwickTree(n)\n    output_lines = []\n    \n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            ft.update(i, delta)\n        else:  # op == '?'\n            i = int(next(it))\n            # Query prefix sum from 0 to i-1\n            result = ft.query(i)\n            output_lines.append(str(result))\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.714277267456055}

{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.38569974899292}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build the string\n    s = []\n    current_char = 'a'\n    i = 0\n    while i < n:\n        # Determine the length of the next block\n        # We need to find the largest L such that c[L-1] > 0\n        # But we must also ensure we don't exceed remaining positions\n        max_len = 1\n        for L in range(1, n-i+1):\n            if L <= n and c[L-1] > 0:\n                max_len = L\n            else:\n                break\n        \n        # Add a block of length max_len with current_char\n        s.extend([current_char] * max_len)\n        \n        # Update c values for the substrings we've created\n        for L in range(1, max_len+1):\n            c[L-1] -= (max_len - L + 1)\n        \n        # Move to next character\n        current_char = chr(ord(current_char) + 1)\n        if current_char > 'z':\n            current_char = 'a'\n        \n        i += max_len\n    \n    # Output the result\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 59.82246398925781}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.74046182632446}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.height = 0\n\ndef insert(root, value, depth, counter):\n    if root is None:\n        return Node(value), depth\n    \n    if value < root.value:\n        root.left, new_depth = insert(root.left, value, depth + 1, counter)\n    else:\n        root.right, new_depth = insert(root.right, value, depth + 1, counter)\n    \n    return root, new_depth\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    sequence = list(map(int, data[1:1+n]))\n    \n    root = None\n    counter = 0\n    results = []\n    \n    for value in sequence:\n        if root is None:\n            root = Node(value)\n            depth = 0\n        else:\n            root, depth = insert(root, value, 0, counter)\n        \n        counter += depth\n        results.append(str(counter))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.941559076309204}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.9241111278534}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Calculate remaining money after buying cake\n    remaining_after_cake = X - A\n    \n    # Calculate how many donuts can be bought\n    donuts_count = remaining_after_cake // B\n    \n    # Calculate remaining money after buying donuts\n    remaining_after_donuts = remaining_after_cake - (donuts_count * B)\n    \n    # Output the result\n    print(remaining_after_donuts)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.547399997711182}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 154.5150179862976}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\n\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Preprocess: for each k, find the optimal subsequence indices\n# Step 1: Sort indices by value descending, then by index ascending for tie-breaking\nindices = list(range(n))\nindices.sort(key=lambda i: (-a[i], i))\n\n# Step 2: For each k, select first k indices from sorted list, then sort them by original index\nselected_for_k = {}\nselected_indices = []\nfor i in range(n):\n    selected_indices.append(indices[i])\n    k_val = i + 1\n    # Sort selected indices by position to maintain original order\n    sorted_selected = sorted(selected_indices)\n    selected_for_k[k_val] = sorted_selected\n\n# Step 3: Answer queries\nanswers = []\nfor k, pos in queries:\n    seq_indices = selected_for_k[k]\n    # pos is 1-indexed\n    answer = a[seq_indices[pos - 1]]\n    answers.append(answer)\n\n# Output\nprint('\\n'.join(map(str, answers)))", "complexity_estimate": null, "runtime_sec": 25.1073899269104}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.94127798080444}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 60.46880507469177}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.23550724983215}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 75.1486279964447}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.17306995391846}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = [int(next(it)) for _ in range(n)]\n    c = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for length in l:\n        g = math.gcd(g, length)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting with gcd 0 (no cards selected)\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for current_gcd, cost in dp.items():\n            new_gcd = math.gcd(current_gcd, l[i])\n            new_cost = cost + c[i]\n            if new_cost < new_dp[new_gcd]:\n                new_dp[new_gcd] = new_cost\n        dp = new_dp\n    \n    result = dp.get(1, float('inf'))\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.166088104248047}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) != 3:\n        return\n    \n    D, T, S = map(int, data)\n    \n    # Calculate time needed to travel D meters at speed S\n    # Since all values are integers, we can compare T * S with D\n    # If T * S >= D, he arrives in time\n    if T * S >= D:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.607846975326538}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.91490507125854}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.55118012428284}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.22444796562195}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.10134720802307}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 68.34779214859009}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # The game is equivalent to a Nim game where each branch piece\n    # corresponds to a pile with Grundy number equal to its length.\n    # For a piece of length x, the Grundy number g(x) = x.\n    # The XOR of all pieces' Grundy numbers determines the winner.\n    # Initially, there's one piece of length n, so XOR = n.\n    \n    if n % 2 == 0:\n        # Alice wins for even n\n        print(\"Alice\")\n        # She can break off any piece of length 1 to n-1,\n        # but to ensure a winning move, break off 1.\n        # This leaves Bob with a piece of length n-1 (odd),\n        # making XOR = n-1 (non-zero), so Bob is in a losing position.\n        print(1)\n    else:\n        # Bob wins for odd n\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.57456612586975}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 1, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.27237296104431}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            needed = target - current_height\n            if needed > m - days_used:\n                return False\n            days_used += needed\n            current += needed\n            # Mark the end of the watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    \n    return days_used <= m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = min(heights) + m  # Upper bound: we can at most add m to the smallest\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(high)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.7445969581604}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.484598875045776}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.29385805130005}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.31577801704407}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 37.18067717552185}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 103.55794715881348}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (2^4 - 1)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.28861904144287}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    seen = set()\n    result = []\n    for i in range(n - 1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.33248782157898}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.5133409500122}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Function to calculate final score given fifth time\n    def final_score(t5):\n        all_times = times + [t5]\n        all_times.sort()\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Check if already winning with current four times\n    # We need to consider all possible t5 values from 1.00 to 20.00\n    # But we can reason analytically:\n    \n    # Case 1: Check if impossible\n    # To see if impossible, we need to check if even with best possible t5 (1.00),\n    # the final score would still be > target\n    best_t5 = 1.00\n    if final_score(best_t5) > target:\n        print(\"impossible\")\n        return\n    \n    # Case 2: Check if infinite\n    # To see if infinite, we need to check if even with worst possible t5 (20.00),\n    # the final score would still be <= target\n    worst_t5 = 20.00\n    if final_score(worst_t5) <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 3: Find threshold t5\n    # We need to find maximum t5 such that final_score(t5) <= target\n    # Since final_score is non-decreasing with t5 (adding larger t5 can only\n    # increase or keep same the average of middle three), we can binary search\n    \n    lo, hi = 1.00, 20.00\n    eps = 1e-9\n    \n    # Binary search for maximum t5 that satisfies condition\n    for _ in range(100):  # Enough iterations for precision\n        mid = (lo + hi) / 2.0\n        if final_score(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to 2 decimal places\n    result = round(lo, 2)\n    # Ensure it's formatted with exactly 2 decimal places\n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 35.030226945877075}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.1457359790802}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.23778891563416}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            print(s)\n            return\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.34050989151001}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Calculate total cost: train fare X + half of bus fare Y\n    total_cost = X + Y // 2\n    \n    # Output the result\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.745455026626587}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have actually happened\n    dream_events = []  # events that were part of dreams (for checking re-occurrence)\n    output = []\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == 'E':\n            event = parts[1]\n            events_stack.append(event)\n            # Remove from dream_events if it was previously dreamed\n            if event in dream_events:\n                dream_events.remove(event)\n        \n        elif cmd == 'D':\n            r = int(parts[1])\n            # Mark the last r events as dreamed\n            for _ in range(r):\n                if events_stack:\n                    dream_events.append(events_stack.pop())\n        \n        elif cmd == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current reality\n            consistent_with_reality = True\n            for ev in scenario_events:\n                if ev.startswith('!'):\n                    event_name = ev[1:]\n                    if event_name in events_stack:\n                        consistent_with_reality = False\n                        break\n                else:\n                    if ev not in events_stack:\n                        consistent_with_reality = False\n                        break\n            \n            if consistent_with_reality:\n                output.append(\"Yes\")\n                continue\n            \n            # Find smallest r such that scenario would be consistent if D r happened\n            min_r = None\n            # Try all possible r from 1 to len(events_stack)\n            for r in range(1, len(events_stack) + 1):\n                # Simulate removing last r events\n                temp_stack = events_stack[:-r] if r < len(events_stack) else []\n                consistent = True\n                for ev in scenario_events:\n                    if ev.startswith('!'):\n                        event_name = ev[1:]\n                        if event_name in temp_stack:\n                            consistent = False\n                            break\n                    else:\n                        if ev not in temp_stack:\n                            consistent = False\n                            break\n                if consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                output.append(f\"{min_r} Just A Dream\")\n            else:\n                output.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 57.13143301010132}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    N, T = map(int, input[:2])\n    dishes = []\n    idx = 2\n    for _ in range(N):\n        a = int(input[idx]); b = int(input[idx+1])\n        dishes.append((a, b))\n        idx += 2\n    \n    # Sort dishes by eating time\n    dishes.sort()\n    \n    # DP array: dp[t] = max happiness achievable with total eating time exactly t\n    dp = [-1] * (T + 1)\n    dp[0] = 0\n    \n    max_happiness = 0\n    \n    for a, b in dishes:\n        # Process in reverse to avoid using same dish multiple times\n        for t in range(T - 1, -1, -1):\n            if dp[t] >= 0:\n                new_t = t + a\n                if new_t < T:\n                    dp[new_t] = max(dp[new_t], dp[t] + b)\n                else:\n                    # If adding this dish would exceed T-0.5, we can still order it\n                    # as long as we start eating before T-0.5\n                    max_happiness = max(max_happiness, dp[t] + b)\n        \n        # Also consider taking only this dish\n        if a < T:\n            dp[a] = max(dp[a], b)\n        else:\n            max_happiness = max(max_happiness, b)\n    \n    # Check maximum from dp array\n    max_happiness = max(max_happiness, max(dp))\n    \n    print(max_happiness)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 62.12687706947327}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    P, Q, R = map(int, input().split())\n    # The route consists of two flights between three airports\n    # We need to consider all possible ordered pairs of flights\n    # Since flights are bidirectional, we can think of all permutations\n    # of three airports taken two at a time with order\n    # But simpler: the minimum sum will be the sum of the two smallest flight times\n    # Because we can always choose a route that uses those two flights\n    # For example, if P and Q are smallest, route A->B->C uses P+Q\n    # Similarly for other combinations\n    # So answer is min(P+Q, Q+R, R+P)\n    ans = min(P+Q, Q+R, R+P)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.268261194229126}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 174.15375423431396}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.53810691833496}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        out_lines.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.29562282562256}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.92476487159729}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.88396286964417}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    X = int(next(it))\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(next(it))\n        # Count days: 1, A+1, 2A+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A\n    \n    # Prepared = eaten + remaining\n    prepared = total_eaten + X\n    print(prepared)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.624692916870117}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * n\n    components = []\n    \n    for i in range(n):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp_nodes = []\n            while stack:\n                node = stack.pop()\n                comp_nodes.append(node)\n                for nb in adj[node]:\n                    if not visited[nb]:\n                        visited[nb] = True\n                        stack.append(nb)\n            components.append(comp_nodes)\n    \n    # Count needed edits: (number_of_components - 1) * 2\n    needed = (len(components) - 1) * 2 if len(components) > 1 else 0\n    \n    # Check socket capacity constraints\n    for comp in components:\n        total_sockets = sum(capacities[node] for node in comp)\n        existing_edges_in_comp = sum(len(adj[node]) for node in comp) // 2\n        max_possible_edges = total_sockets // 2\n        if existing_edges_in_comp > max_possible_edges:\n            print(\"no\")\n            return\n        # For connectivity within component, we need at least |comp|-1 edges\n        min_needed_in_comp = len(comp) - 1\n        if max_possible_edges < min_needed_in_comp:\n            print(\"no\")\n            return\n    \n    # Check if k is sufficient\n    if needed <= k:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.584946155548096}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Total distinct numbers\n    distinct = list(freq.keys())\n    m = len(distinct)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (given to left robot)\n    for i in range(m):\n        p = distinct[i]\n        # Find the first position where left robot would stop\n        # It stops at the first occurrence of p from left\n        # Since we only care about distinct numbers, we just need to know\n        # that left robot stops somewhere before or at the first occurrence\n        # Actually, we need to count how many q values are valid for this p\n        \n        # For a given p, left robot stops at its first occurrence\n        # Let pos_left be the index of first occurrence of p (0-based)\n        # We need q such that right robot stops at a position > pos_left\n        # Right robot stops at the last occurrence of q from right\n        # So we need: last_occurrence(q) > first_occurrence(p)\n        \n        # Precompute first occurrence for each distinct number\n        first_occ = {}\n        for idx, val in enumerate(arr):\n            if val not in first_occ:\n                first_occ[val] = idx\n        \n        # Precompute last occurrence for each distinct number\n        last_occ = {}\n        for idx in range(n-1, -1, -1):\n            val = arr[idx]\n            if val not in last_occ:\n                last_occ[val] = idx\n        \n        # Count valid q for this p\n        pos_left = first_occ[p]\n        valid_q_count = 0\n        for q in distinct:\n            if last_occ[q] > pos_left:\n                valid_q_count += 1\n        \n        total_pairs += valid_q_count\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 38.17840385437012}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.97428917884827}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.57155895233154}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.969191074371338}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # The algorithm swaps each odd number x with x+1, then swaps back.\n    # For odd numbers, after both swaps, they become x+1 then back to x.\n    # For even numbers, they become x-1 then back to x-1.\n    # So final value: if odd -> x, if even -> x-1.\n    result = []\n    for x in arr:\n        if x % 2 == 1:\n            result.append(x)\n        else:\n            result.append(x - 1)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.576220750808716}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    thore_full = \"ThoreHusfeldt\"\n    thore_prefix_no_t = \"ThoreHusfeld\"\n    \n    # Find ThoreHusfeldt's position\n    thore_index = -1\n    for i, name in enumerate(names):\n        if name == thore_full:\n            thore_index = i\n            break\n    \n    # Check if Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check if any name above Thore starts with \"ThoreHusfeld\" (without trailing 't')\n    for i in range(thore_index):\n        if names[i].startswith(thore_prefix_no_t):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    above_names = names[:thore_index]\n    for length in range(1, len(thore_full) + 1):\n        prefix = thore_full[:length]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Fallback (should not happen given constraints)\n    print(thore_full)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.423398971557617}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.85078072547913}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = input().strip()\n    s = list(n)\n    m = len(s)\n    INF = 10**9\n    ans = INF\n    \n    # For divisibility by 25, last two digits must be 00, 25, 50, or 75\n    targets = [('0', '0'), ('2', '5'), ('5', '0'), ('7', '5')]\n    \n    for d1, d2 in targets:\n        # Find positions of d1 and d2 from right to left\n        pos1 = -1\n        pos2 = -1\n        \n        # Find d2 (rightmost digit) first\n        for i in range(m-1, -1, -1):\n            if s[i] == d2:\n                pos2 = i\n                break\n        if pos2 == -1:\n            continue\n        \n        # Find d1 (second from right) that is to the left of pos2\n        for i in range(m-1, -1, -1):\n            if i == pos2:\n                continue\n            if s[i] == d1:\n                pos1 = i\n                break\n        if pos1 == -1:\n            continue\n        \n        # Calculate moves to bring these to last two positions\n        moves = 0\n        # Make a copy to simulate\n        temp = s[:]\n        \n        # Move pos2 to last position (index m-1)\n        for i in range(pos2, m-1):\n            temp[i], temp[i+1] = temp[i+1], temp[i]\n            moves += 1\n        \n        # Update pos1 if it was to the right of original pos2\n        if pos1 > pos2:\n            pos1 -= 1\n        \n        # Move pos1 to second last position (index m-2)\n        for i in range(pos1, m-2):\n            temp[i], temp[i+1] = temp[i+1], temp[i]\n            moves += 1\n        \n        # Check for leading zero\n        if temp[0] == '0':\n            # Find first non-zero digit to swap to front\n            found = False\n            for i in range(1, m-2):  # Don't touch last two fixed digits\n                if temp[i] != '0':\n                    # Move it to front\n                    for j in range(i, 0, -1):\n                        temp[j], temp[j-1] = temp[j-1], temp[j]\n                        moves += 1\n                    found = True\n                    break\n            if not found:\n                continue  # Invalid, leading zero unavoidable\n        \n        ans = min(ans, moves)\n    \n    print(-1 if ans == INF else ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 37.990628242492676}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.643306016922}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 91.26044225692749}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef largest_bus_number(m):\n    if m < 1729:\n        return \"none\"\n    \n    # Dictionary to store count of ways for each sum\n    ways_count = {}\n    \n    # We only need to consider cubes up to cube root of m\n    max_i = int(m ** (1/3)) + 1\n    \n    # Generate all sums of two positive cubes\n    for i in range(1, max_i + 1):\n        i_cube = i * i * i\n        if i_cube > m:\n            break\n        \n        for j in range(i, max_i + 1):\n            j_cube = j * j * j\n            sum_cubes = i_cube + j_cube\n            \n            if sum_cubes > m:\n                break\n            \n            if sum_cubes in ways_count:\n                ways_count[sum_cubes] += 1\n            else:\n                ways_count[sum_cubes] = 1\n    \n    # Find the largest bus number (at least 2 ways)\n    result = 0\n    for num, count in ways_count.items():\n        if count >= 2 and num <= m and num > result:\n            result = num\n    \n    return result if result > 0 else \"none\"\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    result = largest_bus_number(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.232624053955078}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.91206574440002}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.73840308189392}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive_time, calm_time):\n    \"\"\"Return True if dog is aggressive at arrival minute.\"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival % cycle_length\n    # Aggressive from minute 0 to aggressive_time-1 inclusive\n    return position_in_cycle < aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: problem states arrival \"during\" minute N,\n    # so we use arrival minute N-1 (0-indexed)\n    arrivals = [P-1, M-1, G-1]\n    \n    results = []\n    for arrival in arrivals:\n        dog1 = is_aggressive(arrival, A, B)\n        dog2 = is_aggressive(arrival, C, D)\n        if dog1 and dog2:\n            results.append(\"both\")\n        elif dog1 or dog2:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.734816074371338}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_mirror_word(word):\n    \"\"\"Check if word matches its mirror reflection.\"\"\"\n    mirror_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O',\n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',\n        'Y': 'Y'\n    }\n    \n    n = len(word)\n    for i in range((n + 1) // 2):\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Both characters must be mirror-symmetric and map to each other\n        if left_char not in mirror_map or mirror_map[left_char] != right_char:\n            return False\n    \n    return True\n\nif __name__ == \"__main__\":\n    word = input().strip()\n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity_estimate": null, "runtime_sec": 24.65712809562683}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 56.54806399345398}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    if not s:\n        return\n    a_score = 0\n    b_score = 0\n    i = 0\n    n = len(s)\n    while i < n:\n        player = s[i]\n        points = int(s[i+1])\n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        i += 2\n        # Check for win condition\n        if a_score >= 11 or b_score >= 11:\n            if a_score >= 11 and a_score - b_score >= 2:\n                print('A')\n                return\n            if b_score >= 11 and b_score - a_score >= 2:\n                print('B')\n                return\n        # Special case: tie at 10-10\n        if a_score == 10 and b_score == 10:\n            # After tie, win by 2\n            while i < n:\n                player = s[i]\n                points = int(s[i+1])\n                if player == 'A':\n                    a_score += points\n                else:\n                    b_score += points\n                i += 2\n                if abs(a_score - b_score) >= 2:\n                    if a_score > b_score:\n                        print('A')\n                    else:\n                        print('B')\n                    return\n    # Should not reach here for valid input\n    print('A' if a_score > b_score else 'B')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.924772262573242}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.85215306282043}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for dice in range(1, 7):\n        diff_a = abs(a - dice)\n        diff_b = abs(b - dice)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.036869049072266}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Map each value to its position in the required sequence\n    pos = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Count how many complete sequences we can form\n    # seq_count[i] = number of sequences that have progressed up to position i\n    seq_count = [0] * 6\n    \n    for val in arr:\n        idx = pos[val]\n        if idx == 0:\n            # Start a new sequence\n            seq_count[0] += 1\n        else:\n            # Can only extend if we have a sequence waiting at previous position\n            if seq_count[idx-1] > 0:\n                seq_count[idx-1] -= 1\n                seq_count[idx] += 1\n        # If idx != 0 and no sequence at previous position, this element must be removed\n    \n    # Each complete sequence has 6 elements\n    # seq_count[5] holds the number of fully formed sequences\n    complete_sequences = seq_count[5]\n    total_elements_in_good_array = complete_sequences * 6\n    \n    # Minimum removals = total elements - elements in good array\n    result = n - total_elements_in_good_array\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.91705298423767}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 51.42150616645813}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.84605312347412}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.11880922317505}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.31938791275024}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\nimport math\nMOD = 10**9 + 7\n\ndef prime_factorization(n):\n    factors = {}\n    temp = n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                temp //= i\n                cnt += 1\n            factors[i] = cnt\n    if temp > 1:\n        factors[temp] = 1\n    return factors\n\ndef nCr(n, r, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    \n    if M == 1:\n        print(1)\n        return\n    \n    # Factorize M\n    factors = prime_factorization(M)\n    \n    # Precompute factorials and inverse factorials\n    max_exp = max(factors.values()) if factors else 0\n    max_n = N + max_exp\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # For each prime factor, distribute exponents among N positions\n    result = 1\n    for exp in factors.values():\n        # Number of ways to distribute exp identical items into N distinct boxes\n        # Stars and bars: C(N + exp - 1, exp)\n        ways = nCr(N + exp - 1, exp, fact, inv_fact)\n        result = result * ways % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 55.38419580459595}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Since moving by 2 is free, chips can be moved to any coordinate with the same parity\n    # as their original coordinate without paying coins.\n    # To move to a coordinate with different parity, we need to pay 1 coin per chip.\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for pos in x if pos % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller count (moving all to even or all to odd)\n    result = min(even_count, odd_count)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.780948877334595}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.8383207321167}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # current water in each vessel\n    water = [0] * n\n    \n    out_lines = []\n    for _ in range(m):\n        query_type = int(next(it))\n        if query_type == 1:\n            p = int(next(it)) - 1  # 0-indexed\n            x = int(next(it))\n            \n            # pour water into vessel p\n            while p < n and x > 0:\n                space = capacities[p] - water[p]\n                if x >= space:\n                    water[p] = capacities[p]\n                    x -= space\n                    p += 1\n                else:\n                    water[p] += x\n                    x = 0\n        else:  # query_type == 2\n            k = int(next(it)) - 1  # 0-indexed\n            out_lines.append(str(water[k]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.158029794692993}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = int(data[1])\n    enemies = list(map(int, data[2:2+n]))\n    \n    # Sort enemy fleets in ascending order\n    enemies.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemies:\n        # To win, Atli needs enemy+1 ships\n        needed = enemy + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.671587944030762}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.48085594177246}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b.\n    # Since a and b are integers, we need k * b to be integer and within [l, r].\n    # b ranges from x to y inclusive.\n    for b in range(x, y + 1):\n        a = k * b\n        if l <= a <= r:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.154953002929688}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.57783389091492}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s: str) -> int:\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev = suffix[i-1]\n            curr = suffix[i]\n            tmp[curr] = tmp[prev]\n            if (rank[curr] != rank[prev]) or (rank[curr + k] if curr + k < n else -1) != (rank[prev + k] if prev + k < n else -1):\n                tmp[curr] += 1\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # LCP array construction using Kasai's algorithm\n    lcp = [0] * n\n    inv = [0] * n\n    for i in range(n):\n        inv[suffix[i]] = i\n    k = 0\n    for i in range(n):\n        if inv[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # The answer is the maximum value in LCP array\n    return max(lcp) if lcp else 0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    s = data[1]\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.854147911071777}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 52.89581227302551}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    X, A, B = map(int, sys.stdin.readline().split())\n    \n    # Calculate days from best-by date to eating\n    # A days before best-by date, then B days after purchase\n    # So eating occurs at: best-by date - A + B\n    # Days relative to best-by date: (best-by date - A + B) - best-by date = B - A\n    days_from_best_by = B - A\n    \n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by date\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by date\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.161774158477783}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Wall is a line through (x1,y1) and (x2,y2)\n    # Pole is at (0,0)\n    \n    # Distance from pole to wall\n    # Using formula for distance from point to line\n    # Line: (y2-y1)*x - (x2-x1)*y + (x2*y1 - x1*y2) = 0\n    A = y2 - y1\n    B = -(x2 - x1)\n    C = x2*y1 - x1*y2\n    dist_to_wall = abs(A*0 + B*0 + C) / math.sqrt(A*A + B*B)\n    \n    # The dog can cover area on one side of the wall\n    # The accessible area is a circular segment of a circle centered at (0,0)\n    # with radius r, cut by the wall line.\n    # The area of the circular segment (on one side of the wall) must be >= L\n    \n    # Binary search for minimal integer radius r (chain length in meters)\n    low = 0\n    high = 20000  # Upper bound: sqrt(L/pi) + dist_to_wall, but safe bound\n    \n    def area_with_radius(r):\n        if r <= dist_to_wall:\n            # Entire circle is on one side, but if r <= dist_to_wall,\n            # the wall line doesn't cut the circle, so accessible area is half circle?\n            # Actually, if pole is on the wall side, and r <= dist_to_wall,\n            # the wall doesn't intersect the circle, so the dog can access the entire circle\n            # But the problem says the dog cannot cross the wall, so if the wall doesn't intersect\n            # the circle, then the accessible area is the entire circle if the pole is on the correct side.\n            # However, we don't know which side is the lawn side.\n            # Since the lawn is on one specific side (Ellen's side), and we want to cover at least L\n            # on that side, we need to consider the half-plane defined by the wall.\n            # For simplicity, we assume the lawn is on the side where the pole is?\n            # Actually, the problem doesn't specify, but the examples suggest the pole might be on the lawn side.\n            # Let's assume the pole is on the lawn side, so if r <= dist_to_wall, the entire circle is accessible.\n            return math.pi * r * r\n        else:\n            # Circular segment area formula\n            # d = dist_to_wall\n            # Area = r^2 * acos(d/r) - d * sqrt(r^2 - d^2)\n            d = dist_to_wall\n            return r * r * math.acos(d / r) - d * math.sqrt(r * r - d * d)\n    \n    while low < high:\n        mid = (low + high) // 2\n        if area_with_radius(mid) >= L:\n            high = mid\n        else:\n            low = mid + 1\n    \n    print(low)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 38.9264178276062}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.63949418067932}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    print(A * B)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 7.2589099407196045}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count triples (a,b,c) with 1 <= a <= b <= n-1, 1 <= c <= n-1 such that a^2 + b^2  c^2 (mod n).\"\"\"\n    # Precompute squares modulo n\n    squares = [0] * n\n    for i in range(n):\n        squares[i] = (i * i) % n\n    \n    # Count frequencies of each square residue\n    freq = [0] * n\n    for i in range(1, n):\n        freq[squares[i]] += 1\n    \n    # For each pair (a,b) with a <= b, count how many c satisfy the congruence\n    total = 0\n    for a in range(1, n):\n        a_sq = squares[a]\n        for b in range(a, n):\n            target = (a_sq + squares[b]) % n\n            total += freq[target]\n    \n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.092144012451172}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    S = list(input[0])\n    Q = int(input[1])\n    idx = 2\n    \n    # Use deque for efficient operations\n    from collections import deque\n    dq = deque(S)\n    reversed_flag = False\n    \n    for _ in range(Q):\n        T = int(input[idx])\n        idx += 1\n        \n        if T == 1:\n            # Toggle reversal flag instead of actually reversing\n            reversed_flag = not reversed_flag\n        else:\n            F = int(input[idx])\n            C = input[idx + 1]\n            idx += 2\n            \n            # Determine actual position based on reversal flag\n            if (F == 1 and not reversed_flag) or (F == 2 and reversed_flag):\n                dq.appendleft(C)\n            else:\n                dq.append(C)\n    \n    # Apply final reversal if needed\n    if reversed_flag:\n        dq.reverse()\n    \n    print(''.join(dq))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 36.98328399658203}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 77.06198573112488}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 177.71570992469788}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If already rested enough after first alarm\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        remaining = a - b\n        # Sleep gained per cycle after first alarm\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (remaining + gain_per_cycle - 1) // gain_per_cycle\n        \n        total_time = b + cycles * c\n        results.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 80.85735511779785}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data)\n    \n    # Initialize sieve\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    crossed_out = []\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # Cross out p itself\n            if not is_prime[p]:  # Already crossed? (shouldn't happen)\n                continue\n            is_prime[p] = False\n            crossed_out.append(p)\n            if len(crossed_out) == K:\n                print(p)\n                return\n            \n            # Cross out multiples of p\n            multiple = p * p\n            while multiple <= N:\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out.append(multiple)\n                    if len(crossed_out) == K:\n                        print(multiple)\n                        return\n                multiple += p\n    \n    # If K is larger than total crossed out (shouldn't happen given constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 53.96994209289551}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 123.48436403274536}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 177.68506789207458}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, -score, i))  # Store negative score for descending order\n        idx += 2\n    \n    # Sort by city (lexicographical) then by negative score (descending)\n    restaurants.sort(key=lambda x: (x[0], x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.91467809677124}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.26527571678162}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.54534769058228}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    inc = []\n    dec = []\n    for a, b in projects:\n        if b >= 0:\n            inc.append((a, b))\n        else:\n            dec.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    inc.sort(key=lambda x: x[0])\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # Equivalent to sorting by a + b descending\n    dec.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process increasing projects first\n    for a, b in inc:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    # Process decreasing projects\n    for a, b in dec:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.410248041152954}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.71995902061462}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track number of distinct difficulties in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.27693510055542}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    count = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.50330114364624}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 101.76472806930542}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Ensure we move from smaller to larger index for simplicity\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    # Check if positions are reachable via jumps of length k\n    # They must be in same modulo class and path must be clear\n    if (t_pos - g_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Check all intermediate positions at steps of k\n    for pos in range(g_pos + k, t_pos, k):\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.77602195739746}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Helper function to check if a cell is within bounds\n    def in_bounds(x, y):\n        return 0 <= x < r and 0 <= y < c\n    \n    # BFS to mark all connected land cells (including those under clouds)\n    def bfs(start_x, start_y, visited):\n        from collections import deque\n        queue = deque()\n        queue.append((start_x, start_y))\n        visited[start_x][start_y] = True\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if in_bounds(nx, ny) and not visited[nx][ny]:\n                    # If it's land or cloud, we can consider it as part of the same island\n                    if grid[nx][ny] == 'L' or grid[nx][ny] == 'C':\n                        visited[nx][ny] = True\n                        queue.append((nx, ny))\n    \n    visited = [[False] * c for _ in range(r)]\n    island_count = 0\n    \n    # First, count islands from definite land cells\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'L' and not visited[i][j]:\n                bfs(i, j, visited)\n                island_count += 1\n    \n    # Now, for clouds that are not adjacent to any land (including through other clouds),\n    # they can be treated as water to minimize islands.\n    # But since we already counted islands from land, and clouds connected to land are already visited,\n    # the remaining unvisited clouds can be set to water, so they don't form new islands.\n    # However, we need to consider that clouds can form new islands if they are not connected to any land.\n    # To minimize islands, we should avoid creating new islands from clouds.\n    # So, we only count islands from land cells, and treat all clouds as either part of existing islands or as water.\n    # This approach gives the minimum possible islands.\n    \n    print(island_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 61.451354026794434}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.9086217880249}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 72.99839425086975}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite RGB pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We need to check all possible starting positions for the substring of length k\n        # For each starting position, we need to check alignment with the infinite pattern\n        # starting with 'R', 'G', or 'B' at that position\n        min_changes = float('inf')\n        \n        # For each possible starting character of the pattern at position 0 of substring\n        for start_char_idx in range(3):\n            # Precompute mismatches for this pattern alignment\n            # pattern_char = pattern[(start_char_idx + offset) % 3]\n            # We'll compute using sliding window\n            \n            # Initialize for first window starting at position 0\n            changes = 0\n            for i in range(k):\n                expected = pattern[(start_char_idx + i) % 3]\n                if s[i] != expected:\n                    changes += 1\n            min_changes = min(min_changes, changes)\n            \n            # Slide the window\n            for start in range(1, n - k + 1):\n                # Remove leftmost character\n                left_expected = pattern[(start_char_idx + (start - 1)) % 3]\n                if s[start - 1] != left_expected:\n                    changes -= 1\n                \n                # Add new rightmost character\n                right_expected = pattern[(start_char_idx + (start + k - 1)) % 3]\n                if s[start + k - 1] != right_expected:\n                    changes += 1\n                \n                min_changes = min(min_changes, changes)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 31.569706916809082}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.84232306480408}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    table = set()\n    max_socks = 0\n    \n    for sock in socks:\n        if sock in table:\n            table.remove(sock)\n        else:\n            table.add(sock)\n            max_socks = max(max_socks, len(table))\n    \n    print(max_socks)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.268203020095825}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R1, S = map(int, data[:2])\n    # From S = (R1 + R2)/2, solve for R2\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.23478889465332}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.33880996704102}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Convert to 0-based indexing\n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        edges.append((u, v))\n    \n    # Initialize DSU\n    dsu = DSU(n)\n    \n    # Process edges in increasing order of min(u,v)\n    # We'll maintain the maximum node reachable from each component\n    max_in_comp = list(range(n))  # initially each node's max is itself\n    \n    # Union edges and update max_in_comp\n    for u, v in edges:\n        ru = dsu.find(u)\n        rv = dsu.find(v)\n        if ru != rv:\n            # Union the components\n            dsu.union(u, v)\n            new_root = dsu.find(u)\n            # Update max_in_comp for the new component\n            old_max = max(max_in_comp[ru], max_in_comp[rv])\n            max_in_comp[new_root] = old_max\n        else:\n            # Already in same component, ensure max_in_comp is updated\n            max_in_comp[ru] = max(max_in_comp[ru], u, v)\n    \n    # Now scan from left to right\n    answer = 0\n    i = 0\n    while i < n:\n        root_i = dsu.find(i)\n        max_reachable = max_in_comp[root_i]\n        \n        # We need all nodes from i to max_reachable to be in the same component\n        j = i + 1\n        while j <= max_reachable:\n            root_j = dsu.find(j)\n            if root_j != root_i:\n                # Need to merge these components\n                answer += 1\n                dsu.union(i, j)\n                new_root = dsu.find(i)\n                # Update max_reachable\n                max_reachable = max(max_reachable, max_in_comp[root_j])\n                max_in_comp[new_root] = max_reachable\n                root_i = new_root\n            j += 1\n        i = max_reachable + 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 97.14472985267639}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 49.666451930999756}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.6177680492401}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    jobs = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        jobs.append((b, a))  # (deadline, duration)\n    \n    # Sort jobs by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.094823837280273}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        lcm_val = lcm_val * t // math.gcd(lcm_val, t)\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.154221057891846}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 174.5343999862671}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.6644082069397}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Pair boxes with remainder 0 with each other\n    pairs = rem_count[0] // 2\n    \n    # For other remainders, pair remainder i with remainder k-i\n    # Special case when k is even: remainder k/2 pairs with itself\n    if k % 2 == 0:\n        pairs += rem_count[k // 2] // 2\n    \n    # Pair i with k-i for i from 1 to (k-1)//2\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        if i != j:\n            pairs += min(rem_count[i], rem_count[j])\n    \n    # Each pair uses 2 boxes\n    print(pairs * 2)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.341556072235107}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.64534282684326}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.3598029613495}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    a = s\n    i = 1\n    while True:\n        if a in seen:\n            print(i)\n            return\n        seen[a] = i\n        a = f(a)\n        i += 1\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.879518032073975}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.6363489627838}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open+1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close-1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon+1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 41.86282014846802}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    arr = list(map(int, data[idx:idx+n]))\n    idx += n\n    \n    freq = collections.Counter(arr)\n    max_freq = max(freq.values())\n    distinct = len(freq)\n    \n    # The maximum team size x must satisfy:\n    # 1. x <= distinct (for unique skills in first team)\n    # 2. x <= max_freq (for same skills in second team)\n    # 3. We need to allocate 2x students total\n    # 4. But we can use the same skill value in both teams\n    \n    # Try to find maximum x where we can form both teams\n    # We have two constraints:\n    # - First team needs x distinct skills\n    # - Second team needs x copies of one skill\n    \n    # The optimal strategy:\n    # If max_freq > distinct:\n    #   We can take x = distinct (use all distinct for first team)\n    #   and use the most frequent skill for second team\n    #   But we need to check if we have enough of that skill\n    #   after possibly using one copy in first team\n    # If max_freq <= distinct:\n    #   We can take x = max_freq\n    #   But we need to check if we have enough distinct skills\n    #   after possibly using the frequent skill in first team\n    \n    # Actually, the formula is: x = min(distinct, max_freq)\n    # But we need to handle the case where distinct == max_freq\n    # because then we might be using the same skill in both teams\n    # and need to check if we have enough copies\n    \n    x = min(distinct, max_freq)\n    \n    # Adjust if needed:\n    # If distinct == max_freq, we might be using the same skill\n    # in both teams. We need at least max_freq+1 copies if we use\n    # that skill in both teams, or we need to choose a different\n    # skill for second team if available\n    if distinct == max_freq:\n        # Check if we can use the same skill in both teams\n        # We need max_freq copies for second team + 1 for first team\n        # if we use that skill in first team\n        # Actually, we can avoid using that skill in first team\n        # if there are other distinct skills\n        if distinct > 1:\n            # We can use distinct-1 skills for first team\n            # and the frequent skill for second team\n            x = min(distinct - 1, max_freq)\n        else:\n            # Only one skill available, can't form both teams\n            x = 0\n    \n    # Also need to ensure we have enough students total\n    # But with the constraints given, this should be satisfied\n    # since we're using at most 2x students and x <= n/2\n    \n    # The answer can't exceed n//2 since we need 2x students\n    x = min(x, n // 2)\n    \n    results.append(str(x))\n\nprint('\\n'.join(results))", "complexity_estimate": null, "runtime_sec": 37.43170094490051}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Function to reduce a number by dividing by 2 and 3 as much as possible\n    def reduce_to_core(x):\n        while x % 2 == 0:\n            x //= 2\n        while x % 3 == 0:\n            x //= 3\n        return x\n    \n    # Reduce all numbers to their core (divisible only by primes other than 2 and 3)\n    core = reduce_to_core(a[0])\n    for num in a[1:]:\n        if reduce_to_core(num) != core:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.86355209350586}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.24066710472107}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    it = iter(input_data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n        edges.append((x, y, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute shortest distances from each district\n    dist_from = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dist_from[i] = dijkstra(n, adj, i)\n    \n    # Compute original total cost\n    original_total = 0\n    for a, b in routes:\n        original_total += dist_from[a][b]\n    \n    # Try making each road zero cost\n    best = original_total\n    for x, y, w in edges:\n        # For each route, new distance is min(original, using zero road)\n        new_total = 0\n        for a, b in routes:\n            # Path via zero road: a->x + 0 + y->b or a->y + 0 + x->b\n            via_zero = min(dist_from[a][x] + dist_from[y][b],\n                          dist_from[a][y] + dist_from[x][b])\n            new_total += min(dist_from[a][b], via_zero)\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.39092993736267}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.63556599617004}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.74967813491821}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B, C, D, E, F = map(int, sys.stdin.readline().split())\n    \n    # Maximum water mass we can have (in grams)\n    max_water = F\n    water_ops = [100 * A, 100 * B]\n    \n    # Generate all possible water masses using operations 1 and 2\n    water_masses = set()\n    for i in range(max_water // water_ops[0] + 1):\n        for j in range(max_water // water_ops[1] + 1):\n            water = i * water_ops[0] + j * water_ops[1]\n            if water <= max_water and water > 0:\n                water_masses.add(water)\n    \n    # Maximum sugar mass we can have (in grams)\n    max_sugar = F\n    sugar_ops = [C, D]\n    \n    # Generate all possible sugar masses using operations 3 and 4\n    sugar_masses = set()\n    for i in range(max_sugar // sugar_ops[0] + 1):\n        for j in range(max_sugar // sugar_ops[1] + 1):\n            sugar = i * sugar_ops[0] + j * sugar_ops[1]\n            if sugar <= max_sugar:\n                sugar_masses.add(sugar)\n    \n    best_density = -1\n    best_total = 0\n    best_sugar = 0\n    \n    # Try all combinations of water and sugar\n    for water in water_masses:\n        max_sugar_for_water = min(F - water, water // 100 * E)\n        for sugar in sugar_masses:\n            if sugar > max_sugar_for_water:\n                continue\n            total = water + sugar\n            if total > F or total == 0:\n                continue\n            density = (100 * sugar) / total if total > 0 else 0\n            if density > best_density:\n                best_density = density\n                best_total = total\n                best_sugar = sugar\n    \n    # If no sugar water found (only water), output water with 0 sugar\n    if best_total == 0 and water_masses:\n        # Find the smallest non-zero water mass\n        best_total = min(w for w in water_masses if w > 0)\n        best_sugar = 0\n    \n    print(f\"{best_total} {best_sugar}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 31.139728784561157}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.00576901435852}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    print(max_beauty(n, k, s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.342340230941772}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.64052677154541}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 95.89987921714783}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(n, m, x, y):\n    \"\"\"Rotate 90 degrees clockwise: (x,y) -> (y, n-x+1)\"\"\"\n    return y, n - x + 1\n\ndef rotate_90_counterclockwise(n, m, x, y):\n    \"\"\"Rotate 90 degrees counterclockwise: (x,y) -> (m-y+1, x)\"\"\"\n    return m - y + 1, x\n\ndef horizontal_flip(n, m, x, y):\n    \"\"\"Horizontal flip: (x,y) -> (x, m-y+1)\"\"\"\n    return x, m - y + 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        \n        # Apply transformations\n        cur_n, cur_m = n, m\n        cur_x, cur_y = xi, yi\n        \n        # x clockwise rotations (mod 4)\n        for _ in range(x % 4):\n            cur_x, cur_y = rotate_90_clockwise(cur_n, cur_m, cur_x, cur_y)\n            cur_n, cur_m = cur_m, cur_n\n        \n        # y horizontal flips\n        for _ in range(y % 2):\n            cur_x, cur_y = horizontal_flip(cur_n, cur_m, cur_x, cur_y)\n        \n        # z counterclockwise rotations (mod 4)\n        for _ in range(z % 4):\n            cur_x, cur_y = rotate_90_counterclockwise(cur_n, cur_m, cur_x, cur_y)\n            cur_n, cur_m = cur_m, cur_n\n        \n        results.append(f\"{cur_x} {cur_y}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 34.92270016670227}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = int(input().strip())\n    # Each character can be any digit from 1 to N, inclusive\n    # There are N choices for each of the 3 positions\n    total_passwords = N ** 3\n    print(total_passwords)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.047285079956055}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.37220096588135}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        # Count consecutive '<' from left and consecutive '>' from right\n        left_count = 0\n        for ch in s:\n            if ch == '<':\n                left_count += 1\n            else:\n                break\n        right_count = 0\n        for ch in reversed(s):\n            if ch == '>':\n                right_count += 1\n            else:\n                break\n        # Minimum deletions needed is the smaller of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.6366708278656}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    X, Y = map(int, sys.stdin.readline().split())\n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: multiply first equation by 2: 2c + 2t = 2X\n    # Subtract from second: (2c + 4t) - (2c + 2t) = Y - 2X\n    # 2t = Y - 2X\n    # t = (Y - 2X) / 2\n    # c = X - t\n    # Both must be non-negative integers\n    if (Y - 2 * X) % 2 != 0:\n        print(\"No\")\n        return\n    t = (Y - 2 * X) // 2\n    c = X - t\n    if c >= 0 and t >= 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.890846967697144}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if any row is completely evil\n    row_evil = [False] * n\n    col_evil = [False] * n\n    \n    for i in range(n):\n        all_evil = True\n        for j in range(n):\n            if grid[i][j] == '.':\n                all_evil = False\n                break\n        row_evil[i] = all_evil\n    \n    for j in range(n):\n        all_evil = True\n        for i in range(n):\n            if grid[i][j] == '.':\n                all_evil = False\n                break\n        col_evil[j] = all_evil\n    \n    # If there exists both a completely evil row and a completely evil column,\n    # it's impossible because the intersection cell can't be purified\n    has_full_evil_row = any(row_evil)\n    has_full_evil_col = any(col_evil)\n    \n    if has_full_evil_row and has_full_evil_col:\n        print(-1)\n        return\n    \n    # Strategy: cast spells on all '.' cells in each row\n    # But we need to minimize, so we can do:\n    # If there's no completely evil row, cast spells on first '.' in each row\n    # If there's no completely evil column, cast spells on first '.' in each column\n    # Choose the smaller set\n    \n    row_solution = []\n    col_solution = []\n    \n    # Build row-based solution\n    if not has_full_evil_row:\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '.':\n                    row_solution.append((i + 1, j + 1))\n                    break\n    \n    # Build column-based solution\n    if not has_full_evil_col:\n        for j in range(n):\n            for i in range(n):\n                if grid[i][j] == '.':\n                    col_solution.append((i + 1, j + 1))\n                    break\n    \n    # Choose the better solution\n    if not row_solution and not col_solution:\n        print(-1)\n    elif not row_solution:\n        for r, c in col_solution:\n            print(r, c)\n    elif not col_solution:\n        for r, c in row_solution:\n            print(r, c)\n    else:\n        # Choose the smaller one\n        if len(row_solution) <= len(col_solution):\n            for r, c in row_solution:\n                print(r, c)\n        else:\n            for r, c in col_solution:\n                print(r, c)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 115.8125388622284}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute all possible fret positions across all strings\n    frets = []\n    for note in b:\n        positions = []\n        for string_val in a:\n            if note > string_val:\n                positions.append(note - string_val)\n        # Sort positions for this note\n        positions.sort()\n        frets.append(positions)\n    \n    # We need to pick one position per note to minimize max-min difference\n    # Use two-pointer sliding window on sorted list of all (fret, note_index) pairs\n    all_pairs = []\n    for i, positions in enumerate(frets):\n        for pos in positions:\n            all_pairs.append((pos, i))\n    \n    all_pairs.sort()\n    \n    m = len(all_pairs)\n    left = 0\n    count = [0] * n\n    covered = 0\n    ans = float('inf')\n    \n    for right in range(m):\n        pos, note_idx = all_pairs[right]\n        if count[note_idx] == 0:\n            covered += 1\n        count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while covered == n and left <= right:\n            ans = min(ans, all_pairs[right][0] - all_pairs[left][0])\n            left_pos, left_note_idx = all_pairs[left]\n            count[left_note_idx] -= 1\n            if count[left_note_idx] == 0:\n                covered -= 1\n            left += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.121772050857544}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 30.283178091049194}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 79.5597550868988}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    \"\"\"\n    Count how many ships Vasya can make by repeatedly cutting squares\n    from a rectangle of size a x b (where a > b).\n    \n    The process:\n    1. From rectangle a x b, cut the largest possible square of size b x b\n    2. This leaves rectangle (a-b) x b\n    3. Repeat until we get a square (when a == b)\n    \n    This is essentially the Euclidean algorithm for GCD,\n    where the number of ships equals the number of steps.\n    \"\"\"\n    ships = 0\n    while b > 0:\n        # Add ships from current rectangle\n        ships += a // b\n        # Update a, b for next iteration\n        a, b = b, a % b\n    return ships\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    result = count_ships(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.291608095169067}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # The smallest positive integer divisible by both 2 and N is LCM(2, N)\n    # Since 2 is prime, LCM(2, N) = 2 * N / gcd(2, N)\n    # If N is even, gcd(2, N) = 2, so answer = N\n    # If N is odd, gcd(2, N) = 1, so answer = 2 * N\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.829356908798218}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.99404191970825}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef max_f_permutations(n):\n    \"\"\"Generate all permutations of length n with maximum f(p).\"\"\"\n    from itertools import permutations\n    max_val = -1\n    max_perms = []\n    for perm in permutations(range(1, n+1)):\n        total = 0\n        for i in range(n):\n            min_val = perm[i]\n            for j in range(i, n):\n                min_val = min(min_val, perm[j])\n                total += min_val\n        if total > max_val:\n            max_val = total\n            max_perms = [perm]\n        elif total == max_val:\n            max_perms.append(perm)\n    return sorted(max_perms)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    \n    if n <= 8:\n        # Brute force for small n\n        perms = max_f_permutations(n)\n        result = perms[m-1]\n        print(' '.join(map(str, result)))\n    else:\n        # For n > 8, use pattern-based construction\n        # Observations show optimal permutations are decreasing sequences with one element moved\n        # Specifically: [n, n-1, ..., k+1, 1, k, k-1, ..., 2] for some k\n        # We need to find the m-th lexicographic among these patterns\n        \n        # Generate all candidate patterns\n        candidates = []\n        for k in range(1, n+1):\n            perm = list(range(n, 0, -1))  # Start with decreasing sequence\n            # Move 1 to position k (1-based index)\n            # Remove 1 from its original position and insert at position k\n            perm.remove(1)\n            perm.insert(k-1, 1)\n            candidates.append(tuple(perm))\n        \n        # Sort lexicographically\n        candidates.sort()\n        \n        # Output the m-th permutation (1-indexed)\n        result = candidates[m-1]\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.95322871208191}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Simply check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.612266063690186}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.4531500339508}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.82103824615479}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [int(next(it)) for _ in range(n)]\n    v = [int(next(it)) for _ in range(n)]\n    \n    # Pair points with (x, v) and sort by x\n    points = sorted(zip(x, v))\n    \n    # For each point, we need to consider pairs where v_i > v_j and x_i < x_j\n    # The minimum distance is 0 if they meet, otherwise it's the initial distance\n    # Actually, for two points i and j with x_i < x_j:\n    # - If v_i <= v_j: they never meet, min distance = x_j - x_i\n    # - If v_i > v_j: they can meet if v_i > v_j, min distance = 0\n    # But careful: they meet if (x_j - x_i) / (v_i - v_j) >= 0\n    # Since x_j > x_i, they meet when v_i > v_j\n    \n    # So we need to sum over all pairs where v_i <= v_j the distance (x_j - x_i)\n    # We can do this efficiently with a Fenwick tree or similar\n    \n    # Compress speeds for BIT\n    all_speeds = sorted(set(v))\n    speed_to_idx = {sp: i+1 for i, sp in enumerate(all_speeds)}  # 1-indexed\n    m = len(all_speeds)\n    \n    # Two BITs: one for count, one for sum of x\n    bit_count = [0] * (m + 2)\n    bit_sum_x = [0] * (m + 2)\n    \n    def bit_update(bit, idx, val):\n        while idx <= m + 1:\n            bit[idx] += val\n            idx += idx & -idx\n    \n    def bit_query(bit, idx):\n        s = 0\n        while idx > 0:\n            s += bit[idx]\n            idx -= idx & -idx\n        return s\n    \n    total = 0\n    # Process points in increasing x order\n    for x_val, v_val in points:\n        idx = speed_to_idx[v_val]\n        # Query for speeds <= current speed\n        cnt = bit_query(bit_count, idx)\n        sum_x = bit_query(bit_sum_x, idx)\n        # For each earlier point with speed <= current, add (x_val - x_earlier)\n        total += cnt * x_val - sum_x\n        # Update BITs\n        bit_update(bit_count, idx, 1)\n        bit_update(bit_sum_x, idx, x_val)\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 152.4351761341095}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.37540912628174}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = int(data[1])  # Rabbit-Owl\n    b = int(data[2])  # Rabbit-Eeyore\n    c = int(data[3])  # Owl-Eeyore\n    \n    # Base case: only first meal at Rabbit's house\n    if n == 1:\n        print(0)\n        return\n    \n    # For n >= 2, we need to leave Rabbit's house after first meal\n    # We can choose the cheaper of the two edges from Rabbit\n    min_from_rabbit = min(a, b)\n    \n    # After leaving Rabbit, we can oscillate between the other two houses\n    # using the cheapest edge among all three\n    min_edge = min(a, b, c)\n    \n    # Total distance:\n    # 1. Leave Rabbit (first edge)\n    # 2. For remaining (n-2) meals, we can use the cheapest edge repeatedly\n    #    by alternating between the two non-Rabbit houses\n    total = min_from_rabbit + (n - 2) * min_edge\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.265047788619995}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    N = int(input[0])\n    A = list(map(int, input[1:]))\n    \n    # Initialize subordinates count array with zeros\n    subordinates = [0] * (N + 1)  # 1-indexed for convenience\n    \n    # Count each subordinate for its boss\n    for i in range(2, N + 1):\n        boss = A[i - 2]  # A_i corresponds to member i's boss\n        subordinates[boss] += 1\n    \n    # Output results for members 1 through N\n    for i in range(1, N + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.92110514640808}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.87002086639404}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith(\"po\"):\n        return \"FILIPINO\"\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        return \"JAPANESE\"\n    elif sentence.endswith(\"mnida\"):\n        return \"KOREAN\"\n    else:\n        # According to problem statement, this case shouldn't occur\n        # but included for completeness\n        return \"UNKNOWN\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    t = int(data[0].strip())\n    results = []\n    \n    for i in range(1, t + 1):\n        if i >= len(data):\n            break\n        sentence = data[i].strip()\n        language = detect_language(sentence)\n        results.append(language)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.98487901687622}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    N = int(data[idx]); idx += 1\n    C = [0] * (N-1)\n    S = [0] * (N-1)\n    F = [0] * (N-1)\n    for i in range(N-1):\n        C[i] = int(data[idx]); idx += 1\n        S[i] = int(data[idx]); idx += 1\n        F[i] = int(data[idx]); idx += 1\n    \n    results = [0] * N\n    for start in range(N-1):\n        current_time = 0\n        for i in range(start, N-1):\n            if current_time <= S[i]:\n                current_time = S[i]\n            else:\n                remainder = current_time % F[i]\n                if remainder != 0:\n                    current_time += F[i] - remainder\n            current_time += C[i]\n        results[start] = current_time\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.89544415473938}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 148.40549778938293}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.13581109046936}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    grid = data[2:2+H]\n    \n    # Directions: up, down, left, right, and four diagonals\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n            else:\n                count = 0\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                        count += 1\n                row_chars.append(str(count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.645227909088135}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.31584811210632}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.87745475769043}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.70161318778992}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import re\n\ndef is_vowel(c, next_char=None):\n    \"\"\"Check if character c is a vowel given next character.\"\"\"\n    c = c.upper()\n    if next_char:\n        next_char = next_char.upper()\n    if c == 'Y':\n        # Y is consonant if followed by another vowel\n        if next_char and next_char in 'AEIOU':\n            return False\n        return True\n    return c in 'AEIOUY'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the rules.\"\"\"\n    # Extract alphabetic part\n    alphabetic = re.sub(r'[^A-Za-z]', '', word)\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    # Convert to uppercase for processing\n    upper = alphabetic.upper()\n    \n    # Handle QU as single consonant\n    upper = upper.replace('QU', 'Q')\n    \n    # Mark vowels\n    vowels = []\n    for i, ch in enumerate(upper):\n        next_char = upper[i+1] if i+1 < len(upper) else None\n        vowels.append(is_vowel(ch, next_char))\n    \n    # Apply silent E rule\n    if len(upper) >= 1 and upper[-1] == 'E':\n        if len(upper) >= 3 and upper[-2] == 'L' and not is_vowel(upper[-3], None):\n            # Keep E as vowel for words like 'able'\n            pass\n        else:\n            # Silent E\n            vowels[-1] = False\n    \n    # Apply ES rule\n    if len(upper) >= 2 and upper[-2:] == 'ES':\n        if len(upper) >= 3 and not (is_vowel(upper[-3], None) or upper[-3] == 'Q'):\n            # Preceded by consonant\n            if len(upper) >= 4 and not (is_vowel(upper[-4], None) or upper[-4] == 'Q'):\n                # Preceded by two or more consonants, keep ES\n                pass\n            else:\n                # Only one consonant before ES, don't count as syllable\n                vowels[-2] = False\n                vowels[-1] = False\n        else:\n            # Preceded by vowel, ES doesn't add syllable\n            vowels[-2] = False\n            vowels[-1] = False\n    \n    # Count syllable divisions\n    syllables = 0\n    in_syllable = False\n    \n    for i, is_v in enumerate(vowels):\n        if is_v:\n            if not in_syllable:\n                syllables += 1\n                in_syllable = True\n        else:\n            in_syllable = False\n    \n    # Ensure at least one syllable\n    return max(1, syllables)\n\ndef split_haiku(words, syllables):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Try all possible splits\n    for i in range(1, n):\n        for j in range(i+1, n):\n            line1_syl = sum(syllables[:i])\n            line2_syl = sum(syllables[i:j])\n            line3_syl = sum(syllables[j:])\n            \n            if line1_syl == 5 and line2_syl == 7 and line3_syl == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    return None\n\ndef main():\n    line = input().strip()\n    \n    # Split into words preserving punctuation\n    words = []\n    current = ''\n    for ch in line:\n        if ch == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += ch\n    if current:\n        words.append(current)\n    \n    # Count syllables for each word\n    syllables = [count_syllables(word) for word in words]\n    total_syllables = sum(syllables)\n    \n    # Check if total is 17 syllables\n    if total_syllables != 17:\n        print(line)\n        return\n    \n    # Try to split into haiku\n    haiku = split_haiku(words, syllables)\n    if haiku:\n        for line in haiku:\n            print(line)\n    else:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 95.04785013198853}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.4553701877594}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    A, B = map(int, input().split())\n    \n    # Define card strength order: 2-13 then 1\n    def strength(card):\n        return card if card != 1 else 14  # Treat 1 as strongest (14)\n    \n    a_strength = strength(A)\n    b_strength = strength(B)\n    \n    if a_strength > b_strength:\n        print(\"Alice\")\n    elif a_strength < b_strength:\n        print(\"Bob\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.067682981491089}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 154.5458300113678}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        s = input_data[idx]\n        idx += 1\n        \n        # Find first occurrence of different consecutive characters\n        start = 0\n        while start < n and s[start] == s[0]:\n            start += 1\n        \n        if start == n:\n            # All characters are the same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rotate string so we start at a boundary\n        rotated = s[start:] + s[:start]\n        \n        count = 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and rotated[j] == rotated[i]:\n                j += 1\n            length = j - i\n            count += length // 3\n            i = j\n        \n        results.append(count)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.377669095993042}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # Check each position\n    for i in range(5):\n        # If the value at position i is 0, then x_{i+1} was set to 0\n        if x[i] == 0:\n            print(i + 1)\n            return\n    \n    # If no zero is found, check which value doesn't match its expected initial value\n    for i in range(5):\n        if x[i] != i + 1:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.558226346969604}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 53.56785202026367}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "def count_ways(n):\n    # Total parking spaces: 2n - 2\n    total_spaces = 2 * n - 2\n    \n    # We need exactly n successive cars of the same make\n    # The block of n identical cars can start at positions 0 through (total_spaces - n)\n    # For each starting position, we have:\n    # 1. Choose which make for the n-block: 4 choices\n    # 2. For the remaining (total_spaces - n) spaces, each can be any of the 3 other makes\n    #    (since we can't have another n-block of the same make adjacent? Actually careful)\n    \n    # But wait: The problem says \"exactly n successive cars of the same make\"\n    # This means there should be exactly one contiguous block of length n with all same make\n    # The rest should not contain any block of n same make\n    \n    # However, looking at the example for n=3:\n    # total_spaces = 4\n    # The listed configurations all have exactly 3 consecutive same make\n    # Let's analyze: For n=3, total_spaces=4\n    # Possible patterns: XXXX where exactly 3 consecutive are same\n    # That means patterns like: AAAB, AAAA is invalid (has 4 consecutive), ABBB, etc.\n    \n    # Let's think systematically:\n    # Let the block of n identical cars be at positions [i, i+n-1]\n    # The remaining spaces are divided into left part (length i) and right part (length total_spaces - i - n)\n    # In those parts, we must ensure no block of n consecutive same make appears\n    # But since each part has length < n (because total_spaces = 2n-2, so max part length is n-2),\n    # it's impossible to have n consecutive same make in the parts!\n    \n    # So the only constraint is that the cars adjacent to the n-block must be different from the block's make\n    # to avoid extending the block to n+1\n    \n    # Let's verify with n=3, total_spaces=4:\n    # If block is at positions 0-2: pattern is XXXY\n    # Y must be different from X: 3 choices\n    # X has 4 choices for make\n    # So 4 * 3 = 12\n    # \n    # If block is at positions 1-3: pattern is YXXX\n    # Similarly: 4 * 3 = 12\n    # Total: 24  matches example\n    \n    # For general n:\n    # Case 1: Block at the beginning (positions 0 to n-1)\n    # Pattern: X...X Y (n X's followed by 1 car)\n    # The (n+1)th car must be different from X: 3 choices\n    # X has 4 choices\n    # Remaining spaces after position n: total_spaces - n - 1 = (2n-2) - n - 1 = n-3\n    # Those can be any of 4 makes? Wait, careful\n    \n    # Actually for total_spaces = 2n-2:\n    # If block is at beginning: positions 0 to n-1 are X\n    # Position n must be different from X (3 choices)\n    # Positions n+1 to 2n-3 (total n-3 positions) can be any of 4 makes\n    # But we must ensure no n-block forms starting in these positions\n    # Since the only possible n-block would need to include some of the initial X's,\n    # and position n is different from X, it's safe\n    \n    # Similarly for block at the end\n    # And for block in the middle\n    \n    # Let's derive general formula:\n    total_spaces = 2 * n - 2\n    count = 0\n    \n    # For each possible starting position i of the n-block (0 <= i <= total_spaces - n)\n    for i in range(total_spaces - n + 1):\n        # Choose make for the n-block: 4 choices\n        ways = 4\n        \n        # Left constraint: if i > 0, position i-1 must be different from block make\n        if i > 0:\n            ways *= 3  # 3 choices for different make\n        \n        # Right constraint: if i + n < total_spaces, position i+n must be different from block make\n        if i + n < total_spaces:\n            ways *= 3\n        \n        # For remaining positions (excluding the n-block and its immediate neighbors if constrained),\n        # they can be any of 4 makes\n        # Number of remaining positions:\n        remaining = total_spaces - n\n        if i > 0:\n            remaining -= 1  # left neighbor already counted\n        if i + n < total_spaces:\n            remaining -= 1  # right neighbor already counted\n        \n        ways *= (4 ** remaining)\n        \n        count += ways\n    \n    return count\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(count_ways(n))", "complexity_estimate": null, "runtime_sec": 176.74260187149048}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.27309107780457}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.32827997207642}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.23295307159424}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 130.23383593559265}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    a.sort()\n    \n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    total = 0\n    for i in range(N):\n        # Number of ways to choose K-1 smaller keys from i keys\n        ways = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + a[i] * ways) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.77148699760437}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Track rows and columns that have strawberries\n    row_has_strawberry = [False] * r\n    col_has_strawberry = [False] * c\n    \n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                row_has_strawberry[i] = True\n                col_has_strawberry[j] = True\n    \n    # Count rows without strawberries\n    safe_rows = 0\n    for i in range(r):\n        if not row_has_strawberry[i]:\n            safe_rows += 1\n    \n    # Count columns without strawberries\n    safe_cols = 0\n    for j in range(c):\n        if not col_has_strawberry[j]:\n            safe_cols += 1\n    \n    # Calculate maximum cells that can be eaten\n    # All cells in safe rows + all cells in safe columns\n    # But subtract overlap (cells counted twice)\n    max_cells = safe_rows * c + safe_cols * r - safe_rows * safe_cols\n    \n    # However, we must ensure we don't count cells with strawberries\n    # The formula already accounts for this because safe rows/cols have no strawberries\n    \n    print(max_cells)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.714818954467773}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "complexity_estimate": null, "runtime_sec": 8.024515151977539}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach: at each position, try to put the largest possible digit\n    # while ensuring we can complete exactly k swaps\n    for i in range(length):\n        if k <= 0:\n            break\n        # Find the largest digit from i+1 to end\n        max_idx = i\n        for j in range(i+1, length):\n            if n[j] > n[max_idx]:\n                max_idx = j\n        # If the largest digit is already at position i, continue\n        if max_idx == i:\n            continue\n        # Check if swapping with this digit is beneficial\n        # We need to ensure we don't create leading zero\n        if i == 0 and n[max_idx] == '0':\n            # Can't swap leading position with '0'\n            continue\n        # Perform the swap\n        n[i], n[max_idx] = n[max_idx], n[i]\n        k -= 1\n    \n    # If we have swaps left (k > 0), we might need to use them\n    # If k is odd and length >= 2, we can swap two identical digits if they exist\n    # or swap the last two digits if they're different\n    if k > 0 and length >= 2:\n        # Check if there are duplicate digits\n        has_duplicate = len(set(n)) < length\n        if has_duplicate:\n            # If duplicates exist, we can waste swaps by swapping identical digits\n            # This doesn't change the number but consumes swaps\n            pass  # Number remains the same\n        else:\n            # If no duplicates and k is odd, swap last two digits to consume last swap\n            if k % 2 == 1:\n                n[-1], n[-2] = n[-2], n[-1]\n    \n    print(''.join(n))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 66.09661269187927}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "AttributeError(\"'list' object has no attribute 'encode'\")", "runtime_sec": 23.664609670639038}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return -1\n    N = int(data[0])\n    a = [0] * (N + 1)\n    for i in range(1, N + 1):\n        a[i] = int(data[i])\n    \n    visited = [False] * (N + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.426356077194214}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 102.82420587539673}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic(a, n, d):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    # Sum = n/2 * (2a + (n-1)d)\n    n_mod = n % MOD\n    a_mod = a % MOD\n    d_mod = d % MOD\n    \n    # Calculate using modular arithmetic\n    term1 = (2 * a_mod) % MOD\n    term2 = ((n_mod - 1 + MOD) % MOD) * d_mod % MOD\n    sum_val = (term1 + term2) % MOD\n    sum_val = sum_val * n_mod % MOD\n    \n    # Multiply by modular inverse of 2\n    inv2 = (MOD + 1) // 2  # Since MOD is prime and 2 is invertible\n    return sum_val * inv2 % MOD\n\ndef get_stage_info(k):\n    \"\"\"Return (stage_number, numbers_in_stage, start_pos, set_type) for position k.\"\"\"\n    # Stage i has 2^(i-1) numbers (i starts from 1)\n    # Cumulative numbers up to stage i: 2^i - 1\n    \n    # Binary search for stage\n    low, high = 1, 61  # 2^60 > 10^18\n    while low < high:\n        mid = (low + high) // 2\n        if (1 << mid) - 1 >= k:\n            high = mid\n        else:\n            low = mid + 1\n    \n    stage = low\n    numbers_in_stage = 1 << (stage - 1)\n    start_pos = (1 << (stage - 1)) - 1  # Cumulative before this stage\n    \n    # Set type: odd for odd stages, even for even stages\n    set_type = 'odd' if stage % 2 == 1 else 'even'\n    \n    return stage, numbers_in_stage, start_pos, set_type\n\ndef sum_to_position(k):\n    \"\"\"Return sum of first k numbers modulo MOD.\"\"\"\n    if k == 0:\n        return 0\n    \n    stage, numbers_in_stage, start_pos, set_type = get_stage_info(k)\n    pos_in_stage = k - start_pos\n    \n    # Calculate sum up to previous stage\n    total = 0\n    if stage > 1:\n        # Sum of complete previous stages\n        prev_stage = stage - 1\n        # For each complete stage i:\n        # Numbers count: 2^(i-1)\n        # If odd stage: numbers are consecutive odds starting from some value\n        # If even stage: numbers are consecutive evens starting from some value\n        \n        # We can calculate directly using arithmetic series sums\n        odd_sum = 0\n        even_sum = 0\n        \n        # Calculate starting values for each set\n        odd_start = 1\n        even_start = 2\n        \n        for i in range(1, stage):\n            count = 1 << (i - 1)\n            if i % 2 == 1:  # Odd stage\n                odd_sum = (odd_sum + sum_arithmetic(odd_start, count, 2)) % MOD\n                odd_start += 2 * count\n            else:  # Even stage\n                even_sum = (even_sum + sum_arithmetic(even_start, count, 2)) % MOD\n                even_start += 2 * count\n        \n        total = (odd_sum + even_sum) % MOD\n    \n    # Add partial sum from current stage\n    if set_type == 'odd':\n        # Find starting odd number for this stage\n        # Count how many odd numbers have been used in previous odd stages\n        odd_count_before = 0\n        for i in range(1, stage, 2):  # Odd stages before current\n            odd_count_before += 1 << (i - 1)\n        start_odd = 1 + 2 * odd_count_before\n        total = (total + sum_arithmetic(start_odd, pos_in_stage, 2)) % MOD\n    else:  # even\n        # Find starting even number for this stage\n        even_count_before = 0\n        for i in range(2, stage, 2):  # Even stages before current\n            even_count_before += 1 << (i - 1)\n        start_even = 2 + 2 * even_count_before\n        total = (total + sum_arithmetic(start_even, pos_in_stage, 2)) % MOD\n    \n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    \n    sum_r = sum_to_position(r)\n    sum_l_minus_1 = sum_to_position(l - 1)\n    \n    result = (sum_r - sum_l_minus_1) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 55.33480620384216}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Since coordinates are between 1 and 100, we can brute force all possible meeting points\n    min_stamina = float('inf')\n    \n    # Try all integer coordinates from min(x) to max(x) inclusive\n    for p in range(min(x), max(x)+1):\n        total = 0\n        for xi in x:\n            diff = xi - p\n            total += diff * diff\n        if total < min_stamina:\n            min_stamina = total\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.519957065582275}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.03054594993591}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "from collections import deque\n\ndef bfs_escape(R, C, grid):\n    # Find start and den positions\n    start = den = None\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'D':\n                den = (i, j)\n    \n    # Precompute flood times using BFS\n    flood_time = [[-1] * C for _ in range(R)]\n    q = deque()\n    \n    # Initialize flood sources\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '*':\n                q.append((i, j, 0))\n                flood_time[i][j] = 0\n    \n    # BFS for flood expansion\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while q:\n        x, y, t = q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if flood_time[nx][ny] == -1 and grid[nx][ny] in '.S':  # Flood can spread to empty or start\n                    flood_time[nx][ny] = t + 1\n                    q.append((nx, ny, t + 1))\n    \n    # BFS for escape\n    visited = [[False] * C for _ in range(R)]\n    q = deque()\n    q.append((start[0], start[1], 0))\n    visited[start[0]][start[1]] = True\n    \n    while q:\n        x, y, t = q.popleft()\n        if (x, y) == den:\n            return t\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if not visited[nx][ny] and grid[nx][ny] != 'X':\n                    # Check if position is safe at time t+1\n                    # Den is never flooded (flood_time[den] = -1)\n                    ft = flood_time[nx][ny]\n                    if (ft == -1 or ft > t + 1) and grid[nx][ny] != '*':\n                        visited[nx][ny] = True\n                        q.append((nx, ny, t + 1))\n    \n    return None\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip().splitlines()\n    if not input_data:\n        return\n    \n    R, C = map(int, input_data[0].split())\n    grid = [list(line.strip()) for line in input_data[1:1+R]]\n    \n    result = bfs_escape(R, C, grid)\n    if result is None:\n        print(\"KAKTUS\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 36.9593870639801}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 57.91735005378723}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.26554012298584}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 180.14821410179138}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            xr, yr = yr, xr\n        self.parent[yr] = xr\n        if self.rank[xr] == self.rank[yr]:\n            self.rank[xr] += 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v))\n    \n    edges.sort()\n    \n    dsu = DSU(n)\n    \n    i = 0\n    ans = 0\n    while i < m:\n        j = i\n        while j < m and edges[j][0] == edges[i][0]:\n            j += 1\n        \n        same_weight_edges = edges[i:j]\n        \n        # Count how many edges in this weight group connect different components\n        # in the current MST forest (before processing this weight)\n        count = 0\n        for w, u, v in same_weight_edges:\n            if dsu.find(u) != dsu.find(v):\n                count += 1\n        \n        # Now actually union the edges that can be added to MST\n        for w, u, v in same_weight_edges:\n            if dsu.union(u, v):\n                count -= 1\n        \n        # The remaining 'count' edges are redundant for MST but have same weight\n        # They cause non-uniqueness. We need to increase weight of one edge\n        # from each such pair to break ties.\n        ans += count\n        \n        i = j\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.421650886535645}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.68707609176636}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.42461800575256}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.01504111289978}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.71187496185303}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x1 -= 1; y1 -= 1; x2 -= 1; y2 -= 1\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    if grid[x1][y1] == '@' or grid[x2][y2] == '@':\n        print(-1)\n        return\n    \n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # BFS with direction optimization\n    dq = deque()\n    dq.append((x1, y1))\n    \n    # Precompute next valid positions in each direction\n    # For each cell, store the next cell in each direction that is blocked or out of bounds\n    # This allows O(1) jumps\n    right_next = [[W] * W for _ in range(H)]\n    left_next = [[-1] * W for _ in range(H)]\n    down_next = [[H] * H for _ in range(W)]\n    up_next = [[-1] * H for _ in range(W)]\n    \n    # Fill right_next and left_next\n    for i in range(H):\n        last_block = W\n        for j in range(W-1, -1, -1):\n            if grid[i][j] == '@':\n                last_block = j\n            right_next[i][j] = last_block\n        last_block = -1\n        for j in range(W):\n            if grid[i][j] == '@':\n                last_block = j\n            left_next[i][j] = last_block\n    \n    # Fill down_next and up_next (transposed for efficiency)\n    for j in range(W):\n        last_block = H\n        for i in range(H-1, -1, -1):\n            if grid[i][j] == '@':\n                last_block = i\n            down_next[j][i] = last_block\n        last_block = -1\n        for i in range(H):\n            if grid[i][j] == '@':\n                last_block = i\n            up_next[j][i] = last_block\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        # Check if we reached target\n        if x == x2 and y == y2:\n            print(current_dist)\n            return\n        \n        # Explore four directions\n        # Right\n        limit = min(y + K, right_next[x][y] - 1)\n        for ny in range(y+1, limit+1):\n            if dist[x][ny] > current_dist + 1:\n                dist[x][ny] = current_dist + 1\n                dq.append((x, ny))\n        \n        # Left\n        limit = max(y - K, left_next[x][y] + 1)\n        for ny in range(y-1, limit-1, -1):\n            if dist[x][ny] > current_dist + 1:\n                dist[x][ny] = current_dist + 1\n                dq.append((x, ny))\n        \n        # Down\n        limit = min(x + K, down_next[y][x] - 1)\n        for nx in range(x+1, limit+1):\n            if dist[nx][y] > current_dist + 1:\n                dist[nx][y] = current_dist + 1\n                dq.append((nx, y))\n        \n        # Up\n        limit = max(x - K, up_next[y][x] + 1)\n        for nx in range(x-1, limit-1, -1):\n            if dist[nx][y] > current_dist + 1:\n                dist[nx][y] = current_dist + 1\n                dq.append((nx, y))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.21034216880798}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.70015811920166}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        a = int(next(it))\n        op = next(it)\n        b = int(next(it))\n        if op == '=':\n            dsu.union(a, b)\n        else:  # '>'\n            edges.append((a, b))\n    \n    # Build graph with DSU representatives\n    adj = [[] for _ in range(N)]\n    indeg = [0] * N\n    \n    for a, b in edges:\n        ra = dsu.find(a)\n        rb = dsu.find(b)\n        if ra == rb:\n            print(\"inconsistent\")\n            return\n        adj[ra].append(rb)\n        indeg[rb] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    q = deque([i for i in range(N) if indeg[i] == 0 and dsu.find(i) == i])\n    processed = 0\n    \n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    # Check if all DSU representatives were processed\n    total_reps = sum(1 for i in range(N) if dsu.find(i) == i)\n    if processed == total_reps:\n        print(\"consistent\")\n    else:\n        print(\"inconsistent\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 30.773318767547607}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    s = list(data[2])\n    idx = 3\n    for _ in range(m):\n        l = int(data[idx]) - 1\n        r = int(data[idx + 1]) - 1\n        c1 = data[idx + 2]\n        c2 = data[idx + 3]\n        idx += 4\n        for i in range(l, r + 1):\n            if s[i] == c1:\n                s[i] = c2\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.73056697845459}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_k_periodic(s, k):\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    # First substring\n    prev = s[:k]\n    \n    # Check each subsequent substring\n    for i in range(k, n, k):\n        curr = s[i:i+k]\n        # Check if curr is right-rotation of prev\n        if curr != prev[-1] + prev[:-1]:\n            return False\n        prev = curr\n    \n    return True\n\ndef main():\n    s = input().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if is_k_periodic(s, k):\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.343905925750732}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.3856291770935}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef fenwick_add(tree, idx, delta, n):\n    \"\"\"Add delta to element at index idx (0-based).\"\"\"\n    i = idx + 1  # convert to 1-based for Fenwick tree\n    while i <= n:\n        tree[i] += delta\n        i += i & -i\n\ndef fenwick_sum(tree, idx):\n    \"\"\"Return sum of elements from index 0 to idx-1 (0-based).\"\"\"\n    if idx <= 0:\n        return 0\n    s = 0\n    i = idx  # idx is already 1-based for prefix sum\n    while i > 0:\n        s += tree[i]\n        i -= i & -i\n    return s\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n    \n    # Fenwick tree (1-indexed array of size N+1)\n    tree = [0] * (N + 1)\n    \n    out_lines = []\n    for _ in range(Q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            fenwick_add(tree, i, delta, N)\n        else:  # op == '?'\n            i = int(next(it))\n            result = fenwick_sum(tree, i)  # i is the prefix length\n            out_lines.append(str(result))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.591120958328247}

{"eval_index": 0, "problem_id": 3579, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.5841805934906}
{"eval_index": 1, "problem_id": 4070, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.32746911048889}
{"eval_index": 2, "problem_id": 791, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # Convert string to list of integers for easier manipulation\n    bits = [int(c) for c in s]\n    \n    # Simulate adding 1 with carry\n    carry = 1\n    changed = 0\n    \n    for i in range(n):\n        if carry == 0:\n            break\n        current_bit = bits[i]\n        new_bit = (current_bit + carry) % 2\n        if new_bit != current_bit:\n            changed += 1\n        carry = (current_bit + carry) // 2\n    \n    # If carry is still 1 after processing all bits, it means overflow\n    # In this case, all bits that were 1 become 0 (they changed)\n    # But actually, according to problem: \"if some of the most significant bits of the resulting number do not fit into the cell, they must be discarded\"\n    # So we don't need to handle overflow beyond the cell\n    \n    print(changed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.840429306030273}
{"eval_index": 3, "problem_id": 3788, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.40123319625854}
{"eval_index": 4, "problem_id": 4539, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_harshad_number(N):\n    \"\"\"Return 'Yes' if N is divisible by sum of its digits, else 'No'.\"\"\"\n    digit_sum = sum(int(d) for d in str(N))\n    return \"Yes\" if N % digit_sum == 0 else \"No\"\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(is_harshad_number(N))", "complexity_estimate": null, "runtime_sec": 13.237334489822388}
{"eval_index": 5, "problem_id": 13, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.35442805290222}
{"eval_index": 6, "problem_id": 3349, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nVOWELS = set('AEIOU')\n\ndef count_vowels(word):\n    \"\"\"Count vowels in a word.\"\"\"\n    return sum(1 for ch in word if ch in VOWELS)\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    dictionary = data[1:1+n]\n    message = data[1+n]\n    \n    # Preprocess dictionary: map consonant-only version to list of (word, vowel_count)\n    word_map = {}\n    for word in dictionary:\n        consonant_only = ''.join(ch for ch in word if ch not in VOWELS)\n        if consonant_only not in word_map:\n            word_map[consonant_only] = []\n        word_map[consonant_only].append((word, count_vowels(word)))\n    \n    # Sort each list by vowel count descending for tie-breaking\n    for key in word_map:\n        word_map[key].sort(key=lambda x: -x[1])\n    \n    # DP: dp[i] = (max_vowels, prev_index, word_index) for prefix ending at i\n    m = len(message)\n    dp = [(-1, -1, -1) for _ in range(m+1)]\n    dp[0] = (0, -1, -1)  # Base case: empty prefix\n    \n    for i in range(m):\n        if dp[i][0] == -1:\n            continue  # Unreachable position\n        \n        # Try all possible words starting at position i\n        for length in range(1, min(m-i, 1000)+1):  # Max word length from constraints\n            segment = message[i:i+length]\n            if segment in word_map:\n                # Use the word with highest vowel count first\n                word, vowel_count = word_map[segment][0]\n                new_vowels = dp[i][0] + vowel_count\n                if new_vowels > dp[i+length][0]:\n                    dp[i+length] = (new_vowels, i, word)\n    \n    # Reconstruct solution\n    result = []\n    pos = m\n    while pos > 0:\n        _, prev_pos, word = dp[pos]\n        result.append(word)\n        pos = prev_pos\n    \n    result.reverse()\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 31.92029333114624}
{"eval_index": 7, "problem_id": 4887, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 41.1488938331604}
{"eval_index": 8, "problem_id": 2406, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 72.74591135978699}
{"eval_index": 9, "problem_id": 3868, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    flights = []\n    for _ in range(m):\n        d = int(data[idx]); idx += 1\n        f = int(data[idx]); idx += 1\n        t = int(data[idx]); idx += 1\n        c = int(data[idx]); idx += 1\n        flights.append((d, f, t, c))\n    \n    flights.sort()\n    \n    INF = 10**18\n    \n    # Precompute earliest arrival costs for each city\n    earliest_arrival = [INF] * (n + 1)\n    arrival_cost = [INF] * (n + 1)\n    \n    # Forward pass: compute prefix min cost to arrive by day d\n    prefix_arrival = [INF] * (m + 1)\n    curr_arrival_cost = INF * n\n    flight_idx = 0\n    \n    arrival_day_cost = {}\n    \n    for i in range(1, m + 1):\n        d, f, t, c = flights[i-1]\n        if t == 0:  # flight to Metropolis\n            city = f\n            if earliest_arrival[city] == INF:\n                earliest_arrival[city] = d\n                arrival_cost[city] = c\n                curr_arrival_cost += c - INF\n            elif c < arrival_cost[city]:\n                curr_arrival_cost += c - arrival_cost[city]\n                arrival_cost[city] = c\n        \n        # Store the minimal cost to have all n people in Metropolis by day d\n        if earliest_arrival.count(INF) == 1:  # all cities have flights\n            prefix_arrival[i] = curr_arrival_cost\n        arrival_day_cost[d] = prefix_arrival[i]\n    \n    # Backward pass: compute suffix min cost to depart after day d\n    latest_departure = [0] * (n + 1)\n    departure_cost = [INF] * (n + 1)\n    \n    suffix_departure = [INF] * (m + 2)\n    curr_departure_cost = INF * n\n    \n    departure_day_cost = {}\n    \n    for i in range(m, 0, -1):\n        d, f, t, c = flights[i-1]\n        if f == 0:  # flight from Metropolis\n            city = t\n            if latest_departure[city] == 0:\n                latest_departure[city] = d\n                departure_cost[city] = c\n                curr_departure_cost += c - INF\n            elif c < departure_cost[city]:\n                curr_departure_cost += c - departure_cost[city]\n                departure_cost[city] = c\n        \n        # Store the minimal cost to send all n people back after day d\n        if latest_departure.count(0) == 1:  # all cities have return flights\n            suffix_departure[i] = curr_departure_cost\n        departure_day_cost[d] = suffix_departure[i]\n    \n    # Find minimal total cost where arrival day + k < departure day\n    min_cost = INF\n    \n    # Convert day costs to arrays for binary search\n    arrival_days = sorted(arrival_day_cost.keys())\n    departure_days = sorted(departure_day_cost.keys())\n    \n    # For each possible arrival day, find earliest departure day > arrival_day + k\n    for arr_day in arrival_days:\n        arr_cost = arrival_day_cost[arr_day]\n        if arr_cost >= INF:\n            continue\n        \n        # Binary search for departure day > arr_day + k\n        target_day = arr_day + k + 1\n        left, right = 0, len(departure_days) - 1\n        dep_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if departure_days[mid] >= target_day:\n                dep_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        if dep_idx != -1:\n            dep_day = departure_days[dep_idx]\n            dep_cost = departure_day_cost[dep_day]\n            if dep_cost < INF:\n                total_cost = arr_cost + dep_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n    \n    if min_cost >= INF:\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 62.374422550201416}
{"eval_index": 10, "problem_id": 4458, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    p = list(map(int, input().split()))\n    \n    count = 0\n    min_so_far = float('inf')\n    \n    for i in range(n):\n        if p[i] < min_so_far:\n            min_so_far = p[i]\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.409557819366455}
{"eval_index": 11, "problem_id": 2035, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 101.92943525314331}
{"eval_index": 12, "problem_id": 3956, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.9606535434723}
{"eval_index": 13, "problem_id": 4865, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef adjust_time(direction, minutes, hour, minute):\n    \"\"\"Adjust time based on direction and minutes.\"\"\"\n    total_minutes = hour * 60 + minute\n    \n    if direction == 'F':\n        total_minutes += minutes\n    else:  # direction == 'B'\n        total_minutes -= minutes\n    \n    # Handle wrap-around\n    total_minutes %= 24 * 60\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    \n    new_hour = total_minutes // 60\n    new_minute = total_minutes % 60\n    \n    return new_hour, new_minute\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(n):\n        direction = data[idx]\n        minutes = int(data[idx + 1])\n        hour = int(data[idx + 2])\n        minute = int(data[idx + 3])\n        idx += 4\n        \n        new_hour, new_minute = adjust_time(direction, minutes, hour, minute)\n        results.append(f\"{new_hour} {new_minute}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 22.795430660247803}
{"eval_index": 14, "problem_id": 1575, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.6496331691742}
{"eval_index": 15, "problem_id": 3828, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    # Map value to its index for quick lookup\n    pos = [0] * (n + 1)\n    for i, val in enumerate(p):\n        pos[val] = i\n    \n    # Find the longest contiguous increasing subsequence in the permutation\n    # that appears in order in the array\n    longest = 1\n    current = 1\n    for val in range(2, n + 1):\n        if pos[val] > pos[val - 1]:\n            current += 1\n            longest = max(longest, current)\n        else:\n            current = 1\n    \n    # Minimum moves = n - longest\n    print(n - longest)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.467432975769043}
{"eval_index": 16, "problem_id": 4176, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Compute LCM\n    lcm_val = A * B // math.gcd(A, B)\n    \n    # Output the result\n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.185081005096436}
{"eval_index": 17, "problem_id": 1536, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 72.1938087940216}
{"eval_index": 18, "problem_id": 3544, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_seat_all(groups, X):\n    \"\"\"Check if all groups can be seated with widest row X.\"\"\"\n    # Create a list of group sizes with their counts\n    group_list = []\n    for size, count in enumerate(groups, start=1):\n        group_list.extend([size] * count)\n    \n    # Sort groups by size descending (largest groups first)\n    group_list.sort(reverse=True)\n    \n    rows_used = 0\n    current_row_seats = X\n    \n    # Try to seat groups\n    while group_list:\n        # Start a new row\n        rows_used += 1\n        seats_available = current_row_seats\n        \n        # Try to fill current row\n        i = 0\n        while i < len(group_list) and seats_available > 0:\n            group_size = group_list[i]\n            \n            # Calculate seats needed for this group\n            # Groups need at least 1 empty seat between them unless at row end\n            seats_needed = group_size\n            if seats_available != current_row_seats:  # Not at row start\n                seats_needed += 1  # Need empty seat before group\n            \n            if seats_needed <= seats_available:\n                # Can seat this group\n                seats_available -= seats_needed\n                group_list.pop(i)\n            else:\n                i += 1\n        \n        # Move to next row (one seat narrower)\n        current_row_seats -= 1\n        if current_row_seats <= 0:\n            break\n    \n    return len(group_list) == 0\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    groups = list(map(int, data[1:1+n]))\n    \n    # Try all possible X from 1 to 12\n    for X in range(1, 13):\n        if can_seat_all(groups[:], X):\n            print(X)\n            return\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 31.251293659210205}
{"eval_index": 19, "problem_id": 4263, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    S = sys.stdin.readline().strip()\n    n = len(S)\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            valid = True\n            for k in range(i, j + 1):\n                if S[k] not in \"ACGT\":\n                    valid = False\n                    break\n            if valid:\n                max_len = max(max_len, j - i + 1)\n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.42408275604248}
{"eval_index": 20, "problem_id": 175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    \n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a %= (2 * b)\n        elif b >= 2 * a:\n            b %= (2 * a)\n        else:\n            break\n    \n    print(f\"{a} {b}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.944404125213623}
{"eval_index": 21, "problem_id": 3433, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\n# Directions: up, down, left, right\nDIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return \"IMPOSSIBLE\"\n    \n    R, C = map(int, data[0].split())\n    maze = data[1:1+R]\n    \n    # Find Joe's starting position and initial fire positions\n    joe_start = None\n    fire_start = []\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'J':\n                joe_start = (i, j)\n            elif maze[i][j] == 'F':\n                fire_start.append((i, j))\n    \n    # BFS for fire spread times\n    fire_time = [[-1] * C for _ in range(R)]\n    fire_queue = deque()\n    for (fi, fj) in fire_start:\n        fire_time[fi][fj] = 0\n        fire_queue.append((fi, fj, 0))\n    \n    while fire_queue:\n        x, y, t = fire_queue.popleft()\n        for dx, dy in DIRS:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if maze[nx][ny] != '#' and fire_time[nx][ny] == -1:\n                    fire_time[nx][ny] = t + 1\n                    fire_queue.append((nx, ny, t + 1))\n    \n    # BFS for Joe's escape\n    joe_visited = [[False] * C for _ in range(R)]\n    joe_queue = deque()\n    jx, jy = joe_start\n    joe_visited[jx][jy] = True\n    joe_queue.append((jx, jy, 0))\n    \n    while joe_queue:\n        x, y, t = joe_queue.popleft()\n        # Check if Joe is at border (can exit)\n        if x == 0 or x == R-1 or y == 0 or y == C-1:\n            return str(t + 1)  # +1 because exiting takes 1 minute\n        \n        for dx, dy in DIRS:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C:\n                if maze[nx][ny] != '#' and not joe_visited[nx][ny]:\n                    # Check if fire reaches this cell at time t+1 or earlier\n                    fire_arrival = fire_time[nx][ny]\n                    if fire_arrival == -1 or fire_arrival > t + 1:\n                        joe_visited[nx][ny] = True\n                        joe_queue.append((nx, ny, t + 1))\n    \n    return \"IMPOSSIBLE\"\n\nif __name__ == \"__main__\":\n    print(solve())", "complexity_estimate": null, "runtime_sec": 39.629074811935425}
{"eval_index": 22, "problem_id": 4737, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    p = int(data[1])\n    times = list(map(int, data[2:2+N]))\n    \n    # Problem p must be solved first\n    first_time = times[p]\n    if first_time > 300:\n        # Cannot solve problem p within contest time\n        print(\"0 0\")\n        return\n    \n    # Remaining problems (excluding problem p)\n    remaining = [times[i] for i in range(N) if i != p]\n    remaining.sort()  # Sort to pick easier problems first\n    \n    total_time = first_time\n    num_ac = 1\n    penalty = first_time\n    \n    for t in remaining:\n        if total_time + t <= 300:\n            total_time += t\n            num_ac += 1\n            penalty += total_time\n        else:\n            break\n    \n    print(f\"{num_ac} {penalty}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.383382081985474}
{"eval_index": 23, "problem_id": 1496, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 1, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 120.17793798446655}
{"eval_index": 24, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.20104956626892}
{"eval_index": 25, "problem_id": 4494, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    S = input().strip()\n    if S == \"ABC\":\n        print(\"ARC\")\n    else:\n        print(\"ABC\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.535149812698364}
{"eval_index": 26, "problem_id": 1513, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 57.306368589401245}
{"eval_index": 27, "problem_id": 3746, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.61600041389465}
{"eval_index": 28, "problem_id": 4338, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, x, y = map(int, data[:3])\n    a = list(map(int, data[3:3+n]))\n    \n    # If x > y, we can break all doors eventually\n    if x > y:\n        print(n)\n        return\n    \n    # Sort the durabilities\n    a.sort()\n    \n    # Count doors that can be broken before Slavik can repair them\n    count = 0\n    for i in range(n):\n        if a[i] <= x:\n            count += 1\n        else:\n            break\n    \n    # We can break at most ceil(count/2) doors\n    # Because Slavik will try to repair one door for every two we break\n    result = (count + 1) // 2\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 80.59935450553894}
{"eval_index": 29, "problem_id": 1113, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Track the maximum possible mex value that could be generated at each step\nmax_possible = 0\n# Track the smallest step where a mistake is detected\nerror_step = -1\n\nfor i in range(n):\n    # At step i+1, the value a[i] must be <= max_possible\n    # because mex of any subset of previous elements cannot exceed max_possible\n    if a[i] > max_possible:\n        error_step = i + 1\n        break\n    \n    # Update max_possible: if a[i] equals current max_possible,\n    # then we can potentially generate max_possible+1 in future steps\n    if a[i] == max_possible:\n        max_possible += 1\n\nprint(error_step)", "complexity_estimate": null, "runtime_sec": 47.00100922584534}
{"eval_index": 30, "problem_id": 3694, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Sort the array\n    a.sort()\n    \n    # Check for initial invalid conditions\n    cnt_dup = 0\n    dup_value = -1\n    for i in range(1, n):\n        if a[i] == a[i-1]:\n            cnt_dup += 1\n            dup_value = a[i]\n    \n    # If there are more than one duplicate pair, CSL wins immediately\n    if cnt_dup > 1:\n        print(\"cslnb\")\n        return\n    \n    # If there's exactly one duplicate pair\n    if cnt_dup == 1:\n        # Check if the duplicate value is 0 - can't reduce from 0\n        if dup_value == 0:\n            print(\"cslnb\")\n            return\n        # Check if there's a[i] = dup_value-1 in the array\n        for i in range(n):\n            if a[i] == dup_value - 1:\n                print(\"cslnb\")\n                return\n        # Also check if there are three equal values (which would be caught by cnt_dup>1)\n        # But we need to handle case like [x,x] where x>0\n        # The move would be to reduce one x to x-1, creating [x-1, x]\n        # This is valid if x-1 doesn't exist elsewhere\n    \n    # Calculate total moves\n    total_moves = 0\n    for i in range(n):\n        if a[i] < i:\n            print(\"cslnb\")\n            return\n        total_moves += a[i] - i\n    \n    # If total_moves is odd, Tokitsukaze wins, else CSL wins\n    if total_moves % 2 == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 37.25801730155945}
{"eval_index": 31, "problem_id": 4785, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    s = input().strip()\n    for i in range(len(s) - 1):\n        if s[i] == 's' and s[i + 1] == 's':\n            print('hiss')\n            return\n    print('no hiss')\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.79934024810791}
{"eval_index": 32, "problem_id": 2158, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.71555542945862}
{"eval_index": 33, "problem_id": 3853, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.67002177238464}
{"eval_index": 34, "problem_id": 4850, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.13155341148376}
{"eval_index": 35, "problem_id": 2706, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 31.04513645172119}
{"eval_index": 36, "problem_id": 3120, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.98401474952698}
{"eval_index": 37, "problem_id": 4388, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    n = input().strip()\n    result = ''\n    for digit in n:\n        if digit == '1':\n            result += '9'\n        elif digit == '9':\n            result += '1'\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.272256851196289}
{"eval_index": 38, "problem_id": 2370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    A = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Check basic conditions\n    for i in range(N):\n        if A[i][i] != 0:\n            print(-1)\n            return\n        for j in range(N):\n            if i != j and A[i][j] != A[j][i]:\n                print(-1)\n                return\n            if i != j and A[i][j] <= 0:\n                print(-1)\n                return\n    \n    # Check triangle inequality and existence of direct road\n    edges = []\n    for i in range(N):\n        for j in range(i+1, N):\n            # Check if A[i][j] could be a direct road\n            valid = True\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if A[i][j] > A[i][k] + A[k][j]:\n                    # Triangle inequality violation\n                    print(-1)\n                    return\n                if A[i][j] == A[i][k] + A[k][j]:\n                    # There exists a shorter path through k, so i-j might not be direct\n                    valid = False\n                    break\n            if valid:\n                edges.append((i, j, A[i][j]))\n    \n    # Build graph with potential direct edges\n    # We need to verify all distances match using these edges\n    INF = 10**18\n    dist = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n    \n    for u, v, w in edges:\n        dist[u][v] = w\n        dist[v][u] = w\n    \n    # Floyd-Warshall to compute shortest paths\n    for k in range(N):\n        for i in range(N):\n            if dist[i][k] == INF:\n                continue\n            for j in range(N):\n                if dist[k][j] == INF:\n                    continue\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    \n    # Verify all distances match\n    for i in range(N):\n        for j in range(N):\n            if dist[i][j] != A[i][j]:\n                print(-1)\n                return\n    \n    # Compute total length\n    total = 0\n    for u, v, w in edges:\n        total += w\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 77.84544825553894}
{"eval_index": 39, "problem_id": 3085, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.70510363578796}
{"eval_index": 40, "problem_id": 4317, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Calculate all three expressions\n    add_result = A + B\n    sub_result = A - B\n    mul_result = A * B\n    \n    # Find the maximum\n    max_value = max(add_result, sub_result, mul_result)\n    \n    # Output the result\n    print(max_value)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.086222648620605}
{"eval_index": 41, "problem_id": 1980, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = int(next(it))\n    \n    d = [0] * (n + 1)\n    c = [0] * (n + 1)\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        d[i] = int(next(it))\n        c[i] = int(next(it))\n        prefix_sum[i] = prefix_sum[i - 1] + (a - c[i])\n    \n    # Precompute squared gaps between consecutive difficulties\n    gap_sq = [0] * (n + 1)\n    for i in range(1, n):\n        diff = d[i + 1] - d[i]\n        gap_sq[i] = diff * diff\n    \n    # Kadane's algorithm with penalty for max gap in segment\n    max_profit = 0\n    current_sum = 0\n    current_start = 1\n    current_max_gap_sq = 0\n    \n    for i in range(1, n + 1):\n        # Start new segment if current_sum becomes negative\n        if current_sum < 0:\n            current_sum = 0\n            current_start = i\n            current_max_gap_sq = 0\n        \n        # Add current element's profit\n        current_sum += (a - c[i])\n        \n        # Update max gap in current segment\n        if i > current_start:\n            current_max_gap_sq = max(current_max_gap_sq, gap_sq[i - 1])\n        \n        # Calculate profit for current segment\n        profit = current_sum - current_max_gap_sq\n        max_profit = max(max_profit, profit)\n    \n    # Also check all possible segments using prefix sums\n    # This handles cases where optimal segment doesn't start at positive prefix\n    for l in range(1, n + 1):\n        max_gap = 0\n        for r in range(l, n + 1):\n            if r > l:\n                max_gap = max(max_gap, gap_sq[r - 1])\n            profit = prefix_sum[r] - prefix_sum[l - 1] - max_gap\n            max_profit = max(max_profit, profit)\n            # Early break if profit can't improve\n            if profit < 0 and max_gap > 0:\n                break\n    \n    print(max_profit)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 119.4164981842041}
{"eval_index": 42, "problem_id": 3050, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 131.27391910552979}
{"eval_index": 43, "problem_id": 4162, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 73.83702278137207}
{"eval_index": 44, "problem_id": 2852, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.32227611541748}
{"eval_index": 45, "problem_id": 3727, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.77676701545715}
{"eval_index": 46, "problem_id": 4839, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.4582679271698}
{"eval_index": 47, "problem_id": 298, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    # Sasha wins if he can make strictly more moves than Lena\n    # Total moves = floor(n / k)\n    # Sasha moves first, so he gets ceil(total_moves / 2) moves\n    # Lena gets floor(total_moves / 2) moves\n    # Sasha wins if his moves > Lena's moves\n    total_moves = n // k\n    sasha_moves = (total_moves + 1) // 2  # ceil division\n    lena_moves = total_moves // 2\n    if sasha_moves > lena_moves:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.412007570266724}
{"eval_index": 48, "problem_id": 3761, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.15940237045288}
{"eval_index": 49, "problem_id": 4894, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.8162693977356}
{"eval_index": 50, "problem_id": 1545, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    a = list(map(int, data[2:2+26]))\n    \n    # Convert letters to indices 0-25\n    s_indices = [ord(ch) - ord('a') for ch in s]\n    \n    # Precompute max allowed length for each starting position\n    max_len_from = [0] * n\n    for i in range(n):\n        min_allowed = float('inf')\n        for j in range(i, n):\n            ch_idx = s_indices[j]\n            min_allowed = min(min_allowed, a[ch_idx])\n            if j - i + 1 > min_allowed:\n                break\n            max_len_from[i] = j - i + 1\n    \n    # DP for number of ways\n    ways = [0] * (n + 1)\n    ways[0] = 1  # empty prefix\n    \n    for i in range(n):\n        if ways[i] == 0:\n            continue\n        max_len = max_len_from[i]\n        for length in range(1, max_len + 1):\n            ways[i + length] = (ways[i + length] + ways[i]) % MOD\n    \n    # DP for minimum number of substrings\n    min_parts = [float('inf')] * (n + 1)\n    min_parts[0] = 0\n    \n    for i in range(n):\n        if min_parts[i] == float('inf'):\n            continue\n        max_len = max_len_from[i]\n        for length in range(1, max_len + 1):\n            min_parts[i + length] = min(min_parts[i + length], min_parts[i] + 1)\n    \n    # Find maximum substring length in any valid splitting\n    max_substring_len = 0\n    for i in range(n):\n        max_substring_len = max(max_substring_len, max_len_from[i])\n    \n    print(ways[n])\n    print(max_substring_len)\n    print(min_parts[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.45621967315674}
{"eval_index": 51, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_make_equal(arr):\n    \"\"\"\n    Check if all numbers can be made equal by repeatedly multiplying by 2 and 3.\n    \n    The key insight is that we can only change numbers by multiplying by 2 and 3,\n    which means we can only change the prime factorization by adding factors of 2 and 3.\n    \n    Therefore, all numbers must have the same \"core\" value when we remove all\n    factors of 2 and 3. After removing these factors, if all numbers are equal,\n    then we can make them equal by adding appropriate factors of 2 and 3.\n    \"\"\"\n    # Function to remove all factors of 2 and 3 from a number\n    def remove_factors(x):\n        while x % 2 == 0:\n            x //= 2\n        while x % 3 == 0:\n            x //= 3\n        return x\n    \n    # Get the core value of the first element\n    first_core = remove_factors(arr[0])\n    \n    # Check if all elements have the same core value\n    for num in arr[1:]:\n        if remove_factors(num) != first_core:\n            return False\n    return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    if can_make_equal(arr):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 30.083174228668213}
{"eval_index": 52, "problem_id": 4547, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    N = sys.stdin.readline().strip()\n    if '9' in N:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.106016159057617}
{"eval_index": 53, "problem_id": 556, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, k = map(int, data[:3])\n    \n    result = []\n    power = 1  # k^0\n    \n    # Handle the case where k=1 separately to avoid infinite loop\n    if k == 1:\n        if l <= 1 <= r:\n            result.append(1)\n    else:\n        while power <= r:\n            if power >= l:\n                result.append(power)\n            # Check for overflow before multiplying\n            if power > r // k:\n                break\n            power *= k\n    \n    if not result:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.339064121246338}
{"eval_index": 54, "problem_id": 3496, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 147.37867665290833}
{"eval_index": 55, "problem_id": 4558, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    t = int(data[1])\n    \n    # The amount remaining is initial minus what has dropped, but not less than 0\n    result = max(0, X - t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.561894416809082}
{"eval_index": 56, "problem_id": 2277, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_inversions(arr):\n    \"\"\"Count inversions using Fenwick tree\"\"\"\n    n = len(arr)\n    bit = [0] * (n + 2)\n    inv_count = 0\n    \n    # Process elements in reverse order\n    for i in range(n - 1, -1, -1):\n        x = arr[i]\n        # Query sum of elements < x\n        idx = x - 1\n        while idx > 0:\n            inv_count += bit[idx]\n            idx -= idx & -idx\n        # Update BIT\n        idx = x\n        while idx <= n:\n            bit[idx] += 1\n            idx += idx & -idx\n    return inv_count\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    queries = [(int(next(it)), int(next(it))) for _ in range(m)]\n    \n    # Initial inversion parity\n    inv_parity = count_inversions(a) % 2\n    \n    out_lines = []\n    for l, r in queries:\n        # Convert to 0-based indexing\n        l -= 1\n        r -= 1\n        length = r - l + 1\n        \n        # Number of pairs reversed within the segment\n        # Each pair (i,j) with i<j becomes (j,i) after reversal\n        # This changes inversion count by: C(length, 2) = length*(length-1)//2\n        # Only parity matters\n        pairs = length * (length - 1) // 2\n        if pairs % 2 == 1:\n            inv_parity ^= 1  # Toggle parity\n        \n        out_lines.append(\"odd\" if inv_parity == 1 else \"even\")\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.543941974639893}
{"eval_index": 57, "problem_id": 3973, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.88531398773193}
{"eval_index": 58, "problem_id": 4068, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    broken = set()\n    for _ in range(M):\n        broken.add(int(input()))\n    \n    # dp[i] = number of ways to reach step i\n    dp = [0] * (N + 1)\n    dp[0] = 1  # starting point\n    \n    for i in range(1, N + 1):\n        if i in broken:\n            dp[i] = 0\n            continue\n        ways = 0\n        if i - 1 >= 0:\n            ways += dp[i - 1]\n        if i - 2 >= 0:\n            ways += dp[i - 2]\n        dp[i] = ways % MOD\n    \n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.72213625907898}
{"eval_index": 59, "problem_id": 2424, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 998244353\n\n# Function to compute modular inverse using Fermat's Little Theorem\ndef mod_inv(x, mod=MOD):\n    return pow(x, mod-2, mod)\n\n# Read input\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    \n    # Lists to store k_i and items\n    k_list = []\n    items = []\n    total_items = 0\n    \n    # Count frequency of each item across all kids\n    freq = {}\n    \n    for i in range(n):\n        k_i = int(next(it))\n        k_list.append(k_i)\n        total_items += k_i\n        kid_items = []\n        for _ in range(k_i):\n            item = int(next(it))\n            kid_items.append(item)\n            freq[item] = freq.get(item, 0) + 1\n        items.append(kid_items)\n    \n    # Compute probability\n    # P(valid) = sum over all kids i of (1/n) * (1/k_i) * (freq[y]/n) for each item y in kid i's list\n    # = (1/n^2) * sum_i (1/k_i) * sum_{y in items_i} freq[y]\n    \n    numerator = 0\n    for i in range(n):\n        k_i = k_list[i]\n        if k_i == 0:\n            continue\n        sum_freq = 0\n        for item in items[i]:\n            sum_freq += freq[item]\n        # Add (1/k_i) * sum_freq\n        numerator += sum_freq * mod_inv(k_i, MOD)\n        numerator %= MOD\n    \n    # Multiply by 1/n^2\n    inv_n = mod_inv(n, MOD)\n    inv_n2 = (inv_n * inv_n) % MOD\n    result = (numerator * inv_n2) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.952235221862793}
{"eval_index": 60, "problem_id": 3711, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 1, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 130.20372009277344}
{"eval_index": 61, "problem_id": 4345, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.54106283187866}
{"eval_index": 62, "problem_id": 541, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    \n    # We'll store the rightmost endpoint for each request\n    # For each request (a, b), we need to ensure no bridge connects a to b\n    # This is equivalent to ensuring that for any bridge between i and i+1,\n    # there is no request where a <= i < b\n    # So we need to find bridges that are covered by at least one request interval\n    # and remove them. But we want minimum removals.\n    # This becomes: find the maximum number of bridges we can keep such that\n    # no kept bridge is covered by any request interval.\n    # Actually, think differently: each request (a, b) means we must break\n    # all paths between a and b. Since islands are in a line, the path between\n    # a and b is the consecutive bridges from a to b-1.\n    # To break the path, we need to remove at least one bridge in [a, b-1].\n    # Multiple requests may overlap. We want to remove minimum bridges\n    # such that each request interval has at least one removed bridge.\n    # This is classic interval covering problem: sort requests by right endpoint,\n    # and greedily remove the bridge at the rightmost possible position\n    # (i.e., at b-1) when needed.\n    \n    requests = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        # Convert to bridge indices: bridges are between i and i+1, indexed 1..N-1\n        # Request (a, b) affects bridges from a to b-1\n        requests.append((a, b-1))  # left and right bridge indices\n    \n    # Sort requests by their right endpoint (b-1)\n    requests.sort(key=lambda x: x[1])\n    \n    removed_count = 0\n    last_removed = 0  # track the rightmost bridge we removed\n    \n    for left, right in requests:\n        # If the last removed bridge is within [left, right], then this request is already satisfied\n        if last_removed >= left and last_removed <= right:\n            continue\n        # Otherwise, we need to remove a bridge in [left, right]\n        # Greedily remove the rightmost one (at position 'right') to cover as many future requests as possible\n        removed_count += 1\n        last_removed = right\n    \n    print(removed_count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 66.43510031700134}
{"eval_index": 63, "problem_id": 3751, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def can_be_obfuscated(s):\n    \"\"\"Check if string s can be result of Kostya's obfuscation.\"\"\"\n    seen = set()\n    next_char = 'a'\n    \n    for ch in s:\n        if ch not in seen:\n            # New identifier must be mapped to next available letter\n            if ch != next_char:\n                return False\n            seen.add(ch)\n            next_char = chr(ord(next_char) + 1)\n        else:\n            # Already seen identifier must follow mapping rules\n            # All occurrences of same identifier must have same character\n            # This is automatically true since we're checking character equality\n            pass\n    \n    # Check that mapping follows alphabetical order without gaps\n    # The seen characters should be exactly 'a', 'b', 'c', ... up to some letter\n    if seen:\n        expected = set(chr(ord('a') + i) for i in range(len(seen)))\n        if seen != expected:\n            return False\n    \n    return True\n\n# Read input and solve\nimport sys\ndef main():\n    s = sys.stdin.readline().strip()\n    if can_be_obfuscated(s):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.91563606262207}
{"eval_index": 64, "problem_id": 4540, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = [0] + list(map(int, data[1:1+N]))  # 1-indexed for easier reasoning\n    \n    # Precompute prefix and suffix distances\n    prefix = [0] * (N + 2)  # prefix[i] = cost from 0 to A[i] via all spots up to i-1\n    suffix = [0] * (N + 2)  # suffix[i] = cost from A[i] to 0 via all spots from i+1 to N\n    \n    # Compute prefix: travel from 0 to A[1], then A[1] to A[2], ..., A[i-1] to A[i]\n    prefix[1] = abs(A[1] - 0)\n    for i in range(2, N + 1):\n        prefix[i] = prefix[i-1] + abs(A[i] - A[i-1])\n    \n    # Compute suffix: travel from A[i] to A[i+1], ..., A[N-1] to A[N], then A[N] to 0\n    suffix[N] = abs(0 - A[N])\n    for i in range(N-1, 0, -1):\n        suffix[i] = suffix[i+1] + abs(A[i+1] - A[i])\n    \n    # For each i, total cost = prefix[i-1] + suffix[i+1] + direct cost between neighbors of i\n    results = []\n    for i in range(1, N + 1):\n        if i == 1:\n            # Skip first spot: go from 0 to A[2], then continue normally, then back to 0\n            cost = abs(0 - A[2]) + suffix[2] if N > 1 else abs(0 - 0)\n        elif i == N:\n            # Skip last spot: go from 0 to A[1], then continue normally, then from A[N-1] to 0\n            cost = prefix[N-1] + abs(A[N-1] - 0)\n        else:\n            # Skip middle spot: connect A[i-1] directly to A[i+1]\n            cost = prefix[i-1] + abs(A[i+1] - A[i-1]) + suffix[i+1]\n        results.append(str(cost))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 61.955267667770386}
{"eval_index": 65, "problem_id": 1425, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.33791828155518}
{"eval_index": 66, "problem_id": 3918, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k1 = int(next(it))\n    k2 = int(next(it))\n    \n    A = [int(next(it)) for _ in range(n)]\n    B = [int(next(it)) for _ in range(n)]\n    \n    # Calculate initial absolute differences\n    diff = [abs(A[i] - B[i]) for i in range(n)]\n    \n    # Total operations available\n    total_ops = k1 + k2\n    \n    # Greedy approach: reduce largest differences first\n    # We can use a max-heap or sort and process\n    diff.sort(reverse=True)\n    \n    # Process operations\n    for i in range(total_ops):\n        if diff[0] == 0:\n            # If largest difference is 0, we can only increase it\n            # But we need to use operations, so we increase any difference\n            # The optimal is to increase the smallest non-zero or any to 1\n            # Since all are 0, we create a difference of 1\n            diff[0] = 1\n        else:\n            diff[0] -= 1\n        # Re-sort to maintain max at front (simple bubble-down for efficiency)\n        # For n <= 1000 and total_ops <= 1000, O(n * total_ops) is acceptable\n        j = 0\n        while j + 1 < n and diff[j] < diff[j + 1]:\n            diff[j], diff[j + 1] = diff[j + 1], diff[j]\n            j += 1\n    \n    # Calculate final error\n    error = sum(d * d for d in diff)\n    print(error)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 93.43995523452759}
{"eval_index": 67, "problem_id": 4511, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.76608562469482}
{"eval_index": 68, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.15143966674805}
{"eval_index": 69, "problem_id": 3307, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.2346794605255}
{"eval_index": 70, "problem_id": 4435, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Convert to 0-based indexing\n    a = [x for x in a]\n    \n    # Initialize answer array with -1\n    ans = [-1] * n\n    \n    # BFS from all positions with same parity\n    # We'll do two BFS: one starting from all even positions, one from all odd positions\n    \n    # Adjacency list for the graph\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        # Jump to i - a[i]\n        if i - a[i] >= 0:\n            adj[i - a[i]].append(i)\n        # Jump to i + a[i]\n        if i + a[i] < n:\n            adj[i + a[i]].append(i)\n    \n    # BFS from all positions with parity p to find distances to positions with opposite parity\n    def bfs(parity):\n        dist = [-1] * n\n        q = deque()\n        \n        # Initialize queue with all positions having the given parity\n        for i in range(n):\n            if a[i] % 2 == parity:\n                dist[i] = 0\n                q.append(i)\n        \n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        \n        return dist\n    \n    # Get distances from even positions to odd positions\n    dist_even_to_odd = bfs(0)  # 0 for even\n    # Get distances from odd positions to even positions\n    dist_odd_to_even = bfs(1)  # 1 for odd\n    \n    # Build answer\n    for i in range(n):\n        if a[i] % 2 == 0:  # even\n            ans[i] = dist_odd_to_even[i]\n        else:  # odd\n            ans[i] = dist_even_to_odd[i]\n    \n    print(' '.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 92.06782102584839}
{"eval_index": 71, "problem_id": 40, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    ratings = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx]); b = int(data[idx+1])\n        ratings.append((a, b))\n        idx += 2\n    \n    # Check if any rating changed\n    any_change = any(a != b for a, b in ratings)\n    \n    # Check if standings are sorted by rating (non-increasing)\n    sorted_by_rating = all(ratings[i][0] >= ratings[i+1][0] for i in range(n-1))\n    \n    if any_change:\n        print(\"rated\")\n    elif not sorted_by_rating:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.08793067932129}
{"eval_index": 72, "problem_id": 3872, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef is_equivalent(s1, s2):\n    \"\"\"Recursively check if two strings are equivalent according to the problem definition.\"\"\"\n    # Base case: if strings are equal, they're equivalent\n    if s1 == s2:\n        return True\n    \n    # If length is odd, they can't be split into equal halves\n    # According to problem, strings have same length, so just check one\n    n = len(s1)\n    if n % 2 == 1:\n        return False\n    \n    # Split into halves\n    mid = n // 2\n    s1_left, s1_right = s1[:mid], s1[mid:]\n    s2_left, s2_right = s2[:mid], s2[mid:]\n    \n    # Check both possible cases:\n    # Case 1: s1_left equivalent to s2_left AND s1_right equivalent to s2_right\n    # Case 2: s1_left equivalent to s2_right AND s1_right equivalent to s2_left\n    return (is_equivalent(s1_left, s2_left) and is_equivalent(s1_right, s2_right)) or \\\n           (is_equivalent(s1_left, s2_right) and is_equivalent(s1_right, s2_left))\n\ndef main():\n    # Read input\n    s1 = sys.stdin.readline().strip()\n    s2 = sys.stdin.readline().strip()\n    \n    # Check equivalence\n    result = is_equivalent(s1, s2)\n    \n    # Output result\n    print(\"YES\" if result else \"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.20996117591858}
{"eval_index": 73, "problem_id": 4495, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef count_divisible(a: int, b: int, x: int) -> int:\n    \"\"\"Return count of integers in [a, b] divisible by x.\"\"\"\n    # Count multiples of x up to b\n    count_up_to_b = b // x\n    # Count multiples of x up to (a-1)\n    count_up_to_a_minus_1 = (a - 1) // x if a > 0 else -1\n    # Adjust for a=0 case\n    if a == 0:\n        count_up_to_a_minus_1 = -1  # Ensures 0 is included when a=0\n    # Result is count up to b minus count up to (a-1)\n    return count_up_to_b - count_up_to_a_minus_1\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, x = map(int, data)\n    result = count_divisible(a, b, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 37.92605805397034}
{"eval_index": 74, "problem_id": 625, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef f(n):\n    \"\"\"Calculate f(n) = -1 + 2 - 3 + ... + (-1)^n * n\"\"\"\n    # For even n: pairs (-1+2) + (-3+4) + ... = n/2\n    # For odd n: even part + last term = (n-1)/2 - n = -(n+1)/2\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return -(n + 1) // 2\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = f(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.04985737800598}
{"eval_index": 75, "problem_id": 3887, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.22062873840332}
{"eval_index": 76, "problem_id": 4534, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 19.520646810531616}
{"eval_index": 77, "problem_id": 391, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 79.50596809387207}
{"eval_index": 78, "problem_id": 3372, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    s = int(next(it))\n    t = int(next(it))\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N)]\n    \n    for u in range(N):\n        typ = next(it)\n        m = int(next(it))\n        if typ == 'N':\n            # Direct list of destinations\n            for _ in range(m):\n                v = int(next(it))\n                adj[u].append(v)\n        else:  # typ == 'C'\n            # Complement: all airports except those listed\n            excluded = set()\n            for _ in range(m):\n                v = int(next(it))\n                excluded.add(v)\n            # Add all airports not in excluded\n            for v in range(N):\n                if v != u and v not in excluded:\n                    adj[u].append(v)\n    \n    # BFS to find shortest path\n    if s == t:\n        print(0)\n        return\n    \n    dist = [-1] * N\n    dist[s] = 0\n    q = deque([s])\n    \n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                if v == t:\n                    print(dist[v])\n                    return\n                q.append(v)\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.900468349456787}
{"eval_index": 79, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    N = int(input().strip())\n    ans = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        ans += max_b\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.50218391418457}
{"eval_index": 80, "problem_id": 551, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.03255009651184}
{"eval_index": 81, "problem_id": 3101, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 95.34819555282593}
{"eval_index": 82, "problem_id": 4621, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    H = int(data[0])\n    W = int(data[1])\n    \n    # Read the original image\n    original_image = data[2:2 + H]\n    \n    # Extend vertically by repeating each row\n    extended_image = []\n    for row in original_image:\n        extended_image.append(row)\n        extended_image.append(row)\n    \n    # Output the extended image\n    for row in extended_image:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.353198051452637}
{"eval_index": 83, "problem_id": 2846, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef h_index(citations):\n    \"\"\"\n    Calculate H-index given a list of citation counts.\n    \n    Args:\n        citations: List of integers representing citation counts for each paper\n    \n    Returns:\n        Integer representing the H-index\n    \"\"\"\n    n = len(citations)\n    \n    # Sort citations in descending order\n    citations.sort(reverse=True)\n    \n    # Find the largest h where citations[h-1] >= h\n    h = 0\n    for i in range(n):\n        if citations[i] >= i + 1:\n            h = i + 1\n        else:\n            break\n    \n    return h\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    citations = list(map(int, data[1:1+n]))\n    \n    # Calculate and print H-index\n    result = h_index(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.65205144882202}
{"eval_index": 84, "problem_id": 3510, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    positions = [chr(ord('a') + i) for i in range(n)]\n    pos_to_idx = {pos: i for i, pos in enumerate(positions)}\n    \n    # Parse options\n    options = [[] for _ in range(n)]\n    for i in range(n):\n        m = int(data[idx]); idx += 1\n        for _ in range(m):\n            s = data[idx]; idx += 1\n            # Convert string to list of position indices\n            option_set = [pos_to_idx[ch] for ch in s]\n            options[i].append(option_set)\n    \n    # DP: dp[p][q] = minimal rounds to guarantee reaching q from p\n    INF = 10**9\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Base case: same position\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # BFS-like update\n    updated = True\n    while updated:\n        updated = False\n        for p in range(n):\n            for q in range(n):\n                if dp[p][q] != INF:\n                    continue\n                # Check if Alice can force reaching q from p\n                # Alice chooses an option where all Bob's choices lead to positions\n                # from which q is reachable in fewer rounds\n                for option in options[p]:\n                    max_rounds = -1\n                    valid = True\n                    for r in option:\n                        if dp[r][q] == INF:\n                            valid = False\n                            break\n                        max_rounds = max(max_rounds, dp[r][q])\n                    if valid:\n                        new_val = max_rounds + 1\n                        if dp[p][q] > new_val:\n                            dp[p][q] = new_val\n                            updated = True\n    \n    # Output\n    out_lines = []\n    for p in range(n):\n        line_vals = []\n        for q in range(n):\n            val = dp[p][q]\n            line_vals.append(str(val if val != INF else -1))\n        out_lines.append(' '.join(line_vals))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 31.820488691329956}
{"eval_index": 85, "problem_id": 4425, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # Probability of winning\n    win_prob = 0.0\n    \n    # For each possible initial die roll\n    for start in range(1, N + 1):\n        # If initial score is already >= K, win immediately\n        if start >= K:\n            win_prob += 1.0 / N\n            continue\n        \n        # Find minimum number of consecutive heads needed\n        current = start\n        heads_needed = 0\n        while current < K:\n            current *= 2\n            heads_needed += 1\n        \n        # Probability of getting exactly 'heads_needed' consecutive heads\n        # before a tail appears\n        prob = (1.0 / N) * (0.5 ** heads_needed)\n        win_prob += prob\n    \n    # Print with sufficient precision\n    print(f\"{win_prob:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.582905054092407}
{"eval_index": 86, "problem_id": 2524, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    ans = 0\n    # Process each bit position from 0 to 59 (since A_i < 2^60)\n    for bit in range(60):\n        mask = 1 << bit\n        cnt1 = 0\n        # Count numbers with this bit set\n        for num in arr:\n            if num & mask:\n                cnt1 += 1\n        cnt0 = n - cnt1\n        \n        # For each pair (i,j), XOR contributes 2^bit if bits differ\n        # Number of pairs with different bits = cnt0 * cnt1\n        pairs_with_bit_set = cnt0 * cnt1\n        \n        # Contribution of this bit to total sum\n        bit_contribution = (pairs_with_bit_set % MOD) * (mask % MOD) % MOD\n        ans = (ans + bit_contribution) % MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.036758184432983}
{"eval_index": 87, "problem_id": 3197, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.94600248336792}
{"eval_index": 88, "problem_id": 4305, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H = int(data[0])\n    A = int(data[1])\n    \n    # Calculate number of attacks needed\n    # Use integer division with ceiling: (H + A - 1) // A\n    attacks = (H + A - 1) // A\n    \n    print(attacks)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.184394598007202}
{"eval_index": 89, "problem_id": 2268, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    s = list(next(it))\n    \n    # Initialize mapping: each letter maps to itself\n    mapping = [chr(ord('a') + i) for i in range(26)]\n    \n    for _ in range(m):\n        x = next(it)\n        y = next(it)\n        if x == y:\n            continue\n        # Swap the mappings for x and y\n        for i in range(26):\n            if mapping[i] == x:\n                mapping[i] = y\n            elif mapping[i] == y:\n                mapping[i] = x\n    \n    # Apply the final mapping to each character in the string\n    for i in range(n):\n        s[i] = mapping[ord(s[i]) - ord('a')]\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.839619874954224}
{"eval_index": 90, "problem_id": 3170, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.12233781814575}
{"eval_index": 91, "problem_id": 4491, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = []\n    idx = 1\n    for _ in range(2):\n        row = list(map(int, data[idx:idx+N]))\n        A.append(row)\n        idx += N\n    \n    # Prefix sums for both rows\n    prefix_top = [0] * (N + 1)\n    prefix_bottom = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_top[i] = prefix_top[i-1] + A[0][i-1]\n        prefix_bottom[i] = prefix_bottom[i-1] + A[1][i-1]\n    \n    max_candies = 0\n    # Try all possible columns where we move down\n    for k in range(1, N + 1):\n        # Path: (1,1) -> (1,k) -> (2,k) -> (2,N)\n        candies = (prefix_top[k] - prefix_top[0]) + (prefix_bottom[N] - prefix_bottom[k-1])\n        max_candies = max(max_candies, candies)\n    \n    print(max_candies)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.52643847465515}
{"eval_index": 92, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.33180832862854}
{"eval_index": 93, "problem_id": 3848, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_tolerable(s, p):\n    \"\"\"Check if string s is tolerable.\"\"\"\n    n = len(s)\n    # Check each character is within first p letters\n    max_char = chr(ord('a') + p - 1)\n    for ch in s:\n        if ch > max_char:\n            return False\n    \n    # Check for palindromes of length >= 2\n    for i in range(n):\n        for length in [2, 3]:  # Only need to check length 2 and 3\n            j = i + length - 1\n            if j >= n:\n                break\n            # Check if s[i:j+1] is palindrome\n            is_pal = True\n            for k in range(length // 2):\n                if s[i + k] != s[j - k]:\n                    is_pal = False\n                    break\n            if is_pal:\n                return False\n    return True\n\ndef next_tolerable(s, p):\n    \"\"\"Find lexicographically next tolerable string.\"\"\"\n    n = len(s)\n    max_char = chr(ord('a') + p - 1)\n    s_list = list(s)\n    \n    # Try to increment from the end\n    for i in range(n - 1, -1, -1):\n        original = s_list[i]\n        # Try all possible next characters for this position\n        for ch_code in range(ord(original) + 1, ord(max_char) + 1):\n            s_list[i] = chr(ch_code)\n            # Fill the rest with smallest possible characters\n            for j in range(i + 1, n):\n                # Try 'a' first, then increment if needed\n                for try_char in range(ord('a'), ord(max_char) + 1):\n                    s_list[j] = chr(try_char)\n                    # Check if current prefix is tolerable\n                    if is_tolerable(''.join(s_list[:j + 1]), p):\n                        break\n                else:\n                    # No valid character found for position j\n                    break\n            else:\n                # All positions filled, check if entire string is tolerable\n                candidate = ''.join(s_list)\n                if is_tolerable(candidate, p):\n                    return candidate\n        # Reset this position to original for next iteration\n        s_list[i] = original\n    \n    return \"NO\"\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = int(data[1])\n    s = data[2]\n    \n    result = next_tolerable(s, p)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 38.83413577079773}
{"eval_index": 94, "problem_id": 4712, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    grid = data[2:2+H]\n    \n    # Top border\n    print('#' * (W + 2))\n    \n    # Middle rows with side borders\n    for row in grid:\n        print(f\"#{row}#\")\n    \n    # Bottom border\n    print('#' * (W + 2))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.805608987808228}
{"eval_index": 95, "problem_id": 1482, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 55.49464225769043}
{"eval_index": 96, "problem_id": 3289, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.02709197998047}
{"eval_index": 97, "problem_id": 4885, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef read_board():\n    \"\"\"Read the ASCII chessboard from stdin.\"\"\"\n    lines = []\n    for line in sys.stdin:\n        line = line.rstrip('\\n')\n        if line:  # skip empty lines if any\n            lines.append(line)\n    return lines\n\ndef parse_board(lines):\n    \"\"\"Parse the ASCII board to extract piece positions.\"\"\"\n    pieces = []\n    # The board has 8 rows, each represented by 3 lines: border, content, border\n    # We only care about the content lines (index 1, 4, 7, ...)\n    for row_idx in range(8):\n        content_line = lines[1 + row_idx * 2]  # 1, 3, 5, ... but adjusted for 0-index\n        # Each cell is 4 chars: '|', then 3 chars for content, then '|' at end\n        # Extract the middle char of each cell (the piece or '.'/':')\n        for col_idx in range(8):\n            # Position in the line: 1 + col_idx*4 gives the start of cell content\n            pos = 1 + col_idx * 4\n            cell_content = content_line[pos:pos+3]  # e.g., '.r.', ':::', etc.\n            middle_char = cell_content[1]  # the middle character\n            if middle_char != '.' and middle_char != ':':\n                # It's a piece\n                piece_type = middle_char\n                # Convert to chess notation: rows are 8 to 1 from top, cols a to h from left\n                chess_row = 8 - row_idx  # because row_idx 0 is top row (row 8)\n                chess_col = chr(ord('a') + col_idx)\n                position = f\"{chess_col}{chess_row}\"\n                pieces.append((piece_type, position))\n    return pieces\n\ndef sort_pieces(pieces, is_white):\n    \"\"\"Sort pieces according to problem rules.\"\"\"\n    # Order: K, Q, R, B, N, P\n    order = {'K': 0, 'Q': 1, 'R': 2, 'B': 3, 'N': 4, 'P': 5}\n    # For sorting, we need to compare by type, then row, then column\n    def sort_key(piece):\n        piece_type, pos = piece\n        col, row = pos[0], int(pos[1])\n        # For white: smaller row first; for black: larger row first\n        row_key = row if is_white else -row\n        return (order[piece_type.upper()], row_key, col)\n    return sorted(pieces, key=sort_key)\n\ndef format_output(pieces, is_white):\n    \"\"\"Format sorted pieces into the required output string.\"\"\"\n    sorted_pieces = sort_pieces(pieces, is_white)\n    terms = []\n    for piece_type, position in sorted_pieces:\n        if piece_type.upper() == 'P':\n            # Pawn: omit the piece letter\n            terms.append(position)\n        else:\n            terms.append(f\"{piece_type.upper()}{position}\")\n    return ','.join(terms)\n\ndef main():\n    lines = read_board()\n    pieces = parse_board(lines)\n    # Separate white (uppercase) and black (lowercase) pieces\n    white_pieces = [(p_type, pos) for p_type, pos in pieces if p_type.isupper()]\n    black_pieces = [(p_type, pos) for p_type, pos in pieces if p_type.islower()]\n    white_output = format_output(white_pieces, is_white=True)\n    black_output = format_output(black_pieces, is_white=False)\n    print(f\"White: {white_output}\")\n    print(f\"Black: {black_output}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 44.722615242004395}
{"eval_index": 98, "problem_id": 1750, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    n = int(sys.stdin.readline())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Find maximum degree\n    max_deg = 0\n    for i in range(n):\n        max_deg = max(max_deg, len(adj[i]))\n    \n    # Minimum colors needed is max_deg + 1\n    k = max_deg + 1\n    colors = [0] * n\n    \n    # BFS to assign colors\n    from collections import deque\n    q = deque([0])\n    colors[0] = 1\n    parent_color = 0  # color of parent for root is 0 (non-existent)\n    \n    while q:\n        u = q.popleft()\n        color_idx = 1\n        for v in adj[u]:\n            if colors[v] == 0:  # not visited\n                while color_idx == colors[u] or color_idx == parent_color:\n                    color_idx += 1\n                colors[v] = color_idx\n                color_idx += 1\n                q.append(v)\n        # For next children, parent_color will be colors[u]\n        # We need to pass parent_color to children during BFS\n        # We'll handle this by storing parent information\n    \n    # Better approach: DFS with parent parameter\n    def dfs(u, parent, parent_color):\n        color_idx = 1\n        for v in adj[u]:\n            if v == parent:\n                continue\n            while color_idx == colors[u] or color_idx == parent_color:\n                color_idx += 1\n            colors[v] = color_idx\n            color_idx += 1\n            dfs(v, u, colors[u])\n    \n    colors[0] = 1\n    dfs(0, -1, 0)\n    \n    print(k)\n    print(' '.join(map(str, colors)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 59.23127365112305}
{"eval_index": 99, "problem_id": 3499, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.0317211151123}
{"eval_index": 100, "problem_id": 4078, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.21366357803345}
{"eval_index": 101, "problem_id": 1451, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def count_lucky_digits(num):\n    \"\"\"Count how many digits in num are 4 or 7.\"\"\"\n    count = 0\n    while num > 0:\n        digit = num % 10\n        if digit == 4 or digit == 7:\n            count += 1\n        num //= 10\n    return count\n\ndef main():\n    # Read input\n    n, k = map(int, input().split())\n    numbers = list(map(int, input().split()))\n    \n    # Count numbers with at most k lucky digits\n    answer = 0\n    for num in numbers:\n        if count_lucky_digits(num) <= k:\n            answer += 1\n    \n    # Output result\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.633755207061768}
{"eval_index": 102, "problem_id": 3922, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.35326385498047}
{"eval_index": 103, "problem_id": 4401, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input from standard input\n    X, Y, Z = map(int, input().split())\n    \n    # First swap: A and B\n    # After swap: A = Y, B = X, C = Z\n    a, b, c = Y, X, Z\n    \n    # Second swap: A and C\n    # After swap: A = c, B = b, C = a\n    a, b, c = c, b, a\n    \n    # Print the final contents of A, B, C\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.641735076904297}
{"eval_index": 104, "problem_id": 2679, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 35.35569643974304}
{"eval_index": 105, "problem_id": 3912, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.90389275550842}
{"eval_index": 106, "problem_id": 4373, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 60.8535897731781}
{"eval_index": 107, "problem_id": 2775, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    print(0)\n    sys.exit(0)\n\nn = int(input_data[0])\nx_h, y_h, x_w, y_w = map(int, input_data[1:5])\nerrands = []\nidx = 5\nfor i in range(n):\n    x, y = int(input_data[idx]), int(input_data[idx+1])\n    idx += 2\n    errands.append((x, y))\n\n# Normalize coordinates so house is at (0,0) and workplace is in first quadrant\n# This doesn't change relative positions for Manhattan distance\n# We'll consider the rectangle between house and workplace\ndx = x_w - x_h\ndy = y_w - y_h\n\n# Determine if we need to flip axes to ensure dx >= 0 and dy >= 0\n# Actually, we can handle all cases by considering the bounding box\nmin_x = min(x_h, x_w)\nmax_x = max(x_h, x_w)\nmin_y = min(y_h, y_w)\nmax_y = max(y_h, y_w)\n\n# Filter errands that are within the bounding box of house and workplace\n# and on the Manhattan path (i.e., can be visited without extra distance)\n# An errand (x,y) can be visited if:\n# 1. min_x <= x <= max_x and min_y <= y <= max_y\n# 2. The Manhattan distance from house to errand plus errand to workplace\n#    equals the Manhattan distance from house to workplace\n# This simplifies to checking if the errand lies on some monotonic path\n# In grid with Manhattan distance, the condition is:\n# (x between x_h and x_w) AND (y between y_h and y_w)\n# AND the errand is \"between\" house and workplace in both coordinates\n# More precisely: (x - x_h) and (x_w - x) have same sign as dx,\n# and similarly for y. But since we normalized to first quadrant,\n# we can just check bounds.\n\nvalid_errands = []\nfor x, y in errands:\n    if min_x <= x <= max_x and min_y <= y <= max_y:\n        # Check if it's on a shortest path\n        # For Manhattan distance, any point within the rectangle\n        # can be visited with same total distance if we go via that point\n        # Actually, we need to ensure we don't go backwards\n        # The condition is: (x - x_h) and (x_w - x) have same sign as dx,\n        # but since we have min/max, it's already satisfied\n        # Let's compute Manhattan distances to verify\n        dist_h_to_e = abs(x - x_h) + abs(y - y_h)\n        dist_e_to_w = abs(x_w - x) + abs(y_w - y)\n        dist_h_to_w = abs(x_w - x_h) + abs(y_w - y_h)\n        if dist_h_to_e + dist_e_to_w == dist_h_to_w:\n            valid_errands.append((x, y))\n\n# Now we need to find maximum number of errands we can visit\n# on a monotonic path from house to workplace\n# Since we can only move right/up (after normalization),\n# this becomes finding longest chain in partial order\n# Sort errands by x, then by y, and find LIS on y\nif not valid_errands:\n    print(0)\n    sys.exit(0)\n\n# Normalize coordinates relative to house\n# Shift so house is at (0,0)\nshifted = [(x - x_h, y - y_h) for x, y in valid_errands]\n\n# Determine direction\n# We want to move from (0,0) to (dx, dy) where dx = x_w - x_h, dy = y_w - y_h\n# If dx < 0, we can reflect x-axis\n# If dy < 0, we can reflect y-axis\n# Actually, we can sort based on direction\n# We'll transform coordinates so that we always move non-decreasing in both axes\n# by flipping signs if needed\nif dx < 0:\n    shifted = [(-x, y) for x, y in shifted]\n    dx = -dx\nif dy < 0:\n    shifted = [(x, -y) for x, y in shifted]\n    dy = -dy\n\n# Now dx >= 0 and dy >= 0\n# Filter points that are within [0, dx] and [0, dy]\nfiltered = [(x, y) for x, y in shifted if 0 <= x <= dx and 0 <= y <= dy]\n\n# Sort by x, then by y\nfiltered.sort(key=lambda p: (p[0], p[1]))\n\n# Find longest non-decreasing subsequence on y\n# Since x is sorted, we need y to be non-decreasing to maintain monotonic path\nimport bisect\n\nlis = []\nfor x, y in filtered:\n    # For LIS, we want strictly increasing? Actually, we can have same y if x increases\n    # But if same x, we should take smallest y first to maximize count\n    # Already sorted by x then y, so for same x, y increasing\n    # We need y non-decreasing for the path\n    pos = bisect.bisect_right(lis, y)\n    if pos == len(lis):\n        lis.append(y)\n    else:\n        lis[pos] = y\n\nprint(len(lis))", "complexity_estimate": null, "runtime_sec": 58.225144147872925}
{"eval_index": 108, "problem_id": 3443, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.48552083969116}
{"eval_index": 109, "problem_id": 4802, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input\n    h, m = map(int, input().split())\n    \n    # Convert total minutes\n    total_minutes = h * 60 + m\n    \n    # Subtract 45 minutes\n    new_total_minutes = total_minutes - 45\n    \n    # Handle negative case (wrap around to previous day)\n    if new_total_minutes < 0:\n        new_total_minutes += 24 * 60  # Add one full day in minutes\n    \n    # Convert back to hours and minutes\n    new_h = new_total_minutes // 60\n    new_m = new_total_minutes % 60\n    \n    # Output result\n    print(f\"{new_h} {new_m}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.296590805053711}
{"eval_index": 110, "problem_id": 663, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, x, y, xp, yp = map(int, data)\n    \n    # Calculate Euclidean distance between centers\n    dx = xp - x\n    dy = yp - y\n    dist = math.hypot(dx, dy)\n    \n    # If already at destination\n    if dist == 0:\n        print(0)\n        return\n    \n    # Each step can move the center by at most 2r\n    # Minimum steps = ceil(dist / (2r))\n    steps = math.ceil(dist / (2 * r))\n    print(steps)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.71102547645569}
{"eval_index": 111, "problem_id": 3669, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    points = []\n    idx = 1\n    for _ in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        points.append((x, y))\n        idx += 2\n    \n    # Count points with same x and same y\n    x_count = {}\n    y_count = {}\n    for x, y in points:\n        x_count[x] = x_count.get(x, 0) + 1\n        y_count[y] = y_count.get(y, 0) + 1\n    \n    # Count how many points have at least one other point sharing x or y\n    # These are \"connected\" points in the bipartite graph\n    connected = 0\n    for x, y in points:\n        if x_count[x] > 1 or y_count[y] > 1:\n            connected += 1\n    \n    # The game reduces to a bipartite graph where each move removes an edge\n    # The parity of connected points determines the winner\n    # If connected is odd, Mirko wins; if even, Slavko wins\n    # But careful: the first move must be possible\n    if connected == 0:\n        # No possible moves at all\n        print(\"Slavko\")\n    else:\n        # The game is equivalent to removing edges from a bipartite graph\n        # The number of moves equals the number of connected points\n        # Since Mirko moves first, if connected is odd, he gets the last move\n        if connected % 2 == 1:\n            print(\"Mirko\")\n        else:\n            print(\"Slavko\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.582622051239014}
{"eval_index": 112, "problem_id": 4954, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    B = int(data[idx]); idx += 1\n    H = int(data[idx]); idx += 1\n    W = int(data[idx]); idx += 1\n    \n    min_cost = float('inf')\n    \n    for _ in range(H):\n        p = int(data[idx]); idx += 1\n        available_beds = []\n        for _ in range(W):\n            available_beds.append(int(data[idx])); idx += 1\n        \n        total_price = p * N\n        if total_price > B:\n            continue\n        \n        for beds in available_beds:\n            if beds >= N:\n                min_cost = min(min_cost, total_price)\n                break\n    \n    if min_cost == float('inf'):\n        print(\"stay home\")\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.920594692230225}
{"eval_index": 113, "problem_id": 2365, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 19.42582869529724}
{"eval_index": 114, "problem_id": 3233, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    # Map value to index for O(1) lookup\n    pos = [0] * (n + 1)\n    for i, val in enumerate(p):\n        pos[val] = i\n    \n    # Count subarrays where leftmost element is median\n    # For odd length k, median is element at position (k-1)//2 in sorted order\n    # Since elements are distinct, we need exactly (k-1)//2 elements < p[l] and (k-1)//2 elements > p[l]\n    # in the subarray p[l:l+k]\n    \n    # We'll process each starting position l\n    ans = n  # all length-1 subarrays are scary\n    \n    # For each starting index l\n    for l in range(n):\n        left_val = p[l]\n        \n        # We'll expand to the right while maintaining counts\n        # Use two pointers: cnt_less = number of elements < left_val in current window\n        #                   cnt_greater = number of elements > left_val in current window\n        cnt_less = 0\n        cnt_greater = 0\n        \n        # Current window is [l, r]\n        r = l\n        while r < n:\n            if r > l:  # window length > 1\n                if p[r] < left_val:\n                    cnt_less += 1\n                else:\n                    cnt_greater += 1\n                \n                # Check if current window length is odd and conditions hold\n                window_len = r - l + 1\n                if window_len % 2 == 1:  # odd length\n                    required = (window_len - 1) // 2\n                    if cnt_less == required and cnt_greater == required:\n                        ans += 1\n            \n            r += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.184619426727295}
{"eval_index": 115, "problem_id": 4300, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    d = list(map(int, data[1:1+n]))\n    \n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total += d[i] * d[j]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.15245532989502}
{"eval_index": 116, "problem_id": 1111, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.2613227367401}
{"eval_index": 117, "problem_id": 3096, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.72923469543457}
{"eval_index": 118, "problem_id": 4201, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W, K = map(int, data[:3])\n    grid = data[3:]\n    \n    # Count black squares in each row and column\n    row_black = [0] * H\n    col_black = [0] * W\n    total_black = 0\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_black[i] += 1\n                col_black[j] += 1\n                total_black += 1\n    \n    ans = 0\n    # Iterate over all subsets of rows (2^H possibilities)\n    for row_mask in range(1 << H):\n        # Iterate over all subsets of columns (2^W possibilities)\n        for col_mask in range(1 << W):\n            # Count black squares that are NOT painted red\n            # A black square remains if its row is NOT chosen AND its column is NOT chosen\n            remaining = 0\n            for i in range(H):\n                if row_mask & (1 << i):\n                    continue  # This row is painted red, skip its black squares\n                for j in range(W):\n                    if col_mask & (1 << j):\n                        continue  # This column is painted red, skip its black squares\n                    if grid[i][j] == '#':\n                        remaining += 1\n            if remaining == K:\n                ans += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 46.94058346748352}
{"eval_index": 119, "problem_id": 588, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 72.13417768478394}
{"eval_index": 120, "problem_id": 3826, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # If all elements are already distinct\n    if len(set(a)) == n:\n        print(0)\n        return\n    \n    # Precompute frequency of each element\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Find the minimum length of subsegment to remove\n    min_remove = n  # Initialize with worst case\n    \n    # Try all possible left boundaries\n    for l in range(n):\n        # Reset frequency for current left boundary\n        current_freq = freq.copy()\n        \n        # Try all possible right boundaries starting from l\n        for r in range(l, n):\n            # Remove element at position r from frequency\n            val = a[r]\n            current_freq[val] -= 1\n            if current_freq[val] == 0:\n                del current_freq[val]\n            \n            # Check if remaining elements are distinct\n            # All frequencies should be <= 1\n            distinct = True\n            for count in current_freq.values():\n                if count > 1:\n                    distinct = False\n                    break\n            \n            if distinct:\n                # Calculate length of removed segment\n                segment_length = r - l + 1\n                min_remove = min(min_remove, segment_length)\n                # No need to try larger r for this l since we want minimum\n                break\n    \n    print(min_remove)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.432313919067383}
{"eval_index": 121, "problem_id": 4726, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.05753946304321}
{"eval_index": 122, "problem_id": 1652, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    S = sys.stdin.readline().strip()\n    words = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\n    # Reverse strings to avoid ambiguity\n    words_rev = [w[::-1] for w in words]\n    S_rev = S[::-1]\n    \n    i = 0\n    n = len(S_rev)\n    while i < n:\n        matched = False\n        for w in words_rev:\n            if S_rev.startswith(w, i):\n                i += len(w)\n                matched = True\n                break\n        if not matched:\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.221389055252075}
{"eval_index": 123, "problem_id": 3938, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', \"import sys\\r\\n\\r\\n# Read input\\r\\ninput_data = sys.stdin.read().strip().split()\\r\\nif not input_data:\\r\\n    print(0)\\r\\n    sys.exit(0)\\r\\n\\r\\nit = iter(input_data)\\r\\nn = int(next(it))\\r\\nm = int(next(it))\\r\\n\\r\\n# If no black rectangles, cost is 0\\r\\nif m == 0:\\r\\n    print(0)\\r\\n    sys.exit(0)\\r\\n\\r\\nrectangles = []\\r\\nfor _ in range(m):\\r\\n    x1 = int(next(it))\\r\\n    y1 = int(next(it))\\r\\n    x2 = int(next(it))\\r\\n    y2 = int(next(it))\\r\\n    rectangles.append((x1, y1, x2, y2))\\r\\n\\r\\n# Step 1: Find all distinct x and y coordinates\\r\\nxs = set()\\r\\nys = set()\\r\\nfor x1, y1, x2, y2 in rectangles:\\r\\n    xs.add(x1)\\r\\n    xs.add(x2 + 1)  # Add x2+1 to capture boundaries\\r\\n    ys.add(y1)\\r\\n    ys.add(y2 + 1)  # Add y2+1 to capture boundaries\\r\\n\\r\\n# Sort coordinates\\r\\nxs = sorted(xs)\\r\\nys = sorted(ys)\\r\\n\\r\\n# Step 2: Create compressed grid\\r\\n# Map coordinates to indices\\r\\nx_to_idx = {x: i for i, x in enumerate(xs)}\\r\\ny_to_idx = {y: i for i, y in enumerate(ys)}\\r\\n\\r\\n# Initialize grid with zeros\\r\\ncompressed_h = len(xs) - 1\\r\\ncompressed_w = len(ys) - 1\\r\\ngrid = [[0] * compressed_w for _ in range(compressed_h)]\\r\\n\\r\\n# Mark black cells in compressed grid\\r\\nfor x1, y1, x2, y2 in rectangles:\\r\\n    # Find indices in compressed grid\\r\\n    idx_x1 = x_to_idx[x1]\\r\\n    idx_x2 = x_to_idx[x2 + 1] - 1\\r\\n    idx_y1 = y_to_idx[y1]\\r\\n    idx_y2 = y_to_idx[y2 + 1] - 1\\r\\n    \\r\\n    # Mark the region as black (1)\\r\\n    for i in range(idx_x1, idx_x2 + 1):\\r\\n        for j in range(idx_y1, idx_y2 + 1):\\r\\n            grid[i][j] = 1\\r\\n\\r\\n# Step 3: Solve minimum cost to cover all black cells with rectangles\\r\\n# This is equivalent to finding minimum vertex cover in bipartite graph\\r\\n# where rows and columns are vertices, and black cells are edges\\r\\n\\r\\n# Build bipartite graph\\r\\nrow_nodes = compressed_h\\r\\ncol_nodes = compressed_w\\r\\nadj = [[] for _ in range(row_nodes)]\\r\\n\\r\\nfor i in range(row_nodes):\\r\\n    for j in range(col_nodes):\\r\\n        if grid[i][j] == 1:\\r\\n            adj[i].append(j)\\r\\n\\r\\n# Hopcroft-Karp algorithm for maximum matching\\r\\ndef hopcroft_karp(adj, n_left, n_right):\\r\\n    INF = 10**9\\r\\n    pair_u = [-1] * n_left\\r\\n    pair_v = [-1] * n_right\\r\\n    dist = [0] * n_left\\r\\n    \\r\\n    from collections import deque\\r\\n    \\r\\n    def bfs():\\r\\n        q = deque()\\r\\n        for u in range(n_left):\\r\\n            if pair_u[u] == -1:\\r\\n                dist[u] = 0\\r\\n                q.append(u)\\r\\n            else:\\r\\n                dist[u] = INF\\r\\n        \\r\\n        found = False\\r\\n        while q:\\r\\n            u = q.popleft()\\r\\n            for v in adj[u]:\\r\\n                pu = pair_v[v]\\r\\n                if pu != -1 and dist[pu] == INF:\\r\\n                    dist[pu] = dist[u] + 1\\r\\n                    q.append(pu)\\r\\n                elif pu == -1:\\r\\n                    found = True\\r\\n        return found\\r\\n    \\r\\n    def dfs(u):\\r\\n        for v in adj[u]:\\r\\n            pu = pair_v[v]\\r\\n            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):\\r\\n                pair_u[u] = v\\r\\n                pair_v[v] = u\\r\\n                return True\\r\\n        dist[u] = INF\\r\\n        return False\\r\\n    \\r\\n    matching = 0\\r\\n    while bfs():\\r\\n        for u in range(n_left):\\r\\n            if pair_u[u] == -1 and dfs(u):\\r\\n                matching += 1\\r\\n    return matching\\r\\n\\r\\n# Get maximum matching\\r\\nmax_match = hopcroft_karp(adj, row_nodes, col_nodes)\\r\\n\\r\\n# Minimum vertex cover size = maximum matching size (Knig's theorem)\\r\\nmin_cost = max_match\\r\\n\\r\\nprint(min_cost)\", 3294, 3295, 'illegal multibyte sequence')", "runtime_sec": 95.21882820129395}
{"eval_index": 124, "problem_id": 4722, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    # We need to check if total cookies (A, B, or A+B) is divisible by 3\n    # and also ensure that the chosen total is achievable with the given tins\n    # Since we can only give A, B, or A+B cookies, we check each case\n    possible = False\n    # Case 1: Give A cookies\n    if A % 3 == 0:\n        possible = True\n    # Case 2: Give B cookies\n    if B % 3 == 0:\n        possible = True\n    # Case 3: Give A+B cookies\n    if (A + B) % 3 == 0:\n        possible = True\n    print(\"Possible\" if possible else \"Impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.39003324508667}
{"eval_index": 125, "problem_id": 915, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    k = int(sys.stdin.readline().strip())\n    target = \"codeforces\"\n    n = len(target)  # n = 10\n    \n    # Initialize counts for each character\n    counts = [1] * n\n    \n    # Current total subsequences\n    total = 1\n    \n    # Increase counts greedily\n    while total < k:\n        # Find character to increment that gives maximum increase\n        best_idx = 0\n        best_increase = 0\n        \n        for i in range(n):\n            # If we increment counts[i], total multiplies by (counts[i]+1)/counts[i]\n            increase = total // counts[i]\n            if increase > best_increase:\n                best_increase = increase\n                best_idx = i\n        \n        # Increment the best character\n        counts[best_idx] += 1\n        total = 1\n        for cnt in counts:\n            total *= cnt\n        \n        # Early exit if we've reached k\n        if total >= k:\n            break\n    \n    # Build the result string\n    result = []\n    for i in range(n):\n        result.append(target[i] * counts[i])\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.918215036392212}
{"eval_index": 126, "problem_id": 3619, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.26729035377502}
{"eval_index": 127, "problem_id": 4404, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    # Parse the date string\n    year, month, day = map(int, S.split('/'))\n    \n    # Check if date is not later than April 30, 2019\n    if year < 2019:\n        print(\"Heisei\")\n    elif year == 2019:\n        if month < 4:\n            print(\"Heisei\")\n        elif month == 4:\n            if day <= 30:\n                print(\"Heisei\")\n            else:\n                print(\"TBD\")\n        else:\n            print(\"TBD\")\n    else:\n        print(\"TBD\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.162124872207642}
{"eval_index": 128, "problem_id": 943, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    total_sum = sum(arr)\n    \n    # If total sum is already even, it's the answer\n    if total_sum % 2 == 0:\n        print(total_sum)\n        return\n    \n    # Find the smallest odd number to subtract\n    min_odd = float('inf')\n    for num in arr:\n        if num % 2 == 1 and num < min_odd:\n            min_odd = num\n    \n    # If no odd number exists (shouldn't happen since sum is odd), but handle\n    if min_odd == float('inf'):\n        print(0)\n    else:\n        print(total_sum - min_odd)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.4739933013916}
{"eval_index": 129, "problem_id": 3564, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.32583498954773}
{"eval_index": 130, "problem_id": 4487, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    # Read input as three strings separated by spaces\n    A, B, C = input().split()\n    \n    # Check both conditions for word chain\n    if A[-1] == B[0] and B[-1] == C[0]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.206576585769653}
{"eval_index": 131, "problem_id": 2784, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    graph = defaultdict(list)\n    \n    # Build graph from fragments\n    for i in range(1, n + 1):\n        parts = data[i].split()\n        if not parts:\n            continue\n        station = parts[0]\n        for neighbor in parts[1:]:\n            if neighbor not in graph[station]:\n                graph[station].append(neighbor)\n            if station not in graph[neighbor]:\n                graph[neighbor].append(station)\n    \n    # Get start and destination\n    start, dest = data[n + 1].split()\n    \n    # BFS to find shortest path\n    visited = {start: None}\n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        if current == dest:\n            # Reconstruct path\n            path = []\n            while current is not None:\n                path.append(current)\n                current = visited[current]\n            path.reverse()\n            print(' '.join(path))\n            return\n        \n        for neighbor in graph.get(current, []):\n            if neighbor not in visited:\n                visited[neighbor] = current\n                queue.append(neighbor)\n    \n    # No route found\n    print(\"no route found\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.73469114303589}
{"eval_index": 132, "problem_id": 3889, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # Count frequency of each character\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    \n    # Check conditions\n    # Condition 1: If all characters are the same, always possible\n    # Condition 2: If there's at least one character with frequency >= 2, possible\n    # Condition 3: If n == 1, always possible (single character)\n    \n    possible = False\n    if n == 1:\n        possible = True\n    else:\n        # Check if any character appears at least twice\n        for count in freq:\n            if count >= 2:\n                possible = True\n                break\n        \n        # Special case: if all characters are different and n > 1, impossible\n        # This is already covered by the loop above (no count >= 2)\n    \n    print(\"Yes\" if possible else \"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.795870065689087}
{"eval_index": 133, "problem_id": 4614, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read three integers from standard input\n    data = sys.stdin.read().strip().split()\n    A, B, C = map(int, data)\n    \n    # Compare the three numbers to find the different one\n    if A == B:\n        # A and B are same, so C is different\n        print(C)\n    elif A == C:\n        # A and C are same, so B is different\n        print(B)\n    else:\n        # B and C must be same, so A is different\n        print(A)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.891212701797485}
{"eval_index": 134, "problem_id": 1486, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # Precompute min and max distances for each city\n    min_costs = [0] * n\n    max_costs = [0] * n\n    \n    # For each city i:\n    # min distance is to the nearest neighbor (either left or right)\n    # max distance is to the farthest city (either first or last)\n    for i in range(n):\n        if i == 0:\n            # First city: nearest is next city, farthest is last city\n            min_costs[i] = x[1] - x[0]\n            max_costs[i] = x[-1] - x[0]\n        elif i == n - 1:\n            # Last city: nearest is previous city, farthest is first city\n            min_costs[i] = x[-1] - x[-2]\n            max_costs[i] = x[-1] - x[0]\n        else:\n            # Middle city: nearest is min of left and right neighbors\n            min_costs[i] = min(x[i] - x[i-1], x[i+1] - x[i])\n            # Farthest is max of distance to first or last city\n            max_costs[i] = max(x[i] - x[0], x[-1] - x[i])\n    \n    # Output results\n    out_lines = []\n    for i in range(n):\n        out_lines.append(f\"{min_costs[i]} {max_costs[i]}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.349098205566406}
{"eval_index": 135, "problem_id": 3635, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    bananas = list(map(int, data[1:1+n]))\n    \n    # prefix sums for quick range sum queries\n    prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i-1] + bananas[i-1]\n    \n    # dp[i] = maximum number of executives using first i briefcases\n    dp = [0] * (n + 1)\n    # last_sum[i] = total bananas given to last executive when using first i briefcases\n    last_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        # try to start a new executive at position j\n        for j in range(i):\n            if dp[j] == 0:\n                # first executive\n                new_dp = 1\n                new_last = prefix[i] - prefix[j]\n            else:\n                # check if we can add another executive\n                current_sum = prefix[i] - prefix[j]\n                if current_sum >= last_sum[j]:\n                    new_dp = dp[j] + 1\n                    new_last = current_sum\n                else:\n                    continue\n            \n            # update if better\n            if new_dp > dp[i] or (new_dp == dp[i] and new_last < last_sum[i]):\n                dp[i] = new_dp\n                last_sum[i] = new_last\n    \n    print(dp[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.69372272491455}
{"eval_index": 136, "problem_id": 4648, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    t = int(input().strip())\n    results = []\n    \n    for _ in range(t):\n        n = int(input().strip())\n        moves = 0\n        \n        # Keep dividing by 6 as much as possible\n        while n % 6 == 0:\n            n //= 6\n            moves += 1\n        \n        # Now we need to reach 1 by multiplying by 2 and dividing by 6\n        # This is equivalent to dividing by 3\n        while n % 3 == 0:\n            n //= 3\n            moves += 2  # Multiply by 2 then divide by 6 = divide by 3\n        \n        # If we reached 1, output moves, else -1\n        if n == 1:\n            results.append(str(moves))\n        else:\n            results.append(\"-1\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.997567415237427}
{"eval_index": 137, "problem_id": 475, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 73.79600811004639}
{"eval_index": 138, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.07040977478027}
{"eval_index": 139, "problem_id": 4656, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        k = int(next(it))\n        s = next(it)\n        \n        # Count frequencies of each character\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n        \n        # Try all possible necklace lengths from n down to 1\n        for length in range(n, 0, -1):\n            # For each length, we need to check if we can form a k-beautiful necklace\n            # A k-beautiful necklace of length L must have a period that divides gcd(L, k)\n            # Let g = gcd(L, k)\n            # The necklace can be divided into g blocks of size L/g, each block must be identical\n            # So we need to check if we can form g identical blocks using available beads\n            \n            g = math.gcd(length, k)\n            block_size = length // g\n            \n            # For each block, we need to assign beads\n            # Since blocks are identical, we can think of distributing beads among g positions\n            # Each position in a block gets the same character across all blocks\n            # So for each character, we can use at most (freq[char] // block_size) * block_size beads\n            # And we need to fill g positions\n            \n            total_usable_positions = 0\n            for f in freq:\n                total_usable_positions += f // block_size\n            \n            if total_usable_positions >= g:\n                out_lines.append(str(length))\n                break\n        else:\n            # Should not happen since length=1 always works\n            out_lines.append(\"1\")\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 63.000054121017456}
{"eval_index": 140, "problem_id": 1018, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.43079495429993}
{"eval_index": 141, "problem_id": 3460, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    cans = []\n    for i in range(n):\n        x, r = map(int, input().split())\n        cans.append((x, r, i))\n    \n    # Sort by position\n    cans.sort(key=lambda c: c[0])\n    positions = [c[0] for c in cans]\n    radii = [c[1] for c in cans]\n    indices = [c[2] for c in cans]\n    \n    # Precompute rightmost reach for each can\n    rightmost = [0] * n\n    stack = []\n    for i in range(n-1, -1, -1):\n        rightmost[i] = positions[i] + radii[i]\n        while stack and rightmost[i] >= positions[stack[-1]]:\n            rightmost[i] = max(rightmost[i], rightmost[stack.pop()])\n        stack.append(i)\n    \n    # Precompute leftmost reach for each can\n    leftmost = [0] * n\n    stack = []\n    for i in range(n):\n        leftmost[i] = positions[i] - radii[i]\n        while stack and leftmost[i] <= positions[stack[-1]]:\n            leftmost[i] = min(leftmost[i], leftmost[stack.pop()])\n        stack.append(i)\n    \n    # For each can, find explosion count using binary search\n    result = [0] * n\n    for i in range(n):\n        # Find right boundary\n        lo, hi = i, n-1\n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            if positions[mid] <= rightmost[i]:\n                lo = mid\n            else:\n                hi = mid - 1\n        right_idx = lo\n        \n        # Find left boundary\n        lo, hi = 0, i\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if positions[mid] >= leftmost[i]:\n                hi = mid\n            else:\n                lo = mid + 1\n        left_idx = lo\n        \n        result[indices[i]] = right_idx - left_idx + 1\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 27.152027368545532}
{"eval_index": 142, "problem_id": 4074, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        idx += 2\n        \n        # Initialize answer with worst case: n packages of size 1\n        ans = n\n        \n        # Find all divisors d of n where d <= k\n        # Check divisors up to sqrt(n)\n        d = 1\n        while d * d <= n:\n            if n % d == 0:\n                # Check divisor d\n                if d <= k:\n                    ans = min(ans, n // d)\n                # Check complementary divisor n//d\n                if n // d <= k:\n                    ans = min(ans, d)\n            d += 1\n        \n        results.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 41.031827211380005}
{"eval_index": 143, "problem_id": 2633, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 30.262001276016235}
{"eval_index": 144, "problem_id": 3052, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.13881492614746}
{"eval_index": 145, "problem_id": 4194, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:2+M]))\n    \n    total_work_days = sum(A)\n    \n    if total_work_days > N:\n        print(-1)\n    else:\n        hangout_days = N - total_work_days\n        print(hangout_days)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.490375280380249}
{"eval_index": 146, "problem_id": 2618, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.readline\n    q = int(input().strip())\n    results = []\n    \n    for _ in range(q):\n        n = int(input().strip())\n        prices = list(map(int, input().split()))\n        x, a = map(int, input().split())\n        y, b = map(int, input().split())\n        k = int(input().strip())\n        \n        # Ensure x >= y for consistent handling\n        if x < y:\n            x, y = y, x\n            a, b = b, a\n        \n        # Sort prices in descending order\n        prices.sort(reverse=True)\n        \n        # Precompute contributions for each position\n        lcm_ab = a * b // math.gcd(a, b)\n        \n        # Binary search for minimum number of tickets\n        left, right = 1, n\n        answer = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # Count how many positions get each multiplier\n            cnt_lcm = mid // lcm_ab\n            cnt_a = mid // a - cnt_lcm\n            cnt_b = mid // b - cnt_lcm\n            \n            # Calculate total contribution\n            total = 0\n            idx = 0\n            \n            # First assign to LCM positions (highest multiplier)\n            for i in range(cnt_lcm):\n                total += prices[idx] * (x + y) // 100\n                idx += 1\n            \n            # Then assign to 'a' positions\n            for i in range(cnt_a):\n                total += prices[idx] * x // 100\n                idx += 1\n            \n            # Then assign to 'b' positions\n            for i in range(cnt_b):\n                total += prices[idx] * y // 100\n                idx += 1\n            \n            if total >= k:\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        results.append(answer)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.749999284744263}
{"eval_index": 147, "problem_id": 3738, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    s = data[2]\n    \n    # Compute net displacement after one full command\n    dx = 0\n    dy = 0\n    for ch in s:\n        if ch == 'U':\n            dy += 1\n        elif ch == 'D':\n            dy -= 1\n        elif ch == 'R':\n            dx += 1\n        elif ch == 'L':\n            dx -= 1\n    \n    # Check if (a,b) can be reached\n    x = 0\n    y = 0\n    for ch in s:\n        # Check current position\n        if x == a and y == b:\n            print(\"Yes\")\n            return\n        # Check if we can reach (a,b) by adding multiples of net displacement\n        # We need to solve: x + k*dx = a, y + k*dy = b for some integer k >= 0\n        # This means (a-x) must be divisible by dx if dx != 0, similarly for dy\n        # And k must be the same for both equations\n        if dx == 0 and dy == 0:\n            # No net movement after full command\n            # Only check if current position matches\n            if x == a and y == b:\n                print(\"Yes\")\n                return\n        else:\n            # Check if we can reach (a,b) from current position using net displacement\n            if dx != 0:\n                if (a - x) % dx == 0:\n                    kx = (a - x) // dx\n                    if kx >= 0:\n                        # Check y coordinate matches with same k\n                        if dy != 0:\n                            if (b - y) % dy == 0:\n                                ky = (b - y) // dy\n                                if kx == ky and kx >= 0:\n                                    print(\"Yes\")\n                                    return\n                        else:\n                            # dy == 0, need b == y\n                            if b == y and kx >= 0:\n                                print(\"Yes\")\n                                return\n            else:\n                # dx == 0, need a == x\n                if a == x:\n                    if dy != 0:\n                        if (b - y) % dy == 0:\n                            ky = (b - y) // dy\n                            if ky >= 0:\n                                print(\"Yes\")\n                                return\n                    else:\n                        # dy == 0, need b == y\n                        if b == y:\n                            print(\"Yes\")\n                            return\n        \n        # Move to next position\n        if ch == 'U':\n            y += 1\n        elif ch == 'D':\n            y -= 1\n        elif ch == 'R':\n            x += 1\n        elif ch == 'L':\n            x -= 1\n    \n    # Check final position after one full command\n    if x == a and y == b:\n        print(\"Yes\")\n        return\n    \n    # If net displacement is zero, we've already checked all positions in one cycle\n    if dx == 0 and dy == 0:\n        print(\"No\")\n        return\n    \n    # For positions beyond one cycle, check using net displacement\n    # We need to solve: x + k*dx = a, y + k*dy = b for integer k >= 0\n    # where (x,y) is position after one full command\n    if dx != 0:\n        if (a - x) % dx == 0:\n            kx = (a - x) // dx\n            if kx >= 0:\n                if dy != 0:\n                    if (b - y) % dy == 0:\n                        ky = (b - y) // dy\n                        if kx == ky:\n                            print(\"Yes\")\n                            return\n                else:\n                    if b == y:\n                        print(\"Yes\")\n                        return\n    else:\n        if a == x:\n            if dy != 0:\n                if (b - y) % dy == 0:\n                    ky = (b - y) // dy\n                    if ky >= 0:\n                        print(\"Yes\")\n                        return\n            else:\n                if b == y:\n                    print(\"Yes\")\n                    return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 53.5557701587677}
{"eval_index": 148, "problem_id": 4880, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef char_to_num(c):\n    return ord(c) - ord('a')\n\ndef num_to_char(x):\n    return chr(x + ord('a'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    last_n_plain = data[2]\n    ciphertext = data[3]\n    \n    # Convert to lists of numbers\n    last_plain_nums = [char_to_num(c) for c in last_n_plain]\n    cipher_nums = [char_to_num(c) for c in ciphertext]\n    \n    # Initialize plaintext with the known last n letters\n    plain_nums = [0] * m\n    for i in range(n):\n        plain_nums[m - n + i] = last_plain_nums[i]\n    \n    # Recover the key and plaintext from the end\n    key_nums = [0] * m\n    \n    # First, compute the key for the last n positions\n    for i in range(m - n, m):\n        # b_i = a_i + k_i mod 26\n        # So k_i = (b_i - a_i) mod 26\n        key_nums[i] = (cipher_nums[i] - plain_nums[i]) % 26\n    \n    # Now work backwards to recover earlier plaintext letters\n    # For i < m-n, k_{n+i} = a_i\n    # So a_i = k_{n+i}\n    # And also b_i = a_i + k_i mod 26\n    # So we can compute a_i from known k_{n+i} and then k_i from a_i and b_i\n    for i in range(m - n - 1, -1, -1):\n        # k_{n+i} is known from previous step (it's a_{i} from earlier iteration)\n        # Actually, for position i, k_{n+i} = a_i\n        # But we don't know a_i yet. However, we know:\n        # 1. k_{n+i} will be equal to a_i (once we compute it)\n        # 2. b_i = a_i + k_i mod 26\n        # We can solve: a_i = (b_i - k_i) mod 26\n        # But we don't know k_i yet.\n        \n        # Wait, let's think differently:\n        # We know the key prefix (first n positions) are unknown.\n        # But we know that for i >= n, k_i = a_{i-n}\n        # So for i >= n, we can compute a_{i-n} from k_i\n        # And k_i can be computed from b_i and a_i\n        \n        # Actually, let's work from the end:\n        # We have plain_nums[i+n] for i from 0 to m-n-1\n        # And we know k_{i+n} = plain_nums[i]\n        # So we can compute plain_nums[i] from k_{i+n}\n        # And k_{i+n} can be computed from cipher_nums[i+n] and plain_nums[i+n]\n        \n        # For position i (where i < m-n):\n        # We want plain_nums[i]\n        # We know that k_{i+n} = plain_nums[i]\n        # And we can compute k_{i+n} from:\n        #   k_{i+n} = (cipher_nums[i+n] - plain_nums[i+n]) % 26\n        # Because b_{i+n} = a_{i+n} + k_{i+n} mod 26\n        \n        # So:\n        k_next = (cipher_nums[i + n] - plain_nums[i + n]) % 26\n        plain_nums[i] = k_next\n        \n        # Now we can also compute k_i for this position\n        # k_i = (cipher_nums[i] - plain_nums[i]) % 26\n        key_nums[i] = (cipher_nums[i] - plain_nums[i]) % 26\n    \n    # Convert plaintext numbers back to characters\n    plaintext = ''.join(num_to_char(x) for x in plain_nums)\n    print(plaintext)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 44.95121097564697}
{"eval_index": 149, "problem_id": 234, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_bombs(grid, i, j, n, m):\n    \"\"\"Count bombs in the 8 neighboring cells.\"\"\"\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    count = 0\n    for dx, dy in directions:\n        ni, nj = i + dx, j + dy\n        if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '*':\n            count += 1\n    return count\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:2 + n]\n    \n    for i in range(n):\n        for j in range(m):\n            cell = grid[i][j]\n            if cell == '.':\n                # Empty cell: all neighbors must have no bombs\n                if count_bombs(grid, i, j, n, m) != 0:\n                    print(\"NO\")\n                    return\n            elif cell.isdigit():\n                # Digit cell: must have exactly that many bomb neighbors\n                expected = int(cell)\n                actual = count_bombs(grid, i, j, n, m)\n                if expected != actual:\n                    print(\"NO\")\n                    return\n            # Bomb cells ('*') are not checked directly\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.46636652946472}
{"eval_index": 150, "problem_id": 3807, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.97678899765015}
{"eval_index": 151, "problem_id": 4199, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    N = int(data[0])\n    K = int(data[1])\n    heights = list(map(int, data[2:2+N]))\n    \n    # Count friends with height >= K\n    count = 0\n    for h in heights:\n        if h >= K:\n            count += 1\n    \n    # Output result\n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.207143068313599}
{"eval_index": 152, "problem_id": 113, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef k_rounding(n, k):\n    \"\"\"Return the k-rounding of n.\"\"\"\n    # If k is 0, the answer is n itself\n    if k == 0:\n        return n\n    \n    # Count factors of 2 and 5 in n\n    count2 = 0\n    count5 = 0\n    temp = n\n    \n    while temp % 2 == 0:\n        count2 += 1\n        temp //= 2\n    \n    while temp % 5 == 0:\n        count5 += 1\n        temp //= 5\n    \n    # Calculate how many additional factors of 2 and 5 we need\n    needed2 = max(0, k - count2)\n    needed5 = max(0, k - count5)\n    \n    # Multiply n by 2^needed2 * 5^needed5\n    multiplier = (2 ** needed2) * (5 ** needed5)\n    return n * multiplier\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    result = k_rounding(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 29.66535758972168}
{"eval_index": 153, "problem_id": 3974, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    s = input().strip()\n    max_people = 0\n    current_inside = 0\n    total_people = 0\n    \n    for ch in s:\n        if ch == '+':\n            current_inside += 1\n            total_people = max(total_people, current_inside)\n        else:  # ch == '-'\n            if current_inside == 0:\n                # Someone must have been inside before shift started\n                total_people += 1\n            else:\n                current_inside -= 1\n    \n    print(total_people)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 32.45099997520447}
{"eval_index": 154, "problem_id": 4152, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Precompute powers of two up to 2*10^9\n    powers = set()\n    p = 1\n    while p <= 2 * 10**9:\n        powers.add(p)\n        p <<= 1\n    \n    # For each value, check if it can be paired\n    to_remove = 0\n    for val in a:\n        found = False\n        # Check all powers of two\n        for power in powers:\n            target = power - val\n            if target in freq:\n                # If target is same as val, need at least 2 occurrences\n                if target == val:\n                    if freq[target] > 1:\n                        found = True\n                        break\n                else:\n                    found = True\n                    break\n        if not found:\n            to_remove += 1\n    \n    print(to_remove)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.951598644256592}
{"eval_index": 155, "problem_id": 1073, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # Map directions to coordinate changes\n    dir_map = {'U': (0, 1), 'R': (1, 0), 'D': (0, -1), 'L': (-1, 0)}\n    \n    # Prefix sums of positions\n    prefix = [(0, 0)] * (n + 1)\n    for i in range(1, n + 1):\n        dx, dy = dir_map[s[i-1]]\n        prefix[i] = (prefix[i-1][0] + dx, prefix[i-1][1] + dy)\n    \n    # Count substrings where start and end positions are equal\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix[i] == prefix[j]:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.73687243461609}
{"eval_index": 156, "problem_id": 3835, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.3321704864502}
{"eval_index": 157, "problem_id": 4348, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = list(data[2])\n    \n    # Count occurrences of each character\n    cnt = [0] * 26\n    for ch in s:\n        cnt[ord(ch) - ord('a')] += 1\n    \n    # Remove characters according to the algorithm\n    removed = 0\n    for c in range(26):  # from 'a' to 'z'\n        if removed >= k:\n            break\n        # Try to remove as many of current character as possible\n        to_remove = min(cnt[c], k - removed)\n        cnt[c] -= to_remove\n        removed += to_remove\n    \n    # Build result string by removing characters from the end\n    result = []\n    for ch in reversed(s):\n        idx = ord(ch) - ord('a')\n        if cnt[idx] > 0:\n            result.append(ch)\n            cnt[idx] -= 1\n    \n    # Reverse back to original order\n    result.reverse()\n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.621230840682983}
{"eval_index": 158, "problem_id": 1283, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    grid = data[2:]\n    \n    # Initialize count array\n    cnt = [[0] * n for _ in range(n)]\n    \n    # Check horizontal placements\n    for i in range(n):\n        for j in range(n - k + 1):\n            valid = True\n            for d in range(k):\n                if grid[i][j + d] == '#':\n                    valid = False\n                    break\n            if valid:\n                for d in range(k):\n                    cnt[i][j + d] += 1\n    \n    # Check vertical placements\n    for i in range(n - k + 1):\n        for j in range(n):\n            valid = True\n            for d in range(k):\n                if grid[i + d][j] == '#':\n                    valid = False\n                    break\n            if valid:\n                for d in range(k):\n                    cnt[i + d][j] += 1\n    \n    # Find cell with maximum count\n    max_val = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        for j in range(n):\n            if cnt[i][j] > max_val:\n                max_val = cnt[i][j]\n                max_i, max_j = i, j\n    \n    # Output 1-indexed coordinates\n    print(max_i + 1, max_j + 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 54.72647213935852}
{"eval_index": 159, "problem_id": 3008, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.65793514251709}
{"eval_index": 160, "problem_id": 4121, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Stack to track heights modulo 2\n    stack = []\n    for height in a:\n        parity = height % 2\n        if stack and stack[-1] == parity:\n            stack.pop()\n        else:\n            stack.append(parity)\n    \n    # Wall can be completed if stack is empty or has exactly one element\n    # (which would be the final uniform height parity)\n    if len(stack) <= 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 46.16347146034241}
{"eval_index": 161, "problem_id": 607, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 0\n\n# Modular arithmetic functions\nmod_add = lambda a, b: (a + b) % MOD\nmod_sub = lambda a, b: (a - b) % MOD\nmod_mul = lambda a, b: (a * b) % MOD\n\n# Precompute factorials and inverse factorials modulo MOD\ndef precompute_factorials(n):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = mod_mul(fact[i - 1], i)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)  # Fermat's little theorem\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = mod_mul(inv_fact[i + 1], i + 1)\n    return fact, inv_fact\n\n# Compute binomial coefficient C(n, k) modulo MOD\ndef nCr(n, k, fact, inv_fact):\n    if k < 0 or k > n:\n        return 0\n    return mod_mul(fact[n], mod_mul(inv_fact[k], inv_fact[n - k]))\n\n# Main solution function\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    global MOD\n    MOD = int(data[1])\n    \n    # Precompute factorials up to n\n    fact, inv_fact = precompute_factorials(n)\n    \n    # Total permutations = n! modulo MOD\n    total_permutations = fact[n]\n    \n    # Initialize answer\n    ans = 0\n    \n    # Iterate over all possible lengths L of framed segments\n    for L in range(1, n + 1):\n        # Number of ways to choose the min and max values for the segment\n        # There are (n - L + 1) possible pairs (min, max) with max-min = L-1\n        ways_values = n - L + 1\n        \n        # Number of ways to arrange the L elements in the segment\n        # The L elements must be consecutive values from min to max\n        # They can be arranged in any order: L! ways\n        ways_arrange_segment = fact[L]\n        \n        # Number of ways to arrange the remaining (n-L) elements outside the segment\n        ways_arrange_outside = fact[n - L]\n        \n        # Number of positions to place the segment of length L in the permutation\n        # The segment can start at positions 1 to (n-L+1)\n        positions = n - L + 1\n        \n        # Contribution for this L:\n        # ways_values * ways_arrange_segment * ways_arrange_outside * positions\n        contribution = mod_mul(ways_values, ways_arrange_segment)\n        contribution = mod_mul(contribution, ways_arrange_outside)\n        contribution = mod_mul(contribution, positions)\n        \n        # Add to answer\n        ans = mod_add(ans, contribution)\n    \n    # Output the answer modulo MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 52.75003695487976}
{"eval_index": 162, "problem_id": 3858, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.7958984375}
{"eval_index": 163, "problem_id": 4467, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    reds = []\n    blues = []\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        reds.append((a, b))\n    for _ in range(N):\n        c = int(next(it))\n        d = int(next(it))\n        blues.append((c, d))\n    \n    # Sort reds by x ascending, then y ascending\n    reds.sort(key=lambda p: (p[0], p[1]))\n    # Sort blues by x ascending, then y ascending\n    blues.sort(key=lambda p: (p[0], p[1]))\n    \n    # Greedy matching: for each blue point, try to match with the red point\n    # that has the largest y less than blue's y, among reds with x less than blue's x.\n    # This is essentially a bipartite matching problem that can be solved greedily\n    # due to the constraints on distinct coordinates.\n    \n    # We'll process blues in sorted order and maintain a list of candidate reds\n    # that have x < current blue's x.\n    from bisect import bisect_left\n    \n    matched = [False] * N\n    red_idx = 0\n    count = 0\n    \n    # For each blue point\n    for bx, by in blues:\n        # Collect all reds with x < bx that are not yet matched\n        candidates = []\n        while red_idx < N and reds[red_idx][0] < bx:\n            if not matched[red_idx]:\n                candidates.append(reds[red_idx][1])\n            red_idx += 1\n        # Among candidates, choose the one with largest y < by\n        # Since y values are distinct, we can sort candidates and binary search\n        candidates.sort()\n        # Find the largest y < by\n        pos = bisect_left(candidates, by) - 1\n        if pos >= 0:\n            # Match this candidate\n            count += 1\n            # Mark the red as matched (we remove it from candidates)\n            # In implementation, we track matched by index, but here we simulate removal\n            # by not adding it back. Since we process reds in order, we can't easily\n            # mark which specific red was matched. Instead, we need a different approach.\n    \n    # The above approach is flawed because we lose track of which reds are matched.\n    # Let's implement a proper greedy algorithm:\n    # For each blue in sorted order, we consider all unmatched reds with x < blue.x\n    # and y < blue.y, and choose the one with the largest y.\n    # This can be done efficiently by maintaining a sorted list of available red y's.\n    \n    # Reset\n    matched = [False] * N\n    count = 0\n    \n    # Process blues in sorted order\n    for bx, by in blues:\n        best_red_idx = -1\n        best_y = -1\n        # Find the best unmatched red with x < bx and y < by\n        for i in range(N):\n            if not matched[i]:\n                rx, ry = reds[i]\n                if rx < bx and ry < by:\n                    if ry > best_y:\n                        best_y = ry\n                        best_red_idx = i\n        if best_red_idx != -1:\n            matched[best_red_idx] = True\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 45.44242739677429}
{"eval_index": 164, "problem_id": 1020, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    w, h, k = map(int, data)\n    total = 0\n    for i in range(k):\n        width = w - 4 * i\n        height = h - 4 * i\n        if width <= 0 or height <= 0:\n            break\n        perimeter = 2 * (width + height) - 4\n        total += perimeter\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.79508900642395}
{"eval_index": 165, "problem_id": 3375, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.74674081802368}
{"eval_index": 166, "problem_id": 4855, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    I = int(data[1])\n    # We need minimal citations C such that ceil(C/A) >= I\n    # Since ceil(C/A) >= I means C/A > I-1\n    # So C > A*(I-1)\n    # Minimal integer C is A*(I-1) + 1\n    # But we need to bribe scientists for additional citations beyond existing 0\n    # So bribes = C - 0 = C\n    # However, we must ensure ceil(C/A) == I exactly\n    # Let's compute minimal C where ceil(C/A) == I\n    # This is equivalent to: I-1 < C/A <= I\n    # The minimal integer C is A*(I-1) + 1\n    # Let's verify: ceil((A*(I-1)+1)/A) = ceil(I-1 + 1/A) = I since 1/A > 0\n    # So answer is A*(I-1) + 1\n    result = A * (I - 1) + 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.46600103378296}
{"eval_index": 167, "problem_id": 1469, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.0203423500061}
{"eval_index": 168, "problem_id": 3441, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.9649305343628}
{"eval_index": 169, "problem_id": 4559, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Handle zero case early\n    if 0 in arr:\n        print(0)\n        return\n    \n    LIMIT = 10**18\n    product = 1\n    \n    for num in arr:\n        # Check if multiplication would exceed limit\n        if product > LIMIT // num:\n            print(-1)\n            return\n        product *= num\n    \n    print(product)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.632092714309692}
{"eval_index": 170, "problem_id": 2355, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    output_lines = []\n    \n    for _ in range(t):\n        n = int(data[idx]); p = int(data[idx + 1])\n        idx += 2\n        edges_needed = 2 * n + p\n        edges = []\n        \n        # First, create a complete graph on vertices 1..(p+2) if p+2 <= n\n        # This ensures many edges while keeping subgraph constraints\n        # Actually, simpler: connect each vertex to the next ones in sequence\n        # until we have enough edges\n        \n        # Start with a base structure: connect vertex 1 to all others\n        for j in range(2, n + 1):\n            edges.append((1, j))\n        \n        # Then add more edges between other vertices\n        # We'll add edges in a systematic way to avoid violating constraints\n        i = 2\n        j = 3\n        while len(edges) < edges_needed:\n            edges.append((i, j))\n            j += 1\n            if j > n:\n                i += 1\n                j = i + 1\n        \n        # Output edges for this test case\n        for a, b in edges:\n            output_lines.append(f\"{a} {b}\")\n    \n    sys.stdout.write(\"\\n\".join(output_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.218846797943115}
{"eval_index": 171, "problem_id": 3134, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.22127771377563}
{"eval_index": 172, "problem_id": 4003, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    left = 0\n    right = n - 1\n    last = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] <= last and a[right] <= last:\n            break\n        \n        if a[left] > last and a[right] > last:\n            if a[left] < a[right]:\n                moves.append('L')\n                last = a[left]\n                left += 1\n            elif a[left] > a[right]:\n                moves.append('R')\n                last = a[right]\n                right -= 1\n            else:\n                # When both ends are equal, we need to look ahead\n                l_count = 1\n                r_count = 1\n                \n                # Count how many we can take from left side\n                i = left + 1\n                while i <= right and a[i] > a[i-1]:\n                    l_count += 1\n                    i += 1\n                \n                # Count how many we can take from right side\n                j = right - 1\n                while j >= left and a[j] > a[j+1]:\n                    r_count += 1\n                    j -= 1\n                \n                if l_count > r_count:\n                    moves.append('L')\n                    last = a[left]\n                    left += 1\n                else:\n                    moves.append('R')\n                    last = a[right]\n                    right -= 1\n        elif a[left] > last:\n            moves.append('L')\n            last = a[left]\n            left += 1\n        else:  # a[right] > last\n            moves.append('R')\n            last = a[right]\n            right -= 1\n    \n    print(len(moves))\n    print(''.join(moves))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.944074630737305}
{"eval_index": 173, "problem_id": 1302, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.67795610427856}
{"eval_index": 174, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.54054927825928}
{"eval_index": 175, "problem_id": 4516, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.01768279075623}
{"eval_index": 176, "problem_id": 1457, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef min_replacements(ai_name, phone_name):\n    \"\"\"Return minimum number of characters to replace with '#' to avoid phone_name as substring.\"\"\"\n    n, m = len(ai_name), len(phone_name)\n    if m > n:\n        return 0\n    \n    # Precompute prefix function for KMP\n    def compute_prefix(pattern):\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n    \n    lps = compute_prefix(phone_name)\n    positions = []\n    i = j = 0\n    while i < n:\n        if ai_name[i] == phone_name[j]:\n            i += 1\n            j += 1\n        if j == m:\n            positions.append(i - j)\n            j = lps[j - 1]\n        elif i < n and ai_name[i] != phone_name[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    if not positions:\n        return 0\n    \n    # Greedy interval covering\n    intervals = []\n    for start in positions:\n        intervals.append((start, start + m - 1))\n    \n    intervals.sort(key=lambda x: x[1])\n    count = 0\n    last_end = -1\n    for start, end in intervals:\n        if start > last_end:\n            count += 1\n            last_end = end\n    \n    return count\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    ai_name = data[0]\n    phone_name = data[1]\n    result = min_replacements(ai_name, phone_name)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 30.80323886871338}
{"eval_index": 177, "problem_id": 3820, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = data[2]\n    t = data[3]\n    \n    # Find the position of '*' in s\n    star_pos = s.find('*')\n    \n    # Case 1: No wildcard in s\n    if star_pos == -1:\n        if s == t:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n        return\n    \n    # Case 2: With wildcard\n    # Check if m >= n-1 (since '*' can be empty or have characters)\n    if m < n - 1:\n        print(\"NO\")\n        return\n    \n    # Split s into prefix and suffix around '*'\n    prefix = s[:star_pos]\n    suffix = s[star_pos + 1:]\n    \n    # Check if prefix matches the beginning of t\n    if not t.startswith(prefix):\n        print(\"NO\")\n        return\n    \n    # Check if suffix matches the end of t\n    # The middle part (wildcard replacement) should be between prefix and suffix\n    remaining_length = m - len(prefix) - len(suffix)\n    if remaining_length < 0:\n        print(\"NO\")\n        return\n    \n    # Verify suffix matches the end of t\n    if not t.endswith(suffix):\n        print(\"NO\")\n        return\n    \n    # All checks passed\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.38523769378662}
{"eval_index": 178, "problem_id": 4104, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 95.63016128540039}
{"eval_index": 179, "problem_id": 1031, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.93319368362427}
{"eval_index": 180, "problem_id": 3199, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.96250557899475}
{"eval_index": 181, "problem_id": 4877, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.readline().strip()\n    if not data:\n        return\n    a, b, h = map(int, data.split())\n    if h <= a:\n        print(1)\n        return\n    # effective progress per crawl (before the last crawl)\n    progress_per_crawl = a - b\n    # remaining height after first crawl\n    remaining = h - a\n    # number of full crawls needed for the remaining part\n    # ceil division: (remaining + progress_per_crawl - 1) // progress_per_crawl\n    crawls = 1 + (remaining + progress_per_crawl - 1) // progress_per_crawl\n    print(crawls)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.667865991592407}
{"eval_index": 182, "problem_id": 584, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    max_len_outside = 0\n    count_inside = 0\n    \n    i = 0\n    inside_parentheses = False\n    \n    while i < n:\n        if s[i] == '(':\n            inside_parentheses = True\n            i += 1\n            continue\n        elif s[i] == ')':\n            inside_parentheses = False\n            i += 1\n            continue\n        elif s[i] == '_':\n            i += 1\n            continue\n        else:\n            # Start of a word\n            start = i\n            while i < n and s[i].isalpha():\n                i += 1\n            word_len = i - start\n            \n            if inside_parentheses:\n                count_inside += 1\n            else:\n                if word_len > max_len_outside:\n                    max_len_outside = word_len\n            \n            # Skip any underscores or parentheses after the word\n            continue\n    \n    print(f\"{max_len_outside} {count_inside}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.63576579093933}
{"eval_index": 183, "problem_id": 3541, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.5202887058258}
{"eval_index": 184, "problem_id": 4701, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # DP approach: dp[i] = minimum value after i operations\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 1  # Starting value\n    \n    for i in range(N):\n        # Operation A: double\n        dp[i + 1] = min(dp[i + 1], dp[i] * 2)\n        # Operation B: add K\n        dp[i + 1] = min(dp[i + 1], dp[i] + K)\n    \n    print(dp[N])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.322688341140747}
{"eval_index": 185, "problem_id": 1887, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    row1 = [int(next(it)) for _ in range(n)]\n    row2 = [int(next(it)) for _ in range(n)]\n    \n    # dp0: max sum ending at position i, last taken from row1\n    # dp1: max sum ending at position i, last taken from row2\n    dp0 = dp1 = 0\n    \n    for i in range(n):\n        new_dp0 = max(dp0, dp1 + row1[i])  # take from row1\n        new_dp1 = max(dp1, dp0 + row2[i])  # take from row2\n        dp0, dp1 = new_dp0, new_dp1\n    \n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.614012718200684}
{"eval_index": 186, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.09630799293518}
{"eval_index": 187, "problem_id": 4380, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    # Check if there exists C in [1,3] such that A*B*C is odd\n    # A*B*C is odd iff all three numbers are odd\n    # So we need to check if there exists an odd C such that A and B are odd\n    # Since C can be 1,2,3, we just need to check if A and B are both odd\n    # If both are odd, we can choose C=1 (or any odd C) to make product odd\n    if A % 2 == 1 and B % 2 == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.322717428207397}
{"eval_index": 188, "problem_id": 2825, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    times = sorted(map(int, data[1:1+n]))\n    \n    total = 0\n    while n > 3:\n        # Strategy: send two fastest with two slowest\n        # Option 1: fastest shuttles two slowest\n        option1 = times[1] + times[0] + times[n-1] + times[1]\n        # Option 2: two slowest go together, fastest returns\n        option2 = times[n-1] + times[0] + times[n-2] + times[0]\n        total += min(option1, option2)\n        n -= 2  # Two slowest crossed\n    \n    # Base cases\n    if n == 3:\n        total += times[0] + times[1] + times[2]\n    elif n == 2:\n        total += times[1]\n    elif n == 1:\n        total += times[0]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.28830051422119}
{"eval_index": 189, "problem_id": 3150, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.4897437095642}
{"eval_index": 190, "problem_id": 4132, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # The minimum possible final health is the GCD of all health values\n    # because each attack reduces health by the attacker's current health,\n    # which is equivalent to subtracting multiples of health values.\n    # The process is analogous to repeatedly applying the Euclidean algorithm.\n    result = arr[0]\n    for i in range(1, n):\n        result = math.gcd(result, arr[i])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.555739641189575}
{"eval_index": 191, "problem_id": 2545, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    t = int(input_data[0])\n    results = []\n    idx = 1\n    for _ in range(t):\n        a = int(input_data[idx])\n        b = int(input_data[idx + 1])\n        idx += 2\n        # Check if both are zero initially\n        if a == 0 and b == 0:\n            results.append(\"YES\")\n            continue\n        # Check if one is zero but not both\n        if (a == 0 and b != 0) or (a != 0 and b == 0):\n            results.append(\"NO\")\n            continue\n        # Check if sum is divisible by 3\n        total = a + b\n        if total % 3 != 0:\n            results.append(\"NO\")\n            continue\n        # Check if the larger number is not more than twice the smaller\n        if max(a, b) > 2 * min(a, b):\n            results.append(\"NO\")\n            continue\n        results.append(\"YES\")\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.753440618515015}
{"eval_index": 192, "problem_id": 3406, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.67865133285522}
{"eval_index": 193, "problem_id": 4555, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B, K = map(int, data)\n    \n    # Calculate total numbers in range\n    total = B - A + 1\n    \n    # Determine how many numbers we actually need to take from each end\n    # If K is larger than half the range, we'll take all numbers\n    k_effective = min(K, total)\n    \n    # Generate the K smallest numbers\n    smallest = list(range(A, A + k_effective))\n    \n    # Generate the K largest numbers\n    largest = list(range(B - k_effective + 1, B + 1))\n    \n    # Combine and deduplicate while maintaining order\n    result_set = set(smallest + largest)\n    result = sorted(result_set)\n    \n    # Output each number on its own line\n    for num in result:\n        print(num)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.366604804992676}
{"eval_index": 194, "problem_id": 2931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.49972367286682}
{"eval_index": 195, "problem_id": 3851, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.8483636379242}
{"eval_index": 196, "problem_id": 4235, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 77.65805745124817}
{"eval_index": 197, "problem_id": 659, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.57419657707214}
{"eval_index": 198, "problem_id": 3515, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ninput = sys.stdin.readline\n\n# Read input\nN = int(input().strip())\ncities = []\nfor i in range(N):\n    y, d, r = map(int, input().split())\n    cities.append((y, d, r, i))  # (y-coordinate, min_distance, airport_time, original_index)\n\n# Sort cities by y-coordinate\ncities.sort(key=lambda x: x[0])\n\n# Map original index to sorted position\npos_in_sorted = [0] * N\nfor idx, (_, _, _, orig_idx) in enumerate(cities):\n    pos_in_sorted[orig_idx] = idx\n\n# Initialize distances array with infinity\ndist = [float('inf')] * N\nstart_pos = pos_in_sorted[0]  # City 1's position in sorted list\ndist[start_pos] = 0\n\n# Min-heap for Dijkstra: (current_time, city_position_in_sorted)\nheap = [(0, start_pos)]\n\nwhile heap:\n    current_time, current_pos = heapq.heappop(heap)\n    if current_time > dist[current_pos]:\n        continue\n    \n    y_curr, d_curr, r_curr, orig_idx_curr = cities[current_pos]\n    \n    # Find reachable cities to the right\n    # We need j such that |y_j - y_curr| >= d_curr\n    # For right side: y_j >= y_curr + d_curr\n    left_bound = y_curr + d_curr\n    # Binary search for first city with y >= left_bound\n    lo, hi = current_pos + 1, N - 1\n    first_right = N\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if cities[mid][0] >= left_bound:\n            first_right = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    \n    # Process all cities from first_right to end\n    for j in range(first_right, N):\n        y_j, d_j, r_j, orig_idx_j = cities[j]\n        flight_time = abs(y_j - y_curr)\n        total_time = current_time + r_curr + flight_time\n        if total_time < dist[j]:\n            dist[j] = total_time\n            heapq.heappush(heap, (total_time, j))\n    \n    # Find reachable cities to the left\n    # For left side: y_j <= y_curr - d_curr\n    right_bound = y_curr - d_curr\n    # Binary search for last city with y <= right_bound\n    lo, hi = 0, current_pos - 1\n    last_left = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if cities[mid][0] <= right_bound:\n            last_left = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    \n    # Process all cities from 0 to last_left\n    for j in range(last_left, -1, -1):\n        y_j, d_j, r_j, orig_idx_j = cities[j]\n        flight_time = abs(y_j - y_curr)\n        total_time = current_time + r_curr + flight_time\n        if total_time < dist[j]:\n            dist[j] = total_time\n            heapq.heappush(heap, (total_time, j))\n\n# Prepare output in original order (excluding city 1)\nresult = []\nfor i in range(1, N):\n    pos = pos_in_sorted[i]\n    if dist[pos] == float('inf'):\n        result.append(-1)\n    else:\n        result.append(dist[pos])\n\n# Print results\nprint('\\n'.join(map(str, result)))", "complexity_estimate": null, "runtime_sec": 105.53750395774841}
{"eval_index": 199, "problem_id": 4326, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    N = int(sys.stdin.readline().strip())\n    # Maximum groups of size >= 3 is floor(N / 3)\n    result = N // 3\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.634351968765259}
{"eval_index": 200, "problem_id": 2089, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs(start, n, adj):\n    dist = [-1] * (n + 1)\n    q = deque([start])\n    dist[start] = 0\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    s = int(next(it))\n    t = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    existing = [[False] * (n + 1) for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n        existing[u][v] = existing[v][u] = True\n    \n    dist_s = bfs(s, n, adj)\n    dist_t = bfs(t, n, adj)\n    \n    original_dist = dist_s[t]\n    \n    # Count pairs (u, v) where adding edge (u, v) does not decrease distance\n    count = 0\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if existing[u][v]:\n                continue\n            # Check if adding edge (u, v) would create a shorter path\n            # New possible distance via u-v: dist_s[u] + 1 + dist_t[v]\n            # or dist_s[v] + 1 + dist_t[u]\n            new_dist_via_uv = min(dist_s[u] + 1 + dist_t[v], dist_s[v] + 1 + dist_t[u])\n            if new_dist_via_uv >= original_dist:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 29.488817930221558}
{"eval_index": 201, "problem_id": 3684, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.87523198127747}
{"eval_index": 202, "problem_id": 4015, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data)\n    \n    # If n equals m, no moves needed\n    if n == m:\n        print(0)\n        return\n    \n    # Check if m is divisible by n\n    if m % n != 0:\n        print(-1)\n        return\n    \n    quotient = m // n\n    moves = 0\n    \n    # Repeatedly divide by 2 and 3 while possible\n    while quotient % 2 == 0:\n        quotient //= 2\n        moves += 1\n    while quotient % 3 == 0:\n        quotient //= 3\n        moves += 1\n    \n    # If quotient is 1, we successfully reduced to n\n    if quotient == 1:\n        print(moves)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.72313117980957}
{"eval_index": 203, "problem_id": 2964, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.66116070747375}
{"eval_index": 204, "problem_id": 3924, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 73.6108865737915}
{"eval_index": 205, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Mark visited cells\n    visited = [[False] * c for _ in range(r)]\n    \n    def dfs(i, j):\n        stack = [(i, j)]\n        visited[i][j] = True\n        while stack:\n            x, y = stack.pop()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and grid[nx][ny] != 'W':\n                    visited[nx][ny] = True\n                    stack.append((nx, ny))\n    \n    # Count islands from definite land\n    islands = 0\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'L' and not visited[i][j]:\n                islands += 1\n                dfs(i, j)\n    \n    # For clouds, we can treat them as water to minimize islands\n    # Since we already counted islands from definite land,\n    # clouds don't create new islands when treated as water\n    # So no additional processing needed\n    \n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.93714141845703}
{"eval_index": 206, "problem_id": 2595, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef min_operations(a, b):\n    if a == b:\n        return 0\n    \n    # Check if b can be obtained from a by multiplying/dividing by powers of 2\n    # Let's find the ratio and check if it's a power of 2\n    if a > b:\n        # Need to divide a to reach b\n        if a % b != 0:\n            return -1\n        ratio = a // b\n    else:\n        # Need to multiply a to reach b\n        if b % a != 0:\n            return -1\n        ratio = b // a\n    \n    # Check if ratio is a power of 2\n    if ratio & (ratio - 1) != 0:\n        return -1\n    \n    # Count how many times we need to multiply/divide by 2, 4, or 8\n    # We want to minimize operations, so use largest possible factor (8) first\n    operations = 0\n    while ratio > 1:\n        if ratio >= 8 and ratio % 8 == 0:\n            ratio //= 8\n        elif ratio >= 4 and ratio % 4 == 0:\n            ratio //= 4\n        elif ratio >= 2 and ratio % 2 == 0:\n            ratio //= 2\n        else:\n            return -1  # Should not happen if ratio is power of 2\n        operations += 1\n    \n    return operations\n\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        a, b = map(int, input().split())\n        results.append(str(min_operations(a, b)))\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 27.511518716812134}
{"eval_index": 207, "problem_id": 3806, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport math\\r\\n\\r\\ndef cross(ax, ay, bx, by):\\r\\n    return ax * by - ay * bx\\r\\n\\r\\ndef dot(ax, ay, bx, by):\\r\\n    return ax * bx + ay * by\\r\\n\\r\\ndef area_of_swept_region(n, px, py, vertices):\\r\\n    # Calculate polygon area using shoelace formula\\r\\n    polygon_area = 0.0\\r\\n    for i in range(n):\\r\\n        x1, y1 = vertices[i]\\r\\n        x2, y2 = vertices[(i + 1) % n]\\r\\n        polygon_area += cross(x1, y1, x2, y2)\\r\\n    polygon_area = abs(polygon_area) / 2.0\\r\\n    \\r\\n    # Calculate centroid of polygon\\r\\n    cx, cy = 0.0, 0.0\\r\\n    for i in range(n):\\r\\n        x1, y1 = vertices[i]\\r\\n        x2, y2 = vertices[(i + 1) % n]\\r\\n        factor = cross(x1, y1, x2, y2)\\r\\n        cx += (x1 + x2) * factor\\r\\n        cy += (y1 + y2) * factor\\r\\n    cx /= (6.0 * polygon_area)\\r\\n    cy /= (6.0 * polygon_area)\\r\\n    \\r\\n    # Calculate distance from P to centroid\\r\\n    dx = cx - px\\r\\n    dy = cy - py\\r\\n    distance = math.hypot(dx, dy)\\r\\n    \\r\\n    # Calculate perimeter of polygon\\r\\n    perimeter = 0.0\\r\\n    for i in range(n):\\r\\n        x1, y1 = vertices[i]\\r\\n        x2, y2 = vertices[(i + 1) % n]\\r\\n        perimeter += math.hypot(x2 - x1, y2 - y1)\\r\\n    \\r\\n    # Area = polygon_area + perimeter * distance +  * distance\\r\\n    result = polygon_area + perimeter * distance + math.pi * distance * distance\\r\\n    return result\\r\\n\\r\\ndef main():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    \\r\\n    it = iter(data)\\r\\n    n = int(next(it))\\r\\n    px = int(next(it))\\r\\n    py = int(next(it))\\r\\n    \\r\\n    vertices = []\\r\\n    for _ in range(n):\\r\\n        x = int(next(it))\\r\\n        y = int(next(it))\\r\\n        vertices.append((x, y))\\r\\n    \\r\\n    result = area_of_swept_region(n, px, py, vertices)\\r\\n    print(f\"{result:.15f}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()', 1188, 1189, 'illegal multibyte sequence')", "runtime_sec": 29.767524480819702}
{"eval_index": 208, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    \n    # Calculate days from best-by date to eating\n    # Bought A days before best-by, ate B days after buying\n    # So ate at: best-by - A + B\n    days_from_best_by = B - A\n    \n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.73973035812378}
{"eval_index": 209, "problem_id": 254, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.9948980808258}
{"eval_index": 210, "problem_id": 3754, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.3121955394745}
{"eval_index": 211, "problem_id": 4422, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    N = int(input_data[0])\n    K = int(input_data[1])\n    S = input_data[2]\n    if K < 1 or K > N:\n        return\n    result = list(S)\n    result[K-1] = result[K-1].lower()\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.35916256904602}
{"eval_index": 212, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.05233097076416}
{"eval_index": 213, "problem_id": 3816, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.12058544158936}
{"eval_index": 214, "problem_id": 4597, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    \n    # Calculate factorial modulo MOD\n    result = 1\n    for i in range(1, N + 1):\n        result = (result * i) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.942115545272827}
{"eval_index": 215, "problem_id": 1542, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    prices = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [int(next(it)) for _ in range(q)]\n    \n    # Sort prices to enable binary search\n    prices.sort()\n    \n    # Preprocess: For each query, find the number of shops with price <= m_i\n    results = []\n    for m in queries:\n        # Use bisect_right to find the first index where price > m\n        count = bisect.bisect_right(prices, m)\n        results.append(str(count))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.850865125656128}
{"eval_index": 216, "problem_id": 3353, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    P = int(next(it))\n    R = int(next(it))\n    L = int(next(it))\n    \n    # Node mapping: left bank = 0, right bank = 1, boulders = 2 to R+1\n    n = R + 2\n    adj = [[] for _ in range(n)]\n    \n    for _ in range(L):\n        u = int(next(it))\n        v = int(next(it))\n        # Convert to internal indices\n        if u == -2:\n            u = 0\n        elif u == -1:\n            u = 1\n        else:\n            u = u + 2\n        if v == -2:\n            v = 0\n        elif v == -1:\n            v = 1\n        else:\n            v = v + 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # BFS to find shortest path from left bank (0) to right bank (1)\n    def bfs():\n        if 0 == 1:\n            return []  # trivial case, but shouldn't happen\n        dist = [-1] * n\n        parent = [-1] * n\n        q = deque([0])\n        dist[0] = 0\n        while q:\n            u = q.popleft()\n            if u == 1:\n                break\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    parent[v] = u\n                    q.append(v)\n        if dist[1] == -1:\n            return None  # no path\n        # Reconstruct path\n        path = []\n        cur = 1\n        while cur != 0:\n            prev = parent[cur]\n            path.append((prev, cur))\n            cur = prev\n        path.reverse()\n        return path\n    \n    total_time = 0\n    people_crossed = 0\n    \n    for person in range(P):\n        path = bfs()\n        if path is None:\n            # cannot cross more people\n            left_behind = P - people_crossed\n            print(f\"{left_behind} people left behind\")\n            return\n        # This person crosses along this path\n        total_time += len(path)  # each edge takes 1 second\n        people_crossed += 1\n        # Remove edges used\n        for u, v in path:\n            adj[u].remove(v)\n            adj[v].remove(u)\n    \n    print(total_time)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 120.16192388534546}
{"eval_index": 217, "problem_id": 4633, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef sum_of_digits(x):\n    \"\"\"Return sum of digits of x.\"\"\"\n    return sum(int(d) for d in str(x))\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n_str = data[idx]\n        s = int(data[idx + 1])\n        idx += 2\n        \n        # If current sum of digits already <= s, answer is 0\n        if sum_of_digits(n_str) <= s:\n            out_lines.append('0')\n            continue\n        \n        n = int(n_str)\n        original_n = n\n        moves = 0\n        factor = 1  # factor represents 10^k\n        \n        # Process digits from right to left\n        while True:\n            digit = (n // factor) % 10\n            if digit == 0:\n                factor *= 10\n                continue\n            \n            # Add enough to make this digit 0 and carry over\n            add = (10 - digit) * factor\n            n += add\n            moves += add\n            \n            # Check if sum of digits <= s now\n            if sum_of_digits(str(n)) <= s:\n                out_lines.append(str(moves))\n                break\n            \n            factor *= 10\n\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.814764976501465}
{"eval_index": 218, "problem_id": 2488, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\ninput = sys.stdin.readline\n\ndef main():\n    N, D, A = map(int, input().split())\n    monsters = []\n    for _ in range(N):\n        x, h = map(int, input().split())\n        monsters.append((x, h))\n    \n    # Sort monsters by position\n    monsters.sort()\n    \n    positions = [x for x, _ in monsters]\n    healths = [h for _, h in monsters]\n    \n    # Binary search to find rightmost index within range [x, x+2D]\n    def find_rightmost(left_pos):\n        left = 0\n        right = N - 1\n        result = left\n        while left <= right:\n            mid = (left + right) // 2\n            if positions[mid] <= left_pos + 2 * D:\n                result = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Difference array for cumulative damage\n    diff = [0] * (N + 1)\n    total_damage = 0\n    bombs = 0\n    \n    for i in range(N):\n        total_damage += diff[i]\n        current_health = healths[i] - total_damage\n        \n        if current_health > 0:\n            # Need bombs to cover this monster\n            bombs_needed = (current_health + A - 1) // A  # ceil division\n            bombs += bombs_needed\n            damage = bombs_needed * A\n            total_damage += damage\n            \n            # Apply damage to future monsters within range\n            j = find_rightmost(positions[i])\n            if j + 1 < N + 1:\n                diff[j + 1] -= damage\n    \n    print(bombs)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 86.16912794113159}
{"eval_index": 219, "problem_id": 3489, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 1, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.98996019363403}
{"eval_index": 220, "problem_id": 4077, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.87283825874329}
{"eval_index": 221, "problem_id": 282, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    d = int(data[1])\n    s = data[2]\n    \n    # DP array: dp[i] = min jumps to reach position i (1-indexed)\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0  # start at position 1\n    \n    for i in range(1, n + 1):\n        if s[i-1] == '0' or dp[i] == float('inf'):\n            continue  # no lily or unreachable\n        \n        # try all possible jumps from i\n        for jump in range(1, d + 1):\n            next_pos = i + jump\n            if next_pos <= n and s[next_pos-1] == '1':\n                dp[next_pos] = min(dp[next_pos], dp[i] + 1)\n    \n    result = dp[n]\n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.09336543083191}
{"eval_index": 222, "problem_id": 3697, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.83982586860657}
{"eval_index": 223, "problem_id": 4480, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 21.68262267112732}
{"eval_index": 224, "problem_id": 2505, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.22552728652954}
{"eval_index": 225, "problem_id": 3244, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.3147954940796}
{"eval_index": 226, "problem_id": 4823, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read the input line\n    line = sys.stdin.readline().strip()\n    # Split into cards\n    cards = line.split()\n    \n    # Extract ranks from each card (first character)\n    ranks = [card[0] for card in cards]\n    \n    # Count frequency of each rank\n    freq = {}\n    for rank in ranks:\n        freq[rank] = freq.get(rank, 0) + 1\n    \n    # The strength is the maximum frequency\n    strength = max(freq.values())\n    \n    # Output the result\n    print(strength)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.88990044593811}
{"eval_index": 227, "problem_id": 2095, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    matrix = []\n    idx = 1\n    for i in range(n):\n        row = list(map(int, data[idx:idx + n]))\n        matrix.append(row)\n        idx += n\n    \n    good_cars = []\n    for i in range(n):\n        is_good = True\n        for j in range(n):\n            if i == j:\n                continue\n            val = matrix[i][j]\n            if val == 1 or val == 3:\n                is_good = False\n                break\n        if is_good:\n            good_cars.append(i + 1)\n    \n    print(len(good_cars))\n    if good_cars:\n        print(' '.join(map(str, good_cars)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.738049030303955}
{"eval_index": 228, "problem_id": 3927, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 147.47345638275146}
{"eval_index": 229, "problem_id": 4644, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().split()))\n        \n        # Count parity of elements\n        odd_count = sum(1 for x in a if x % 2 == 1)\n        even_count = n - odd_count\n        \n        # Conditions for possible odd sum:\n        # 1. There must be at least one odd number\n        # 2. If n == 1, the single element must be odd\n        # 3. If n > 1 and all numbers are even, impossible\n        # 4. If n > 1 and all numbers are odd, need n to be odd\n        \n        if odd_count == 0:\n            # All even numbers - sum always even\n            results.append(\"NO\")\n        elif n == 1:\n            # Single element - must be odd\n            results.append(\"YES\" if a[0] % 2 == 1 else \"NO\")\n        elif odd_count % 2 == 1:\n            # Odd count of odd numbers - sum is odd\n            results.append(\"YES\")\n        else:\n            # Even count of odd numbers - need to change parity\n            # We can change one odd to even or one even to odd\n            # But we need at least one even to change an odd to even\n            # Actually, with even count of odds, sum is even\n            # To make sum odd, we need to change parity of one element\n            # This requires both odd and even numbers present\n            if odd_count > 0 and even_count > 0:\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.328094005584717}
{"eval_index": 230, "problem_id": 2495, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    \n    # Initialize prefix sums and operations count\n    prefix_sum = 0\n    operations = 0\n    \n    # Process each element\n    for i in range(n):\n        prefix_sum += arr[i]\n        \n        # Condition 1: prefix sum should not be zero\n        if prefix_sum == 0:\n            # Need to change current element to make prefix sum non-zero\n            # We'll adjust by +1 or -1 depending on what gives alternating signs\n            # For simplicity, we always adjust by +1 (could also be -1)\n            operations += 1\n            arr[i] += 1\n            prefix_sum += 1  # Update prefix sum after adjustment\n        \n        # Condition 2: alternating signs between consecutive prefix sums\n        if i > 0:\n            prev_prefix = prefix_sum - arr[i]  # Prefix sum up to i-1\n            if (prev_prefix > 0 and prefix_sum > 0) or (prev_prefix < 0 and prefix_sum < 0):\n                # Same sign, need to adjust current element to flip sign\n                # We need to change prefix_sum to have opposite sign of prev_prefix\n                target_sign = -1 if prev_prefix > 0 else 1\n                \n                # Calculate required change to current element\n                # new_prefix = prev_prefix + (arr[i] + delta)\n                # We want sign(new_prefix) = target_sign\n                \n                # Simple approach: adjust by minimal amount to flip sign\n                # If both positive, make current prefix negative by decreasing enough\n                # If both negative, make current prefix positive by increasing enough\n                \n                # Calculate current difference from zero\n                if target_sign == 1:  # Need positive\n                    # Currently prefix_sum is negative or zero\n                    # Need to increase enough to make it positive\n                    delta = abs(prefix_sum) + 1\n                    operations += delta\n                    arr[i] += delta\n                    prefix_sum += delta\n                else:  # Need negative\n                    # Currently prefix_sum is positive or zero\n                    # Need to decrease enough to make it negative\n                    delta = abs(prefix_sum) + 1\n                    operations += delta\n                    arr[i] -= delta\n                    prefix_sum -= delta\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.803318977355957}
{"eval_index": 231, "problem_id": 3797, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.87997174263}
{"eval_index": 232, "problem_id": 4731, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    words = data[1:1+n]\n    \n    seen = set()\n    prev_last = ''\n    \n    for i, word in enumerate(words):\n        player = (i % 2) + 1  # Player 1 starts first\n        \n        # Rule 1: Word must not have been used before\n        if word in seen:\n            return f\"Player {player} lost\"\n        \n        # Rule 2: Word must start with last letter of previous word (except first word)\n        if i > 0:\n            if word[0] != prev_last:\n                return f\"Player {player} lost\"\n        \n        # Update state\n        seen.add(word)\n        prev_last = word[-1]\n    \n    return \"Fair Game\"\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "complexity_estimate": null, "runtime_sec": 19.172775268554688}
{"eval_index": 233, "problem_id": 1687, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the minimum element in the array\n    min_val = min(arr)\n    \n    # Check if all elements are divisible by min_val\n    for num in arr:\n        if num % min_val != 0:\n            print(-1)\n            return\n    \n    # If all divisible, check if min_val exists in the array\n    # (it always does since we took min from array)\n    print(min_val)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.755656003952026}
{"eval_index": 234, "problem_id": 3572, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 153.03620409965515}
{"eval_index": 235, "problem_id": 4781, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    K = int(data[0])  # initial player with box\n    N = int(data[1])  # number of questions\n    \n    # Current player holding the box (1-indexed)\n    current_player = K\n    # Total time elapsed in seconds\n    total_time = 0\n    # Explosion time: 3 minutes 30 seconds = 210 seconds\n    explosion_time = 210\n    \n    idx = 2\n    for _ in range(N):\n        T = int(data[idx])  # time for this question\n        Z = data[idx + 1]   # answer type\n        idx += 2\n        \n        # Add question time to total\n        total_time += T\n        \n        # Check if explosion happened during this question\n        if total_time >= explosion_time:\n            # Explosion occurred while current player had the box\n            print(current_player)\n            return\n        \n        # If answer is correct ('T'), pass box to left\n        if Z == 'T':\n            # Move to left (counter-clockwise)\n            current_player = current_player % 8 + 1\n        # For 'N' (false) or 'P' (skip), box stays with current player\n    \n    # If we processed all questions and explosion hasn't happened yet,\n    # it must happen after the last question. But problem states:\n    # \"The box will surely explode on a player's turn.\"\n    # Since we've processed all questions, the explosion must happen\n    # after the last question while current player has the box.\n    print(current_player)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.87288236618042}
{"eval_index": 236, "problem_id": 72, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.84539103507996}
{"eval_index": 237, "problem_id": 3277, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N, K, S = map(int, data[:3])\n    A = list(map(int, data[3:3+N]))\n    \n    # For K-smoothness, the array must have a repeating pattern of length K\n    # The sum of each K consecutive elements must be S\n    # We need to find the pattern of length K that requires minimal changes\n    \n    # We'll try all possible patterns of length K\n    # Each position i in the array corresponds to pattern position i % K\n    # For each pattern position p (0 <= p < K), we have values at indices p, p+K, p+2K, ...\n    # We need to choose a value for pattern[p] that minimizes changes for all its occurrences\n    \n    # For each pattern position p, we count frequency of each value in its occurrences\n    # The optimal value for pattern[p] is the one that appears most frequently\n    # (since we want to minimize changes, we keep the most common value)\n    \n    # However, we also need to ensure the sum constraint: sum(pattern) == S\n    # So we need to find pattern values that satisfy this while minimizing changes\n    \n    # Dynamic programming approach:\n    # dp[p][sum_so_far] = min changes for first p pattern positions with sum sum_so_far\n    \n    # Precompute for each pattern position p, the cost of choosing value v\n    # cost[p][v] = number of occurrences where A[index] != v\n    \n    # Initialize frequency counters for each pattern position\n    freq = [{} for _ in range(K)]\n    total_counts = [0] * K\n    \n    for i in range(N):\n        p = i % K\n        val = A[i]\n        freq[p][val] = freq[p].get(val, 0) + 1\n        total_counts[p] += 1\n    \n    # Precompute cost for each pattern position and possible value (0 to S)\n    INF = 10**9\n    dp = [[INF] * (S + 1) for _ in range(K + 1)]\n    dp[0][0] = 0\n    \n    for p in range(K):\n        for current_sum in range(S + 1):\n            if dp[p][current_sum] == INF:\n                continue\n            \n            # Try all possible values for pattern position p\n            for v in range(S + 1):\n                new_sum = current_sum + v\n                if new_sum > S:\n                    continue\n                \n                # Cost: total occurrences at position p minus frequency of value v\n                changes = total_counts[p] - freq[p].get(v, 0)\n                new_cost = dp[p][current_sum] + changes\n                \n                if new_cost < dp[p + 1][new_sum]:\n                    dp[p + 1][new_sum] = new_cost\n    \n    # The answer is dp[K][S]\n    print(dp[K][S])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 41.643441677093506}
{"eval_index": 238, "problem_id": 4335, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    S = data[1]\n    \n    # Check if N is even\n    if N % 2 != 0:\n        print(\"No\")\n        return\n    \n    half = N // 2\n    # Compare first half with second half\n    if S[:half] == S[half:]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.833935499191284}
{"eval_index": 239, "problem_id": 1894, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.11067605018616}
{"eval_index": 240, "problem_id": 3833, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 116.08784413337708}
{"eval_index": 241, "problem_id": 4875, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel (a, e, i, o, u, or y).\"\"\"\n    return c in 'aeiouy'\n\ndef pig_latin_word(word):\n    \"\"\"Convert a single word to Pig Latin.\"\"\"\n    # Find index of first vowel\n    for i, ch in enumerate(word):\n        if is_vowel(ch):\n            break\n    else:\n        # Should not happen per problem statement\n        return word + 'yay'\n    \n    if i == 0:\n        # Word begins with vowel\n        return word + 'yay'\n    else:\n        # Word begins with consonant(s)\n        return word[i:] + word[:i] + 'ay'\n\ndef main():\n    \"\"\"Read input and output translated text.\"\"\"\n    output_lines = []\n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            output_lines.append('')\n            continue\n        words = line.split()\n        translated = [pig_latin_word(w) for w in words]\n        output_lines.append(' '.join(translated))\n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 19.494393825531006}
{"eval_index": 242, "problem_id": 1650, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.99023962020874}
{"eval_index": 243, "problem_id": 3099, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.92144751548767}
{"eval_index": 244, "problem_id": 4049, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.96606063842773}
{"eval_index": 245, "problem_id": 569, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # If n > 26, impossible because there are only 26 letters\n    # and we need more than 26 distinct substrings of length 1\n    if n > 26:\n        print(-1)\n        return\n    \n    # Count frequency of each character\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    \n    # For each character that appears more than once,\n    # we need to change all but one occurrence\n    changes = 0\n    for count in freq:\n        if count > 1:\n            changes += count - 1\n    \n    print(changes)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.97161054611206}
{"eval_index": 246, "problem_id": 3782, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 136.82807183265686}
{"eval_index": 247, "problem_id": 4079, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_diverse(s: str) -> bool:\n    \"\"\"Check if a string is diverse.\"\"\"\n    # Convert characters to their positions in alphabet (0-indexed)\n    positions = [ord(ch) - ord('a') for ch in s]\n    \n    # Check for duplicates using set\n    if len(set(positions)) != len(positions):\n        return False\n    \n    # Check if positions form a contiguous segment\n    min_pos = min(positions)\n    max_pos = max(positions)\n    \n    # The range should be exactly (max_pos - min_pos + 1) and equal to length\n    return (max_pos - min_pos + 1) == len(positions)\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    results = []\n    \n    for i in range(1, n + 1):\n        s = data[i].strip()\n        if is_diverse(s):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.7954363822937}
{"eval_index": 248, "problem_id": 2738, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.57924008369446}
{"eval_index": 249, "problem_id": 3371, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.3347647190094}
{"eval_index": 250, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Special case: 1 is the strongest\n    if A == 1 and B != 1:\n        print(\"Alice\")\n    elif B == 1 and A != 1:\n        print(\"Bob\")\n    elif A == B:\n        print(\"Draw\")\n    elif A > B:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.50244426727295}
{"eval_index": 251, "problem_id": 1823, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    a = list(map(int, data[2:2+n]))\n    \n    # Count stresses for each possible excluded genre\n    best_genre = 1\n    min_stresses = float('inf')\n    \n    for x in range(1, k+1):\n        stresses = 0\n        prev = -1  # previous genre watched (after excluding x)\n        \n        for genre in a:\n            if genre == x:\n                continue  # skip this movie\n            \n            if prev == -1:\n                # first movie watched\n                prev = genre\n            elif genre != prev:\n                stresses += 1\n                prev = genre\n            # if genre == prev, no stress\n        \n        if stresses < min_stresses or (stresses == min_stresses and x < best_genre):\n            min_stresses = stresses\n            best_genre = x\n    \n    print(best_genre)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.288264513015747}
{"eval_index": 252, "problem_id": 3473, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.03064918518066}
{"eval_index": 253, "problem_id": 4590, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    # Compute prefix sums for both desks\n    prefix_A = [0] * (N + 1)\n    for i in range(N):\n        prefix_A[i + 1] = prefix_A[i] + A[i]\n    \n    prefix_B = [0] * (M + 1)\n    for i in range(M):\n        prefix_B[i + 1] = prefix_B[i] + B[i]\n    \n    # Try all possible numbers of books from desk A\n    max_books = 0\n    j = M  # Start from the maximum possible books from desk B\n    \n    for i in range(N + 1):\n        if prefix_A[i] > K:\n            break\n        \n        # Reduce j while the total time exceeds K\n        while j >= 0 and prefix_A[i] + prefix_B[j] > K:\n            j -= 1\n        \n        # Update maximum books\n        max_books = max(max_books, i + j)\n    \n    print(max_books)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.97435426712036}
{"eval_index": 254, "problem_id": 793, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.292809009552}
{"eval_index": 255, "problem_id": 3198, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 50.500922203063965}
{"eval_index": 256, "problem_id": 4886, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_guarantee_win(N_str, K_str):\n    \"\"\"\n    Determine if we can guarantee to win with K questions for N numbers.\n    \n    With K true/false questions, we can distinguish at most 2^K possibilities.\n    To guarantee finding the secret number among N possibilities, we need 2^K >= N.\n    \n    Since N can be up to 10^101, we need to handle arbitrarily large integers.\n    \"\"\"\n    # Convert strings to Python integers (handles arbitrarily large numbers)\n    N = int(N_str)\n    K = int(K_str)\n    \n    # Special case: if K >= N, we can ask \"Is the number 1?\", \"Is the number 2?\", etc.\n    # But actually, with K >= N, we have 2^K >= 2^N which is definitely >= N for N >= 2\n    # So we can just check 2^K >= N\n    \n    # Calculate 2^K\n    # For K up to N (which can be 10^101), 2^K would be astronomically huge\n    # But we only need to compare with N\n    # We can compute 2^K incrementally and stop once it exceeds N\n    \n    if K >= 63:  # 2^63 is already ~9.22e18, much larger than typical N\n        # For K >= 63, 2^K will definitely be >= N for N <= 10^101\n        # Actually, 2^63 > 10^18, and N max is 10^101, so we need K >= 336 (since 2^336 > 10^101)\n        # But let's handle it properly\n        if K >= 336:  # 2^336 > 10^101\n            return True\n        else:\n            # Compute 2^K and compare with N\n            power = 1\n            for _ in range(K):\n                power *= 2\n                if power >= N:\n                    return True\n            return power >= N\n    else:\n        # For smaller K, compute 2^K directly\n        power = 1 << K  # 2^K\n        return power >= N\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N_str, K_str = data[0], data[1]\n    \n    if can_guarantee_win(N_str, K_str):\n        print(\"Your wish is granted!\")\n    else:\n        print(\"You will become a flying monkey!\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 31.91090989112854}
{"eval_index": 257, "problem_id": 2724, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculate Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef can_pair_with_max_distance(students, tutors, max_dist):\n    \"\"\"Check if a perfect bipartite matching exists where all distances <= max_dist.\"\"\"\n    n = len(students)\n    # Build adjacency list: student i can be matched with tutor j if distance <= max_dist\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if manhattan_distance(students[i], tutors[j]) <= max_dist:\n                adj[i].append(j)\n    \n    # Hopcroft-Karp algorithm for bipartite matching\n    pair_u = [-1] * n  # which tutor is matched to student i\n    pair_v = [-1] * n  # which student is matched to tutor j\n    dist = [0] * n\n    \n    def bfs():\n        from collections import deque\n        q = deque()\n        for u in range(n):\n            if pair_u[u] == -1:\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = float('inf')\n        found = False\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if pair_v[v] == -1:\n                    found = True\n                elif dist[pair_v[v]] == float('inf'):\n                    dist[pair_v[v]] = dist[u] + 1\n                    q.append(pair_v[v])\n        return found\n    \n    def dfs(u):\n        for v in adj[u]:\n            if pair_v[v] == -1 or (dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v])):\n                pair_u[u] = v\n                pair_v[v] = u\n                return True\n        dist[u] = float('inf')\n        return False\n    \n    matching = 0\n    while bfs():\n        for u in range(n):\n            if pair_u[u] == -1 and dfs(u):\n                matching += 1\n    return matching == n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    students = [(int(next(it)), int(next(it))) for _ in range(n)]\n    tutors = [(int(next(it)), int(next(it))) for _ in range(n)]\n    \n    # Collect all possible distances\n    distances = []\n    for s in students:\n        for t in tutors:\n            distances.append(manhattan_distance(s, t))\n    distances = sorted(set(distances))\n    \n    # Binary search on the answer\n    left, right = 0, len(distances) - 1\n    answer = distances[-1]\n    while left <= right:\n        mid = (left + right) // 2\n        if can_pair_with_max_distance(students, tutors, distances[mid]):\n            answer = distances[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 40.581196308135986}
{"eval_index": 258, "problem_id": 3897, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.21016836166382}
{"eval_index": 259, "problem_id": 4617, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'def main():\\r\\n    # Read two lines of input\\r\\n    row1 = input().strip()\\r\\n    row2 = input().strip()\\r\\n    \\r\\n    # Check if the grid is symmetric after 180-degree rotation\\r\\n    # For a 2x3 grid, 180-degree rotation means:\\r\\n    # (1,1)  (2,3), (1,2)  (2,2), (1,3)  (2,1)\\r\\n    if (row1[0] == row2[2] and row1[1] == row2[1] and row1[2] == row2[0]):\\r\\n        print(\"YES\")\\r\\n    else:\\r\\n        print(\"NO\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()', 232, 233, 'illegal multibyte sequence')", "runtime_sec": 14.805471897125244}
{"eval_index": 260, "problem_id": 2036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.3019506931305}
{"eval_index": 261, "problem_id": 3322, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    # For each antique, store (shop_original, price_original, shop_knockoff, price_knockoff)\n    antiques = []\n    for _ in range(n):\n        a = int(next(it)) - 1  # 0-indexed\n        p = int(next(it))\n        b = int(next(it)) - 1  # 0-indexed\n        q = int(next(it))\n        antiques.append((a, p, b, q))\n    \n    # DP state: dp[mask][shop_set] = min cost\n    # mask: bitmask of antiques collected (n <= 100, but we can compress)\n    # shop_set: bitmask of shops visited (m <= 40)\n    INF = 10**18\n    \n    # Since n can be up to 100, we can't have mask of size 2^100.\n    # Instead, we process antiques one by one, updating DP for shop sets.\n    # dp[shop_set] = min cost to collect all antiques processed so far using exactly these shops\n    # Initialize with INF, dp[0] = 0\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    \n    for a, p, b, q in antiques:\n        new_dp = [INF] * (1 << m)\n        for mask in range(1 << m):\n            if dp[mask] == INF:\n                continue\n            # Option 1: buy original at shop a\n            cost1 = dp[mask] + p\n            new_mask1 = mask | (1 << a)\n            if cost1 < new_dp[new_mask1]:\n                new_dp[new_mask1] = cost1\n            \n            # Option 2: buy knockoff at shop b\n            cost2 = dp[mask] + q\n            new_mask2 = mask | (1 << b)\n            if cost2 < new_dp[new_mask2]:\n                new_dp[new_mask2] = cost2\n        dp = new_dp\n    \n    # Find minimum cost among shop sets with at most k shops\n    ans = INF\n    for mask in range(1 << m):\n        if bin(mask).count('1') <= k:\n            ans = min(ans, dp[mask])\n    \n    if ans == INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 37.98256254196167}
{"eval_index": 262, "problem_id": 4455, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    n, k = map(int, input().split())\n    skills = list(map(int, input().split()))\n    \n    # Count how many programmers have strictly lower skill than each programmer\n    # Sort skills with indices to count efficiently\n    sorted_indices = sorted(range(n), key=lambda i: skills[i])\n    \n    # Precompute lower skill counts using binary search\n    sorted_skills = sorted(skills)\n    lower_counts = [0] * n\n    for i in range(n):\n        # Count elements strictly less than skills[i]\n        # Use bisect_left to find first position >= skills[i], then count elements before it\n        import bisect\n        lower_counts[i] = bisect.bisect_left(sorted_skills, skills[i])\n    \n    # Adjust for quarrels: subtract 1 for each quarrel where the other has lower skill\n    quarrel_adj = [0] * n\n    for _ in range(k):\n        x, y = map(int, input().split())\n        x -= 1  # Convert to 0-based indexing\n        y -= 1\n        \n        # If x has higher skill than y, x loses y as potential mentee\n        if skills[x] > skills[y]:\n            quarrel_adj[x] += 1\n        # If y has higher skill than x, y loses x as potential mentee\n        if skills[y] > skills[x]:\n            quarrel_adj[y] += 1\n    \n    # Compute final answer for each programmer\n    result = [0] * n\n    for i in range(n):\n        result[i] = lower_counts[i] - quarrel_adj[i]\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 27.095766067504883}
{"eval_index": 263, "problem_id": 1322, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 151.66063785552979}
{"eval_index": 264, "problem_id": 3744, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 139.27810096740723}
{"eval_index": 265, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    # Dictionary to store count of ways each sum can be expressed\n    ways_count = {}\n    \n    # We only need to check cubes up to cube root of m\n    max_i = int(m ** (1/3)) + 2  # Add 2 for safety margin\n    \n    # Generate all sums of two positive cubes\n    for i in range(1, max_i):\n        i_cube = i * i * i\n        if i_cube > m:\n            break\n            \n        for j in range(i, max_i):\n            j_cube = j * j * j\n            sum_cubes = i_cube + j_cube\n            \n            if sum_cubes > m:\n                break\n            \n            # Count this representation\n            ways_count[sum_cubes] = ways_count.get(sum_cubes, 0) + 1\n    \n    # Find the largest number with at least 2 representations\n    largest_bus = 0\n    for num, count in ways_count.items():\n        if count >= 2 and num <= m:\n            if num > largest_bus:\n                largest_bus = num\n    \n    return largest_bus if largest_bus > 0 else \"none\"\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    result = find_largest_bus_number(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.08105230331421}
{"eval_index": 266, "problem_id": 725, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    idx = 2\n    colored = False\n    for _ in range(n):\n        for _ in range(m):\n            pixel = data[idx]\n            idx += 1\n            if pixel in {'C', 'M', 'Y'}:\n                colored = True\n                break\n        if colored:\n            break\n    print(\"#Color\" if colored else \"#Black&White\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.789122343063354}
{"eval_index": 267, "problem_id": 3636, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.3533296585083}
{"eval_index": 268, "problem_id": 4151, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    \n    # Map each value to its first and last occurrence indices\n    first_occurrence = {}\n    last_occurrence = {}\n    for i, val in enumerate(a):\n        if val not in first_occurrence:\n            first_occurrence[val] = i\n        last_occurrence[val] = i\n    \n    # Merge intervals where values must be equal in b\n    intervals = []\n    for val in first_occurrence:\n        l = first_occurrence[val]\n        r = last_occurrence[val]\n        intervals.append((l, r))\n    \n    # Sort intervals by start position\n    intervals.sort()\n    \n    # Merge overlapping intervals\n    merged = []\n    for l, r in intervals:\n        if not merged or merged[-1][1] < l:\n            merged.append([l, r])\n        else:\n            merged[-1][1] = max(merged[-1][1], r)\n    \n    # Count segments where b can increase\n    # Each merged interval forces b to be constant within it\n    # Between intervals, b can either stay same or increase by 1\n    segments = len(merged)\n    # Number of gaps between segments where we can choose increase or not\n    gaps = segments - 1\n    # For each gap, 2 choices: increase or not\n    # Total possibilities: 2^gaps\n    ans = pow(2, gaps, MOD)\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 62.29888868331909}
{"eval_index": 269, "problem_id": 1022, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.31530237197876}
{"eval_index": 270, "problem_id": 3316, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.33978366851807}
{"eval_index": 271, "problem_id": 4734, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef extend_name(Y, P):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Rule 3: If Y already ends with \"ex\"\n    if Y.endswith('ex'):\n        return Y + P\n    \n    # Rule 1: If Y ends with 'e'\n    if Y[-1] == 'e':\n        return Y + 'x' + P\n    \n    # Rule 2: If Y ends with any other vowel (a, i, o, u)\n    if Y[-1] in vowels and Y[-1] != 'e':\n        return Y[:-1] + 'ex' + P\n    \n    # Default case: Y + \"ex\" + P\n    return Y + 'ex' + P\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) != 2:\n        return\n    Y, P = data[0], data[1]\n    result = extend_name(Y, P)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.00438690185547}
{"eval_index": 272, "problem_id": 962, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.02550673484802}
{"eval_index": 273, "problem_id": 3882, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.84960770606995}
{"eval_index": 274, "problem_id": 4107, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    # dp[i] = minimum cost to cover first i rooms (1-indexed)\n    INF = 10**18\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    \n    # Precompute prefix sums for direct connection costs\n    prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] + i\n    \n    # Process rooms\n    for i in range(1, n + 1):\n        # Option 1: Connect room i directly\n        dp[i] = min(dp[i], dp[i - 1] + i)\n        \n        # Option 2: Place router at room i if possible\n        if s[i - 1] == '1':\n            left = max(1, i - k)\n            right = min(n, i + k)\n            # Cost to cover up to right using router at i\n            # Rooms left..right are covered by router costing i\n            # Need to cover rooms 1..left-1 optimally\n            cost = dp[left - 1] + i\n            # Update dp for all positions up to right\n            for j in range(right, left - 1, -1):\n                if dp[j] > cost:\n                    dp[j] = cost\n                else:\n                    break\n    \n    print(dp[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 49.91520071029663}
{"eval_index": 275, "problem_id": 1999, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\nreadline = sys.stdin.readline\n\nn = int(readline())\na = list(map(int, readline().split()))\n\n# Use a min-heap to track the smallest value with at least 2 occurrences\n# Each element in heap is (value, index)\n# We'll maintain the array and process operations\n\n# We need to efficiently find the first two occurrences of the smallest value with duplicates\n# Approach: Use a dictionary to map values to a list of indices where they appear\n# Use a min-heap to track values that have at least 2 occurrences\n\nfrom collections import defaultdict, deque\n\n# Map value to deque of indices (sorted ascending)\npos = defaultdict(deque)\n# Min-heap of values with at least 2 occurrences\nheap = []\n# Set to avoid duplicate values in heap\nin_heap = set()\n\n# Initialize\nfor i, val in enumerate(a):\n    pos[val].append(i)\n    if len(pos[val]) == 2 and val not in in_heap:\n        heapq.heappush(heap, val)\n        in_heap.add(val)\n\n# Process operations\nwhile heap:\n    x = heapq.heappop(heap)\n    in_heap.remove(x)\n    \n    # Get the first two occurrences\n    indices = pos[x]\n    if len(indices) < 2:\n        # This shouldn't happen if we maintain heap correctly\n        continue\n    \n    i1 = indices.popleft()  # leftmost (first occurrence)\n    i2 = indices.popleft()  # second occurrence\n    \n    # Remove a[i1] (by marking as None) and update a[i2] to 2*x\n    a[i1] = None\n    a[i2] = 2 * x\n    \n    # Update positions for the new value 2*x\n    new_val = 2 * x\n    pos[new_val].append(i2)\n    # Keep the deque sorted (i2 is already the largest since we process left to right)\n    # But we need to maintain sorted order for future operations\n    # We'll sort when needed\n    \n    # Check if x still has at least 2 occurrences\n    if len(pos[x]) >= 2 and x not in in_heap:\n        heapq.heappush(heap, x)\n        in_heap.add(x)\n    \n    # Check if new_val now has at least 2 occurrences\n    if len(pos[new_val]) >= 2 and new_val not in in_heap:\n        heapq.heappush(heap, new_val)\n        in_heap.add(new_val)\n\n# Build final array by removing None values\nresult = [val for val in a if val is not None]\n\n# Output\nprint(len(result))\nprint(' '.join(map(str, result)))", "complexity_estimate": null, "runtime_sec": 40.01201844215393}
{"eval_index": 276, "problem_id": 3502, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 153.97400283813477}
{"eval_index": 277, "problem_id": 4165, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_form_polygon(N, lengths):\n    \"\"\"\n    Check if an N-sided polygon can be formed using the given side lengths.\n    \n    According to the theorem: A polygon can be formed if and only if\n    the longest side is strictly less than the sum of all other sides.\n    \"\"\"\n    # Find the longest side\n    max_length = max(lengths)\n    \n    # Calculate sum of all sides\n    total_sum = sum(lengths)\n    \n    # Check the condition: longest side < sum of all other sides\n    # This is equivalent to: longest side < total_sum - longest side\n    # Or: 2 * longest side < total_sum\n    if max_length < total_sum - max_length:\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    \n    if not data:\n        return\n    \n    # First value is N\n    N = int(data[0])\n    \n    # Next N values are the side lengths\n    lengths = list(map(int, data[1:1+N]))\n    \n    # Check if polygon can be formed\n    result = can_form_polygon(N, lengths)\n    \n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.11947727203369}
{"eval_index": 278, "problem_id": 1437, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\n# Mapping from character to its base-64 value (0-63)\nchar_to_val = {}\n# digits\nfor i in range(10):\n    char_to_val[str(i)] = i\n# uppercase letters\nfor i in range(26):\n    char_to_val[chr(ord('A') + i)] = 10 + i\n# lowercase letters\nfor i in range(26):\n    char_to_val[chr(ord('a') + i)] = 36 + i\nchar_to_val['-'] = 62\nchar_to_val['_'] = 63\n\ndef count_pairs(s):\n    \"\"\"\n    Count number of pairs (a,b) of length |s| strings such that a & b = s.\n    For each character position independently:\n    Let v = value of s[i] (0-63).\n    We need count of pairs (x,y) in [0,63] such that (x & y) = v.\n    Then total answer = product over i of count_i, modulo MOD.\n    \"\"\"\n    ans = 1\n    for ch in s:\n        v = char_to_val[ch]\n        # Count pairs (x,y) with x & y = v\n        # For each bit position (6 bits total, since 64=2^6):\n        # If bit in v is 1: both x and y must have that bit = 1 -> 1 possibility for that bit\n        # If bit in v is 0: possibilities for (x_bit, y_bit) are (0,0), (0,1), (1,0) -> 3 possibilities\n        # So count = 3^{number of zero bits in v}\n        zero_bits = 0\n        for bit in range(6):\n            if not (v >> bit) & 1:\n                zero_bits += 1\n        ways = pow(3, zero_bits, MOD)\n        ans = (ans * ways) % MOD\n    return ans\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(count_pairs(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 32.126906871795654}
{"eval_index": 279, "problem_id": 3863, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.00850820541382}
{"eval_index": 280, "problem_id": 4569, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    s = sys.stdin.readline().strip()\n    \n    # Define the cycle\n    cycle = [\"Sunny\", \"Cloudy\", \"Rainy\"]\n    \n    # Find the index of today's weather in the cycle\n    today_index = cycle.index(s)\n    \n    # Calculate tomorrow's index (next in cycle, wrap around)\n    tomorrow_index = (today_index + 1) % 3\n    \n    # Output tomorrow's weather\n    print(cycle[tomorrow_index])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.659977436065674}
{"eval_index": 281, "problem_id": 1428, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, C = map(int, input().split())\n    D = [list(map(int, input().split())) for _ in range(C)]\n    grid = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Count how many cells of each original color are in each modulo class\n    cnt = [[0] * C for _ in range(3)]\n    for i in range(N):\n        for j in range(N):\n            mod = (i + j) % 3\n            color = grid[i][j] - 1  # 0-indexed\n            cnt[mod][color] += 1\n    \n    # Precompute cost for each modulo class to be painted with each color\n    cost = [[0] * C for _ in range(3)]\n    for mod in range(3):\n        for new_color in range(C):\n            total = 0\n            for orig_color in range(C):\n                total += cnt[mod][orig_color] * D[orig_color][new_color]\n            cost[mod][new_color] = total\n    \n    # Try all triples of distinct colors for the three modulo classes\n    ans = float('inf')\n    for c0 in range(C):\n        for c1 in range(C):\n            if c1 == c0:\n                continue\n            for c2 in range(C):\n                if c2 == c0 or c2 == c1:\n                    continue\n                total_cost = cost[0][c0] + cost[1][c1] + cost[2][c2]\n                if total_cost < ans:\n                    ans = total_cost\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.284013509750366}
{"eval_index": 282, "problem_id": 3317, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input efficiently\ninput = sys.stdin.readline\n\n# Read the string\ns = input().strip()\nn = len(s)\n\n# Precompute suffix array and LCP array using doubling algorithm\n# Since n <= 100000, we need O(n log n) preprocessing\n\n# Helper function for suffix array construction\ndef build_suffix_array(txt):\n    n = len(txt)\n    # Initial ranks based on characters\n    rank = [ord(c) for c in txt]\n    sa = list(range(n))\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        # Sort by (rank[i], rank[i+k]) pairs\n        sa.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        \n        # Assign new ranks\n        tmp[sa[0]] = 0\n        for i in range(1, n):\n            prev, curr = sa[i-1], sa[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            curr_key = (rank[curr], rank[curr + k] if curr + k < n else -1)\n            tmp[curr] = tmp[prev] + (prev_key != curr_key)\n        \n        rank, tmp = tmp, rank\n        if rank[sa[-1]] == n-1:\n            break\n        k <<= 1\n    \n    return sa\n\n# Build LCP array using Kasai algorithm\ndef build_lcp_array(txt, sa):\n    n = len(txt)\n    rank = [0] * n\n    for i, pos in enumerate(sa):\n        rank[pos] = i\n    \n    lcp = [0] * (n-1)\n    h = 0\n    for i in range(n):\n        if rank[i] > 0:\n            j = sa[rank[i]-1]\n            while i+h < n and j+h < n and txt[i+h] == txt[j+h]:\n                h += 1\n            lcp[rank[i]-1] = h\n            if h > 0:\n                h -= 1\n    return lcp\n\n# Build RMQ for LCP array\nclass RMQ:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.k = int(math.log2(self.n)) + 1\n        self.st = [[0] * self.k for _ in range(self.n)]\n        \n        # Initialize sparse table\n        for i in range(self.n):\n            self.st[i][0] = arr[i]\n        \n        # Build sparse table\n        j = 1\n        while (1 << j) <= self.n:\n            i = 0\n            while i + (1 << j) - 1 < self.n:\n                self.st[i][j] = min(self.st[i][j-1], self.st[i + (1 << (j-1))][j-1])\n                i += 1\n            j += 1\n    \n    def query(self, l, r):\n        # l and r are inclusive indices in the original array\n        if l > r:\n            return 0\n        j = int(math.log2(r - l + 1))\n        return min(self.st[l][j], self.st[r - (1 << j) + 1][j])\n\n# Build suffix array and LCP array\nsa = build_suffix_array(s)\nlcp = build_lcp_array(s, sa)\n\n# Build RMQ for LCP array\nrmq = RMQ(lcp)\n\n# Build rank array for O(1) lookup\nrank = [0] * n\nfor i, pos in enumerate(sa):\n    rank[pos] = i\n\n# Process queries\nq = int(input())\noutput = []\nfor _ in range(q):\n    i, j = map(int, input().split())\n    \n    # Get ranks of suffixes starting at i and j\n    ri, rj = rank[i], rank[j]\n    \n    # Ensure ri < rj for RMQ query\n    if ri > rj:\n        ri, rj = rj, ri\n    \n    # The LCP between suffixes at positions i and j is the minimum in lcp[ri..rj-1]\n    # But we need to handle the case when ri == rj (identical suffixes)\n    if ri == rj:\n        # Same starting position, but since i < j by problem statement, this shouldn't happen\n        # But if it does, the longest common prefix is the remaining string length\n        output.append(n - i)\n    else:\n        # Query RMQ for lcp[ri..rj-1]\n        lcp_value = rmq.query(ri, rj-1)\n        # The answer is the LCP value\n        output.append(lcp_value)\n\n# Print all answers\nprint('\\n'.join(map(str, output)))", "complexity_estimate": null, "runtime_sec": 54.816643953323364}
{"eval_index": 283, "problem_id": 4247, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    count = 0\n    for i in range(1, n-1):\n        # Get the three consecutive elements\n        triple = [p[i-1], p[i], p[i+1]]\n        # Sort to find the second smallest\n        sorted_triple = sorted(triple)\n        # Check if p[i] is the second smallest\n        if p[i] == sorted_triple[1]:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.605990171432495}
{"eval_index": 284, "problem_id": 552, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.43551182746887}
{"eval_index": 285, "problem_id": 3451, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.96076154708862}
{"eval_index": 286, "problem_id": 4428, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    d = list(map(int, data[1:1+n]))\n    \n    # Two-pointer approach\n    left = 0\n    right = n - 1\n    sum1 = 0\n    sum3 = 0\n    max_sum = 0\n    \n    while left <= right:\n        if sum1 < sum3:\n            sum1 += d[left]\n            left += 1\n        elif sum1 > sum3:\n            sum3 += d[right]\n            right -= 1\n        else:  # sum1 == sum3\n            max_sum = sum1  # update maximum\n            # Try to extend both sides\n            if left <= right:\n                sum1 += d[left]\n                left += 1\n            else:\n                break\n    \n    # Check if last equal sums should be considered\n    if sum1 == sum3:\n        max_sum = max(max_sum, sum1)\n    \n    print(max_sum)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.11646294593811}
{"eval_index": 287, "problem_id": 2325, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.7196660041809}
{"eval_index": 288, "problem_id": 3494, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 101.39942669868469}
{"eval_index": 289, "problem_id": 4916, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    idx = 0\n    n = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    # positions[i] will store list of (x, y) positions for number i+1\n    positions = [[] for _ in range(k)]\n    \n    for i in range(n):\n        for j in range(n):\n            val = int(data[idx]); idx += 1\n            if 1 <= val <= k:\n                positions[val-1].append((i, j))\n    \n    # Check if any number from 1 to k has no tiles\n    for i in range(k):\n        if not positions[i]:\n            print(-1)\n            return\n    \n    # DP[i][j] = min total distance to reach tile j of number i+1\n    # Initialize for number 1\n    m1 = len(positions[0])\n    dp = [0] * m1\n    \n    # Process numbers 2 to k\n    for i in range(1, k):\n        m_prev = len(positions[i-1])\n        m_curr = len(positions[i])\n        new_dp = [float('inf')] * m_curr\n        \n        for curr_idx in range(m_curr):\n            x_curr, y_curr = positions[i][curr_idx]\n            for prev_idx in range(m_prev):\n                x_prev, y_prev = positions[i-1][prev_idx]\n                dist = abs(x_curr - x_prev) + abs(y_curr - y_prev)\n                new_dp[curr_idx] = min(new_dp[curr_idx], dp[prev_idx] + dist)\n        \n        dp = new_dp\n    \n    # Answer is min of dp for number k\n    print(min(dp))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.967124700546265}
{"eval_index": 290, "problem_id": 1842, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 75.08854579925537}
{"eval_index": 291, "problem_id": 3753, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(1 << 25)\n\nread = sys.stdin.readline\n\nn, m = map(int, read().split())\ngrid = [read().strip() for _ in range(n)]\n\n# BFS from (1,1) to find reachable cells\nfrom collections import deque\ndef bfs(start_r, start_c, target_r, target_c):\n    q = deque()\n    q.append((start_r, start_c))\n    visited = [[False] * m for _ in range(n)]\n    visited[start_r][start_c] = True\n    while q:\n        r, c = q.popleft()\n        if r == target_r and c == target_c:\n            return True\n        # down\n        if r + 1 < n and grid[r+1][c] == '.' and not visited[r+1][c]:\n            visited[r+1][c] = True\n            q.append((r+1, c))\n        # right\n        if c + 1 < m and grid[r][c+1] == '.' and not visited[r][c+1]:\n            visited[r][c+1] = True\n            q.append((r, c+1))\n    return False\n\n# If already blocked\nif not bfs(0, 0, n-1, m-1):\n    print(0)\n    sys.exit()\n\n# Find all cells on any path from (1,1) to (n,m)\n# We can do BFS from start and BFS from end, then intersect\nfrom_start = [[False] * m for _ in range(n)]\nq = deque()\nq.append((0, 0))\nfrom_start[0][0] = True\nwhile q:\n    r, c = q.popleft()\n    if r + 1 < n and grid[r+1][c] == '.' and not from_start[r+1][c]:\n        from_start[r+1][c] = True\n        q.append((r+1, c))\n    if c + 1 < m and grid[r][c+1] == '.' and not from_start[r][c+1]:\n        from_start[r][c+1] = True\n        q.append((r, c+1))\n\nfrom_end = [[False] * m for _ in range(n)]\nq = deque()\nq.append((n-1, m-1))\nfrom_end[n-1][m-1] = True\nwhile q:\n    r, c = q.popleft()\n    if r - 1 >= 0 and grid[r-1][c] == '.' and not from_end[r-1][c]:\n        from_end[r-1][c] = True\n        q.append((r-1, c))\n    if c - 1 >= 0 and grid[r][c-1] == '.' and not from_end[r][c-1]:\n        from_end[r][c-1] = True\n        q.append((r, c-1))\n\n# Cells that are on some path\non_path = []\nfor i in range(n):\n    for j in range(m):\n        if from_start[i][j] and from_end[i][j]:\n            on_path.append((i, j))\n\n# Now we need to find minimum vertices to remove to disconnect (1,1) and (n,m)\n# Since moves are only down/right, the graph is a DAG.\n# The problem reduces to finding minimum cut in this DAG with unit capacities.\n# But we can think simpler: all paths go through cells with increasing (i+j).\n# Group cells by (i+j). For each sum s from 2 to n+m-2, count cells with that sum that are on_path.\n# The answer is the minimum over these counts.\n# Because any path must take exactly one cell from each diagonal (i+j constant).\n# So blocking all cells in a diagonal blocks all paths.\n# But we must exclude (1,1) and (n,m) which are sums 2 and n+m.\n\ncnt = {}\nfor i, j in on_path:\n    s = i + j\n    if s == 0 or s == n + m - 2:  # (1,1) sum=0? Actually (0,0) sum=0, (n-1,m-1) sum=n+m-2\n        continue\n    cnt[s] = cnt.get(s, 0) + 1\n\nif not cnt:\n    # Should not happen since we already checked reachable\n    print(0)\nelse:\n    print(min(cnt.values()))", "complexity_estimate": null, "runtime_sec": 80.11337757110596}
{"eval_index": 292, "problem_id": 4847, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Function to calculate triangle area using given formula\ndef triangle_area(x1, y1, x2, y2, x3, y3):\n    return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0\n\n# Function to check if point is inside or on the border of triangle\ndef point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    # Calculate area of main triangle\n    area_abc = triangle_area(x1, y1, x2, y2, x3, y3)\n    \n    # Calculate areas of three subtriangles formed by point and triangle vertices\n    area_pbc = triangle_area(px, py, x2, y2, x3, y3)\n    area_apc = triangle_area(x1, y1, px, py, x3, y3)\n    area_abp = triangle_area(x1, y1, x2, y2, px, py)\n    \n    # Point is inside or on border if sum of subtriangle areas equals main triangle area\n    # Using small epsilon for floating point comparison\n    return abs(area_abc - (area_pbc + area_apc + area_abp)) < 1e-9\n\ndef main():\n    # Read triangle vertices\n    x1, y1 = map(int, sys.stdin.readline().split())\n    x2, y2 = map(int, sys.stdin.readline().split())\n    x3, y3 = map(int, sys.stdin.readline().split())\n    \n    # Read number of apple trees\n    n = int(sys.stdin.readline().strip())\n    \n    # Count trees inside triangle\n    count = 0\n    \n    # Process each apple tree\n    for _ in range(n):\n        px, py = map(int, sys.stdin.readline().split())\n        if point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n            count += 1\n    \n    # Calculate area of triangle\n    area = triangle_area(x1, y1, x2, y2, x3, y3)\n    \n    # Output results with required formatting\n    print(f\"{area:.1f}\")\n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 30.240915536880493}
{"eval_index": 293, "problem_id": 2782, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.77131581306458}
{"eval_index": 294, "problem_id": 3949, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.74543714523315}
{"eval_index": 295, "problem_id": 4172, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    \n    # Prefix sums for efficient calculation\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + a[i]\n    \n    ans = float('inf')\n    \n    # Try to make each value the target\n    i = 0\n    while i < n:\n        j = i\n        while j < n and a[j] == a[i]:\n            j += 1\n        count = j - i  # frequency of current value\n        \n        if count >= k:\n            ans = 0\n            break\n        \n        needed = k - count\n        \n        # Calculate cost to bring elements from left (smaller values)\n        if i > 0:\n            # We need to raise (i) elements from left to a[i] - 1\n            # Then raise needed elements from a[i] - 1 to a[i]\n            left_cost = (a[i] - 1) * i - prefix[i]\n            if i >= needed:\n                # We have enough elements on left\n                ans = min(ans, left_cost + needed)\n            else:\n                # Need to also use elements from right\n                # First bring left elements to a[i] - 1, then to a[i]\n                cost = left_cost + i\n                remaining = needed - i\n                # Now need to bring remaining elements from right down\n                # We'll handle this in the right calculation\n                pass\n        \n        # Calculate cost to bring elements from right (larger values)\n        if j < n:\n            # We need to lower (n - j) elements from right to a[i] + 1\n            # Then lower needed elements from a[i] + 1 to a[i]\n            right_sum = prefix[n] - prefix[j]\n            right_count = n - j\n            right_cost = right_sum - (a[i] + 1) * right_count\n            if right_count >= needed:\n                # We have enough elements on right\n                ans = min(ans, right_cost + needed)\n            else:\n                # Need to also use elements from left\n                cost = right_cost + right_count\n                remaining = needed - right_count\n                # Now need to bring remaining elements from left up\n                # We'll handle this in the left calculation\n                pass\n        \n        # Calculate cost using both sides\n        # Total elements available = i + (n - j)\n        total_available = i + (n - j)\n        if total_available >= needed:\n            # Try all possible splits between left and right\n            # Use x from left and (needed - x) from right\n            for x in range(max(0, needed - (n - j)), min(i, needed) + 1):\n                y = needed - x\n                cost = 0\n                if x > 0:\n                    # Bring x elements from left: first to a[i] - 1, then to a[i]\n                    left_cost = (a[i] - 1) * i - prefix[i]\n                    cost += left_cost + x\n                if y > 0:\n                    # Bring y elements from right: first to a[i] + 1, then to a[i]\n                    right_sum = prefix[n] - prefix[j]\n                    right_count = n - j\n                    right_cost = right_sum - (a[i] + 1) * right_count\n                    cost += right_cost + y\n                ans = min(ans, cost)\n        \n        i = j\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 68.44942998886108}
{"eval_index": 296, "problem_id": 2108, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.96225214004517}
{"eval_index": 297, "problem_id": 3392, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.16773128509521}
{"eval_index": 298, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\nINF = 10**18\n\ndef dijkstra(n, graph, start):\n    dist = [INF] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        edges.append((x, y, w))\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(n, graph, i)\n    \n    # Compute base total cost without any zero road\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # For each route, new distance is min(original, using zero road)\n        saved = 0\n        for a, b in routes:\n            original = dists[a][b]\n            # Path via zero road: a->x + 0 + y->b or a->y + 0 + x->b\n            via_zero = min(dists[a][x] + dists[y][b], dists[a][y] + dists[x][b])\n            if via_zero < original:\n                saved += original - via_zero\n        new_total = base_total - saved\n        if new_total < best:\n            best = new_total\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 32.67565417289734}
{"eval_index": 299, "problem_id": 1473, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.97410821914673}
{"eval_index": 300, "problem_id": 3651, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.97335815429688}
{"eval_index": 301, "problem_id": 4339, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Compute c_i = a_i - b_i\n    c = [a[i] - b[i] for i in range(n)]\n    \n    # Sort c to use two-pointer technique\n    c.sort()\n    \n    count = 0\n    left = 0\n    right = n - 1\n    \n    # For each i, find j > i such that c_i + c_j > 0\n    # Equivalent to c_j > -c_i\n    # Use two-pointer: for each i from 0 to n-1, find first j > i with c_j > -c_i\n    # Then all indices from j to n-1 satisfy the condition\n    for i in range(n):\n        # Binary search for first j > i with c_j > -c_i\n        lo = i + 1\n        hi = n - 1\n        pos = n  # default if no such j\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if c[mid] > -c[i]:\n                pos = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        count += n - pos\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.65593671798706}
{"eval_index": 302, "problem_id": 2461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef dfs(u, parent, g, a, dp, ans):\n    \"\"\"\n    dp[u][0] = GCD of path from root to u without changing any value\n    dp[u][1] = maximum GCD achievable by changing exactly one value to 0 on the path\n    \"\"\"\n    # Initialize with current node's value\n    dp[u][0] = a[u]\n    dp[u][1] = 0  # Initially, no change made\n    \n    # Process parent's DP values\n    if parent != -1:\n        # Without changing current node:\n        # Option 1: Continue without change from parent\n        dp[u][0] = gcd(dp[parent][0], a[u])\n        \n        # With exactly one change:\n        # Option 2: Change current node to 0, use parent's unchanged GCD\n        cand1 = dp[parent][0]\n        # Option 3: Keep current node, use parent's changed GCD\n        cand2 = gcd(dp[parent][1], a[u]) if dp[parent][1] != 0 else 0\n        # Option 4: Change current node to 0, use parent's changed GCD (but this would be 2 changes)\n        # Not allowed, so we don't consider it\n        dp[u][1] = max(cand1, cand2)\n    \n    # Answer for current node is max of both states\n    ans[u] = max(dp[u][0], dp[u][1])\n    \n    # Recursively process children\n    for v in g[u]:\n        if v != parent:\n            dfs(v, u, g, a, dp, ans)\n\ndef main():\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    a = [0] + list(map(int, input[1:1+n]))  # 1-indexed\n    \n    # Build adjacency list\n    g = [[] for _ in range(n+1)]\n    idx = 1 + n\n    for _ in range(n-1):\n        x = int(input[idx]); y = int(input[idx+1])\n        idx += 2\n        g[x].append(y)\n        g[y].append(x)\n    \n    # DP arrays: dp[node][0] = no change, dp[node][1] = one change used\n    dp = [[0, 0] for _ in range(n+1)]\n    ans = [0] * (n+1)\n    \n    # DFS from root (vertex 1)\n    dfs(1, -1, g, a, dp, ans)\n    \n    # Output results for vertices 1..n\n    print(' '.join(str(ans[i]) for i in range(1, n+1)))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 37.31040024757385}
{"eval_index": 303, "problem_id": 3124, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.42155599594116}
{"eval_index": 304, "problem_id": 4456, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.82440948486328}
{"eval_index": 305, "problem_id": 1183, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); x = int(data[idx+1])\n        idx += 2\n        a = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        # Use a set to track existing places\n        existing = set(a)\n        v = 1\n        # Try to extend v as far as possible\n        while True:\n            if v not in existing:\n                if x > 0:\n                    x -= 1  # Use one future contest to get place v\n                else:\n                    break  # No more future contests\n            v += 1\n        results.append(str(v-1))  # v-1 is the largest valid v\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.28160047531128}
{"eval_index": 306, "problem_id": 3591, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.38095283508301}
{"eval_index": 307, "problem_id": 4713, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.readline\n    \n    N = int(input().strip())\n    S = input().strip()\n    \n    x = 0\n    max_x = 0  # maximum value, starting from initial x=0\n    \n    for ch in S:\n        if ch == 'I':\n            x += 1\n        else:  # ch == 'D'\n            x -= 1\n        max_x = max(max_x, x)\n    \n    print(max_x)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.763843297958374}
{"eval_index": 308, "problem_id": 1323, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 111.41791319847107}
{"eval_index": 309, "problem_id": 3796, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.36436891555786}
{"eval_index": 310, "problem_id": 4513, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.683539152145386}
{"eval_index": 311, "problem_id": 2275, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        k = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        max_time = 0\n        i = 0\n        while i < k:\n            if s[i] == 'A':\n                j = i + 1\n                while j < k and s[j] == 'P':\n                    j += 1\n                max_time = max(max_time, j - i - 1)\n                i = j\n            else:\n                i += 1\n        results.append(str(max_time))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.44145894050598}
{"eval_index": 312, "problem_id": 3529, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(2000)\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if xroot == yroot:\n        return False\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n    return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    edges = []\n    for _ in range(m):\n        c = data[idx]; idx += 1\n        f = int(data[idx]) - 1; idx += 1\n        t = int(data[idx]) - 1; idx += 1\n        color = 1 if c == 'B' else 0  # 1 for blue, 0 for red\n        edges.append((color, f, t))\n    \n    # First, find minimum and maximum possible blue edges in any spanning tree\n    # Sort edges: first by color (red first for min, blue first for max)\n    \n    # Minimum blue edges\n    parent = list(range(n))\n    rank = [0] * n\n    min_blue = 0\n    for color, u, v in sorted(edges, key=lambda x: x[0]):  # red (0) first\n        if union(parent, rank, u, v):\n            if color == 1:\n                min_blue += 1\n    \n    # Maximum blue edges\n    parent = list(range(n))\n    rank = [0] * n\n    max_blue = 0\n    for color, u, v in sorted(edges, key=lambda x: -x[0]):  # blue (1) first\n        if union(parent, rank, u, v):\n            if color == 1:\n                max_blue += 1\n    \n    # Check if k is within [min_blue, max_blue]\n    if min_blue <= k <= max_blue:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 30.14064860343933}
{"eval_index": 313, "problem_id": 4432, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        arr = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        # Find maximum length alternating subsequence\n        # Greedy: take maximum element from each consecutive block of same sign\n        max_sum = 0\n        i = 0\n        while i < n:\n            # Find block of same sign\n            j = i\n            max_in_block = arr[i]\n            while j < n and ((arr[i] > 0) == (arr[j] > 0)):\n                max_in_block = max(max_in_block, arr[j])\n                j += 1\n            max_sum += max_in_block\n            i = j\n        \n        results.append(str(max_sum))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.881422519683838}
{"eval_index": 314, "problem_id": 1066, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Count of odd numbers from 1 to n\n    odd_count = (n + 1) // 2\n    \n    if k <= odd_count:\n        # Position is in the odd numbers part\n        # k-th odd number: 2*k - 1\n        result = 2 * k - 1\n    else:\n        # Position is in the even numbers part\n        # Adjust k to be position within even numbers\n        pos_in_even = k - odd_count\n        # pos_in_even-th even number: 2 * pos_in_even\n        result = 2 * pos_in_even\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.6489040851593}
{"eval_index": 315, "problem_id": 3789, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 59.463876724243164}
{"eval_index": 316, "problem_id": 4298, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    D = int(data[1])\n    \n    # Greedy approach: place inspector at the leftmost uncovered tree + D\n    count = 0\n    i = 1\n    while i <= N:\n        count += 1\n        # Place inspector at position i + D, covering [i, i+2D]\n        i = i + 2 * D + 1\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.765668392181396}
{"eval_index": 317, "problem_id": 942, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.75959086418152}
{"eval_index": 318, "problem_id": 3536, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.68741273880005}
{"eval_index": 319, "problem_id": 4933, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def find_fourth_number():\n    # Read input\n    nums = list(map(int, input().split()))\n    \n    # Sort the three numbers to find potential positions\n    nums.sort()\n    a, b, c = nums\n    \n    # Case 1: The missing number is at the beginning\n    # If b-a == c-b, then missing number is at the end\n    # Otherwise, check if we can have arithmetic progression with missing at beginning\n    diff1 = b - a\n    diff2 = c - b\n    \n    # If differences are equal, the sequence is already arithmetic\n    # The missing number could be either before a or after c\n    if diff1 == diff2:\n        # Two possibilities: before a or after c\n        # Choose after c as per example\n        return c + diff1\n    \n    # If differences are not equal, the missing number is between two of them\n    # Check which difference is twice the other\n    if diff1 * 2 == diff2:\n        # Missing number between b and c\n        return b + diff1\n    elif diff2 * 2 == diff1:\n        # Missing number between a and b\n        return a + diff2\n    \n    # This shouldn't happen given problem constraints\n    return None\n\nif __name__ == \"__main__\":\n    result = find_fourth_number()\n    print(result)", "complexity_estimate": null, "runtime_sec": 53.00995445251465}
{"eval_index": 320, "problem_id": 1072, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    table = data[2:2+n]\n    \n    # If n <= 1, table is always good\n    if n <= 1:\n        print(0)\n        return\n    \n    removed = 0\n    # good[i] indicates if row i is already lexicographically <= row i+1\n    good = [False] * (n-1)\n    \n    # Process columns one by one\n    for col in range(m):\n        # Check if we need to keep this column\n        need_remove = False\n        for row in range(n-1):\n            if not good[row]:\n                # Compare current column's characters\n                if table[row][col] > table[row+1][col]:\n                    need_remove = True\n                    break\n        \n        if need_remove:\n            removed += 1\n        else:\n            # Update good array based on this column\n            for row in range(n-1):\n                if not good[row] and table[row][col] < table[row+1][col]:\n                    good[row] = True\n    \n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 71.57889676094055}
{"eval_index": 321, "problem_id": 3798, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef digit_sum_in_base(n, b):\n    \"\"\"Return sum of digits of n in base b.\"\"\"\n    total = 0\n    while n > 0:\n        total += n % b\n        n //= b\n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = int(data[1])\n    \n    # Case 1: b > n\n    # For b > n, f(b,n) = n (since n < b)\n    if n == s:\n        # Smallest b > n is n+1, but need to check if n+1 >= 2\n        # If n=1, then b=2 works since f(2,1)=1\n        print(max(n + 1, 2))\n        return\n    \n    # Case 2: b <= sqrt(n)\n    # Try all b from 2 to sqrt(n)\n    sqrt_n = int(n ** 0.5)\n    ans = -1\n    for b in range(2, sqrt_n + 1):\n        if digit_sum_in_base(n, b) == s:\n            print(b)\n            return\n    \n    # Case 3: b > sqrt(n)\n    # When b > sqrt(n), n in base b has at most 2 digits: n = p*b + q\n    # where p = n // b, q = n % b, with 0 <= q < b and p < b (since b > sqrt(n))\n    # Then f(b,n) = p + q = s\n    # So we have: n = p*b + q, p + q = s, 0 <= q < b, p < b\n    # From p + q = s, we get q = s - p\n    # Substitute into n = p*b + (s - p) => n - s = p*(b - 1)\n    # So b - 1 must divide n - s, and b > sqrt(n)\n    # Also constraints: 0 <= p < b, 0 <= q < b\n    diff = n - s\n    if diff > 0:\n        # Find divisors of diff\n        # For each divisor d of diff, let p = d, then b = (n - s) // p + 1\n        # Need to check p < b and q = s - p >= 0 and q < b\n        # Since b > sqrt(n), we only consider divisors p <= sqrt(diff) to avoid duplicates\n        sqrt_diff = int(diff ** 0.5)\n        candidates = []\n        for p in range(1, sqrt_diff + 1):\n            if diff % p == 0:\n                # Try p as divisor\n                b1 = diff // p + 1\n                q1 = s - p\n                if p < b1 and 0 <= q1 < b1:\n                    candidates.append(b1)\n                # Try diff//p as divisor\n                p2 = diff // p\n                if p2 != p:\n                    b2 = p + 1  # since diff = p2*(b2-1) => b2 = diff//p2 + 1 = p + 1\n                    q2 = s - p2\n                    if p2 < b2 and 0 <= q2 < b2:\n                        candidates.append(b2)\n        if candidates:\n            print(min(candidates))\n            return\n    \n    # No solution found\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 50.57484483718872}
{"eval_index": 322, "problem_id": 4462, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.24173831939697}
{"eval_index": 323, "problem_id": 2431, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.66094636917114}
{"eval_index": 324, "problem_id": 3419, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.68447780609131}
{"eval_index": 325, "problem_id": 4609, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    numbers = list(map(int, data[1:1+n]))\n    \n    # Use a set to track numbers currently on the sheet\n    sheet = set()\n    \n    for num in numbers:\n        if num in sheet:\n            sheet.remove(num)  # Erase if present\n        else:\n            sheet.add(num)     # Write if not present\n    \n    # The answer is the size of the set\n    print(len(sheet))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.95641827583313}
{"eval_index": 326, "problem_id": 384, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input().strip())\n    s = input().strip()\n    \n    groups = []\n    count = 0\n    \n    for ch in s:\n        if ch == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(' '.join(map(str, groups)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.258277893066406}
{"eval_index": 327, "problem_id": 3240, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.01062488555908}
{"eval_index": 328, "problem_id": 4025, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    \n    # Weekly consumption pattern: 0=fish, 1=rabbit, 2=chicken\n    # Days: Mon Tue Wed Thu Fri Sat Sun\n    pattern = [\n        0,  # Monday: fish\n        1,  # Tuesday: rabbit\n        2,  # Wednesday: chicken\n        0,  # Thursday: fish\n        2,  # Friday: chicken\n        1,  # Saturday: rabbit\n        0   # Sunday: fish\n    ]\n    \n    # Count how many times each food type appears in a week\n    weekly_counts = [0, 0, 0]\n    for food_type in pattern:\n        weekly_counts[food_type] += 1\n    \n    # Calculate full weeks we can feed\n    full_weeks = min(\n        a // weekly_counts[0] if weekly_counts[0] > 0 else float('inf'),\n        b // weekly_counts[1] if weekly_counts[1] > 0 else float('inf'),\n        c // weekly_counts[2] if weekly_counts[2] > 0 else float('inf')\n    )\n    \n    # Remaining food after full weeks\n    remaining = [\n        a - full_weeks * weekly_counts[0],\n        b - full_weeks * weekly_counts[1],\n        c - full_weeks * weekly_counts[2]\n    ]\n    \n    max_days = full_weeks * 7\n    \n    # Try all 7 possible starting days for the remaining days\n    best_extra = 0\n    for start_day in range(7):\n        current = remaining.copy()\n        day = start_day\n        extra_days = 0\n        \n        while True:\n            food_needed = pattern[day]\n            if current[food_needed] > 0:\n                current[food_needed] -= 1\n                extra_days += 1\n                day = (day + 1) % 7\n            else:\n                break\n        \n        best_extra = max(best_extra, extra_days)\n    \n    result = max_days + best_extra\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.85795783996582}
{"eval_index": 329, "problem_id": 1288, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    a = list(map(int, data[2:2+n]))\n    \n    # Sort the array\n    a_sorted = sorted(a)\n    \n    # We need to pick k elements\n    # The cost is min(max_odd, max_even) where odd/even indices are in the subsequence\n    # We can think of selecting elements such that we minimize the larger of the two maxima\n    \n    # Binary search on the answer\n    def can_achieve(limit):\n        # Try to form a subsequence of size k where both odd and even maxima are <= limit\n        # But actually we need min(max_odd, max_even) >= limit? Wait, we want to minimize cost.\n        # For binary search, we check if we can achieve cost <= limit\n        # That means we need to find a subsequence where min(max_odd, max_even) <= limit\n        # Which is equivalent to: we can choose elements such that at least one of max_odd or max_even is <= limit\n        # And total size is k\n        \n        # Strategy: try to pick elements for odd positions with values <= limit,\n        # and elements for even positions with values <= limit,\n        # alternating as much as possible\n        \n        # Greedy: iterate through original array, try to pick elements for odd positions first\n        # then even positions, etc.\n        \n        # Actually simpler: we need k elements total. Let's say we want max_odd <= limit.\n        # Then we can pick elements for odd positions from those <= limit.\n        # The even positions can be anything (since min with something <= limit will be <= limit).\n        # But we need exactly k elements total.\n        \n        # Better approach: count how many elements we can pick if we want:\n        # Option 1: odd positions limited to <= limit, even positions unlimited\n        # Option 2: even positions limited to <= limit, odd positions unlimited\n        \n        # For option 1: we need to pick elements in order. We'll pick for odd positions when possible.\n        # Let's simulate:\n        count1 = 0\n        odd_turn = True\n        for val in a:\n            if odd_turn:\n                if val <= limit:\n                    count1 += 1\n                    odd_turn = False  # next will be even\n            else:\n                # even position - can be any value\n                count1 += 1\n                odd_turn = True  # next will be odd\n        \n        # For option 2: even positions limited\n        count2 = 0\n        even_turn = False  # start with first position odd (index 1)\n        for val in a:\n            if even_turn:\n                if val <= limit:\n                    count2 += 1\n                    even_turn = False\n                else:\n                    # can't pick this for even position, skip it\n                    # but we might use it for odd position later? No, we're at even turn\n                    # Actually we should skip it and keep same turn\n                    continue\n            else:\n                # odd position - can be any value\n                count2 += 1\n                even_turn = True\n        \n        return max(count1, count2) >= k\n    \n    # Binary search bounds\n    left, right = 1, 10**9\n    answer = right\n    while left <= right:\n        mid = (left + right) // 2\n        if can_achieve(mid):\n            answer = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 89.59680223464966}
{"eval_index": 330, "problem_id": 3944, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.7149519920349}
{"eval_index": 331, "problem_id": 4719, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"\"\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    # Count character frequencies for each string\n    freq_list = []\n    for s in strings:\n        freq = [0]*26\n        for ch in s:\n            freq[ord(ch)-97] += 1\n        freq_list.append(freq)\n    \n    # Find minimum frequency for each character across all strings\n    min_freq = [0]*26\n    for i in range(26):\n        min_val = float('inf')\n        for f in freq_list:\n            min_val = min(min_val, f[i])\n        min_freq[i] = min_val\n    \n    # Build the result string\n    result_chars = []\n    for i in range(26):\n        ch = chr(97 + i)\n        result_chars.extend([ch] * min_freq[i])\n    \n    # Sort to get lexicographically smallest\n    result = ''.join(result_chars)\n    \n    # If result is empty, print empty line\n    if not result:\n        print()\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.589240074157715}
{"eval_index": 332, "problem_id": 1471, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 65.12191438674927}
{"eval_index": 333, "problem_id": 3634, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 129.02993178367615}
{"eval_index": 334, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data)\n    # The route consists of two flights between three airports.\n    # We need to consider all possible ordered pairs of flights that visit all three airports.\n    # Since flights are bidirectional, we can think of starting at any airport,\n    # then going to a different airport, then to the remaining airport.\n    # The possible sums are:\n    # 1. A->B then B->C: P + Q\n    # 2. A->C then C->B: R + Q\n    # 3. B->A then A->C: P + R\n    # 4. B->C then C->A: Q + R\n    # 5. C->A then A->B: R + P\n    # 6. C->B then B->A: Q + P\n    # But note that P+Q = Q+P, etc., so we only have three distinct sums:\n    # P+Q, Q+R, R+P.\n    # The minimum is the smallest of these three sums.\n    sums = [P + Q, Q + R, R + P]\n    print(min(sums))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.131792068481445}
{"eval_index": 335, "problem_id": 2840, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.31556344032288}
{"eval_index": 336, "problem_id": 3540, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    # Read input\n    grid = [list(sys.stdin.readline().strip()) for _ in range(4)]\n    \n    # Target configuration: rows in order R, G, B, Y\n    target = [\n        ['R', 'R', 'R', 'R'],\n        ['G', 'G', 'G', 'G'],\n        ['B', 'B', 'B', 'B'],\n        ['Y', 'Y', 'Y', 'Y']\n    ]\n    \n    # Helper to convert grid to tuple for hashing\n    def to_tuple(grid):\n        return tuple(tuple(row) for row in grid)\n    \n    # Helper to shift rows left/right\n    def shift_row(grid, r, direction):\n        new_grid = [list(row) for row in grid]\n        row = new_grid[r]\n        if direction == 'L':\n            new_grid[r] = row[1:] + [row[0]]\n        else:  # 'R'\n            new_grid[r] = [row[-1]] + row[:-1]\n        return new_grid\n    \n    # Helper to shift columns up/down\n    def shift_col(grid, c, direction):\n        new_grid = [list(row) for row in grid]\n        col = [new_grid[r][c] for r in range(4)]\n        if direction == 'U':\n            for r in range(4):\n                new_grid[r][c] = col[(r + 1) % 4]\n        else:  # 'D'\n            for r in range(4):\n                new_grid[r][c] = col[(r - 1) % 4]\n        return new_grid\n    \n    # BFS to find minimum moves\n    start = to_tuple(grid)\n    target_state = to_tuple(target)\n    \n    if start == target_state:\n        print(0)\n        return\n    \n    visited = {start: 0}\n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        current_moves = visited[current]\n        \n        # Generate all possible moves\n        for r in range(4):\n            for direction in ['L', 'R']:\n                new_grid = shift_row(current, r, direction)\n                new_state = to_tuple(new_grid)\n                if new_state not in visited:\n                    if new_state == target_state:\n                        print(current_moves + 1)\n                        return\n                    visited[new_state] = current_moves + 1\n                    queue.append(new_state)\n        \n        for c in range(4):\n            for direction in ['U', 'D']:\n                new_grid = shift_col(current, c, direction)\n                new_state = to_tuple(new_grid)\n                if new_state not in visited:\n                    if new_state == target_state:\n                        print(current_moves + 1)\n                        return\n                    visited[new_state] = current_moves + 1\n                    queue.append(new_state)\n    \n    # Should never reach here since problem states all configurations solvable < 13 moves\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 37.37810182571411}
{"eval_index": 337, "problem_id": 4629, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_good_number(x):\n    \"\"\"Check if x can be represented as sum of distinct powers of 3.\"\"\"\n    while x > 0:\n        if x % 3 == 2:\n            return False\n        x //= 3\n    return True\n\ndef find_smallest_good_number(n):\n    \"\"\"Find smallest good number >= n.\"\"\"\n    # Start from n and check upwards\n    m = n\n    while True:\n        if is_good_number(m):\n            return m\n        m += 1\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    q = int(input_data[0])\n    results = []\n    \n    for i in range(1, q + 1):\n        n = int(input_data[i])\n        result = find_smallest_good_number(n)\n        results.append(str(result))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 22.018048763275146}
{"eval_index": 338, "problem_id": 2831, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.71919298171997}
{"eval_index": 339, "problem_id": 3215, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.856099128723145}
{"eval_index": 340, "problem_id": 4477, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    idx = 1\n    for _ in range(t):\n        x = data[idx]\n        idx += 1\n        digit = int(x[0])\n        length = len(x)\n        # Calculate total keypresses\n        # For each digit from 1 to (digit-1), we press all lengths from 1 to 4\n        # For the current digit, we press lengths from 1 to length\n        total = 0\n        # Previous digits\n        for d in range(1, digit):\n            total += 10  # 1+2+3+4 = 10 for each previous digit\n        # Current digit\n        total += sum(range(1, length + 1))\n        results.append(str(total))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.341031312942505}
{"eval_index": 341, "problem_id": 1625, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.85935640335083}
{"eval_index": 342, "problem_id": 3748, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.14724278450012}
{"eval_index": 343, "problem_id": 4988, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef last_digit_factorial(n):\n    \"\"\"Return the last digit of n!\"\"\"\n    # For n >= 5, factorial includes 2 and 5, making last digit 0\n    if n >= 5:\n        return 0\n    # Compute factorial for n < 5\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result % 10\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        results.append(str(last_digit_factorial(n)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.025084733963013}
{"eval_index": 344, "problem_id": 67, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    x, y, z = map(int, data)\n    \n    # Determine the possible range of net votes (upvotes - downvotes)\n    # Minimum net votes: all z unknown vote downvote\n    min_net = x - (y + z)\n    # Maximum net votes: all z unknown vote upvote\n    max_net = (x + z) - y\n    \n    # Check if result is certain\n    if min_net > 0 and max_net > 0:\n        # Both min and max are positive => result is always \"+\"\n        print(\"+\")\n    elif min_net < 0 and max_net < 0:\n        # Both min and max are negative => result is always \"-\"\n        print(\"-\")\n    elif min_net == 0 and max_net == 0:\n        # Both min and max are zero => result is always \"0\"\n        print(\"0\")\n    else:\n        # The ranges cross zero or have mixed signs => uncertain\n        print(\"?\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.972376108169556}
{"eval_index": 345, "problem_id": 3486, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.04903030395508}
{"eval_index": 346, "problem_id": 4830, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Mapping from letters to digits based on T9 keyboard\nletter_to_digit = {\n    'a': '2', 'b': '2', 'c': '2',\n    'd': '3', 'e': '3', 'f': '3',\n    'g': '4', 'h': '4', 'i': '4',\n    'j': '5', 'k': '5', 'l': '5',\n    'm': '6', 'n': '6', 'o': '6',\n    'p': '7', 'q': '7', 'r': '7', 's': '7',\n    't': '8', 'u': '8', 'v': '8',\n    'w': '9', 'x': '9', 'y': '9', 'z': '9'\n}\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    words = data[1:1+n]\n    s = data[1+n] if len(data) > 1+n else ''\n    \n    count = 0\n    for word in words:\n        # Convert word to its T9 digit sequence\n        digit_seq = ''.join(letter_to_digit[ch] for ch in word)\n        if digit_seq == s:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.498725414276123}
{"eval_index": 347, "problem_id": 1446, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.08921647071838}
{"eval_index": 348, "problem_id": 3331, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 174.65579962730408}
{"eval_index": 349, "problem_id": 4985, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "def main():\n    import sys\n    \n    # Read first line\n    first_line = sys.stdin.readline().strip().split()\n    N = int(first_line[0])\n    dominant_suit = first_line[1]\n    \n    # Define card values based on the table\n    dominant_values = {\n        'A': 11, 'K': 4, 'Q': 3, 'J': 20, 'T': 10, '9': 14, '8': 0, '7': 0\n    }\n    non_dominant_values = {\n        'A': 11, 'K': 4, 'Q': 3, 'J': 2, 'T': 10, '9': 0, '8': 0, '7': 0\n    }\n    \n    total_points = 0\n    \n    # Read 4N cards\n    for _ in range(4 * N):\n        card = sys.stdin.readline().strip()\n        number = card[0]\n        suit = card[1]\n        \n        if suit == dominant_suit:\n            total_points += dominant_values[number]\n        else:\n            total_points += non_dominant_values[number]\n    \n    print(total_points)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 57.328533411026}
{"eval_index": 350, "problem_id": 2838, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport itertools\n\n# Read input\nexpression = sys.stdin.readline().strip()\n\n# Step 1: Identify all bracket pairs\nstack = []\nbracket_pairs = []  # each pair is (open_index, close_index)\nfor i, ch in enumerate(expression):\n    if ch == '(':\n        stack.append(i)\n    elif ch == ')':\n        open_idx = stack.pop()\n        bracket_pairs.append((open_idx, i))\n\n# Step 2: Generate all subsets of bracket pairs to remove\nn = len(bracket_pairs)\nall_expressions = set()\n# We must keep at least one pair (original expression) and can remove up to all\nfor mask in range(1, 1 << n):  # mask 0 means remove none, which is original\n    # Build new expression by removing selected brackets\n    to_remove = set()\n    for i in range(n):\n        if mask & (1 << i):\n            open_idx, close_idx = bracket_pairs[i]\n            to_remove.add(open_idx)\n            to_remove.add(close_idx)\n    new_expr_chars = []\n    for i, ch in enumerate(expression):\n        if i not in to_remove:\n            new_expr_chars.append(ch)\n    new_expr = ''.join(new_expr_chars)\n    all_expressions.add(new_expr)\n\n# Step 3: Sort lexicographically and output\nsorted_expressions = sorted(all_expressions)\nfor expr in sorted_expressions:\n    print(expr)", "complexity_estimate": null, "runtime_sec": 48.03797245025635}
{"eval_index": 351, "problem_id": 3756, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, t = map(int, data[:2])\n    s = data[2]\n    \n    # Find decimal point position\n    dot_pos = s.find('.')\n    # Convert to list of characters for easy manipulation\n    digits = list(s)\n    \n    # Find first digit after decimal point that is >=5\n    # We'll try to round from there\n    i = dot_pos + 1\n    while i < len(digits) and digits[i] < '5':\n        i += 1\n    \n    # If no digit >=5 found, no rounding possible\n    if i == len(digits):\n        # Remove trailing zeros after decimal point\n        result = s.rstrip('0').rstrip('.')\n        print(result)\n        return\n    \n    # We found a digit >=5 at position i\n    # Now we need to use t seconds to propagate rounding\n    seconds_used = 0\n    while i > dot_pos and seconds_used < t:\n        if digits[i] >= '5':\n            # Round at position i-1\n            # If i-1 is before decimal point, need to handle integer part\n            if i-1 == dot_pos:\n                # Rounding at decimal point means rounding integer part\n                j = dot_pos - 1\n                while j >= 0 and digits[j] == '9':\n                    digits[j] = '0'\n                    j -= 1\n                if j >= 0:\n                    digits[j] = chr(ord(digits[j]) + 1)\n                else:\n                    # Need to add '1' at the beginning\n                    digits.insert(0, '1')\n                    dot_pos += 1  # Decimal point moved\n                # Set all after decimal point to 0\n                for k in range(dot_pos + 1, len(digits)):\n                    digits[k] = '0'\n                break\n            else:\n                # Normal rounding after decimal point\n                digits[i-1] = chr(ord(digits[i-1]) + 1)\n                # Set current and all following digits to 0\n                for k in range(i, len(digits)):\n                    digits[k] = '0'\n                seconds_used += 1\n                # Check if rounding caused previous digit to become >=5\n                i -= 1\n                # If we rounded to 10, need to propagate\n                while i > dot_pos and digits[i] == '10':\n                    digits[i] = '0'\n                    digits[i-1] = chr(ord(digits[i-1]) + 1)\n                    i -= 1\n                # If we reached decimal point with '10'\n                if i == dot_pos and digits[i] == '10':\n                    digits[i] = '0'\n                    j = dot_pos - 1\n                    while j >= 0 and digits[j] == '9':\n                        digits[j] = '0'\n                        j -= 1\n                    if j >= 0:\n                        digits[j] = chr(ord(digits[j]) + 1)\n                    else:\n                        digits.insert(0, '1')\n                        dot_pos += 1\n                    break\n        else:\n            break\n    \n    # Convert back to string\n    result = ''.join(digits)\n    # Remove trailing zeros after decimal point\n    if '.' in result:\n        result = result.rstrip('0').rstrip('.')\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 82.25863981246948}
{"eval_index": 352, "problem_id": 4582, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = data[0], data[1]\n    # Truth table logic:\n    # If AtCoDeer is honest (a='H'), then his statement about TopCoDeer is true.\n    # So TopCoDeer's honesty matches b.\n    # If AtCoDeer is dishonest (a='D'), then his statement is false.\n    # So TopCoDeer's honesty is opposite of b.\n    if a == 'H':\n        print(b)\n    else:  # a == 'D'\n        print('H' if b == 'D' else 'D')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.79425859451294}
{"eval_index": 353, "problem_id": 2084, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 102.53287696838379}
{"eval_index": 354, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.46993970870972}
{"eval_index": 355, "problem_id": 4946, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Dictionary to store last occurrence index for each language\n    last_pos = {}\n    min_distance = n  # Initialize with n (maximum possible)\n    \n    for i, lang in enumerate(arr):\n        if lang in last_pos:\n            # Calculate distance between current and last occurrence\n            distance = i - last_pos[lang]\n            if distance < min_distance:\n                min_distance = distance\n        # Update last position for this language\n        last_pos[lang] = i\n    \n    # If no two people speak same language, min_distance remains n\n    print(min_distance)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.251665830612183}
{"eval_index": 356, "problem_id": 1238, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    a.sort()\n    \n    # The minimum stolen keyboards is the total range minus n\n    # We need to find the smallest possible range that contains all remaining keyboards\n    # The range is from min(a) to max(a), and all numbers in between must be accounted for\n    # Stolen = (max - min + 1) - n\n    min_val = a[0]\n    max_val = a[-1]\n    total_in_range = max_val - min_val + 1\n    stolen = total_in_range - n\n    \n    # Ensure non-negative result\n    if stolen < 0:\n        stolen = 0\n    \n    print(stolen)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.17905616760254}
{"eval_index": 357, "problem_id": 3167, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    # Read N and K\n    n, k = map(int, input().split())\n    # Read the jump sequence\n    jumps = list(map(int, input().split()))\n    \n    # freq[i] will store how many times index i is incremented\n    freq = [0] * (n + 1)\n    \n    # Process each jump\n    for jump in jumps:\n        # For each jump, increment all multiples of jump\n        for i in range(0, n, jump):\n            freq[i] += 1\n    \n    # Build prefix sum array for quick range sum queries\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + freq[i]\n    \n    # Read Q\n    q = int(input())\n    results = []\n    for _ in range(q):\n        l, r = map(int, input().split())\n        # Sum from L to R inclusive using prefix sums\n        total = prefix[r + 1] - prefix[l]\n        results.append(str(total))\n    \n    # Output all results\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 78.23035168647766}
{"eval_index": 358, "problem_id": 4273, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 53.43147277832031}
{"eval_index": 359, "problem_id": 958, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Fast input reading\ninput = sys.stdin.readline\n\n# Read n and k\nn, k = map(int, input().split())\n# Read the string s\ns = input().strip()\n\n# Convert string to list of characters for easy modification\ns_list = list(s)\n\n# Initialize result string as list\nresult = [''] * n\n\n# For each character in s, we try to maximize the distance we can achieve\nremaining_k = k\nfor i in range(n):\n    # Current character\n    current_char = s_list[i]\n    # Convert to 0-indexed position in alphabet (a=0, b=1, ..., z=25)\n    current_pos = ord(current_char) - ord('a')\n    \n    # Maximum distance we can get from this position by moving to 'a' or 'z'\n    max_dist_from_current = max(current_pos, 25 - current_pos)\n    \n    if remaining_k >= max_dist_from_current:\n        # We can take the maximum possible distance for this character\n        if current_pos >= 25 - current_pos:\n            # Move to 'a' gives max distance\n            result[i] = 'a'\n            remaining_k -= current_pos\n        else:\n            # Move to 'z' gives max distance\n            result[i] = 'z'\n            remaining_k -= (25 - current_pos)\n    else:\n        # We cannot take the maximum, so we take as much as possible\n        # We have two directions: towards 'a' or towards 'z'\n        # Choose the direction that gives us the required distance\n        if remaining_k <= current_pos:\n            # Move towards 'a'\n            result[i] = chr(ord('a') + (current_pos - remaining_k))\n            remaining_k = 0\n        else:\n            # Move towards 'z'\n            result[i] = chr(ord('a') + (current_pos + remaining_k))\n            remaining_k = 0\n\n# After processing all characters, if remaining_k is not zero, it's impossible\nif remaining_k != 0:\n    print(-1)\nelse:\n    print(''.join(result))", "complexity_estimate": null, "runtime_sec": 31.019959449768066}
{"eval_index": 360, "problem_id": 3091, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.30825996398926}
{"eval_index": 361, "problem_id": 4756, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 75.14791703224182}
{"eval_index": 362, "problem_id": 232, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    colors = [int(next(it)) for _ in range(n)]\n    k = [int(next(it)) for _ in range(m)]\n    \n    # Precompute prefix sums for each color\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n    for idx, col in enumerate(colors, 1):\n        for c in range(1, m + 1):\n            prefix[c][idx] = prefix[c][idx - 1]\n        prefix[col][idx] += 1\n    \n    # Check all possible intervals\n    for start in range(1, n + 1):\n        for end in range(start, n + 1):\n            valid = True\n            for c in range(1, m + 1):\n                count = prefix[c][end] - prefix[c][start - 1]\n                if count != k[c - 1]:\n                    valid = False\n                    break\n            if valid:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 44.492751598358154}
{"eval_index": 363, "problem_id": 3827, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # The string must be of the form a...a b...b c...c\n    # with at least one 'a' and one 'b' before the 'c's start.\n    # The number of 'c's must equal either the number of 'a's or the number of 'b's.\n    \n    # First, check that the string only contains 'a', 'b', 'c' in order.\n    # It should be non-decreasing with respect to the order 'a' < 'b' < 'c'.\n    for i in range(1, n):\n        if s[i] < s[i-1]:\n            print(\"NO\")\n            return\n    \n    # Count occurrences of each character.\n    cnt_a = s.count('a')\n    cnt_b = s.count('b')\n    cnt_c = s.count('c')\n    \n    # Conditions:\n    # 1. At least one 'a' and one 'b' (given in problem statement).\n    # 2. The number of 'c's must equal either cnt_a or cnt_b.\n    # 3. The counts must be positive and the order must be correct.\n    if cnt_a == 0 or cnt_b == 0:\n        print(\"NO\")\n        return\n    \n    if cnt_c == cnt_a or cnt_c == cnt_b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.073818683624268}
{"eval_index": 364, "problem_id": 4993, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    P = int(data[0])\n    N = int(data[1])\n    parts = data[2:2+N]\n    \n    seen = set()\n    replaced_count = 0\n    \n    for day in range(N):\n        part = parts[day]\n        if part not in seen:\n            seen.add(part)\n            replaced_count += 1\n            if replaced_count == P:\n                print(day + 1)  # 1-indexed day\n                return\n    \n    print(\"paradox avoided\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.833231925964355}
{"eval_index": 365, "problem_id": 2450, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    results = []\n    for _ in range(t):\n        n = int(next(it))\n        m = int(next(it))\n        x = int(next(it))\n        y = int(next(it))\n        # Process each row\n        total_cost = 0\n        for i in range(n):\n            row = next(it)\n            j = 0\n            while j < m:\n                if row[j] == '*':\n                    j += 1\n                    continue\n                # Count consecutive white squares\n                count = 0\n                while j < m and row[j] == '.':\n                    count += 1\n                    j += 1\n                # Calculate min cost for this segment\n                if y < 2 * x:\n                    # Use as many 1x2 tiles as possible\n                    total_cost += (count // 2) * y + (count % 2) * x\n                else:\n                    # Use only 1x1 tiles\n                    total_cost += count * x\n        results.append(str(total_cost))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.14033579826355}
{"eval_index": 366, "problem_id": 3075, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 86.47314953804016}
{"eval_index": 367, "problem_id": 4245, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Start with 1 socket (the original one)\n    sockets = 1\n    strips = 0\n    \n    # Keep adding strips until we have at least B sockets\n    while sockets < B:\n        # Each strip adds A sockets but uses up 1 socket\n        sockets += A - 1\n        strips += 1\n    \n    print(strips)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.588452339172363}
{"eval_index": 368, "problem_id": 884, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.64336514472961}
{"eval_index": 369, "problem_id": 3399, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.83261823654175}
{"eval_index": 370, "problem_id": 4995, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    total_sl_minutes = 0.0\n    total_real_minutes = 0.0\n    for i in range(n):\n        m = int(data[2*i + 1])\n        s = int(data[2*i + 2])\n        total_sl_minutes += m\n        total_real_minutes += s / 60.0\n    if total_sl_minutes == 0:\n        print(\"measurement error\")\n        return\n    avg = total_real_minutes / total_sl_minutes\n    if avg <= 1.0:\n        print(\"measurement error\")\n    else:\n        print(f\"{avg:.9f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.849760055541992}
{"eval_index": 371, "problem_id": 288, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.39731550216675}
{"eval_index": 372, "problem_id": 3107, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.13682889938354}
{"eval_index": 373, "problem_id": 4909, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    D = list(map(int, data[1:1+n]))\n    \n    # Condition 1: Sum of degrees must be 2*(N-1) for a tree\n    if sum(D) != 2 * (n - 1):\n        print(\"NO\")\n        return\n    \n    # Condition 2: For room 1 (root), D[0] >= 1\n    if D[0] < 1:\n        print(\"NO\")\n        return\n    \n    # Condition 3: For other rooms, D[i] >= 1 (since tree is connected)\n    for i in range(1, n):\n        if D[i] < 1:\n            print(\"NO\")\n            return\n    \n    # Condition 4: Check the special property about increasing indices\n    # In a rooted tree where path from root to any node has increasing indices,\n    # each node (except root) must have degree <= parent's degree + 1?\n    # Actually, the condition implies the tree can be built with BFS order = index order.\n    # We need to check if we can assign parent-child relationships.\n    # Sort degrees (except root) and try to assign parents.\n    \n    # Sort degrees of non-root nodes in descending order\n    non_root_degrees = sorted(D[1:], reverse=True)\n    \n    # Available \"slots\" from root and other nodes as we build the tree\n    # Start with root having D[0] children slots\n    slots = [D[0]]\n    \n    for deg in non_root_degrees:\n        if not slots:\n            print(\"NO\")\n            return\n        # Use one slot for this node's parent connection\n        slots[0] -= 1\n        if slots[0] == 0:\n            slots.pop(0)\n        # This node provides (deg - 1) new slots for its children\n        if deg - 1 > 0:\n            slots.append(deg - 1)\n            slots.sort(reverse=True)  # Keep sorted to always use largest slot\n    \n    # If we successfully assigned all nodes\n    if all(s == 0 for s in slots):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.120481729507446}
{"eval_index": 374, "problem_id": 247, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 1, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.67318391799927}
{"eval_index": 375, "problem_id": 3070, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.82412552833557}
{"eval_index": 376, "problem_id": 4064, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    n, h, l, r = map(int, data[:4])\n    a = list(map(int, data[4:4+n]))\n    \n    # dp[i][j] = max good sleeps after i sleeps, ending at hour j\n    # initialize with -inf\n    INF = -10**9\n    dp = [[INF] * h for _ in range(n+1)]\n    dp[0][0] = 0  # start at hour 0\n    \n    for i in range(1, n+1):\n        for j in range(h):\n            if dp[i-1][j] == INF:\n                continue\n            # option 1: sleep after a_i hours\n            t1 = (j + a[i-1]) % h\n            good1 = 1 if l <= t1 <= r else 0\n            dp[i][t1] = max(dp[i][t1], dp[i-1][j] + good1)\n            \n            # option 2: sleep after a_i - 1 hours\n            t2 = (j + a[i-1] - 1) % h\n            good2 = 1 if l <= t2 <= r else 0\n            dp[i][t2] = max(dp[i][t2], dp[i-1][j] + good2)\n    \n    ans = max(dp[n])\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.756167888641357}
{"eval_index": 377, "problem_id": 366, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    S = int(data[1])\n    \n    # If n >= S, we can use a single coin of value S\n    if n >= S:\n        print(1)\n        return\n    \n    # Use as many coins of value n as possible\n    coins_needed = S // n\n    remainder = S % n\n    \n    # If remainder is 0, we're done\n    if remainder == 0:\n        print(coins_needed)\n        return\n    \n    # Otherwise, we need one more coin for the remainder\n    # Since remainder < n and we have coin values 1..n, we can always use one coin for remainder\n    print(coins_needed + 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.777763605117798}
{"eval_index": 378, "problem_id": 3665, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.25492453575134}
{"eval_index": 379, "problem_id": 4799, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    G, S, C = map(int, data)\n    \n    # Calculate total buying power\n    buying_power = G * 3 + S * 2 + C * 1\n    \n    # Determine best victory card\n    if buying_power >= 8:\n        victory_card = \"Province\"\n    elif buying_power >= 5:\n        victory_card = \"Duchy\"\n    elif buying_power >= 2:\n        victory_card = \"Estate\"\n    else:\n        victory_card = None\n    \n    # Determine best treasure card\n    if buying_power >= 6:\n        treasure_card = \"Gold\"\n    elif buying_power >= 3:\n        treasure_card = \"Silver\"\n    else:\n        treasure_card = \"Copper\"\n    \n    # Output result\n    if victory_card:\n        print(f\"{victory_card} or {treasure_card}\")\n    else:\n        print(treasure_card)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.830578088760376}
{"eval_index": 380, "problem_id": 903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    a.sort()\n    median_idx = n // 2\n    \n    # Start from the current median\n    current_median = a[median_idx]\n    operations_used = 0\n    \n    # Try to increase the median and all elements to its right\n    for i in range(median_idx + 1, n):\n        # Calculate how many operations needed to raise all elements from median_idx to i to the same level\n        needed = (a[i] - current_median) * (i - median_idx)\n        if operations_used + needed <= k:\n            operations_used += needed\n            current_median = a[i]\n        else:\n            # Can partially raise\n            remaining_ops = k - operations_used\n            can_increase = remaining_ops // (i - median_idx)\n            current_median += can_increase\n            operations_used += can_increase * (i - median_idx)\n            break\n    else:\n        # If we processed all elements to the right, we can still increase further\n        remaining_ops = k - operations_used\n        can_increase = remaining_ops // (n - median_idx)\n        current_median += can_increase\n    \n    print(current_median)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.276230096817017}
{"eval_index": 381, "problem_id": 3241, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 131.5258858203888}
{"eval_index": 382, "problem_id": 4819, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read 10 integers from standard input\n    numbers = [int(sys.stdin.readline().strip()) for _ in range(10)]\n    \n    # Compute each number modulo 42\n    mod_values = [num % 42 for num in numbers]\n    \n    # Use a set to find distinct values\n    distinct_mods = set(mod_values)\n    \n    # Output the count of distinct values\n    print(len(distinct_mods))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.232889175415039}
{"eval_index": 383, "problem_id": 2380, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 66.8382842540741}
{"eval_index": 384, "problem_id": 3512, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.35280561447144}
{"eval_index": 385, "problem_id": 4138, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_digits(n):\n    \"\"\"Return total digits from 1 to n inclusive.\"\"\"\n    total = 0\n    length = 1\n    start = 1\n    while start <= n:\n        end = min(n, start * 10 - 1)\n        count = end - start + 1\n        total += count * length\n        length += 1\n        start *= 10\n    return total\n\ndef block_length(i):\n    \"\"\"Return total digits in block i (1 to i).\"\"\"\n    return count_digits(i)\n\ndef total_digits_up_to_block(n):\n    \"\"\"Return total digits in first n blocks.\"\"\"\n    total = 0\n    length = 1\n    start = 1\n    while start <= n:\n        end = min(n, start * 10 - 1)\n        count = end - start + 1\n        # Sum of arithmetic series: count * (first + last) // 2\n        first = count_digits(start)\n        last = count_digits(end)\n        total += count * (first + last) // 2\n        length += 1\n        start *= 10\n    return total\n\ndef find_block(k):\n    \"\"\"Find which block contains position k using binary search.\"\"\"\n    low, high = 1, int(1e9)  # Upper bound for block index\n    while low <= high:\n        mid = (low + high) // 2\n        if total_digits_up_to_block(mid) < k:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\ndef find_number_in_block(block_idx, pos_in_block):\n    \"\"\"Find which number in block contains position pos_in_block.\"\"\"\n    low, high = 1, block_idx\n    while low <= high:\n        mid = (low + high) // 2\n        if count_digits(mid) < pos_in_block:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    q = int(input_data[0])\n    results = []\n    for i in range(1, q + 1):\n        k = int(input_data[i])\n        # Step 1: Find which block contains position k\n        block_idx = find_block(k)\n        # Step 2: Find position within that block\n        digits_before = total_digits_up_to_block(block_idx - 1)\n        pos_in_block = k - digits_before\n        # Step 3: Find which number in the block contains this position\n        num_in_block = find_number_in_block(block_idx, pos_in_block)\n        # Step 4: Find position within that number\n        digits_before_num = count_digits(num_in_block - 1)\n        pos_in_num = pos_in_block - digits_before_num\n        # Step 5: Extract the digit\n        digit = int(str(num_in_block)[pos_in_num - 1])\n        results.append(str(digit))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 38.95233869552612}
{"eval_index": 386, "problem_id": 57, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    # Collect unique x and y coordinates\n    xs = set()\n    ys = set()\n    for x, y in points:\n        xs.add(x)\n        ys.add(y)\n    \n    # Determine if area can be uniquely determined\n    if len(xs) == 2 and len(ys) == 2:\n        # Have both x extremes and y extremes -> can compute area\n        x_vals = sorted(xs)\n        y_vals = sorted(ys)\n        width = x_vals[1] - x_vals[0]\n        height = y_vals[1] - y_vals[0]\n        area = width * height\n        print(area)\n    elif n == 4:\n        # All four vertices given -> definitely unique\n        x_vals = sorted(xs)\n        y_vals = sorted(ys)\n        width = x_vals[1] - x_vals[0]\n        height = y_vals[1] - y_vals[0]\n        area = width * height\n        print(area)\n    else:\n        # Not enough information\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.823899507522583}
{"eval_index": 387, "problem_id": 3802, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.20584392547607}
{"eval_index": 388, "problem_id": 4111, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    \n    # Precompute prefix sums for odd and even positions\n    prefix_odd = [0] * (n + 2)\n    prefix_even = [0] * (n + 2)\n    \n    for i in range(n):\n        idx = i + 1  # 1-based index\n        if idx % 2 == 1:\n            prefix_odd[idx] = prefix_odd[idx - 1] + a[i]\n            prefix_even[idx] = prefix_even[idx - 1]\n        else:\n            prefix_even[idx] = prefix_even[idx - 1] + a[i]\n            prefix_odd[idx] = prefix_odd[idx - 1]\n    \n    # Also compute suffix sums for odd and even positions\n    suffix_odd = [0] * (n + 2)\n    suffix_even = [0] * (n + 2)\n    \n    for i in range(n - 1, -1, -1):\n        idx = i + 1  # 1-based index\n        if idx % 2 == 1:\n            suffix_odd[idx] = suffix_odd[idx + 1] + a[i]\n            suffix_even[idx] = suffix_even[idx + 1]\n        else:\n            suffix_even[idx] = suffix_even[idx + 1] + a[i]\n            suffix_odd[idx] = suffix_odd[idx + 1]\n    \n    count = 0\n    for i in range(1, n + 1):\n        # When candy i is given to dad\n        # Sum of odd days = odd sum before i + even sum after i\n        # Sum of even days = even sum before i + odd sum after i\n        odd_sum = prefix_odd[i - 1] + suffix_even[i + 1]\n        even_sum = prefix_even[i - 1] + suffix_odd[i + 1]\n        \n        if odd_sum == even_sum:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.362714290618896}
{"eval_index": 389, "problem_id": 35, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:2+n]\n    \n    # Check if n is divisible by 3 for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        valid = True\n        for i in range(3):\n            start = i * stripe_height\n            end = start + stripe_height\n            stripe_color = grid[start][0]\n            # Check all cells in this stripe have same color\n            for row in range(start, end):\n                if any(cell != stripe_color for cell in grid[row]):\n                    valid = False\n                    break\n            if not valid:\n                break\n            colors.add(stripe_color)\n        if valid and len(colors) == 3:\n            print(\"YES\")\n            return\n    \n    # Check if m is divisible by 3 for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        valid = True\n        for i in range(3):\n            start = i * stripe_width\n            end = start + stripe_width\n            stripe_color = grid[0][start]\n            # Check all cells in this stripe have same color\n            for row in range(n):\n                if any(grid[row][col] != stripe_color for col in range(start, end)):\n                    valid = False\n                    break\n            if not valid:\n                break\n            colors.add(stripe_color)\n        if valid and len(colors) == 3:\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.98702883720398}
{"eval_index": 390, "problem_id": 3383, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 154.63144183158875}
{"eval_index": 391, "problem_id": 4754, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if pairing is possible\ncount = {}\nfor sock in a:\n    count[sock] = count.get(sock, 0) + 1\n\nfor freq in count.values():\n    if freq % 2 != 0:\n        print(\"impossible\")\n        sys.exit()\n\n# Simulate the process\noriginal = a[::-1]  # Reverse so top is at end for pop()\nauxiliary = []\nmoves = 0\n\nwhile original:\n    # Move from original to auxiliary\n    auxiliary.append(original.pop())\n    moves += 1\n    \n    # Try to pair as much as possible\n    while auxiliary and original and auxiliary[-1] == original[-1]:\n        auxiliary.pop()\n        original.pop()\n        moves += 1\n\n# If auxiliary is empty, all socks are paired\nif not auxiliary:\n    print(moves)\nelse:\n    print(\"impossible\")", "complexity_estimate": null, "runtime_sec": 19.12525486946106}
{"eval_index": 392, "problem_id": 1690, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We need to find maximum total chocolates with the condition:\n    # For all j < i, either x_j = 0 or x_j < x_i\n    # This means the non-zero x_i must form a strictly increasing sequence\n    # when considering only indices where x_i > 0\n    \n    # Approach: Process from right to left, maintaining the maximum possible\n    # value for current position while ensuring it's less than the next non-zero\n    # value to the right (if any).\n    \n    # Start from the rightmost element\n    total = 0\n    next_val = float('inf')  # No constraint from right initially\n    \n    for i in range(n-1, -1, -1):\n        # For position i, we can take at most min(a[i], next_val-1)\n        # But we also need to consider that we might take 0\n        # Actually, we want to maximize total, so we take as much as possible\n        # while maintaining the strict increasing property\n        \n        # The maximum we can take at position i is:\n        # min(a[i], next_val - 1) if next_val > 0\n        # But careful: if next_val is 0 or 1, we can only take 0\n        \n        if next_val <= 1:\n            # Can't take anything here if next_val is 0 or 1\n            # because we need x_i < next_val and x_i >= 0\n            # So best is 0\n            current = 0\n        else:\n            # We can take up to min(a[i], next_val - 1)\n            current = min(a[i], next_val - 1)\n            \n        total += current\n        \n        # Update next_val for the next position to the left\n        # If current > 0, then for position i-1, we need x_{i-1} < current\n        # If current == 0, then position i-1 has no constraint from position i\n        # (it can be 0 or any value < next_val)\n        # Actually, if current == 0, the sequence of non-zero values breaks\n        # So for position i-1, next_val remains as before\n        \n        if current > 0:\n            next_val = current\n        # else: next_val remains unchanged\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.01573610305786}
{"eval_index": 393, "problem_id": 3542, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.65500211715698}
{"eval_index": 394, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    \n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    increase = []\n    decrease = []\n    \n    for a, b in projects:\n        if b >= 0:\n            increase.append((a, b))\n        else:\n            decrease.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    increase.sort(key=lambda x: x[0])\n    \n    # Process increasing projects first\n    for a, b in increase:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # Equivalent to sorting by (a + b) descending\n    decrease.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process decreasing projects\n    for a, b in decrease:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.67530059814453}
{"eval_index": 395, "problem_id": 1991, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        \n        # Count how many positions are already correct\n        correct_positions = 0\n        for i in range(n):\n            if arr[i] == i + 1:\n                correct_positions += 1\n        \n        # If all positions are correct, no exchanges needed\n        if correct_positions == n:\n            results.append(0)\n            continue\n        \n        # Find the first incorrect position from left\n        left = 0\n        while left < n and arr[left] == left + 1:\n            left += 1\n        \n        # Find the first incorrect position from right\n        right = n - 1\n        while right >= 0 and arr[right] == right + 1:\n            right -= 1\n        \n        # Check if there are any correct positions between left and right\n        has_correct_in_middle = False\n        for i in range(left, right + 1):\n            if arr[i] == i + 1:\n                has_correct_in_middle = True\n                break\n        \n        # Determine the answer based on the pattern\n        if has_correct_in_middle:\n            # If there's at least one correct position in the middle, need 2 exchanges\n            results.append(2)\n        else:\n            # All positions in the incorrect segment are incorrect, need 1 exchange\n            results.append(1)\n    \n    # Output all results\n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.975627899169922}
{"eval_index": 396, "problem_id": 3410, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.14679741859436}
{"eval_index": 397, "problem_id": 4766, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split('\\n')\n    if not data:\n        return\n    \n    n = int(data[0])\n    output_lines = []\n    \n    for i in range(1, n + 1):\n        line = data[i]\n        if line.startswith(\"Simon says\"):\n            # Check if there's content after \"Simon says\"\n            if len(line) > 10 and line[10] == ' ':\n                # Output everything after \"Simon says\" (including the space)\n                output_lines.append(line[10:])\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 34.16577982902527}
{"eval_index": 398, "problem_id": 2498, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    M = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    # Step 1: Transform each a_k to b_k = a_k // 2\n    b = [x // 2 for x in a]\n    \n    # Step 2: Compute LCM of all b_k\n    lcm_val = 1\n    for val in b:\n        lcm_val = lcm_val * val // math.gcd(lcm_val, val)\n        # Early exit if LCM exceeds M\n        if lcm_val > M:\n            print(0)\n            return\n    \n    # Step 3: Check parity condition\n    for val in b:\n        if (lcm_val // val) % 2 == 0:\n            print(0)\n            return\n    \n    # Step 4: Count multiples of lcm_val up to M\n    # We need to count X such that X = lcm_val * (2t + 1) <= M\n    # => 2t + 1 <= M // lcm_val\n    # => t <= (M // lcm_val - 1) // 2\n    max_t = (M // lcm_val - 1) // 2\n    count = max_t + 1 if max_t >= 0 else 0\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.445719718933105}
{"eval_index": 399, "problem_id": 3964, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.73551082611084}
{"eval_index": 400, "problem_id": 4942, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    t = list(map(int, data[1:1+n]))\n    \n    # Sort growth times in descending order\n    t.sort(reverse=True)\n    \n    # Calculate earliest party day\n    earliest_day = 0\n    for i, days in enumerate(t):\n        # Planting day is i+1 (1-indexed), growth completes at i+1 + days\n        # But we need to consider that planting takes 1 day per tree\n        # Actually, we plant one tree per day starting from day 1\n        # So tree i is planted on day i+1, grows on day i+1 + days\n        completion_day = (i + 1) + days\n        earliest_day = max(earliest_day, completion_day)\n    \n    # Party is on the next day after last tree grows\n    print(earliest_day + 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.130236864089966}
{"eval_index": 401, "problem_id": 1817, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Sort the array\n    arr.sort()\n    \n    # If n is odd, first player picks the median\n    # If n is even, first player picks the smaller of the two middle elements\n    # After sorting, the optimal final number is arr[(n-1)//2]\n    result = arr[(n-1)//2]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.33018183708191}
{"eval_index": 402, "problem_id": 3445, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.8470480442047}
{"eval_index": 403, "problem_id": 4793, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    s, v1, v2 = map(int, data)\n    \n    # Try all possible numbers of v1 bottles from 0 to s//v1\n    best_x = -1\n    best_y = -1\n    min_bottles = float('inf')\n    \n    for x in range(s // v1 + 1):\n        remaining = s - x * v1\n        if remaining % v2 == 0:\n            y = remaining // v2\n            total_bottles = x + y\n            if total_bottles < min_bottles:\n                min_bottles = total_bottles\n                best_x = x\n                best_y = y\n    \n    if best_x == -1:\n        print(\"Impossible\")\n    else:\n        print(f\"{best_x} {best_y}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.960131406784058}
{"eval_index": 404, "problem_id": 146, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    tabs = list(map(int, data[2:2+n]))\n    \n    # Calculate initial total difference\n    total_diff = sum(tabs)  # 1 for test, -1 for social, so sum = e - s\n    \n    max_diff = -float('inf')\n    \n    # Try all possible starting positions b (1-indexed)\n    for b in range(1, n+1):\n        # Calculate which tabs would be closed with this b\n        closed_indices = []\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_indices.append(c-1)  # convert to 0-index\n                i += 1\n            else:\n                break\n        \n        i = -1\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                if c != b:  # avoid duplicate\n                    closed_indices.append(c-1)\n                i -= 1\n            else:\n                break\n        \n        # Remove duplicates and sort\n        closed_indices = sorted(set(closed_indices))\n        \n        # Calculate new difference after closing these tabs\n        # Remove contributions of closed tabs from total_diff\n        new_diff = total_diff - sum(tabs[idx] for idx in closed_indices)\n        \n        # Update maximum absolute difference\n        max_diff = max(max_diff, abs(new_diff))\n    \n    print(max_diff)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 71.84058356285095}
{"eval_index": 405, "problem_id": 3606, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.77458882331848}
{"eval_index": 406, "problem_id": 4788, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef minimum_distance(n1, n2):\n    \"\"\"Calculate shortest rotation from n1 to n2 on compass (0-359 degrees).\"\"\"\n    # Calculate clockwise distance\n    if n2 >= n1:\n        clockwise = n2 - n1\n    else:\n        clockwise = 360 - n1 + n2\n    \n    # Calculate counterclockwise distance\n    counterclockwise = 360 - clockwise\n    \n    # Choose the shorter distance\n    if clockwise < counterclockwise:\n        return clockwise\n    elif counterclockwise < clockwise:\n        return -counterclockwise\n    else:\n        # If equal (180 degrees), choose clockwise as specified\n        return 180\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    \n    n1 = int(data[0])\n    n2 = int(data[1])\n    \n    # Calculate and output result\n    result = minimum_distance(n1, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 39.97555899620056}
{"eval_index": 407, "problem_id": 2121, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ninput = sys.stdin.readline\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Binary search on answer\n    lo, hi = 1, 10**6\n    ans = 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        # Check if we can achieve grade >= mid\n        # We need to see if we can arrange tree so that first k nodes in DFS all have a[i] >= mid\n        \n        # DP on tree: for each node, compute max number of nodes we can include in first k\n        # with all values >= mid, when this node is root of its subtree\n        dp = [0] * n\n        \n        def dfs(u, parent):\n            children = []\n            for v in adj[u]:\n                if v == parent:\n                    continue\n                dfs(v, u)\n                children.append(dp[v])\n            \n            # Sort children in descending order of their dp values\n            children.sort(reverse=True)\n            \n            # Base: if a[u] < mid, this node cannot be included\n            if a[u] < mid:\n                dp[u] = 0\n                return\n            \n            # We can include this node\n            total = 1  # count this node\n            \n            # Add children in order\n            for i, val in enumerate(children):\n                if total + val <= k:\n                    total += val\n                else:\n                    # If adding this child would exceed k, we can take partial?\n                    # Actually we can't take partial from a child's subtree in DFS order\n                    # So we stop when adding next child would exceed k\n                    break\n            \n            dp[u] = total\n        \n        # Try all possible roots\n        possible = False\n        for root in range(n):\n            dfs(root, -1)\n            if dp[root] >= k:\n                possible = True\n                break\n        \n        if possible:\n            ans = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.012922286987305}
{"eval_index": 408, "problem_id": 3884, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 85.43349075317383}
{"eval_index": 409, "problem_id": 4008, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.48398494720459}
{"eval_index": 410, "problem_id": 2131, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\n# Read input\nn = int(sys.stdin.readline())\nadj = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, sys.stdin.readline().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\n# DFS to find degrees and leaf information\ndeg = [0] * (n + 1)\nfor i in range(1, n + 1):\n    deg[i] = len(adj[i])\n\n# Check if decomposition exists\n# Condition: all nodes must have degree <= 2 except possibly one node\n# This is because paths must share at least one vertex\ncnt_deg_gt_2 = 0\ncenter = -1\nfor i in range(1, n + 1):\n    if deg[i] > 2:\n        cnt_deg_gt_2 += 1\n        center = i\n\nif cnt_deg_gt_2 > 1:\n    print(\"No\")\n    sys.exit(0)\n\n# If no node has degree > 2, the tree is a simple path\nif cnt_deg_gt_2 == 0:\n    # Find endpoints of the path (nodes with degree 1)\n    endpoints = [i for i in range(1, n + 1) if deg[i] == 1]\n    if len(endpoints) != 2:\n        # This shouldn't happen for a tree, but handle it\n        print(\"No\")\n        sys.exit(0)\n    print(\"Yes\")\n    print(1)\n    print(f\"{endpoints[0]} {endpoints[1]}\")\n    sys.exit(0)\n\n# There is exactly one node with degree > 2 (center)\n# Decomposition: each edge from center to its neighbors forms a path\n# But we need to extend each path to a leaf\npaths = []\nvisited = [False] * (n + 1)\nvisited[center] = True\n\nfor neighbor in adj[center]:\n    # Follow this branch to a leaf\n    current = neighbor\n    prev = center\n    while deg[current] > 1:\n        # Move to the next node (not going back)\n        for next_node in adj[current]:\n            if next_node != prev:\n                prev = current\n                current = next_node\n                break\n    # current is now a leaf\n    paths.append((center, current))\n\nprint(\"Yes\")\nprint(len(paths))\nfor u, v in paths:\n    print(f\"{u} {v}\")", "complexity_estimate": null, "runtime_sec": 65.0614607334137}
{"eval_index": 411, "problem_id": 3759, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.80864095687866}
{"eval_index": 412, "problem_id": 4903, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read two lines of input\n    jon_ah = sys.stdin.readline().strip()\n    doc_ah = sys.stdin.readline().strip()\n    \n    # Count the number of 'a's in each string\n    jon_a_count = jon_ah.count('a')\n    doc_a_count = doc_ah.count('a')\n    \n    # Compare counts: Jon can go if his 'a' count >= doctor's 'a' count\n    if jon_a_count >= doc_a_count:\n        print(\"go\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.46638584136963}
{"eval_index": 413, "problem_id": 1829, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    poland_words = set(data[2:2+n])\n    enemy_words = set(data[2+n:2+n+m])\n    \n    common = poland_words.intersection(enemy_words)\n    \n    # Count words only Poland knows and only Enemy knows\n    only_poland = len(poland_words) - len(common)\n    only_enemy = len(enemy_words) - len(common)\n    \n    # Poland starts, optimal play analysis\n    # Common words can be used by either player first\n    # If Poland uses a common word, Enemy loses that word too\n    # The game reduces to: Poland has only_poland + ceil(common/2) moves\n    # Enemy has only_enemy + floor(common/2) moves\n    \n    poland_moves = only_poland + (len(common) + 1) // 2\n    enemy_moves = only_enemy + len(common) // 2\n    \n    # Poland wins if he has at least as many moves as Enemy\n    # Actually, Poland wins if he can force Enemy to run out first\n    # Since Poland starts, he wins if poland_moves > enemy_moves\n    \n    if poland_moves > enemy_moves:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.609692096710205}
{"eval_index": 414, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.24051904678345}
{"eval_index": 415, "problem_id": 4153, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    S = sys.stdin.readline().strip()\n    # Count occurrences of '0' and '1'\n    count_0 = S.count('0')\n    count_1 = S.count('1')\n    # Each operation removes one '0' and one '1'\n    # Maximum operations is limited by the smaller count\n    max_removed = 2 * min(count_0, count_1)\n    print(max_removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.935132503509521}
{"eval_index": 416, "problem_id": 2287, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    idx = 1\n    for _ in range(t):\n        s = data[idx]\n        idx += 1\n        \n        # Find first and last occurrence of '1'\n        first_one = -1\n        last_one = -1\n        for i, ch in enumerate(s):\n            if ch == '1':\n                if first_one == -1:\n                    first_one = i\n                last_one = i\n        \n        # If no '1's, answer is 0\n        if first_one == -1:\n            results.append('0')\n            continue\n        \n        # Count zeros between first and last '1'\n        zeros_to_remove = 0\n        for i in range(first_one, last_one + 1):\n            if s[i] == '0':\n                zeros_to_remove += 1\n        \n        results.append(str(zeros_to_remove))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.099507808685303}
{"eval_index": 417, "problem_id": 3143, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 123.83139061927795}
{"eval_index": 418, "problem_id": 4090, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 99.94800090789795}
{"eval_index": 419, "problem_id": 2445, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.79522895812988}
{"eval_index": 420, "problem_id": 3795, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.82489562034607}
{"eval_index": 421, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    current = s\n    idx = 1\n    \n    while True:\n        if current in seen:\n            print(idx)\n            return\n        seen[current] = idx\n        current = f(current)\n        idx += 1\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.888852596282959}
{"eval_index": 422, "problem_id": 1821, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.99126601219177}
{"eval_index": 423, "problem_id": 3865, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.1483793258667}
{"eval_index": 424, "problem_id": 4004, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # If all elements are already equal, D = 0\n    if len(set(a)) == 1:\n        print(0)\n        return\n    \n    # Try all possible target values\n    # Since we can add D, subtract D, or leave unchanged,\n    # the target must be reachable from each element with at most one operation\n    # This means for each element a_i, target must be in {a_i - D, a_i, a_i + D}\n    # So D must be the absolute difference between target and a_i for elements that change\n    \n    # The target value must be one of the values in the array or between them\n    # Actually, we can consider all possible targets from min(a) to max(a)\n    # But since n <= 100 and a_i <= 100, we can brute force all possible D from 0 to 100\n    \n    min_d = float('inf')\n    found = False\n    \n    # Try all possible D values from 0 to 100 (since a_i <= 100)\n    for D in range(0, 101):\n        # For this D, check if there exists a target value that works\n        # We need to find a target T such that for all i:\n        # a_i == T or a_i + D == T or a_i - D == T\n        \n        # For each element, the possible targets are:\n        # a_i, a_i + D, a_i - D (if a_i - D >= 0, but problem allows negative)\n        # Actually problem says \"It is possible that after an operation the value a_i becomes negative\"\n        # So we don't need to check a_i - D >= 0\n        \n        # Collect all possible targets from first element\n        possible_targets = set([a[0], a[0] + D, a[0] - D])\n        \n        # For each subsequent element, intersect with its possible targets\n        for i in range(1, n):\n            element_targets = set([a[i], a[i] + D, a[i] - D])\n            possible_targets = possible_targets.intersection(element_targets)\n            if not possible_targets:\n                break\n        \n        if possible_targets:\n            # This D works\n            min_d = min(min_d, D)\n            found = True\n            # We can break early if D=0 works, but we already checked that\n            # Actually we want minimum D, so we should continue checking smaller D first\n            # But we're iterating D from 0 upward, so first found is minimum\n            # However, we need to check all D from 0 upward to find minimum\n            # Since we're iterating from 0 upward, first valid D is minimum\n            print(D)\n            return\n    \n    if not found:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 83.09500932693481}
{"eval_index": 425, "problem_id": 1832, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 69.45576572418213}
{"eval_index": 426, "problem_id": 3805, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.96850037574768}
{"eval_index": 427, "problem_id": 4962, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(600000)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n + 1))\n        self.size = [1] * (n + 1)\n        self.empty = [True] * (n + 1)\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return root_x\n        if self.size[root_x] < self.size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.parent[root_y] = root_x\n        self.size[root_x] += self.size[root_y]\n        self.empty[root_x] = self.empty[root_x] or self.empty[root_y]\n        return root_x\n\ndef main():\n    input = sys.stdin.readline\n    N, L = map(int, input().split())\n    uf = UnionFind(L)\n    result = []\n    \n    for i in range(1, N + 1):\n        a, b = map(int, input().split())\n        root_a = uf.find(a)\n        root_b = uf.find(b)\n        \n        if uf.empty[root_a]:\n            uf.empty[root_a] = False\n            result.append(\"LADICA\")\n            if root_a != root_b:\n                uf.union(root_a, root_b)\n        elif uf.empty[root_b]:\n            uf.empty[root_b] = False\n            result.append(\"LADICA\")\n            if root_a != root_b:\n                uf.union(root_b, root_a)\n        else:\n            root = uf.union(root_a, root_b)\n            if uf.empty[root]:\n                uf.empty[root] = False\n                result.append(\"LADICA\")\n            else:\n                result.append(\"SMECE\")\n    \n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 27.768391132354736}
{"eval_index": 428, "problem_id": 1511, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    # Read instructions: n x m matrix\n    instructions = []\n    for _ in range(n):\n        row = [int(next(it)) for _ in range(m)]\n        instructions.append(row)\n    \n    # Track locked cores and cells\n    locked_core = [0] * (n + 1)  # 0 means not locked, else cycle number\n    locked_cell = [False] * (k + 1)  # True if cell is locked\n    \n    # Process each cycle\n    for cycle in range(1, m + 1):\n        # For each core, check its instruction for this cycle\n        for core in range(1, n + 1):\n            # Skip if already locked\n            if locked_core[core] != 0:\n                continue\n            \n            instr = instructions[core - 1][cycle - 1]\n            if instr == 0:\n                # Do nothing\n                continue\n            \n            # Writing to cell instr\n            cell = instr\n            if locked_cell[cell]:\n                # Cell is already locked, so this core locks now\n                locked_core[core] = cycle\n                continue\n            \n            # Check if any other core writes to same cell this cycle\n            conflict_cores = []\n            for other_core in range(1, n + 1):\n                if other_core == core:\n                    continue\n                if locked_core[other_core] != 0:\n                    continue\n                other_instr = instructions[other_core - 1][cycle - 1]\n                if other_instr == cell:\n                    conflict_cores.append(other_core)\n            \n            if conflict_cores:\n                # Deadlock: all writing cores and the cell lock\n                locked_core[core] = cycle\n                for oc in conflict_cores:\n                    locked_core[oc] = cycle\n                locked_cell[cell] = True\n            else:\n                # No conflict, write succeeds (but we don't need to track content)\n                pass\n    \n    # Output results\n    out_lines = []\n    for core in range(1, n + 1):\n        out_lines.append(str(locked_core[core]))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 36.26878547668457}
{"eval_index": 429, "problem_id": 3422, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.3113875389099}
{"eval_index": 430, "problem_id": 4441, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    n = int(input().strip())\n    if n == 1:\n        print(\"Hello World\")\n    else:\n        a = int(input().strip())\n        b = int(input().strip())\n        print(a + b)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.692486047744751}
{"eval_index": 431, "problem_id": 2541, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Precompute all perfect powers up to 10^18\nMAX = 10**18\nperfect_powers = set()\n\n# For base a from 2 to 10^9 (since 2^60 > 10^18)\n# For exponent p from 2 to 60 (since 2^60 > 10^18)\nfor a in range(2, 10**6 + 1):  # sqrt(10^18) = 10^9, but we can limit further\n    val = a * a\n    p = 2\n    while val <= MAX:\n        perfect_powers.add(val)\n        val *= a\n        p += 1\n        if val > MAX // a:  # Prevent overflow\n            break\n\n# Add 1 since 1 = 1^p for any p > 1\nperfect_powers.add(1)\n\n# Convert to sorted list for binary search\nperfect_powers_list = sorted(perfect_powers)\n\n# Function to count perfect powers in [L, R]\ndef count_perfect_powers(L, R):\n    # Find first index >= L\n    left = 0\n    right = len(perfect_powers_list) - 1\n    first_idx = len(perfect_powers_list)\n    while left <= right:\n        mid = (left + right) // 2\n        if perfect_powers_list[mid] >= L:\n            first_idx = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    # Find last index <= R\n    left = 0\n    right = len(perfect_powers_list) - 1\n    last_idx = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if perfect_powers_list[mid] <= R:\n            last_idx = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    if first_idx > last_idx:\n        return 0\n    return last_idx - first_idx + 1\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    Q = int(input_data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(Q):\n        L = int(input_data[idx])\n        R = int(input_data[idx + 1])\n        idx += 2\n        results.append(str(count_perfect_powers(L, R)))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 98.03433632850647}
{"eval_index": 432, "problem_id": 3708, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.07479095458984}
{"eval_index": 433, "problem_id": 4838, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    times = list(map(int, data[1:1+n]))\n    \n    total_time = 0\n    is_running = False\n    last_start = 0\n    \n    for i in range(n):\n        current_time = times[i]\n        if is_running:\n            total_time += current_time - last_start\n            is_running = False\n        else:\n            last_start = current_time\n            is_running = True\n    \n    if is_running:\n        print(\"still running\")\n    else:\n        print(total_time)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.510755062103271}
{"eval_index": 434, "problem_id": 2509, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    if K == 0:\n        # All pairs (a,b) with 1 <= a,b <= N are valid\n        print(N * N)\n        return\n    \n    ans = 0\n    # For each b from K+1 to N\n    for b in range(K + 1, N + 1):\n        # Full cycles: each full cycle contributes (b-K) valid a values\n        full_cycles = N // b\n        ans += full_cycles * (b - K)\n        \n        # Partial last cycle\n        remainder = N % b\n        if remainder >= K:\n            ans += remainder - K + 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.298415899276733}
{"eval_index": 435, "problem_id": 3156, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    \n    # inventory[i] = set of items available at store i\n    inventory = [set() for _ in range(N)]\n    # item_to_stores[item] = list of stores that have this item\n    item_to_stores = defaultdict(list)\n    \n    for _ in range(K):\n        store_idx = int(next(it))\n        item = next(it)\n        inventory[store_idx].add(item)\n        item_to_stores[item].append(store_idx)\n    \n    M = int(next(it))\n    bought_items = [next(it) for _ in range(M)]\n    \n    # DP: dp[i][j] = number of ways to assign first i items ending at store j\n    # We only need to track the last store\n    # dp_prev[j] = ways for previous item ending at store j\n    # dp_curr[j] = ways for current item ending at store j\n    \n    # Initialize for first item\n    dp_prev = [0] * N\n    first_item = bought_items[0]\n    possible_stores = item_to_stores.get(first_item, [])\n    if not possible_stores:\n        print(\"impossible\")\n        return\n    for store in possible_stores:\n        dp_prev[store] = 1\n    \n    # Process remaining items\n    for idx in range(1, M):\n        item = bought_items[idx]\n        possible_stores = item_to_stores.get(item, [])\n        if not possible_stores:\n            print(\"impossible\")\n            return\n        \n        dp_curr = [0] * N\n        # For each possible store for current item\n        for curr_store in possible_stores:\n            # Sum ways from previous stores that are <= current store\n            total = 0\n            for prev_store in range(curr_store + 1):\n                if dp_prev[prev_store] > 0:\n                    total += dp_prev[prev_store]\n                    if total > 1:  # Early stop if already ambiguous\n                        total = 2\n                        break\n            if total > 0:\n                dp_curr[curr_store] = min(total, 2)  # Cap at 2 to avoid overflow\n        \n        # Check if any assignment possible for this item\n        if all(v == 0 for v in dp_curr):\n            print(\"impossible\")\n            return\n        \n        dp_prev = dp_curr\n    \n    # Sum all ways for last item\n    total_ways = sum(dp_prev)\n    if total_ways == 0:\n        print(\"impossible\")\n    elif total_ways == 1:\n        print(\"unique\")\n    else:\n        print(\"ambiguous\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 100.32777976989746}
{"eval_index": 436, "problem_id": 4603, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read four integers from standard input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 4:\n        return\n    A, B, C, D = map(int, data[:4])\n    \n    # Choose the minimum fare for train and bus separately\n    min_train = min(A, B)\n    min_bus = min(C, D)\n    \n    # Total minimum fare\n    total = min_train + min_bus\n    \n    # Output the result\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.071901321411133}
{"eval_index": 437, "problem_id": 2407, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndef solve():\n    data = input().split()\n    idx = 0\n    q = int(data[idx]); idx += 1\n    results = []\n    for _ in range(q):\n        n = int(data[idx]); idx += 1\n        r = int(data[idx]); idx += 1\n        positions = list(map(int, data[idx:idx+n]))\n        idx += n\n        positions = sorted(set(positions), reverse=True)\n        missiles = 0\n        push_effect = 0\n        for pos in positions:\n            if pos - push_effect * r <= 0:\n                break\n            missiles += 1\n            push_effect += 1\n        results.append(str(missiles))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.13635277748108}
{"eval_index": 438, "problem_id": 3517, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 142.8389549255371}
{"eval_index": 439, "problem_id": 4321, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    \n    print(n)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.450479984283447}
{"eval_index": 440, "problem_id": 2500, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.97906756401062}
{"eval_index": 441, "problem_id": 3481, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.08630800247192}
{"eval_index": 442, "problem_id": 4005, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.41332745552063}
{"eval_index": 443, "problem_id": 37, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    # Check if c is divisible by gcd(a, b)\n    import math\n    g = math.gcd(a, b)\n    if c % g != 0:\n        print(\"No\")\n        return\n    # For non-negative x, y: a*x + b*y = c\n    # We can check if there exists non-negative integer solution\n    # by trying possible x values from 0 to c//a\n    max_x = c // a\n    for x in range(max_x + 1):\n        remaining = c - a * x\n        if remaining >= 0 and remaining % b == 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.87866711616516}
{"eval_index": 444, "problem_id": 3888, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.98476719856262}
{"eval_index": 445, "problem_id": 4374, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.7898931503296}
{"eval_index": 446, "problem_id": 2439, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.21338987350464}
{"eval_index": 447, "problem_id": 3950, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 148.98048377037048}
{"eval_index": 448, "problem_id": 4840, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef read_input():\n    \"\"\"Read input from stdin.\"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    # Convert to integers\n    nums = list(map(int, data))\n    # Gunnar's dice: a1, b1, a2, b2\n    gunnar = nums[:4]\n    # Emma's dice: a3, b3, a4, b4\n    emma = nums[4:8]\n    return gunnar, emma\n\ndef expected_sum(a, b):\n    \"\"\"Calculate expected value of a die with numbers a..b inclusive.\"\"\"\n    # Sum of arithmetic series: n * (first + last) / 2\n    n = b - a + 1\n    total = n * (a + b) // 2\n    # Expected value = total / n\n    return total / n\n\ndef main():\n    \"\"\"Main function to determine winner.\"\"\"\n    data = read_input()\n    if data is None:\n        return\n    gunnar, emma = data\n    # Calculate expected sum for each player\n    g_exp = expected_sum(gunnar[0], gunnar[1]) + expected_sum(gunnar[2], gunnar[3])\n    e_exp = expected_sum(emma[0], emma[1]) + expected_sum(emma[2], emma[3])\n    # Compare expected sums\n    if g_exp > e_exp:\n        print(\"Gunnar\")\n    elif e_exp > g_exp:\n        print(\"Emma\")\n    else:\n        print(\"Tie\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.99312114715576}
{"eval_index": 449, "problem_id": 1074, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.02430200576782}
{"eval_index": 450, "problem_id": 3709, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.97565984725952}
{"eval_index": 451, "problem_id": 4724, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R = int(data[0])\n    G = int(data[1])\n    # From formula: G = (R + P) / 2\n    # Solve for P: P = 2*G - R\n    performance = 2 * G - R\n    print(performance)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.59235668182373}
{"eval_index": 452, "problem_id": 299, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    chest = biceps = back = 0\n    for i in range(n):\n        if i % 3 == 0:\n            chest += a[i]\n        elif i % 3 == 1:\n            biceps += a[i]\n        else:\n            back += a[i]\n    \n    if chest > biceps and chest > back:\n        print(\"chest\")\n    elif biceps > chest and biceps > back:\n        print(\"biceps\")\n    else:\n        print(\"back\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.110395669937134}
{"eval_index": 453, "problem_id": 3597, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.2297658920288}
{"eval_index": 454, "problem_id": 4182, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 68.92494940757751}
{"eval_index": 455, "problem_id": 1235, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 50.65912199020386}
{"eval_index": 456, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.10610699653625}
{"eval_index": 457, "problem_id": 4400, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    S = input().strip()\n    max_consecutive = 0\n    current_consecutive = 0\n    \n    for char in S:\n        if char == 'R':\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    \n    print(max_consecutive)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.888237953186035}
{"eval_index": 458, "problem_id": 2264, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    max_l = 0\n    min_r = 10**9 + 1\n    \n    for i in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        idx += 2\n        max_l = max(max_l, l)\n        min_r = min(min_r, r)\n    \n    length = max(0, max_l - min_r)\n    results.append(str(length))\n\nprint('\\n'.join(results))", "complexity_estimate": null, "runtime_sec": 17.29852819442749}
{"eval_index": 459, "problem_id": 3825, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.53157591819763}
{"eval_index": 460, "problem_id": 4378, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.77610111236572}
{"eval_index": 461, "problem_id": 2480, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # We need to count contiguous subsequences where (sum % K) == (length % K)\n    # Let prefix_sum[i] = sum(A[0..i-1]) % K\n    # For a subsequence A[l..r], sum = prefix_sum[r+1] - prefix_sum[l] (mod K)\n    # Length = r - l + 1\n    # Condition: (prefix_sum[r+1] - prefix_sum[l]) % K == (r - l + 1) % K\n    # Rearranging: (prefix_sum[r+1] - (r+1)) % K == (prefix_sum[l] - l) % K\n    \n    # Let B[i] = (prefix_sum[i] - i) % K for i from 0 to N\n    # We need pairs (l, r) with 0 <= l < r <= N such that B[l] == B[r]\n    # and r - l < K (since length must be < K for modulo condition to match)\n    \n    prefix_sum = 0\n    B = [0] * (N + 1)\n    B[0] = 0  # prefix_sum[0] = 0, i=0\n    \n    for i in range(1, N + 1):\n        prefix_sum = (prefix_sum + A[i-1]) % K\n        B[i] = (prefix_sum - i) % K\n    \n    # Count valid pairs using sliding window of size K\n    from collections import defaultdict\n    count_map = defaultdict(int)\n    result = 0\n    \n    # Process first K indices (0 to min(K-1, N))\n    for i in range(min(K, N + 1)):\n        result += count_map[B[i]]\n        count_map[B[i]] += 1\n    \n    # Slide window: remove element that's K positions behind\n    for i in range(K, N + 1):\n        count_map[B[i-K]] -= 1\n        result += count_map[B[i]]\n        count_map[B[i]] += 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 144.8392117023468}
{"eval_index": 462, "problem_id": 3271, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef count_sequences(N, C):\n    if C < 0 or C > N * (N - 1) // 2:\n        return 0\n    \n    # dp[i][j] = number of permutations of length i with exactly j inversions\n    dp = [[0] * (C + 1) for _ in range(N + 1)]\n    \n    # Base case: length 0 has 0 inversions\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        # For length i, maximum inversions is i*(i-1)//2\n        max_inv = min(C, i * (i - 1) // 2)\n        \n        # Compute prefix sums for optimization\n        prefix = [0] * (C + 2)\n        for j in range(C + 1):\n            prefix[j + 1] = (prefix[j] + dp[i - 1][j]) % MOD\n        \n        for j in range(max_inv + 1):\n            # When inserting number i at position k (0-indexed) in permutation of length i-1\n            # It creates exactly k new inversions\n            # So we need dp[i-1][j-k] where 0 <= k <= min(i-1, j)\n            k_min = 0\n            k_max = min(i - 1, j)\n            \n            # Using prefix sums: sum_{k=0}^{k_max} dp[i-1][j-k]\n            # = prefix[j+1] - prefix[j-k_max]\n            dp[i][j] = (prefix[j + 1] - prefix[j - k_max]) % MOD\n            \n    return dp[N][C] % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    C = int(data[1])\n    result = count_sequences(N, C)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 54.7814564704895}
{"eval_index": 463, "problem_id": 4267, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read integer input from standard input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    X = int(data)\n    \n    # Check if temperature is 30 or above\n    if X >= 30:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.078356742858887}
{"eval_index": 464, "problem_id": 2849, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 130.55487728118896}
{"eval_index": 465, "problem_id": 3164, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.18646740913391}
{"eval_index": 466, "problem_id": 4019, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 136.0540416240692}
{"eval_index": 467, "problem_id": 1399, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.4469792842865}
{"eval_index": 468, "problem_id": 3272, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 169.43666410446167}
{"eval_index": 469, "problem_id": 4220, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    S = data[1]\n    \n    if len(S) <= K:\n        print(S)\n    else:\n        print(S[:K] + \"...\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.92375135421753}
{"eval_index": 470, "problem_id": 1290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    columns = [0] * (n + 1)  # 1-indexed for convenience\n    points = 0\n    \n    # Process each square appearance\n    for i in range(m):\n        col = int(data[2 + i])\n        columns[col] += 1\n        \n        # Check if all columns have at least one square\n        if all(columns[j] > 0 for j in range(1, n + 1)):\n            points += 1\n            # Remove bottom row: decrement all columns by 1\n            for j in range(1, n + 1):\n                columns[j] -= 1\n    \n    print(points)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.08834934234619}
{"eval_index": 471, "problem_id": 3155, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.3906033039093}
{"eval_index": 472, "problem_id": 4372, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Find the maximum value in a\n    max_a = max(a)\n    \n    # Calculate the sum of differences from max_a\n    diff_sum = 0\n    for val in a:\n        diff_sum += max_a - val\n    \n    # If all values are the same (should not happen per problem statement)\n    if diff_sum == 0:\n        # Find the next maximum\n        unique_vals = sorted(set(a), reverse=True)\n        if len(unique_vals) > 1:\n            second_max = unique_vals[1]\n            diff_sum = 0\n            for val in a:\n                diff_sum += second_max - val\n            # y = n, z = max_a - second_max\n            y = n\n            z = max_a - second_max\n            print(f\"{y} {z}\")\n            return\n    \n    # Calculate GCD of all differences\n    gcd_val = 0\n    for val in a:\n        diff = max_a - val\n        if diff > 0:\n            gcd_val = math.gcd(gcd_val, diff)\n    \n    # If all differences are 0 (all values equal)\n    if gcd_val == 0:\n        # This case shouldn't occur due to problem constraints\n        # But handle it by finding the next maximum\n        unique_vals = sorted(set(a), reverse=True)\n        if len(unique_vals) > 1:\n            second_max = unique_vals[1]\n            gcd_val = 0\n            for val in a:\n                diff = second_max - val\n                if diff > 0:\n                    gcd_val = math.gcd(gcd_val, diff)\n            if gcd_val == 0:\n                gcd_val = 1\n            y = sum((second_max - val) // gcd_val for val in a)\n            z = gcd_val\n            print(f\"{y} {z}\")\n            return\n        else:\n            # All values are equal - shouldn't happen per problem\n            print(\"1 0\")\n            return\n    \n    # Calculate y as sum of (max_a - a_i) / gcd_val\n    y = diff_sum // gcd_val\n    z = gcd_val\n    \n    print(f\"{y} {z}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.30820822715759}
{"eval_index": 473, "problem_id": 953, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 68.77271056175232}
{"eval_index": 474, "problem_id": 3915, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.12345051765442}
{"eval_index": 475, "problem_id": 4333, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    x1, y1, x2, y2 = map(int, data)\n    \n    # Calculate vector from (x1,y1) to (x2,y2)\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Rotate vector 90 degrees counter-clockwise to get from (x2,y2) to (x3,y3)\n    # For counter-clockwise rotation: (dx, dy) -> (-dy, dx)\n    x3 = x2 - dy\n    y3 = y2 + dx\n    \n    # Calculate (x4,y4) by rotating vector from (x1,y1) to (x2,y2) 90 degrees counter-clockwise\n    # and adding to (x1,y1)\n    x4 = x1 - dy\n    y4 = y1 + dx\n    \n    # Output the result\n    print(f\"{x3} {y3} {x4} {y4}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.03855609893799}
{"eval_index": 476, "problem_id": 801, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.05227971076965}
{"eval_index": 477, "problem_id": 3180, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.99526119232178}
{"eval_index": 478, "problem_id": 4861, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 85.07347083091736}
{"eval_index": 479, "problem_id": 1765, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.12564659118652}
{"eval_index": 480, "problem_id": 3381, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 91.48970317840576}
{"eval_index": 481, "problem_id": 4893, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = int(data[1])\n    distances = list(map(int, data[2:2+n]))\n    \n    # Sort distances in ascending order\n    distances.sort()\n    \n    # The car directly in front is the closest one\n    # We need to ensure for all cars x ahead: distance_to_x >= p * (number_of_cars_between + 1)\n    # For the car directly in front (index 0 in sorted list), number_of_cars_between = 0\n    # So we need: distance_to_front >= p * 1 = p\n    # But we also need to check all other cars\n    \n    # For each car at position i (0-indexed), there are i cars between us and that car\n    # So requirement: distances[i] >= p * (i + 1)\n    # We need to find the minimum distance to front that satisfies all requirements\n    \n    # Let d be the distance to the car directly in front\n    # Then distance to car at position i would be d + (distances[i] - distances[0])\n    # Because we maintain relative distances between cars\n    \n    # Requirement becomes: d + (distances[i] - distances[0]) >= p * (i + 1)\n    # So d >= p * (i + 1) - (distances[i] - distances[0])\n    # We need d to satisfy this for all i\n    \n    min_d = 0  # Minimum distance to front car\n    for i in range(n):\n        required = p * (i + 1) - (distances[i] - distances[0])\n        if required > min_d:\n            min_d = required\n    \n    # Also need to satisfy the basic requirement for front car: d >= p\n    if p > min_d:\n        min_d = p\n    \n    # Ensure non-negative distance\n    if min_d < 0:\n        min_d = 0\n    \n    print(min_d)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 77.31852078437805}
{"eval_index": 482, "problem_id": 297, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.31450366973877}
{"eval_index": 483, "problem_id": 3456, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.6915214061737}
{"eval_index": 484, "problem_id": 4368, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # Handle edge case: N = 0 would have 1 digit in any base, but N >= 1 per constraints\n    if N == 0:\n        print(1)\n        return\n    \n    digits = 0\n    n = N\n    while n > 0:\n        n //= K\n        digits += 1\n    \n    print(digits)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.36592698097229}
{"eval_index": 485, "problem_id": 592, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.19891571998596}
{"eval_index": 486, "problem_id": 3822, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 151.77884531021118}
{"eval_index": 487, "problem_id": 4911, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    # Parse attributes\n    attributes = data[0].split()\n    attr_index = {attr: i for i, attr in enumerate(attributes)}\n    \n    # Parse songs\n    m = int(data[1])\n    songs = []\n    for i in range(2, 2 + m):\n        songs.append(data[i].split())\n    \n    # Parse sort commands\n    n = int(data[2 + m])\n    commands = []\n    for i in range(3 + m, 3 + m + n):\n        commands.append(data[i].strip())\n    \n    # Process each sort command\n    output_lines = []\n    for cmd in commands:\n        # Print header\n        output_lines.append(' '.join(attributes))\n        \n        # Stable sort by the current attribute\n        idx = attr_index[cmd]\n        songs.sort(key=lambda x: x[idx])\n        \n        # Print sorted songs\n        for song in songs:\n            output_lines.append(' '.join(song))\n        \n        # Add blank line between outputs (except after last)\n        if cmd != commands[-1]:\n            output_lines.append('')\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.918384790420532}
{"eval_index": 488, "problem_id": 1037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.33333826065063}
{"eval_index": 489, "problem_id": 3539, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.19844102859497}
{"eval_index": 490, "problem_id": 4822, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    R, S, K = map(int, data[:3])\n    grid = data[3:3+R]\n    \n    # Precompute prefix sum for flies\n    prefix = [[0]*(S+1) for _ in range(R+1)]\n    for i in range(R):\n        for j in range(S):\n            prefix[i+1][j+1] = prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\n            if grid[i][j] == '*':\n                prefix[i+1][j+1] += 1\n    \n    max_flies = 0\n    best_i = best_j = 0\n    \n    # Try all possible positions for the inner area (flies strictly inside)\n    # The racket covers area from (i,j) to (i+K-1, j+K-1)\n    # Flies strictly inside means from (i+1,j+1) to (i+K-2, j+K-2)\n    for i in range(R-K+1):\n        for j in range(S-K+1):\n            # Calculate flies in inner rectangle\n            inner_flies = prefix[i+K-1][j+K-1] - prefix[i+1][j+K-1] - prefix[i+K-1][j+1] + prefix[i+1][j+1]\n            if inner_flies > max_flies:\n                max_flies = inner_flies\n                best_i, best_j = i, j\n    \n    # Output max flies\n    print(max_flies)\n    \n    # Create output grid\n    output_grid = [list(row) for row in grid]\n    \n    # Draw the racket\n    top = best_i\n    bottom = best_i + K - 1\n    left = best_j\n    right = best_j + K - 1\n    \n    # Draw corners\n    output_grid[top][left] = '+'\n    output_grid[top][right] = '+'\n    output_grid[bottom][left] = '+'\n    output_grid[bottom][right] = '+'\n    \n    # Draw horizontal edges\n    for col in range(left+1, right):\n        output_grid[top][col] = '-'\n        output_grid[bottom][col] = '-'\n    \n    # Draw vertical edges\n    for row in range(top+1, bottom):\n        output_grid[row][left] = '|'\n        output_grid[row][right] = '|'\n    \n    # Print the grid\n    for row in output_grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.61835026741028}
{"eval_index": 491, "problem_id": 671, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def find_nth_digit(n):\n    # Handle small n directly\n    if n <= 9:\n        return str(n)\n    \n    # Step 1: Find which number block (1-digit, 2-digit, etc.) contains the nth digit\n    length = 1  # length of current numbers (1-digit, 2-digit, etc.)\n    count = 9   # count of numbers with current length\n    start = 1   # first number with current length\n    \n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    # Step 2: Find the specific number containing the nth digit\n    # n is now the position within the block of numbers with 'length' digits\n    # The target number is start + (n-1)//length\n    target_number = start + (n - 1) // length\n    \n    # Step 3: Find the specific digit within that number\n    # The digit position within the number is (n-1) % length\n    digit_index = (n - 1) % length\n    \n    # Convert to string and get the digit\n    return str(target_number)[digit_index]\n\n# Read input and output result\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(find_nth_digit(n))", "complexity_estimate": null, "runtime_sec": 24.72941565513611}
{"eval_index": 492, "problem_id": 3712, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.33266258239746}
{"eval_index": 493, "problem_id": 4975, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef create_playfair_table(key_phrase):\n    \"\"\"Create 5x5 Playfair table from key phrase\"\"\"\n    # Remove spaces and convert to uppercase\n    key = key_phrase.replace(' ', '').upper()\n    \n    # Initialize table and seen letters\n    table = []\n    seen = set()\n    alphabet = 'ABCDEFGHIJKLMNOPRSTUVWXYZ'  # Q is omitted\n    \n    # Add key phrase letters first\n    for ch in key:\n        if ch not in seen:\n            seen.add(ch)\n            table.append(ch)\n    \n    # Add remaining alphabet letters\n    for ch in alphabet:\n        if ch not in seen:\n            seen.add(ch)\n            table.append(ch)\n    \n    # Convert to 5x5 grid\n    grid = [table[i*5:(i+1)*5] for i in range(5)]\n    return grid\n\ndef find_position(grid, ch):\n    \"\"\"Find row and column of a character in the grid\"\"\"\n    for i in range(5):\n        for j in range(5):\n            if grid[i][j] == ch:\n                return i, j\n    return -1, -1  # Should never happen\n\ndef encrypt_pair(grid, a, b):\n    \"\"\"Encrypt a pair of letters using Playfair rules\"\"\"\n    row1, col1 = find_position(grid, a)\n    row2, col2 = find_position(grid, b)\n    \n    # Same row\n    if row1 == row2:\n        return grid[row1][(col1 + 1) % 5] + grid[row2][(col2 + 1) % 5]\n    \n    # Same column\n    if col1 == col2:\n        return grid[(row1 + 1) % 5][col1] + grid[(row2 + 1) % 5][col2]\n    \n    # Rectangle swap\n    return grid[row1][col2] + grid[row2][col1]\n\ndef prepare_text(text):\n    \"\"\"Prepare text for encryption: remove spaces, handle duplicates, add X if needed\"\"\"\n    # Remove spaces and convert to uppercase\n    text = text.replace(' ', '').upper()\n    \n    # Process text to handle same-letter pairs\n    i = 0\n    result = []\n    \n    while i < len(text):\n        if i == len(text) - 1:\n            # Last single character\n            result.append(text[i] + 'X')\n            i += 1\n        elif text[i] == text[i + 1]:\n            # Same letters, insert X\n            result.append(text[i] + 'X')\n            i += 1\n        else:\n            # Normal pair\n            result.append(text[i] + text[i + 1])\n            i += 2\n    \n    return result\n\ndef main():\n    # Read input\n    key_phrase = sys.stdin.readline().strip()\n    plaintext = sys.stdin.readline().strip()\n    \n    # Create Playfair table\n    grid = create_playfair_table(key_phrase)\n    \n    # Prepare text into digraphs\n    digraphs = prepare_text(plaintext)\n    \n    # Encrypt each digraph\n    encrypted_parts = []\n    for digraph in digraphs:\n        encrypted_parts.append(encrypt_pair(grid, digraph[0], digraph[1]))\n    \n    # Combine and output\n    encrypted_text = ''.join(encrypted_parts)\n    print(encrypted_text)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 41.209604263305664}
{"eval_index": 494, "problem_id": 2173, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Create list of (original_value, original_index)\n    indexed = [(a[i], i) for i in range(n)]\n    # Sort by desired rating\n    indexed.sort()\n    \n    result = [0] * n\n    current = 0\n    \n    for val, idx in indexed:\n        # Ensure distinct and at least desired rating\n        current = max(current + 1, val)\n        result[idx] = current\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.914432764053345}
{"eval_index": 495, "problem_id": 3930, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    print(0)\n    sys.exit(0)\n\nn = int(input_data[0])\nk = int(input_data[1])\na = list(map(int, input_data[2:2+n]))\n\n# Handle special cases\nif n == 0:\n    print(0)\n    sys.exit(0)\n\n# Precompute prefix sums\nprefix = [0] * (n + 1)\nfor i in range(1, n + 1):\n    prefix[i] = prefix[i - 1] + a[i - 1]\n\n# Generate all possible powers of k\npowers = set()\nif k == 1:\n    powers.add(1)\nelif k == -1:\n    powers.add(1)\n    powers.add(-1)\nelse:\n    val = 1\n    # Limit the absolute value to avoid overflow\n    while abs(val) <= 10**15:\n        powers.add(val)\n        val *= k\n        if val == 0:\n            break\n\n# Count valid segments\ncount = 0\n# Use dictionary to store prefix sum frequencies\nfreq = {}\n\nfor i in range(n + 1):\n    current_prefix = prefix[i]\n    # For each power, check if (current_prefix - power) exists in previous prefixes\n    for power in powers:\n        target = current_prefix - power\n        if target in freq:\n            count += freq[target]\n    # Update frequency of current prefix\n    freq[current_prefix] = freq.get(current_prefix, 0) + 1\n\nprint(count)", "complexity_estimate": null, "runtime_sec": 30.78695058822632}
{"eval_index": 496, "problem_id": 4813, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    word = data[0].strip()\n    permutation = data[1].strip()\n    \n    word_set = set(word)\n    guessed = set()\n    wrong_guesses = 0\n    max_wrong = 10\n    \n    for letter in permutation:\n        if letter in word_set:\n            guessed.add(letter)\n            if guessed == word_set:\n                print(\"WIN\")\n                return\n        else:\n            wrong_guesses += 1\n            if wrong_guesses == max_wrong:\n                print(\"LOSE\")\n                return\n    \n    # If we exhaust permutation without winning or losing (should not happen with full alphabet)\n    print(\"LOSE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.486085653305054}
{"eval_index": 497, "problem_id": 1841, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Precompute distinct counts from each position to the end\n    distinct_from = [0] * n\n    seen = set()\n    \n    # Process from right to left\n    for i in range(n-1, -1, -1):\n        seen.add(a[i])\n        distinct_from[i] = len(seen)\n    \n    # Answer queries\n    out_lines = []\n    for _ in range(m):\n        l = int(input())\n        out_lines.append(str(distinct_from[l-1]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.926542043685913}
{"eval_index": 498, "problem_id": 3982, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 91.31724047660828}
{"eval_index": 499, "problem_id": 4958, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = list(map(int, sys.stdin.read().strip().split()))\n    if not data:\n        return\n    \n    boxes = data[:6]\n    towers = data[6:8]\n    \n    # Sort boxes in descending order\n    boxes.sort(reverse=True)\n    \n    # Try all combinations of 3 boxes for first tower\n    from itertools import combinations\n    \n    for combo in combinations(boxes, 3):\n        first_tower = list(combo)\n        first_tower_sum = sum(first_tower)\n        \n        # Check if this sum matches either tower height\n        if first_tower_sum not in towers:\n            continue\n        \n        # Determine which tower this is\n        if first_tower_sum == towers[0]:\n            target_tower = towers[0]\n            other_tower = towers[1]\n        else:\n            # If first_tower_sum matches second tower, we need to swap output order\n            target_tower = towers[1]\n            other_tower = towers[0]\n            \n        # Create second tower from remaining boxes\n        remaining = boxes.copy()\n        for box in first_tower:\n            remaining.remove(box)\n        \n        second_tower = list(remaining)\n        second_tower_sum = sum(second_tower)\n        \n        # Verify second tower matches the other tower height\n        if second_tower_sum != other_tower:\n            continue\n        \n        # Sort both towers in descending order\n        first_tower.sort(reverse=True)\n        second_tower.sort(reverse=True)\n        \n        # Output based on which tower matched first\n        if first_tower_sum == towers[0]:\n            output = first_tower + second_tower\n        else:\n            output = second_tower + first_tower\n        \n        print(' '.join(map(str, output)))\n        return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.513967990875244}

{"eval_index": 0, "problem_id": 3579, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.92013502120972}
{"eval_index": 1, "problem_id": 4070, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 43.565510511398315}
{"eval_index": 2, "problem_id": 791, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "n = int(input())\nbits = input().strip()\n\n# Convert to list for mutability\nbit_list = list(bits)\n\n# Simulate adding 1 with carry\ncarry = 1\nchanged_count = 0\n\nfor i in range(n):\n    if carry == 0:\n        break\n    \n    current_bit = bit_list[i]\n    \n    if current_bit == '0':\n        # 0 + 1 = 1, no further carry\n        bit_list[i] = '1'\n        changed_count += 1\n        carry = 0\n    else:  # current_bit == '1'\n        # 1 + 1 = 0, carry 1\n        bit_list[i] = '0'\n        changed_count += 1\n        # carry remains 1 for next iteration\n\nprint(changed_count)", "complexity_estimate": null, "runtime_sec": 20.956668853759766}
{"eval_index": 3, "problem_id": 3788, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.18426084518433}
{"eval_index": 4, "problem_id": 4539, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    N = int(input().strip())\n    digit_sum = sum(int(d) for d in str(N))\n    if digit_sum != 0 and N % digit_sum == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.071113109588623}
{"eval_index": 5, "problem_id": 13, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.81338691711426}
{"eval_index": 6, "problem_id": 3349, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef remove_vowels(word):\n    \"\"\"Return word with vowels removed.\"\"\"\n    vowels = set('AEIOU')\n    return ''.join(c for c in word if c not in vowels)\n\ndef solve():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    dictionary = data[1:1+n]\n    message = data[1+n]\n    \n    # Preprocess dictionary: map consonant-only form to list of (word, vowel_count)\n    dict_map = {}\n    for word in dictionary:\n        cons_only = remove_vowels(word)\n        vowel_count = sum(1 for c in word if c in 'AEIOU')\n        if cons_only not in dict_map:\n            dict_map[cons_only] = []\n        dict_map[cons_only].append((word, vowel_count))\n    \n    # Sort each list by vowel_count descending for tie-breaking\n    for key in dict_map:\n        dict_map[key].sort(key=lambda x: -x[1])\n    \n    m = len(message)\n    # dp[i] = (best_vowel_count, prev_index, word_index) for prefix ending at i-1\n    # Initialize with -inf for unreachable\n    INF_NEG = -10**9\n    dp = [(INF_NEG, -1, -1) for _ in range(m+1)]\n    dp[0] = (0, -1, -1)  # empty prefix\n    \n    for i in range(m):\n        if dp[i][0] == INF_NEG:\n            continue\n        # Try all possible words starting at position i\n        for length in range(1, min(20, m-i+1)):  # max word length heuristic\n            cons_part = message[i:i+length]\n            if cons_part in dict_map:\n                # Use the word with highest vowel count (first in sorted list)\n                word, vowel_inc = dict_map[cons_part][0]\n                new_vowels = dp[i][0] + vowel_inc\n                if new_vowels > dp[i+length][0]:\n                    dp[i+length] = (new_vowels, i, word)\n    \n    # Reconstruct solution\n    result = []\n    pos = m\n    while pos > 0:\n        _, prev_pos, word = dp[pos]\n        result.append(word)\n        pos = prev_pos\n    result.reverse()\n    \n    sys.stdout.write(' '.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 32.51347756385803}
{"eval_index": 7, "problem_id": 4887, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 36.397704124450684}
{"eval_index": 8, "problem_id": 2406, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 65.48134970664978}
{"eval_index": 9, "problem_id": 3868, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.31979393959045}
{"eval_index": 10, "problem_id": 4458, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    count = 0\n    min_so_far = float('inf')\n    \n    for i in range(n):\n        if p[i] < min_so_far:\n            min_so_far = p[i]\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.41566300392151}
{"eval_index": 11, "problem_id": 2035, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.20795369148254}
{"eval_index": 12, "problem_id": 3956, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.7462363243103}
{"eval_index": 13, "problem_id": 4865, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef adjust_time(direction, minutes_change, hour, minute):\n    \"\"\"Adjust time based on DST change.\"\"\"\n    total_minutes = hour * 60 + minute\n    \n    if direction == 'F':\n        total_minutes += minutes_change\n    else:  # direction == 'B'\n        total_minutes -= minutes_change\n    \n    # Handle wrap-around\n    total_minutes %= (24 * 60)\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    \n    new_hour = total_minutes // 60\n    new_minute = total_minutes % 60\n    \n    return new_hour, new_minute\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(n):\n        direction = data[idx]\n        minutes_change = int(data[idx + 1])\n        hour = int(data[idx + 2])\n        minute = int(data[idx + 3])\n        idx += 4\n        \n        new_hour, new_minute = adjust_time(direction, minutes_change, hour, minute)\n        results.append(f\"{new_hour} {new_minute}\")\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 22.87595272064209}
{"eval_index": 14, "problem_id": 1575, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 138.07832169532776}
{"eval_index": 15, "problem_id": 3828, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    # Find the longest contiguous increasing subsequence that appears in order\n    # This is essentially finding the longest prefix of sorted sequence [1,2,...,n] \n    # that appears as a subsequence in p in correct relative order.\n    \n    # We'll track the position of each number in the input\n    pos = [0] * (n + 1)\n    for idx, val in enumerate(p):\n        pos[val] = idx\n    \n    # Find longest chain where numbers appear in increasing order with consecutive positions\n    # Actually, we need longest contiguous increasing subsequence where values differ by 1\n    # and appear in increasing index order.\n    \n    # Better approach: find longest suffix of the sorted sequence that appears in order in p\n    # But actually we want longest contiguous increasing subsequence where values are consecutive.\n    \n    # Let's find the longest chain where for i, i+1, ..., i+k-1, \n    # pos[i] < pos[i+1] < ... < pos[i+k-1]\n    # and these values are consecutive numbers.\n    \n    max_len = 1\n    current_len = 1\n    for i in range(1, n):\n        if pos[i] < pos[i+1]:\n            current_len += 1\n            max_len = max(max_len, current_len)\n        else:\n            current_len = 1\n    \n    # The cars that are already in correct relative order (the longest chain)\n    # don't need to be moved. All others need one move each.\n    # But actually, we can keep the longest contiguous increasing subsequence\n    # and move all others.\n    \n    # Minimum moves = n - max_len\n    print(n - max_len)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.354658603668213}
{"eval_index": 16, "problem_id": 4176, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    # The minimum number that is divisible by both A and B is LCM(A, B)\n    lcm = A * B // math.gcd(A, B)\n    print(lcm)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.87251305580139}
{"eval_index": 17, "problem_id": 1536, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 54.0507869720459}
{"eval_index": 18, "problem_id": 3544, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 134.34988355636597}
{"eval_index": 19, "problem_id": 4263, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    S = input().strip()\n    max_length = 0\n    current_length = 0\n    \n    for char in S:\n        if char in 'ACGT':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.460148572921753}
{"eval_index": 20, "problem_id": 175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            # Reduce a by multiples of 2*b efficiently\n            # a = a % (2*b) would be wrong when a is multiple of 2*b\n            # Instead, we can compute how many times we can subtract\n            # But careful: we want to stop when a < 2*b\n            # So we can do: a = a % (2*b) if a % (2*b) != 0 else a - 2*b\n            # Actually simpler: while a >= 2*b: a -= 2*b\n            # But for large numbers, we need optimization\n            # Use modulo with adjustment:\n            mod_val = 2 * b\n            remainder = a % mod_val\n            if remainder == 0:\n                # This would make a = 0, which ends the loop\n                a = 0\n                break\n            else:\n                a = remainder\n        elif b >= 2 * a:\n            mod_val = 2 * a\n            remainder = b % mod_val\n            if remainder == 0:\n                b = 0\n                break\n            else:\n                b = remainder\n        else:\n            break\n    \n    print(f\"{a} {b}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.59804081916809}
{"eval_index": 21, "problem_id": 3433, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs_fire(R, C, maze, fire_start):\n    fire_time = [[-1] * C for _ in range(R)]\n    q = deque()\n    for fr, fc in fire_start:\n        fire_time[fr][fc] = 0\n        q.append((fr, fc, 0))\n    \n    while q:\n        r, c, t = q.popleft()\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if maze[nr][nc] != '#' and fire_time[nr][nc] == -1:\n                    fire_time[nr][nc] = t + 1\n                    q.append((nr, nc, t + 1))\n    return fire_time\n\ndef bfs_joe(R, C, maze, joe_start, fire_time):\n    joe_time = [[-1] * C for _ in range(R)]\n    q = deque()\n    jr, jc = joe_start\n    joe_time[jr][jc] = 0\n    q.append((jr, jc, 0))\n    \n    while q:\n        r, c, t = q.popleft()\n        if r == 0 or r == R-1 or c == 0 or c == C-1:\n            return t + 1\n        \n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if maze[nr][nc] != '#' and joe_time[nr][nc] == -1:\n                    if fire_time[nr][nc] == -1 or t + 1 < fire_time[nr][nc]:\n                        joe_time[nr][nc] = t + 1\n                        q.append((nr, nc, t + 1))\n    return -1\n\ndef main():\n    input_data = sys.stdin.read().strip().splitlines()\n    if not input_data:\n        return\n    R, C = map(int, input_data[0].split())\n    maze = []\n    joe_start = None\n    fire_start = []\n    \n    for i in range(R):\n        row = list(input_data[i+1])\n        maze.append(row)\n        for j in range(C):\n            if row[j] == 'J':\n                joe_start = (i, j)\n            elif row[j] == 'F':\n                fire_start.append((i, j))\n    \n    fire_time = bfs_fire(R, C, maze, fire_start)\n    result = bfs_joe(R, C, maze, joe_start, fire_time)\n    \n    if result == -1:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 37.40708041191101}
{"eval_index": 22, "problem_id": 4737, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    p = int(data[1])\n    times = list(map(int, data[2:2+N]))\n    \n    # Problem p must be solved first\n    time_p = times[p]\n    \n    # If p itself exceeds 300 minutes, cannot solve any problem\n    if time_p > 300:\n        print(\"0 0\")\n        return\n    \n    # Remaining problems (excluding p)\n    remaining = [times[i] for i in range(N) if i != p]\n    \n    # Sort remaining times to maximize number of problems solved\n    remaining.sort()\n    \n    # Time left after solving problem p\n    time_left = 300 - time_p\n    \n    # Greedy approach: solve shortest problems first\n    num_ac = 1  # problem p is solved\n    penalty = time_p\n    current_time = time_p\n    \n    for t in remaining:\n        if current_time + t <= 300:\n            num_ac += 1\n            current_time += t\n            penalty += current_time\n        else:\n            break\n    \n    print(f\"{num_ac} {penalty}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 57.0828378200531}
{"eval_index": 23, "problem_id": 1496, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 122.0779299736023}
{"eval_index": 24, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "COMPLEXITY": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.71625185012817}
{"eval_index": 25, "problem_id": 4494, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "S = input().strip()\nif S == \"ABC\":\n    print(\"ARC\")\nelse:\n    print(\"ABC\")", "complexity_estimate": null, "runtime_sec": 11.351147890090942}
{"eval_index": 26, "problem_id": 1513, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.669655561447144}
{"eval_index": 27, "problem_id": 3746, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.30069661140442}
{"eval_index": 28, "problem_id": 4338, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, x, y = map(int, data[:3])\n    a = list(map(int, data[3:3+n]))\n    \n    # If x > y, we can break all doors eventually\n    if x > y:\n        print(n)\n        return\n    \n    # Sort the durabilities\n    a.sort()\n    \n    # Count doors that can be broken before Slavik can repair them\n    # We need to consider doors with durability <= x first\n    # Strategy: break the smallest durability doors first\n    count = 0\n    for i in range(n):\n        if a[i] <= x:\n            count += 1\n        else:\n            break\n    \n    # If no door has durability <= x, we cannot break any initially\n    if count == 0:\n        print(0)\n        return\n    \n    # We can break at most ceil(count/2) doors\n    # Because Slavik will try to repair after each of our breaks\n    result = (count + 1) // 2\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 84.76000714302063}
{"eval_index": 29, "problem_id": 1113, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Track the maximum possible mex value that could be generated at each step\n    max_possible = 0\n    \n    for i in range(n):\n        # If current value is greater than max_possible, mistake found\n        if a[i] > max_possible:\n            print(i + 1)  # 1-based index\n            return\n        \n        # Update max_possible for next step\n        # At step i+1, we have i+1 elements in array\n        # The maximum mex we can get is i+1 (if we choose all previous elements)\n        max_possible = max(max_possible, a[i] + 1)\n    \n    # No mistake found\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 50.02078366279602}
{"eval_index": 30, "problem_id": 3694, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Sort the array\n    a.sort()\n    \n    # Check for invalid initial conditions\n    dup_count = 0\n    dup_value = -1\n    for i in range(1, n):\n        if a[i] == a[i-1]:\n            dup_count += 1\n            dup_value = a[i]\n    \n    # If there are more than one duplicate pair, it's invalid\n    if dup_count > 1:\n        print(\"cslnb\")\n        return\n    \n    # If there's exactly one duplicate pair\n    if dup_count == 1:\n        # Check if the duplicate value is 0 or if decreasing it would create another duplicate\n        if dup_value == 0:\n            print(\"cslnb\")\n            return\n        # Check if there's a[i] = dup_value - 1\n        for i in range(n):\n            if a[i] == dup_value - 1:\n                print(\"cslnb\")\n                return\n        # Also check if there are more than 2 piles with the same value\n        count_dup = 0\n        for val in a:\n            if val == dup_value:\n                count_dup += 1\n        if count_dup > 2:\n            print(\"cslnb\")\n            return\n    \n    # Calculate total moves needed to reach [0, 1, 2, ..., n-1]\n    total_moves = 0\n    for i in range(n):\n        if a[i] < i:\n            print(\"cslnb\")\n            return\n        total_moves += a[i] - i\n    \n    # Determine winner based on parity of total_moves\n    if total_moves % 2 == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 38.74377417564392}
{"eval_index": 31, "problem_id": 4785, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    s = input().strip()\n    if 'ss' in s:\n        print('hiss')\n    else:\n        print('no hiss')\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.865148067474365}
{"eval_index": 32, "problem_id": 2158, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.2058322429657}
{"eval_index": 33, "problem_id": 3853, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.1397442817688}
{"eval_index": 34, "problem_id": 4850, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.04872250556946}
{"eval_index": 35, "problem_id": 2706, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 25.53648066520691}
{"eval_index": 36, "problem_id": 3120, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.01823663711548}
{"eval_index": 37, "problem_id": 4388, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "n = input().strip()\nresult = ''\nfor digit in n:\n    if digit == '1':\n        result += '9'\n    elif digit == '9':\n        result += '1'\n    else:\n        result += digit\nprint(result)", "complexity_estimate": null, "runtime_sec": 10.782213687896729}
{"eval_index": 38, "problem_id": 2370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    it = iter(input)\n    N = int(next(it))\n    A = [[int(next(it)) for _ in range(N)] for _ in range(N)]\n    \n    # Check basic properties\n    for i in range(N):\n        if A[i][i] != 0:\n            print(-1)\n            return\n        for j in range(N):\n            if i != j and A[i][j] <= 0:\n                print(-1)\n                return\n            if A[i][j] != A[j][i]:\n                print(-1)\n                return\n    \n    # Check triangle inequality and existence of direct road\n    edges = []\n    for i in range(N):\n        for j in range(i+1, N):\n            # Check if A[i][j] is the shortest possible (triangle inequality)\n            valid = True\n            for k in range(N):\n                if A[i][j] > A[i][k] + A[k][j]:\n                    print(-1)\n                    return\n                if k != i and k != j and A[i][j] == A[i][k] + A[k][j]:\n                    valid = False  # There exists a shorter path via k, so no direct road needed\n            if valid:\n                edges.append((i, j, A[i][j]))\n    \n    # Compute total length\n    total = sum(weight for _, _, weight in edges)\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 101.94939827919006}
{"eval_index": 39, "problem_id": 3085, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.82717537879944}
{"eval_index": 40, "problem_id": 4317, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Calculate all three operations\n    add_result = A + B\n    sub_result = A - B\n    mul_result = A * B\n    \n    # Find the maximum value\n    max_value = max(add_result, sub_result, mul_result)\n    \n    # Print the result\n    print(max_value)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.993953943252563}
{"eval_index": 41, "problem_id": 1980, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.54923176765442}
{"eval_index": 42, "problem_id": 3050, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.03855323791504}
{"eval_index": 43, "problem_id": 4162, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.96412873268127}
{"eval_index": 44, "problem_id": 2852, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.78898406028748}
{"eval_index": 45, "problem_id": 3727, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c, d = map(int, data)\n    total = a + b + c + d\n    \n    # Check if total is 0 (should not happen per constraints but handle)\n    if total == 0:\n        print(\"NO\")\n        return\n    \n    # Try starting from 0\n    seq = []\n    counts = [a, b, c, d]\n    \n    # Helper to try building sequence from start value\n    def try_build(start):\n        temp_counts = counts[:]\n        temp_seq = []\n        current = start\n        \n        while True:\n            if temp_counts[current] <= 0:\n                return None\n            temp_seq.append(current)\n            temp_counts[current] -= 1\n            \n            # Check if done\n            if sum(temp_counts) == 0:\n                return temp_seq\n            \n            # Decide next step\n            if current > 0 and temp_counts[current-1] > 0:\n                current -= 1\n            elif current < 3 and temp_counts[current+1] > 0:\n                current += 1\n            else:\n                return None\n    \n    # Try all possible starting points that have count > 0\n    for start in range(4):\n        if counts[start] > 0:\n            result = try_build(start)\n            if result is not None:\n                print(\"YES\")\n                print(\" \".join(map(str, result)))\n                return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.57900881767273}
{"eval_index": 46, "problem_id": 4839, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 70.9617235660553}
{"eval_index": 47, "problem_id": 298, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Total moves possible: floor(n / k)\n    total_moves = n // k\n    \n    # Sasha moves first, so he gets ceil(total_moves / 2) moves\n    sasha_moves = (total_moves + 1) // 2\n    \n    # Lena gets floor(total_moves / 2) moves\n    lena_moves = total_moves // 2\n    \n    # Sasha wins if he makes strictly more moves than Lena\n    if sasha_moves > lena_moves:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.644285202026367}
{"eval_index": 48, "problem_id": 3761, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 148.2069797515869}
{"eval_index": 49, "problem_id": 4894, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.33811569213867}
{"eval_index": 50, "problem_id": 1545, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    a = list(map(int, data[2:2+26]))\n    \n    # Convert letters to indices 0-25\n    s_indices = [ord(ch) - ord('a') for ch in s]\n    \n    # DP for number of ways\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty prefix has 1 way\n    \n    # For longest substring length\n    longest = 0\n    \n    # For minimum number of substrings\n    min_splits = [float('inf')] * (n + 1)\n    min_splits[0] = 0\n    \n    for i in range(n):\n        # Track the minimum allowed length for current substring starting at i\n        min_allowed = float('inf')\n        \n        # Try extending substring starting at i\n        for j in range(i, n):\n            ch_idx = s_indices[j]\n            min_allowed = min(min_allowed, a[ch_idx])\n            \n            # Check if substring s[i:j+1] is valid\n            length = j - i + 1\n            if length <= min_allowed:\n                # Valid substring\n                dp[j + 1] = (dp[j + 1] + dp[i]) % MOD\n                longest = max(longest, length)\n                min_splits[j + 1] = min(min_splits[j + 1], min_splits[i] + 1)\n            else:\n                # Once invalid, further extensions will also be invalid\n                break\n    \n    print(dp[n] % MOD)\n    print(longest)\n    print(min_splits[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.981931686401367}
{"eval_index": 51, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.198944091796875}
{"eval_index": 52, "problem_id": 4547, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = int(input().strip())\n    if '9' in str(N):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 9.377302408218384}
{"eval_index": 53, "problem_id": 556, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, k = map(int, data[:3])\n    \n    result = []\n    power = 1  # k^0\n    \n    while power <= r:\n        if power >= l:\n            result.append(str(power))\n        # Check for overflow before next multiplication\n        if power > r // k:\n            break\n        power *= k\n    \n    if result:\n        print(' '.join(result))\n    else:\n        print('-1')\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 16.55475687980652}
{"eval_index": 54, "problem_id": 3496, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.6792368888855}
{"eval_index": 55, "problem_id": 4558, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    t = int(data[1])\n    \n    # The amount remaining is initial minus time elapsed, but not less than 0\n    result = max(0, X - t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.77701735496521}
{"eval_index": 56, "problem_id": 2277, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    queries = [(int(next(it)), int(next(it))) for _ in range(m)]\n    \n    # Precompute initial inversion parity using BIT\n    bit = [0] * (n + 2)\n    def bit_update(idx, val):\n        while idx <= n:\n            bit[idx] += val\n            idx += idx & -idx\n    def bit_query(idx):\n        s = 0\n        while idx > 0:\n            s += bit[idx]\n            idx -= idx & -idx\n        return s\n    \n    inv_parity = 0\n    for i in range(n - 1, -1, -1):\n        cnt = bit_query(a[i] - 1)\n        inv_parity ^= (cnt & 1)\n        bit_update(a[i], 1)\n    \n    out_lines = []\n    for l, r in queries:\n        l -= 1\n        r -= 1\n        length = r - l + 1\n        # Number of pairs within reversed segment that change order\n        # Each pair (i,j) with i<j in original becomes j>i in reversed\n        # This flips parity for each such pair\n        # Total pairs within segment: C(length, 2) = length*(length-1)//2\n        pairs = length * (length - 1) // 2\n        if pairs & 1:\n            inv_parity ^= 1\n        out_lines.append(\"odd\" if inv_parity else \"even\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 26.799654006958008}
{"eval_index": 57, "problem_id": 3973, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.28608632087708}
{"eval_index": 58, "problem_id": 4068, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    MOD = 1_000_000_007\n    input = sys.stdin.read().split()\n    if not input:\n        return\n    N = int(input[0])\n    M = int(input[1])\n    broken = set()\n    idx = 2\n    for _ in range(M):\n        broken.add(int(input[idx]))\n        idx += 1\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(1, N + 1):\n        if i in broken:\n            dp[i] = 0\n            continue\n        ways = 0\n        if i - 1 >= 0:\n            ways = (ways + dp[i - 1]) % MOD\n        if i - 2 >= 0:\n            ways = (ways + dp[i - 2]) % MOD\n        dp[i] = ways\n    print(dp[N] % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.493526697158813}
{"eval_index": 59, "problem_id": 2424, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 998244353\n\ndef modinv(a, mod=MOD):\n    return pow(a, mod-2, mod)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    \n    # Read all kids' wishlists\n    kids = []\n    total_items = 0\n    for _ in range(n):\n        k = int(next(it))\n        items = [int(next(it)) for __ in range(k)]\n        kids.append(items)\n        total_items += k\n    \n    # Count how many times each item appears across all kids\n    item_count = {}\n    for items in kids:\n        for item in items:\n            item_count[item] = item_count.get(item, 0) + 1\n    \n    # Calculate probability\n    # For each kid i, for each item in kid i's list:\n    # Probability = (1/n) * (1/k_i) * (count(item)/n)\n    # Sum over all kids and all their items\n    prob_num = 0\n    prob_den = 0\n    \n    # We'll compute numerator and denominator separately\n    # Let's compute as rational number first\n    # Actually, we can compute directly modulo MOD\n    \n    # We need: sum over i (1/n * 1/k_i * sum over items in kid i (count(item)/n))\n    # = (1/n^2) * sum over i (1/k_i * sum over items in kid i count(item))\n    \n    # Compute sum_i (1/k_i * sum_{item in kid i} count(item))\n    total = 0\n    inv_n = modinv(n)\n    inv_n_sq = (inv_n * inv_n) % MOD\n    \n    for items in kids:\n        k_i = len(items)\n        if k_i == 0:\n            continue\n        inv_k_i = modinv(k_i)\n        sum_counts = 0\n        for item in items:\n            sum_counts += item_count[item]\n        total = (total + inv_k_i * sum_counts) % MOD\n    \n    # Final probability = total * inv_n_sq % MOD\n    result = (total * inv_n_sq) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 34.52493453025818}
{"eval_index": 60, "problem_id": 3711, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # Maximum cuts possible: (n-1) horizontal + (m-1) vertical\n    max_cuts = (n - 1) + (m - 1)\n    if k > max_cuts:\n        print(-1)\n        return\n    \n    # Try to maximize the smallest piece area\n    # We can cut either horizontally or vertically\n    # The area of smallest piece = (n // (h+1)) * (m // (v+1))\n    # where h = horizontal cuts, v = vertical cuts, h+v = k\n    \n    # Strategy: try both directions as primary\n    ans = 0\n    \n    # Case 1: prioritize horizontal cuts\n    # We can make at most n-1 horizontal cuts\n    h = min(k, n - 1)\n    v = k - h\n    if v <= m - 1:\n        area = (n // (h + 1)) * (m // (v + 1))\n        ans = max(ans, area)\n    \n    # Case 2: prioritize vertical cuts\n    v = min(k, m - 1)\n    h = k - v\n    if h <= n - 1:\n        area = (n // (h + 1)) * (m // (v + 1))\n        ans = max(ans, area)\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 108.38584065437317}
{"eval_index": 61, "problem_id": 4345, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.54414534568787}
{"eval_index": 62, "problem_id": 541, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    \n    # We'll track the rightmost endpoint of each request starting at each island\n    # For each island i, we want to know the smallest b such that there's a request (i, b)\n    # Actually, we need to know for each island, the farthest right endpoint of any request starting at or before it\n    # But a simpler approach: sort requests by a, then process from left to right\n    \n    requests = []\n    for _ in range(M):\n        a = int(next(it))\n        b = int(next(it))\n        requests.append((a, b))\n    \n    # Sort by a, then by b\n    requests.sort(key=lambda x: (x[0], x[1]))\n    \n    removed = 0\n    current_end = -1  # The rightmost endpoint of the current overlapping segment\n    \n    for a, b in requests:\n        if a >= current_end:\n            # This request starts after or at the current_end, so we need to remove a bridge\n            # We'll remove the bridge just before b to break this request\n            removed += 1\n            current_end = b  # We remove the bridge at b-1, so we can't cross beyond b-1\n        else:\n            # This request starts before current_end, so it's already covered by previous removal\n            # But we need to update current_end to min(current_end, b) because we can only break up to min endpoint\n            current_end = min(current_end, b)\n    \n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.904972314834595}
{"eval_index": 63, "problem_id": 3751, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    seen = set()\n    expected = 'a'\n    for ch in s:\n        if ch not in seen:\n            if ch != expected:\n                print(\"NO\")\n                return\n            seen.add(ch)\n            expected = chr(ord(expected) + 1)\n        else:\n            if ch not in seen:\n                print(\"NO\")\n                return\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.525549173355103}
{"eval_index": 64, "problem_id": 4540, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    # Precompute prefix and suffix arrays for distances\n    prefix = [0] * (N + 2)\n    suffix = [0] * (N + 2)\n    \n    # Fill prefix: distance from 0 to A[0], then between consecutive spots\n    prefix[0] = 0\n    for i in range(1, N + 1):\n        if i == 1:\n            prefix[i] = abs(A[0] - 0)\n        else:\n            prefix[i] = prefix[i-1] + abs(A[i-1] - A[i-2])\n    \n    # Fill suffix: distance from A[N-1] to 0, then between consecutive spots backwards\n    suffix[N+1] = 0\n    for i in range(N, 0, -1):\n        if i == N:\n            suffix[i] = abs(A[N-1] - 0)\n        else:\n            suffix[i] = suffix[i+1] + abs(A[i] - A[i-1])\n    \n    # Compute total cost for each skipped spot i (1-indexed)\n    results = []\n    for i in range(1, N + 1):\n        # Cost before skipping spot i\n        before = prefix[i-1]\n        # Cost after skipping spot i\n        after = suffix[i+1]\n        # Cost to bridge the gap when skipping spot i\n        if i == 1:\n            bridge = abs(A[1] - 0) if N > 1 else 0\n        elif i == N:\n            bridge = abs(A[N-2] - 0) if N > 1 else 0\n        else:\n            bridge = abs(A[i] - A[i-2])\n        total = before + after + bridge\n        results.append(str(total))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.23003101348877}
{"eval_index": 65, "problem_id": 1425, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 75.32139801979065}
{"eval_index": 66, "problem_id": 3918, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k1 = int(next(it))\n    k2 = int(next(it))\n    \n    A = [int(next(it)) for _ in range(n)]\n    B = [int(next(it)) for _ in range(n)]\n    \n    # Calculate absolute differences\n    diffs = [abs(A[i] - B[i]) for i in range(n)]\n    \n    # Total operations available\n    total_ops = k1 + k2\n    \n    # Greedy approach: reduce largest differences first\n    # We can use operations to reduce differences\n    # Each operation reduces a difference by 1 (by changing A or B)\n    # But we must use exactly k1 on A and k2 on B\n    # However, since operations are interchangeable for reducing differences,\n    # we can think of having total_ops to reduce differences\n    \n    # Use operations to reduce differences\n    for _ in range(total_ops):\n        # Find index with maximum difference\n        max_idx = 0\n        max_val = diffs[0]\n        for i in range(1, n):\n            if diffs[i] > max_val:\n                max_val = diffs[i]\n                max_idx = i\n        \n        if max_val == 0:\n            # All differences are zero, we can increase any difference\n            # This will increase error, but we must use operations\n            # Best to create smallest possible increase\n            diffs[0] += 1\n        else:\n            # Reduce the largest difference by 1\n            diffs[max_idx] -= 1\n    \n    # Calculate final error\n    error = sum(d * d for d in diffs)\n    print(error)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.729225635528564}
{"eval_index": 67, "problem_id": 4511, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 178.30915069580078}
{"eval_index": 68, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.17923665046692}
{"eval_index": 69, "problem_id": 3307, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.20955348014832}
{"eval_index": 70, "problem_id": 4435, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.42814898490906}
{"eval_index": 71, "problem_id": 40, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    ratings = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        ratings.append((a, b))\n        idx += 2\n    \n    # Check if any rating changed\n    any_changed = any(a != b for a, b in ratings)\n    \n    # Check if standings are sorted by rating (non-increasing)\n    sorted_by_rating = all(ratings[i][0] >= ratings[i+1][0] for i in range(n-1))\n    \n    # Check if standings are strictly sorted by rating (non-increasing) with no ties\n    strictly_sorted = all(ratings[i][0] > ratings[i+1][0] for i in range(n-1))\n    \n    # Determine result\n    if any_changed:\n        print(\"rated\")\n    elif not sorted_by_rating:\n        # If not sorted and no changes, then round must be unrated\n        # because if it were rated, someone's rating would have changed\n        print(\"unrated\")\n    else:\n        # No changes and sorted by rating\n        # Could be rated (if all stayed same) or unrated (if round was unrated)\n        # Cannot determine for sure\n        print(\"maybe\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 49.98725342750549}
{"eval_index": 72, "problem_id": 3872, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef equivalent(a, b):\n    if a == b:\n        return True\n    if len(a) % 2 == 1:\n        return False\n    \n    mid = len(a) // 2\n    a1, a2 = a[:mid], a[mid:]\n    b1, b2 = b[:mid], b[mid:]\n    \n    return (equivalent(a1, b1) and equivalent(a2, b2)) or (equivalent(a1, b2) and equivalent(a2, b1))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    s1, s2 = data[0], data[1]\n    \n    if equivalent(s1, s2):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.913488388061523}
{"eval_index": 73, "problem_id": 4495, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef count_divisible(a, b, x):\n    \"\"\"Return count of numbers in [a, b] divisible by x.\"\"\"\n    # Count from 0 to b minus count from 0 to a-1\n    # Using integer division\n    if a == 0:\n        return b // x + 1\n    else:\n        return b // x - (a - 1) // x\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, x = map(int, data)\n    result = count_divisible(a, b, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 27.11054277420044}
{"eval_index": 74, "problem_id": 625, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef f(n):\n    # If n is even, result is n // 2\n    # If n is odd, result is -(n // 2 + 1)\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return -(n // 2 + 1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = f(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.031179904937744}
{"eval_index": 75, "problem_id": 3887, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.79172539710999}
{"eval_index": 76, "problem_id": 4534, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 14.382480144500732}
{"eval_index": 77, "problem_id": 391, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 77.65441727638245}
{"eval_index": 78, "problem_id": 3372, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    s = int(next(it))\n    t = int(next(it))\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N)]\n    \n    for u in range(N):\n        typ = next(it)\n        m = int(next(it))\n        \n        if typ == 'N':\n            # Direct list of destinations\n            for _ in range(m):\n                v = int(next(it))\n                adj[u].append(v)\n        else:  # typ == 'C'\n            # Complement: all airports except those listed\n            excluded = set()\n            for _ in range(m):\n                excluded.add(int(next(it)))\n            # Add all airports not in excluded (and not self)\n            for v in range(N):\n                if v != u and v not in excluded:\n                    adj[u].append(v)\n    \n    # BFS to find shortest path\n    dist = [-1] * N\n    dist[s] = 0\n    q = deque([s])\n    \n    while q:\n        u = q.popleft()\n        if u == t:\n            print(dist[t])\n            return\n        \n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.172227144241333}
{"eval_index": 79, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    N = int(sys.stdin.readline().strip())\n    ans = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        ans += max_b\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.334418773651123}
{"eval_index": 80, "problem_id": 551, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.58916926383972}
{"eval_index": 81, "problem_id": 3101, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.78140687942505}
{"eval_index": 82, "problem_id": 4621, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    lines = data[2:]\n    \n    output_lines = []\n    for i in range(H):\n        line = lines[i]\n        output_lines.append(line)\n        output_lines.append(line)\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.202712774276733}
{"eval_index": 83, "problem_id": 2846, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    citations = list(map(int, data[1:1+n]))\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations, start=1):\n        if c >= i:\n            h_index = i\n        else:\n            break\n    print(h_index)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.733062505722046}
{"eval_index": 84, "problem_id": 3510, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    positions = [chr(ord('a') + i) for i in range(n)]\n    pos_index = {pos: i for i, pos in enumerate(positions)}\n    \n    # Parse options\n    options = []\n    for _ in range(n):\n        m = int(next(it))\n        opts = []\n        for _ in range(m):\n            s = next(it)\n            # Convert string to bitmask of positions\n            mask = 0\n            for ch in s:\n                mask |= 1 << pos_index[ch]\n            opts.append(mask)\n        options.append(opts)\n    \n    INF = 10**9\n    # dp[i][j] = min rounds to reach position j from position i\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Base case: starting and ending at same position\n    for i in range(n):\n        dp[i][i] = 0\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(n):  # start position\n            for j in range(n):  # target position\n                if i == j:\n                    continue\n                # Alice wants to reach j from i\n                # She chooses an option at position i\n                best = INF\n                for opt_mask in options[i]:\n                    # Bob chooses a position from the option\n                    # He will try to maximize the rounds to reach j\n                    worst = 0\n                    # Iterate over positions in the option\n                    mask = opt_mask\n                    while mask:\n                        # Extract lowest set bit\n                        lsb = mask & -mask\n                        pos_idx = (lsb.bit_length() - 1)\n                        mask ^= lsb\n                        # Bob chooses position that gives max rounds to reach j\n                        worst = max(worst, dp[pos_idx][j] + 1)\n                    # Alice chooses option that minimizes the worst case\n                    best = min(best, worst)\n                if best < dp[i][j]:\n                    dp[i][j] = best\n                    changed = True\n    \n    # Output\n    out_lines = []\n    for i in range(n):\n        line = []\n        for j in range(n):\n            val = dp[i][j]\n            if val >= INF:\n                line.append(\"-1\")\n            else:\n                line.append(str(val))\n        out_lines.append(\" \".join(line))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.377371311187744}
{"eval_index": 85, "problem_id": 4425, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data)\n    \n    # Probability of winning\n    win_prob = 0.0\n    \n    # For each possible die roll\n    for start in range(1, N + 1):\n        # If starting score is already >= K, win immediately\n        if start >= K:\n            win_prob += 1.0 / N\n            continue\n        \n        # Find minimum number of consecutive heads needed\n        current = start\n        heads_needed = 0\n        while current < K:\n            current *= 2\n            heads_needed += 1\n        \n        # Probability of getting exactly heads_needed consecutive heads\n        # before a tail appears\n        prob = (1.0 / N) * (0.5 ** heads_needed)\n        win_prob += prob\n    \n    # Print with sufficient precision\n    print(f\"{win_prob:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.19660496711731}
{"eval_index": 86, "problem_id": 2524, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 66.85018515586853}
{"eval_index": 87, "problem_id": 3197, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.74661326408386}
{"eval_index": 88, "problem_id": 4305, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, A = map(int, data)\n    # Calculate number of attacks needed\n    attacks = (H + A - 1) // A  # Ceiling division\n    print(attacks)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.17344880104065}
{"eval_index": 89, "problem_id": 2268, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m = map(int, data[:2])\n    s = list(data[2])\n    \n    # Initialize mapping: each letter maps to itself\n    mapping = {chr(ord('a') + i): chr(ord('a') + i) for i in range(26)}\n    \n    idx = 3\n    for _ in range(m):\n        x = data[idx]\n        y = data[idx + 1]\n        idx += 2\n        \n        # Swap mappings for x and y\n        # Find which letters currently map to x and y\n        swap_x = None\n        swap_y = None\n        for ch in mapping:\n            if mapping[ch] == x:\n                swap_x = ch\n            if mapping[ch] == y:\n                swap_y = ch\n        \n        # Perform the swap\n        if swap_x is not None and swap_y is not None:\n            mapping[swap_x], mapping[swap_y] = mapping[swap_y], mapping[swap_x]\n        elif swap_x is not None:\n            mapping[swap_x] = y\n        elif swap_y is not None:\n            mapping[swap_y] = x\n        # If neither exists, nothing changes\n    \n    # Apply final mapping to the string\n    for i in range(n):\n        s[i] = mapping[s[i]]\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.238805294036865}
{"eval_index": 90, "problem_id": 3170, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 167.88801383972168}
{"eval_index": 91, "problem_id": 4491, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    \n    # Read the grid\n    A = [[0] * N for _ in range(2)]\n    for i in range(2):\n        for j in range(N):\n            A[i][j] = int(next(it))\n    \n    # DP array: dp[i][j] = max candies to reach (i, j)\n    dp = [[0] * N for _ in range(2)]\n    dp[0][0] = A[0][0]\n    \n    # Fill first row (only from left)\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + A[0][j]\n    \n    # Fill second row (from left or from above)\n    dp[1][0] = dp[0][0] + A[1][0]\n    for j in range(1, N):\n        dp[1][j] = max(dp[1][j-1], dp[0][j]) + A[1][j]\n    \n    print(dp[1][N-1])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 44.25001621246338}
{"eval_index": 92, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct_nums[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (given to first robot)\n    for i in range(m):\n        p = distinct_nums[i]\n        # Find first occurrence of p from left\n        first_pos = arr.index(p)\n        # Find last occurrence of p from right\n        last_pos = n - 1 - arr[::-1].index(p)\n        \n        # Count numbers that appear strictly after first_pos\n        # Binary search in distinct_nums to find numbers with positions > first_pos\n        # We need numbers whose first occurrence is > first_pos\n        # Actually, we need numbers that the second robot would stop at a position > first_pos\n        # The second robot stops at the first occurrence of q from the right\n        # So we need numbers whose last occurrence is > first_pos\n        \n        # For each q, we need last occurrence of q > first_pos\n        # We can precompute last occurrence positions for each number\n        last_occurrence = {}\n        for idx, num in enumerate(arr):\n            last_occurrence[num] = idx\n        \n        # Count how many distinct numbers have last_occurrence > first_pos\n        count_valid_q = 0\n        for num in distinct_nums:\n            if last_occurrence[num] > first_pos:\n                count_valid_q += 1\n        \n        total_pairs += count_valid_q\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 35.60266041755676}
{"eval_index": 93, "problem_id": 3848, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_tolerable(s, p):\n    \"\"\"Check if string s is tolerable (no palindrome substring of length >= 2).\"\"\"\n    n = len(s)\n    # Check all substrings of length 2 and 3\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:  # length 2 palindrome\n            return False\n    for i in range(n - 2):\n        if s[i] == s[i + 2]:  # length 3 palindrome (center doesn't matter)\n            return False\n    # All characters must be within first p letters\n    max_char = chr(ord('a') + p - 1)\n    for ch in s:\n        if ch > max_char:\n            return False\n    return True\n\ndef next_tolerable(s, p):\n    \"\"\"Find lexicographically next tolerable string of same length.\"\"\"\n    n = len(s)\n    max_char = chr(ord('a') + p - 1)\n    \n    # Convert to list for easy modification\n    s_list = list(s)\n    \n    # Try to increment from the end\n    for i in range(n - 1, -1, -1):\n        original = s_list[i]\n        # Try all possible next characters for this position\n        for ch_code in range(ord(original) + 1, ord(max_char) + 1):\n            s_list[i] = chr(ch_code)\n            # Check if prefix up to i is tolerable\n            if is_tolerable(''.join(s_list[:i+1]), p):\n                # Fill remaining positions with smallest possible characters\n                for j in range(i + 1, n):\n                    # Try 'a' to max_char\n                    for fill_code in range(ord('a'), ord(max_char) + 1):\n                        s_list[j] = chr(fill_code)\n                        if is_tolerable(''.join(s_list[:j+1]), p):\n                            break\n                # Final check\n                if is_tolerable(''.join(s_list), p):\n                    return ''.join(s_list)\n        # Reset this position to original for next iteration\n        s_list[i] = original\n    \n    return \"NO\"\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    n, p = map(int, data[:2])\n    s = data[2]\n    result = next_tolerable(s, p)\n    print(result)", "complexity_estimate": null, "runtime_sec": 38.05939030647278}
{"eval_index": 94, "problem_id": 4712, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    input = sys.stdin.read().splitlines()\n    H, W = map(int, input[0].split())\n    image = input[1:1+H]\n    \n    # Top border\n    print('#' * (W + 2))\n    \n    # Image rows with side borders\n    for row in image:\n        print('#' + row + '#')\n    \n    # Bottom border\n    print('#' * (W + 2))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.090832471847534}
{"eval_index": 95, "problem_id": 1482, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 47.88643717765808}
{"eval_index": 96, "problem_id": 3289, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.58745002746582}
{"eval_index": 97, "problem_id": 4885, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef read_board():\n    \"\"\"Read the ASCII chessboard from stdin.\"\"\"\n    lines = []\n    for line in sys.stdin:\n        line = line.rstrip('\\n')\n        if line:\n            lines.append(line)\n    return lines\n\ndef parse_board(lines):\n    \"\"\"Parse the board lines to extract piece positions.\"\"\"\n    pieces = []\n    # The board has 8 rows, each represented by 3 lines: border, content, border\n    # We only care about the content lines (index 1, 4, 7, ...)\n    for row_idx in range(8):\n        content_line = lines[row_idx * 2 + 1]\n        # Each cell is 4 chars: '|', char1, char2, char3\n        for col_idx in range(8):\n            start = col_idx * 4 + 1\n            cell = content_line[start:start+3]\n            # The middle character is the piece or empty marker\n            middle_char = cell[1]\n            if middle_char != ':' and middle_char != '.':\n                # It's a piece\n                row = 8 - row_idx  # rows are 1-indexed from bottom\n                col = chr(ord('a') + col_idx)\n                pieces.append((middle_char, row, col))\n    return pieces\n\ndef sort_pieces(pieces, is_white):\n    \"\"\"Sort pieces according to the problem's ordering rules.\"\"\"\n    # Order of piece types\n    type_order = {'K': 0, 'Q': 1, 'R': 2, 'B': 3, 'N': 4, 'P': 5}\n    \n    def sort_key(piece):\n        char, row, col = piece\n        piece_type = char.upper()\n        # For pawns, use 'P' as type for ordering\n        if piece_type == 'P':\n            type_val = type_order['P']\n        else:\n            type_val = type_order[piece_type]\n        \n        # For white: smaller row first, then smaller column\n        # For black: larger row first, then smaller column\n        if is_white:\n            row_key = row\n        else:\n            row_key = -row  # negative for descending order\n        \n        col_key = col  # alphabetical order\n        \n        return (type_val, row_key, col_key)\n    \n    return sorted(pieces, key=sort_key)\n\ndef format_output(pieces, is_white):\n    \"\"\"Format the sorted pieces into the required output string.\"\"\"\n    terms = []\n    for char, row, col in pieces:\n        piece_type = char.upper()\n        if piece_type == 'P':\n            # Pawns: no letter prefix\n            term = f\"{col}{row}\"\n        else:\n            term = f\"{piece_type}{col}{row}\"\n        terms.append(term)\n    return \",\".join(terms)\n\ndef main():\n    lines = read_board()\n    pieces = parse_board(lines)\n    \n    # Separate white and black pieces\n    white_pieces = [(char, row, col) for char, row, col in pieces if char.isupper()]\n    black_pieces = [(char.lower(), row, col) for char, row, col in pieces if char.islower()]\n    \n    # Sort according to rules\n    white_sorted = sort_pieces(white_pieces, is_white=True)\n    black_sorted = sort_pieces(black_pieces, is_white=False)\n    \n    # Format output\n    white_output = format_output(white_sorted, is_white=True)\n    black_output = format_output(black_sorted, is_white=False)\n    \n    print(f\"White: {white_output}\")\n    print(f\"Black: {black_output}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 102.65651774406433}
{"eval_index": 98, "problem_id": 1750, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.00509858131409}
{"eval_index": 99, "problem_id": 3499, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    S = data[1] if len(data) > 1 else ''\n    \n    # DP table: dp[i][j] = number of ways to match first i chars of S with first j chars of palindrome\n    # We'll build palindrome from both ends\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # For each position in the palindrome (from 0 to N-1)\n    for pos in range(N):\n        ndp = [[0] * (N + 1) for _ in range(N + 1)]\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if dp[i][j] == 0:\n                    continue\n                val = dp[i][j]\n                \n                # Try all 26 letters\n                for letter_idx in range(26):\n                    # Determine if we match S[i] or S[N-1-j]\n                    match_left = 0\n                    match_right = 0\n                    \n                    # Check left side match\n                    if i < N and chr(ord('A') + letter_idx) == S[i]:\n                        match_left = 1\n                    \n                    # Check right side match\n                    if j < N and chr(ord('A') + letter_idx) == S[N - 1 - j]:\n                        match_right = 1\n                    \n                    # Update DP\n                    ni = i + match_left\n                    nj = j + match_right\n                    ndp[ni][nj] = (ndp[ni][nj] + val) % MOD\n        dp = ndp\n    \n    # Answer is sum of dp[i][j] where i+j >= N (all characters of S matched)\n    ans = 0\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i + j >= N:\n                ans = (ans + dp[i][j]) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 59.696991205215454}
{"eval_index": 100, "problem_id": 4078, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.17680168151855}
{"eval_index": 101, "problem_id": 1451, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_lucky_digits(num):\n    \"\"\"Count how many digits 4 or 7 are in the decimal representation of num.\"\"\"\n    count = 0\n    while num > 0:\n        digit = num % 10\n        if digit == 4 or digit == 7:\n            count += 1\n        num //= 10\n    return count\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    answer = 0\n    for i in range(n):\n        num = int(data[2 + i])\n        if count_lucky_digits(num) <= k:\n            answer += 1\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.336050033569336}
{"eval_index": 102, "problem_id": 3922, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 144.06593084335327}
{"eval_index": 103, "problem_id": 4401, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input values\n    X, Y, Z = map(int, input().split())\n    \n    # Perform first swap: A and B\n    # After swap: A = Y, B = X, C = Z\n    A = Y\n    B = X\n    C = Z\n    \n    # Perform second swap: A and C\n    # After swap: A = C, C = A (old A), B unchanged\n    # Since A currently holds Y, we need to swap with C which holds Z\n    A, C = C, A  # This swaps A and C\n    \n    # Output final values\n    print(A, B, C)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.081894159317017}
{"eval_index": 104, "problem_id": 2679, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 27.56126856803894}
{"eval_index": 105, "problem_id": 3912, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 124.27138161659241}
{"eval_index": 106, "problem_id": 4373, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    a.sort()\n    \n    day = 1\n    i = 0\n    while i < n:\n        if a[i] >= day:\n            day += 1\n        i += 1\n    \n    print(day - 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.975687503814697}
{"eval_index": 107, "problem_id": 2775, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.16179704666138}
{"eval_index": 108, "problem_id": 3443, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 147.448499917984}
{"eval_index": 109, "problem_id": 4802, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    H, M = map(int, input().split())\n    total_minutes = H * 60 + M\n    new_total_minutes = (total_minutes - 45) % (24 * 60)\n    new_H = new_total_minutes // 60\n    new_M = new_total_minutes % 60\n    print(f\"{new_H} {new_M}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.486114501953125}
{"eval_index": 110, "problem_id": 663, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import math\n\ndef solve():\n    r, x, y, xp, yp = map(int, input().split())\n    dx = xp - x\n    dy = yp - y\n    dist = math.hypot(dx, dy)\n    if dist == 0:\n        print(0)\n        return\n    steps = math.ceil(dist / (2 * r))\n    print(steps)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.904920101165771}
{"eval_index": 111, "problem_id": 3669, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    points = []\n    idx = 1\n    for _ in range(n):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        points.append((x, y))\n        idx += 2\n    \n    # Count points with unique x and y coordinates\n    x_count = {}\n    y_count = {}\n    for x, y in points:\n        x_count[x] = x_count.get(x, 0) + 1\n        y_count[y] = y_count.get(y, 0) + 1\n    \n    # Count points that are the only one on their x or y line\n    critical_points = 0\n    for x, y in points:\n        if x_count[x] == 1 or y_count[y] == 1:\n            critical_points += 1\n    \n    # Game theory: if critical_points is odd, first player (Mirko) wins\n    if critical_points % 2 == 1:\n        print(\"Mirko\")\n    else:\n        print(\"Slavko\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.509047508239746}
{"eval_index": 112, "problem_id": 4954, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    B = int(data[idx]); idx += 1\n    H = int(data[idx]); idx += 1\n    W = int(data[idx]); idx += 1\n    \n    min_cost = float('inf')\n    \n    for _ in range(H):\n        p = int(data[idx]); idx += 1\n        available_beds = []\n        for _ in range(W):\n            available_beds.append(int(data[idx])); idx += 1\n        \n        total_price = p * N\n        if total_price > B:\n            continue\n        \n        for beds in available_beds:\n            if beds >= N:\n                min_cost = min(min_cost, total_price)\n                break\n    \n    if min_cost == float('inf'):\n        print(\"stay home\")\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.161163806915283}
{"eval_index": 113, "problem_id": 2365, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 19.337950468063354}
{"eval_index": 114, "problem_id": 3233, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_scary_subarrays(n, arr):\n    \"\"\"Count scary subarrays where leftmost element is median.\"\"\"\n    # Map value to index for O(1) lookup\n    pos = [0] * (n + 1)\n    for i, val in enumerate(arr):\n        pos[val] = i\n    \n    total = 0\n    # For each possible leftmost element\n    for l in range(n):\n        left_val = arr[l]\n        # Initialize counts for elements less/greater than left_val\n        less = 0\n        greater = 0\n        # We'll expand to the right\n        for r in range(l, n):\n            if arr[r] < left_val:\n                less += 1\n            elif arr[r] > left_val:\n                greater += 1\n            # Check if leftmost is median\n            # For odd length: less == greater\n            # For even length: impossible (distinct elements)\n            length = r - l + 1\n            if length % 2 == 1 and less == greater:\n                total += 1\n    return total\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    result = count_scary_subarrays(n, arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.39074730873108}
{"eval_index": 115, "problem_id": 4300, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    d = list(map(int, data[1:1+N]))\n    \n    total = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            total += d[i] * d[j]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.98661208152771}
{"eval_index": 116, "problem_id": 1111, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.5597743988037}
{"eval_index": 117, "problem_id": 3096, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.77357959747314}
{"eval_index": 118, "problem_id": 4201, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W, K = map(int, data[:3])\n    grid = data[3:]\n    \n    # Count initial black squares\n    black_positions = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                black_positions.append((i, j))\n    total_black = len(black_positions)\n    \n    count = 0\n    # Iterate over all subsets of rows (2^H possibilities)\n    for rows_mask in range(1 << H):\n        # Iterate over all subsets of columns (2^W possibilities)\n        for cols_mask in range(1 << W):\n            # Count black squares that are NOT in chosen rows or columns\n            remaining_black = 0\n            for i, j in black_positions:\n                # Check if row i is chosen\n                if (rows_mask >> i) & 1:\n                    continue\n                # Check if column j is chosen\n                if (cols_mask >> j) & 1:\n                    continue\n                remaining_black += 1\n            if remaining_black == K:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.165388822555542}
{"eval_index": 119, "problem_id": 588, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 78.70552515983582}
{"eval_index": 120, "problem_id": 3826, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Precompute frequency of each element\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # If all elements are already distinct\n    if max(freq.values()) == 1:\n        print(0)\n        return\n    \n    min_remove = n  # worst case: remove everything\n    \n    # Try all possible left boundaries of the segment to remove\n    for l in range(n):\n        # Copy frequency for this iteration\n        cur_freq = freq.copy()\n        # Try extending right boundary\n        for r in range(l, n):\n            # Remove element at position r from frequency\n            cur_freq[a[r]] -= 1\n            # Check if remaining elements are all distinct\n            if max(cur_freq.values()) <= 1:\n                # All remaining elements are distinct\n                min_remove = min(min_remove, r - l + 1)\n                break\n        # Early exit if we found optimal solution\n        if min_remove == 0:\n            break\n    \n    print(min_remove)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.3316912651062}
{"eval_index": 121, "problem_id": 4726, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.71870756149292}
{"eval_index": 122, "problem_id": 1652, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    S = sys.stdin.readline().strip()\n    words = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\n    \n    # Reverse strings to avoid ambiguity\n    S_rev = S[::-1]\n    words_rev = [w[::-1] for w in words]\n    \n    i = 0\n    n = len(S_rev)\n    \n    while i < n:\n        matched = False\n        for w in words_rev:\n            if S_rev.startswith(w, i):\n                i += len(w)\n                matched = True\n                break\n        if not matched:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.315049171447754}
{"eval_index": 123, "problem_id": 3938, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    it = iter(data)\\r\\n    n = int(next(it))\\r\\n    m = int(next(it))\\r\\n    \\r\\n    # Read all rectangles\\r\\n    rects = []\\r\\n    for _ in range(m):\\r\\n        x1 = int(next(it))\\r\\n        y1 = int(next(it))\\r\\n        x2 = int(next(it))\\r\\n        y2 = int(next(it))\\r\\n        rects.append((x1, y1, x2, y2))\\r\\n    \\r\\n    # If no black rectangles, cost is 0\\r\\n    if m == 0:\\r\\n        print(0)\\r\\n        return\\r\\n    \\r\\n    # Collect all distinct x and y coordinates\\r\\n    xs = set()\\r\\n    ys = set()\\r\\n    for x1, y1, x2, y2 in rects:\\r\\n        xs.add(x1)\\r\\n        xs.add(x2 + 1)  # Add boundary after rectangle\\r\\n        ys.add(y1)\\r\\n        ys.add(y2 + 1)\\r\\n    \\r\\n    # Sort coordinates\\r\\n    xs = sorted(xs)\\r\\n    ys = sorted(ys)\\r\\n    \\r\\n    # Create compressed grid\\r\\n    x_cnt = len(xs) - 1\\r\\n    y_cnt = len(ys) - 1\\r\\n    \\r\\n    # Initialize compressed grid with zeros\\r\\n    grid = [[0] * y_cnt for _ in range(x_cnt)]\\r\\n    \\r\\n    # Mark black cells in compressed grid\\r\\n    for x1, y1, x2, y2 in rects:\\r\\n        # Find compressed indices\\r\\n        x_start = next(i for i in range(x_cnt) if xs[i] <= x1 < xs[i + 1])\\r\\n        x_end = next(i for i in range(x_cnt) if xs[i] <= x2 < xs[i + 1])\\r\\n        y_start = next(i for i in range(y_cnt) if ys[i] <= y1 < ys[i + 1])\\r\\n        y_end = next(i for i in range(y_cnt) if ys[i] <= y2 < ys[i + 1])\\r\\n        \\r\\n        # Mark all cells in this region as black\\r\\n        for i in range(x_start, x_end + 1):\\r\\n            for j in range(y_start, y_end + 1):\\r\\n                grid[i][j] = 1\\r\\n    \\r\\n    # Now we have a compressed grid of size at most 100x100\\r\\n    # We need to find minimum cost to cover all black cells with rectangles\\r\\n    # where cost = min(height, width)\\r\\n    \\r\\n    # This is essentially finding minimum edge cover in a bipartite graph\\r\\n    # where rows and columns are vertices, and black cells are edges\\r\\n    # Minimum cost = size of minimum vertex cover in bipartite graph\\r\\n    # (Knig\\'s theorem)\\r\\n    \\r\\n    # Build bipartite graph\\r\\n    adj = [[] for _ in range(x_cnt)]\\r\\n    for i in range(x_cnt):\\r\\n        for j in range(y_cnt):\\r\\n            if grid[i][j]:\\r\\n                adj[i].append(j)\\r\\n    \\r\\n    # Maximum bipartite matching using DFS\\r\\n    match_y = [-1] * y_cnt\\r\\n    \\r\\n    def dfs(u, visited):\\r\\n        for v in adj[u]:\\r\\n            if not visited[v]:\\r\\n                visited[v] = True\\r\\n                if match_y[v] == -1 or dfs(match_y[v], visited):\\r\\n                    match_y[v] = u\\r\\n                    return True\\r\\n        return False\\r\\n    \\r\\n    # Find maximum matching\\r\\n    matching = 0\\r\\n    for u in range(x_cnt):\\r\\n        visited = [False] * y_cnt\\r\\n        if dfs(u, visited):\\r\\n            matching += 1\\r\\n    \\r\\n    # By Knig\\'s theorem, minimum vertex cover size = maximum matching size\\r\\n    print(matching)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 2009, 2010, 'illegal multibyte sequence')", "runtime_sec": 44.86578559875488}
{"eval_index": 124, "problem_id": 4722, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    total = A + B\n    # Check if total is divisible by 3 and if either A or B is at least total//3\n    if total % 3 == 0 and (A >= total // 3 or B >= total // 3):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.51123285293579}
{"eval_index": 125, "problem_id": 915, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    k = int(data)\n    \n    # Target string \"codeforces\"\n    target = \"codeforces\"\n    n = len(target)  # n = 10\n    \n    # We need to find counts c1, c2, ..., c10 for each character\n    # such that product(c1 * c2 * ... * c10) >= k\n    # and sum(c1 + c2 + ... + c10) is minimized\n    \n    # Initialize all counts to 1 (minimum possible)\n    counts = [1] * n\n    product = 1\n    \n    # Increase counts one by one in round-robin fashion\n    # to keep the product balanced\n    idx = 0\n    while product < k:\n        # Increase the count at current index\n        product //= counts[idx]  # remove old contribution\n        counts[idx] += 1\n        product *= counts[idx]  # add new contribution\n        \n        # Move to next index\n        idx = (idx + 1) % n\n    \n    # Build the result string\n    result = []\n    for i in range(n):\n        result.append(target[i] * counts[i])\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.016602516174316}
{"eval_index": 126, "problem_id": 3619, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.10566639900208}
{"eval_index": 127, "problem_id": 4404, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    year, month, day = map(int, S.split('/'))\n    \n    # Since year is always 2019 per constraints, we only need to compare month and day\n    if month < 4:\n        print(\"Heisei\")\n    elif month == 4:\n        if day <= 30:\n            print(\"Heisei\")\n        else:\n            print(\"TBD\")\n    else:\n        print(\"TBD\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.92940878868103}
{"eval_index": 128, "problem_id": 943, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    total_sum = sum(arr)\n    \n    # If total sum is already even, it's the answer\n    if total_sum % 2 == 0:\n        return total_sum\n    \n    # Otherwise, we need to remove the smallest odd number\n    # to make the sum even while maximizing the sum\n    min_odd = float('inf')\n    for num in arr:\n        if num % 2 == 1 and num < min_odd:\n            min_odd = num\n    \n    # If no odd number exists (shouldn't happen since sum is odd),\n    # but handle edge case\n    if min_odd == float('inf'):\n        return 0\n    \n    return total_sum - min_odd\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "complexity_estimate": null, "runtime_sec": 19.953922271728516}
{"eval_index": 129, "problem_id": 3564, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.31848812103271}
{"eval_index": 130, "problem_id": 4487, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    # Read input from standard input\n    A, B, C = input().split()\n    \n    # Check the two conditions for word chain\n    condition1 = A[-1] == B[0]\n    condition2 = B[-1] == C[0]\n    \n    # Output YES if both conditions are true, otherwise NO\n    if condition1 and condition2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.790817260742188}
{"eval_index": 131, "problem_id": 2784, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    graph = {}\n    \n    # Build graph from station fragments\n    for i in range(1, n + 1):\n        parts = data[i].split()\n        station = parts[0]\n        connections = parts[1:]\n        \n        if station not in graph:\n            graph[station] = set()\n        \n        for conn in connections:\n            graph[station].add(conn)\n            if conn not in graph:\n                graph[conn] = set()\n            graph[conn].add(station)\n    \n    # Get start and destination\n    start, dest = data[n + 1].split()\n    \n    # BFS to find shortest path\n    visited = {start}\n    queue = [(start, [start])]\n    \n    while queue:\n        current, path = queue.pop(0)\n        \n        if current == dest:\n            print(' '.join(path))\n            return\n        \n        if current not in graph:\n            continue\n            \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    # No route found\n    print(\"no route found\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.358108520507812}
{"eval_index": 132, "problem_id": 3889, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # Count frequencies of each character\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    \n    # Check if any character appears at least twice, or if n == 1\n    possible = False\n    for count in freq:\n        if count >= 2:\n            possible = True\n            break\n    if n == 1:\n        possible = True\n    \n    print(\"Yes\" if possible else \"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.915770292282104}
{"eval_index": 133, "problem_id": 4614, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    A, B, C = map(int, input().split())\n    if A == B:\n        print(C)\n    elif A == C:\n        print(B)\n    else:\n        print(A)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 10.092293739318848}
{"eval_index": 134, "problem_id": 1486, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    results = []\n    for i in range(n):\n        if i == 0:\n            min_cost = x[1] - x[0]\n            max_cost = x[-1] - x[0]\n        elif i == n-1:\n            min_cost = x[-1] - x[-2]\n            max_cost = x[-1] - x[0]\n        else:\n            min_cost = min(x[i] - x[i-1], x[i+1] - x[i])\n            max_cost = max(x[i] - x[0], x[-1] - x[i])\n        results.append(f\"{min_cost} {max_cost}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.739439964294434}
{"eval_index": 135, "problem_id": 3635, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    bananas = list(map(int, data[1:1+n]))\n    \n    # Prefix sums for quick range sum queries\n    prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i-1] + bananas[i-1]\n    \n    # dp[i] = maximum number of executives using first i briefcases\n    dp = [0] * (n + 1)\n    # last_sum[i] = total bananas given to last executive when using first i briefcases\n    last_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        # Try to start a new executive at position j (1-indexed)\n        for j in range(1, i + 1):\n            # Sum from j to i\n            current_sum = prefix[i] - prefix[j-1]\n            # Check if we can append this segment to the solution ending at j-1\n            if dp[j-1] > 0:\n                if current_sum >= last_sum[j-1]:\n                    if dp[j-1] + 1 > dp[i] or (dp[j-1] + 1 == dp[i] and current_sum < last_sum[i]):\n                        dp[i] = dp[j-1] + 1\n                        last_sum[i] = current_sum\n            else:\n                # First executive\n                if dp[i] < 1:\n                    dp[i] = 1\n                    last_sum[i] = current_sum\n    \n    print(dp[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.24391531944275}
{"eval_index": 136, "problem_id": 4648, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    out_lines = []\n    idx = 1\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        moves = 0\n        while n > 1:\n            if n % 6 == 0:\n                n //= 6\n                moves += 1\n            elif n % 3 == 0:\n                n *= 2\n                moves += 1\n            else:\n                moves = -1\n                break\n        out_lines.append(str(moves))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.74296283721924}
{"eval_index": 137, "problem_id": 475, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # dp[i][j] = ways to color first i bricks with exactly j changes\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case: first brick can be any of m colors, with 0 changes\n    dp[1][0] = m\n    \n    for i in range(2, n + 1):\n        for j in range(0, min(k, i - 1) + 1):\n            # Case 1: same color as previous brick\n            # No change added, so we take dp[i-1][j] ways\n            same = dp[i - 1][j]\n            \n            # Case 2: different color from previous brick\n            # A change is added, so we need dp[i-1][j-1] ways\n            # And we have (m-1) choices for the different color\n            diff = 0\n            if j > 0:\n                diff = dp[i - 1][j - 1] * (m - 1) % MOD\n            \n            dp[i][j] = (same + diff) % MOD\n    \n    print(dp[n][k] % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 37.47600054740906}
{"eval_index": 138, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.4968659877777}
{"eval_index": 139, "problem_id": 4656, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); k = int(data[idx+1])\n        idx += 2\n        s = data[idx]\n        idx += 1\n        \n        # Count frequencies of each character\n        freq = [0]*26\n        for ch in s:\n            freq[ord(ch)-97] += 1\n        \n        # Try all possible necklace lengths from n down to 1\n        best = 0\n        for length in range(1, n+1):\n            # For each length, we need to check if we can form a k-beautiful necklace\n            # A k-beautiful necklace of length L means that rotating by k positions\n            # gives the same necklace. This implies that the necklace pattern repeats\n            # every g = gcd(L, k) positions.\n            # So the necklace consists of L/g identical blocks of length g.\n            # Therefore, we need at least L/g copies of each bead in the repeating block.\n            \n            g = length\n            while g > 0 and k % g != 0:\n                g -= 1\n            # Actually, we need gcd(L, k), but we can compute it properly:\n            import math\n            g = math.gcd(length, k)\n            \n            # The necklace consists of L/g identical segments of length g\n            segments = length // g\n            \n            # For each character, we can use at most freq[c] beads.\n            # In each segment of length g, we need to assign beads.\n            # Since all segments are identical, the total usage of each character\n            # must be a multiple of segments.\n            # We want to maximize total beads used = segments * g\n            # But we are iterating length, so we just need to check feasibility.\n            \n            # Count how many full segments we can make\n            total_segments_possible = 0\n            for f in freq:\n                total_segments_possible += f // segments\n            \n            # We need at least g beads per segment, so total_segments_possible must be >= g\n            if total_segments_possible >= g:\n                best = length\n            else:\n                # If this length fails, longer lengths will also fail because\n                # segments = length/g increases, making it harder to satisfy.\n                # But we already iterate from 1 to n, so we just break early for efficiency.\n                # Actually, we can't break because smaller g might work for larger length.\n                # So we continue checking all lengths.\n                pass\n        \n        results.append(str(best))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 101.69510173797607}
{"eval_index": 140, "problem_id": 1018, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.27373814582825}
{"eval_index": 141, "problem_id": 3460, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.46631669998169}
{"eval_index": 142, "problem_id": 4074, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        idx += 2\n        \n        # Find the largest divisor of n that is <= k\n        # We need to find the maximum d such that d <= k and n % d == 0\n        # Then answer = n // d\n        \n        # Approach: check divisors from 1 to min(k, sqrt(n))\n        # For each divisor i, check if i <= k and n % i == 0\n        # Also check the paired divisor n // i if it <= k\n        \n        best = n  # worst case: buy n packages of size 1\n        limit = int(n ** 0.5)\n        \n        for i in range(1, min(k, limit) + 1):\n            if n % i == 0:\n                # i is a divisor\n                if i <= k:\n                    best = min(best, n // i)\n                # Check paired divisor\n                paired = n // i\n                if paired <= k:\n                    best = min(best, n // paired)\n        \n        # Also check if k >= n, then we can buy 1 package of size n\n        if k >= n:\n            best = 1\n        \n        results.append(str(best))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.469380617141724}
{"eval_index": 143, "problem_id": 2633, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 15.159830570220947}
{"eval_index": 144, "problem_id": 3052, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.1515908241272}
{"eval_index": 145, "problem_id": 4194, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:2+M]))\n    \n    total_work_days = sum(A)\n    \n    if total_work_days > N:\n        print(-1)\n    else:\n        hangout_days = N - total_work_days\n        print(hangout_days)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.301721334457397}
{"eval_index": 146, "problem_id": 2618, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    idx = 0\n    q = int(input_data[idx]); idx += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(input_data[idx]); idx += 1\n        prices = list(map(int, input_data[idx:idx+n])); idx += n\n        x, a = map(int, input_data[idx:idx+2]); idx += 2\n        y, b = map(int, input_data[idx:idx+2]); idx += 2\n        k = int(input_data[idx]); idx += 1\n        \n        # Ensure x corresponds to larger percentage for optimal arrangement\n        if x < y:\n            x, y = y, x\n            a, b = b, a\n        \n        # Sort prices in descending order\n        prices.sort(reverse=True)\n        \n        # Precompute contributions for each position\n        contributions = [0] * n\n        for i in range(n):\n            pos = i + 1  # 1-indexed position\n            multiplier = 0\n            if pos % a == 0 and pos % b == 0:\n                multiplier = (x + y) / 100.0\n            elif pos % a == 0:\n                multiplier = x / 100.0\n            elif pos % b == 0:\n                multiplier = y / 100.0\n            contributions[i] = multiplier\n        \n        # Binary search for minimum number of tickets\n        left, right = 1, n\n        answer = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # Calculate maximum possible contribution with mid tickets\n            total = 0.0\n            # We'll assign highest prices to positions with highest multipliers\n            # Create list of multipliers for first mid positions\n            pos_multipliers = contributions[:mid]\n            pos_multipliers.sort(reverse=True)\n            \n            # Assign highest prices to highest multipliers\n            for i in range(mid):\n                total += prices[i] * pos_multipliers[i]\n            \n            if total >= k - 1e-9:  # Account for floating point precision\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        results.append(str(answer))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.704124689102173}
{"eval_index": 147, "problem_id": 3738, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    s = data[2]\n    \n    # Compute net displacement after one full command\n    dx = 0\n    dy = 0\n    for ch in s:\n        if ch == 'U':\n            dy += 1\n        elif ch == 'D':\n            dy -= 1\n        elif ch == 'L':\n            dx -= 1\n        elif ch == 'R':\n            dx += 1\n    \n    # Check positions after each prefix of the command\n    cur_x = 0\n    cur_y = 0\n    for i in range(len(s)):\n        # Check if current position matches (a, b)\n        if cur_x == a and cur_y == b:\n            print(\"Yes\")\n            return\n        \n        # If net displacement is zero, we can't reach further positions\n        if dx == 0 and dy == 0:\n            # Only check current position (already done above)\n            pass\n        else:\n            # For non-zero net displacement, check if (a, b) lies on the infinite line\n            # We need to find integer k such that:\n            # cur_x + k*dx = a  and  cur_y + k*dy = b\n            # This means k must be same for both equations and non-negative integer\n            kx = None\n            ky = None\n            if dx != 0:\n                if (a - cur_x) % dx == 0:\n                    kx = (a - cur_x) // dx\n                else:\n                    kx = None\n            else:\n                # dx == 0, then we need cur_x == a\n                if cur_x == a:\n                    kx = 0  # any k works, we'll use ky to determine\n                else:\n                    kx = None\n            \n            if dy != 0:\n                if (b - cur_y) % dy == 0:\n                    ky = (b - cur_y) // dy\n                else:\n                    ky = None\n            else:\n                # dy == 0, then we need cur_y == b\n                if cur_y == b:\n                    ky = 0  # any k works, we'll use kx to determine\n                else:\n                    ky = None\n            \n            # Determine if valid k exists\n            if kx is not None and ky is not None:\n                # Both equations give a k value\n                if dx == 0:\n                    # kx is 0, check if ky >= 0\n                    if ky >= 0:\n                        print(\"Yes\")\n                        return\n                elif dy == 0:\n                    # ky is 0, check if kx >= 0\n                    if kx >= 0:\n                        print(\"Yes\")\n                        return\n                else:\n                    # Both dx and dy non-zero, need same k and k >= 0\n                    if kx == ky and kx >= 0:\n                        print(\"Yes\")\n                        return\n            elif kx is not None and dy == 0:\n                # dy == 0, ky is 0 if cur_y == b, else None\n                # We already checked cur_y == b when dy == 0 in ky calculation\n                # So if ky is None, it means cur_y != b, so no solution\n                # If ky is 0, then check kx >= 0\n                if ky == 0 and kx >= 0:\n                    print(\"Yes\")\n                    return\n            elif ky is not None and dx == 0:\n                # Similar logic for dx == 0\n                if kx == 0 and ky >= 0:\n                    print(\"Yes\")\n                    return\n        \n        # Move to next position\n        ch = s[i]\n        if ch == 'U':\n            cur_y += 1\n        elif ch == 'D':\n            cur_y -= 1\n        elif ch == 'L':\n            cur_x -= 1\n        elif ch == 'R':\n            cur_x += 1\n    \n    # Check final position after full command\n    if cur_x == a and cur_y == b:\n        print(\"Yes\")\n        return\n    \n    # If we reach here, (a, b) is not reachable\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 53.74476146697998}
{"eval_index": 148, "problem_id": 4880, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 151.40201473236084}
{"eval_index": 149, "problem_id": 234, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def count_bombs(grid, i, j, n, m):\n    count = 0\n    for di in [-1, 0, 1]:\n        for dj in [-1, 0, 1]:\n            if di == 0 and dj == 0:\n                continue\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < m:\n                if grid[ni][nj] == '*':\n                    count += 1\n    return count\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:2 + n]\n    \n    for i in range(n):\n        for j in range(m):\n            cell = grid[i][j]\n            if cell == '.':\n                # Check all neighbors have no bombs\n                if count_bombs(grid, i, j, n, m) != 0:\n                    print(\"NO\")\n                    return\n            elif cell.isdigit():\n                expected = int(cell)\n                actual = count_bombs(grid, i, j, n, m)\n                if expected != actual:\n                    print(\"NO\")\n                    return\n            # For '*', no check needed\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.071593523025513}
{"eval_index": 150, "problem_id": 3807, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.99343276023865}
{"eval_index": 151, "problem_id": 4199, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    heights = list(map(int, data[2:2+N]))\n    count = 0\n    for h in heights:\n        if h >= K:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.275042295455933}
{"eval_index": 152, "problem_id": 113, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef k_rounding(n, k):\n    # Count factors of 2 and 5 in n\n    count2 = 0\n    count5 = 0\n    temp = n\n    while temp % 2 == 0:\n        count2 += 1\n        temp //= 2\n    while temp % 5 == 0:\n        count5 += 1\n        temp //= 5\n    \n    # Calculate additional factors needed\n    needed_zeros = k\n    add2 = max(0, needed_zeros - count2)\n    add5 = max(0, needed_zeros - count5)\n    \n    # Multiply n by 2^add2 * 5^add5\n    multiplier = (2 ** add2) * (5 ** add5)\n    result = n * multiplier\n    \n    return result\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    print(k_rounding(n, k))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 24.239284992218018}
{"eval_index": 153, "problem_id": 3974, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 32.36338973045349}
{"eval_index": 154, "problem_id": 4152, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 91.44062399864197}
{"eval_index": 155, "problem_id": 1073, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # Map directions to coordinate changes\n    dir_map = {'U': (0, 1), 'R': (1, 0), 'D': (0, -1), 'L': (-1, 0)}\n    \n    # Prefix sums of positions\n    prefix = [(0, 0)]  # start at (0,0)\n    for ch in s:\n        dx, dy = dir_map[ch]\n        last_x, last_y = prefix[-1]\n        prefix.append((last_x + dx, last_y + dy))\n    \n    # Count substrings where start and end positions are equal\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix[i] == prefix[j]:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 16.15664839744568}
{"eval_index": 156, "problem_id": 3835, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 136.61390924453735}
{"eval_index": 157, "problem_id": 4348, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = list(data[2])\n    \n    # Count occurrences of each character\n    cnt = [0] * 26\n    for ch in s:\n        cnt[ord(ch) - ord('a')] += 1\n    \n    # Simulate removal\n    removed = 0\n    for c in range(26):  # from 'a' to 'z'\n        if removed >= k:\n            break\n        ch = chr(ord('a') + c)\n        # Remove as many of this character as needed, but not more than available\n        to_remove = min(cnt[c], k - removed)\n        if to_remove == 0:\n            continue\n        # Remove leftmost occurrences\n        removed_here = 0\n        for i in range(n):\n            if s[i] == ch:\n                s[i] = ''  # mark for removal\n                removed_here += 1\n                if removed_here == to_remove:\n                    break\n        removed += to_remove\n    \n    # Build result string from non-removed characters\n    result = ''.join(ch for ch in s if ch != '')\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 56.68466281890869}
{"eval_index": 158, "problem_id": 1283, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    grid = data[2:]\n    \n    # Initialize count matrix\n    cnt = [[0] * n for _ in range(n)]\n    \n    # Check horizontal placements\n    for i in range(n):\n        for j in range(n - k + 1):\n            valid = True\n            for d in range(k):\n                if grid[i][j + d] == '#':\n                    valid = False\n                    break\n            if valid:\n                for d in range(k):\n                    cnt[i][j + d] += 1\n    \n    # Check vertical placements\n    for i in range(n - k + 1):\n        for j in range(n):\n            valid = True\n            for d in range(k):\n                if grid[i + d][j] == '#':\n                    valid = False\n                    break\n            if valid:\n                for d in range(k):\n                    cnt[i + d][j] += 1\n    \n    # Find cell with maximum count\n    max_val = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        for j in range(n):\n            if cnt[i][j] > max_val:\n                max_val = cnt[i][j]\n                max_i, max_j = i, j\n    \n    # Output 1-based indices\n    print(max_i + 1, max_j + 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.216406106948853}
{"eval_index": 159, "problem_id": 3008, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.43282318115234}
{"eval_index": 160, "problem_id": 4121, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # First, we need to make all heights have the same parity\n    # because vertical bricks add 2 (even), horizontal bricks add 1 to two adjacent positions\n    # The parity of each position changes when we use horizontal bricks on it\n    \n    # We'll use a stack to track segments with same parity\n    stack = []\n    \n    for height in a:\n        parity = height % 2\n        \n        if stack and stack[-1] == parity:\n            # Same parity as top of stack, we can potentially merge\n            stack.pop()\n        else:\n            # Different parity, push to stack\n            stack.append(parity)\n    \n    # If stack is empty or has exactly 1 element, it's possible\n    # Empty stack means all parities matched and cancelled out\n    # 1 element means we have one segment left with uniform parity\n    if len(stack) <= 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.885897397994995}
{"eval_index": 161, "problem_id": 607, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    MOD = int(data[1])\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    # Fermat's little theorem for modular inverse\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # Precompute powers of 2 modulo MOD\n    pow2 = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pow2[i] = (pow2[i - 1] * 2) % MOD\n    \n    # Total permutations\n    total_perm = fact[n]\n    \n    # Contribution from length 1 segments: each position contributes to all permutations\n    # For each position i, segment [i,i] is always framed\n    # There are n such positions, each in all n! permutations\n    ans = n * total_perm % MOD\n    \n    # For segments of length L >= 2\n    # For a segment of length L to be framed, the values must be a contiguous set of L integers\n    # There are (n - L + 1) possible sets of values that can form a framed segment\n    # For each such set, we need to count permutations where these values appear consecutively\n    # The set can be arranged in L! ways internally, and the remaining (n-L) elements can be arranged in (n-L)! ways\n    # The framed segment can be placed in (n - L + 1) positions\n    # However, we must avoid double counting when multiple framed segments overlap\n    # Using inclusion-exclusion: for each length L, contribution = (n-L+1)^2 * L! * (n-L)!\n    for L in range(2, n + 1):\n        # Number of possible value sets of size L\n        num_value_sets = n - L + 1\n        # Number of positions where the segment can start\n        num_positions = n - L + 1\n        # Internal arrangements of the framed segment\n        internal_arr = fact[L]\n        # Arrangements of remaining elements\n        remaining_arr = fact[n - L]\n        \n        contribution = num_value_sets * num_positions % MOD\n        contribution = contribution * internal_arr % MOD\n        contribution = contribution * remaining_arr % MOD\n        \n        ans = (ans + contribution) % MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 81.7118763923645}
{"eval_index": 162, "problem_id": 3858, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 103.83570170402527}
{"eval_index": 163, "problem_id": 4467, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    red = []\n    blue = []\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        red.append((a, b))\n    for _ in range(N):\n        c = int(next(it))\n        d = int(next(it))\n        blue.append((c, d))\n    \n    # Sort red points by x ascending, then y ascending\n    red.sort(key=lambda p: (p[0], p[1]))\n    # Sort blue points by x ascending, then y ascending\n    blue.sort(key=lambda p: (p[0], p[1]))\n    \n    # Greedy matching: for each blue point, try to match with the red point\n    # that has the largest y less than blue's y, among reds with x less than blue's x.\n    # This is a classic problem solvable with sorting and binary search.\n    \n    # We'll process blue points in order of increasing x.\n    # Maintain a sorted list of y-coordinates of red points that have x < current blue's x.\n    from bisect import bisect_left\n    \n    red_y_list = []  # will be kept sorted\n    blue_idx = 0\n    red_idx = 0\n    pairs = 0\n    \n    while blue_idx < N:\n        bx, by = blue[blue_idx]\n        # Add all red points with x < bx to red_y_list\n        while red_idx < N and red[red_idx][0] < bx:\n            # Insert y in sorted order\n            y = red[red_idx][1]\n            pos = bisect_left(red_y_list, y)\n            red_y_list.insert(pos, y)\n            red_idx += 1\n        # Find the largest y in red_y_list that is < by\n        pos = bisect_left(red_y_list, by)\n        if pos > 0:\n            # Match with red_y_list[pos-1]\n            red_y_list.pop(pos-1)\n            pairs += 1\n        blue_idx += 1\n    \n    print(pairs)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.25871753692627}
{"eval_index": 164, "problem_id": 1020, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    w, h, k = map(int, data)\n    total = 0\n    for i in range(k):\n        # inner rectangle dimensions after i rings\n        inner_w = w - 4 * i\n        inner_h = h - 4 * i\n        # perimeter of current ring\n        if inner_w <= 0 or inner_h <= 0:\n            break\n        if inner_w == 1:\n            ring_cells = inner_h\n        elif inner_h == 1:\n            ring_cells = inner_w\n        else:\n            ring_cells = 2 * (inner_w + inner_h) - 4\n        total += ring_cells\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.011921167373657}
{"eval_index": 165, "problem_id": 3375, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.63177132606506}
{"eval_index": 166, "problem_id": 4855, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport math\\r\\n\\r\\ndef main():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    A = int(data[0])\\r\\n    I = int(data[1])\\r\\n    \\r\\n    # We need minimal citations C such that ceil(C/A) >= I\\r\\n    # Since ceil(C/A) >= I means C/A > I-1\\r\\n    # So C > A*(I-1)\\r\\n    # Minimal integer C satisfying this is A*(I-1) + 1\\r\\n    # But we need to check if ceil(C/A) == I exactly\\r\\n    # Actually, we need ceil(C/A) >= I, so minimal C is A*(I-1) + 1\\r\\n    # However, we must ensure ceil(C/A) == I, not > I\\r\\n    # Let\\'s derive properly:\\r\\n    # ceil(C/A) >= I  =>  C/A > I-1  =>  C > A*(I-1)\\r\\n    # Since C is integer, minimal C = A*(I-1) + 1\\r\\n    # But wait: ceil(C/A) = I means I-1 < C/A <= I\\r\\n    # Actually ceil(C/A) = I means I-1 < C/A <= I\\r\\n    # So we need C > A*(I-1) and C <= A*I\\r\\n    # Minimal C is A*(I-1) + 1\\r\\n    # Number of bribes = C - current_citations\\r\\n    # Since we start with 0 citations, bribes = C\\r\\n    \\r\\n    # But there\\'s a catch: if I=1, then A*(I-1) + 1 = 1\\r\\n    # ceil(1/A) = 1 for any A>=1, so that\\'s correct\\r\\n    \\r\\n    # Actually, the formula should be:\\r\\n    # We need minimal C such that ceil(C/A) = I\\r\\n    # This means: I-1 < C/A <= I\\r\\n    # So: A*(I-1) < C <= A*I\\r\\n    # Minimal integer C is floor(A*(I-1)) + 1\\r\\n    # Since A and I are integers, A*(I-1) is integer\\r\\n    # So minimal C = A*(I-1) + 1\\r\\n    \\r\\n    # But wait! Check example 1: A=38, I=24\\r\\n    # C = 38*(24-1) + 1 = 38*23 + 1 = 874 + 1 = 875\\r\\n    # ceil(875/38) = ceil(23.026...) = 24 \\r\\n    \\r\\n    # Example 2: A=1, I=100\\r\\n    # C = 1*(100-1) + 1 = 99 + 1 = 100\\r\\n    # ceil(100/1) = 100 \\r\\n    \\r\\n    C = A * (I - 1) + 1\\r\\n    print(C)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()', 1497, 1498, 'illegal multibyte sequence')", "runtime_sec": 32.18818140029907}
{"eval_index": 167, "problem_id": 1469, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 65.33599162101746}
{"eval_index": 168, "problem_id": 3441, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 118.55100560188293}
{"eval_index": 169, "problem_id": 4559, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Handle zero case early\n    if 0 in arr:\n        print(0)\n        return\n    \n    LIMIT = 10**18\n    result = 1\n    \n    for num in arr:\n        # Check if multiplication would exceed limit\n        if result > LIMIT // num:\n            print(-1)\n            return\n        result *= num\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.49733567237854}
{"eval_index": 170, "problem_id": 2355, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.96091961860657}
{"eval_index": 171, "problem_id": 3134, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R = data[0].strip()\n    C = data[1].strip()\n    n = len(R)\n    m = len(C)\n    \n    # Check if total parity constraint is satisfied\n    row_parity_sum = sum(int(ch) for ch in R) % 2\n    col_parity_sum = sum(int(ch) for ch in C) % 2\n    if row_parity_sum != col_parity_sum:\n        print(-1)\n        return\n    \n    # Initialize matrix with all ones\n    matrix = [[1] * m for _ in range(n)]\n    \n    # Adjust rows to match parity\n    for i in range(n):\n        if R[i] == '0':\n            # Even parity row: need even number of 1s\n            # If current row has odd number of 1s (m is odd), flip one cell\n            if m % 2 == 1:\n                matrix[i][0] = 0\n    \n    # Adjust columns to match parity\n    for j in range(m):\n        # Count current 1s in column j\n        col_ones = sum(matrix[i][j] for i in range(n))\n        if C[j] == '0':\n            # Even parity column: need even number of 1s\n            # If current column has odd number of 1s, flip one cell\n            if col_ones % 2 == 1:\n                # Find first row where we can flip without breaking row parity\n                for i in range(n):\n                    if matrix[i][j] == 1:\n                        # Check if flipping breaks row parity\n                        row_ones = sum(matrix[i])\n                        if R[i] == '0':\n                            # Row needs even parity, flipping reduces ones by 1\n                            # If row_ones is odd, flipping makes it even (good)\n                            # If row_ones is even, flipping makes it odd (bad)\n                            if row_ones % 2 == 1:\n                                matrix[i][j] = 0\n                                break\n                        else:\n                            # Row needs odd parity, flipping reduces ones by 1\n                            # If row_ones is odd, flipping makes it even (bad)\n                            # If row_ones is even, flipping makes it odd (good)\n                            if row_ones % 2 == 0:\n                                matrix[i][j] = 0\n                                break\n        else:\n            # Odd parity column: need odd number of 1s\n            # If current column has even number of 1s, flip one cell\n            if col_ones % 2 == 0:\n                for i in range(n):\n                    if matrix[i][j] == 1:\n                        row_ones = sum(matrix[i])\n                        if R[i] == '0':\n                            if row_ones % 2 == 1:\n                                matrix[i][j] = 0\n                                break\n                        else:\n                            if row_ones % 2 == 0:\n                                matrix[i][j] = 0\n                                break\n    \n    # Final verification\n    for i in range(n):\n        row_ones = sum(matrix[i])\n        if (row_ones % 2) != int(R[i]):\n            print(-1)\n            return\n    for j in range(m):\n        col_ones = sum(matrix[i][j] for i in range(n))\n        if (col_ones % 2) != int(C[j]):\n            print(-1)\n            return\n    \n    # Output matrix\n    for i in range(n):\n        print(''.join(str(cell) for cell in matrix[i]))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 70.2773551940918}
{"eval_index": 172, "problem_id": 4003, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    left = 0\n    right = n - 1\n    last = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] <= last and a[right] <= last:\n            break\n        \n        if a[left] > last and a[right] > last:\n            if a[left] < a[right]:\n                moves.append('L')\n                last = a[left]\n                left += 1\n            elif a[left] > a[right]:\n                moves.append('R')\n                last = a[right]\n                right -= 1\n            else:\n                # Equal values, need to check which side gives longer sequence\n                l_len = 1\n                r_len = 1\n                \n                # Check how many we can take from left side\n                for i in range(left + 1, right + 1):\n                    if a[i] > a[left + l_len - 1]:\n                        l_len += 1\n                    else:\n                        break\n                \n                # Check how many we can take from right side\n                for i in range(right - 1, left - 1, -1):\n                    if a[i] > a[right - r_len + 1]:\n                        r_len += 1\n                    else:\n                        break\n                \n                if l_len > r_len:\n                    moves.append('L')\n                    last = a[left]\n                    left += 1\n                else:\n                    moves.append('R')\n                    last = a[right]\n                    right -= 1\n        elif a[left] > last:\n            moves.append('L')\n            last = a[left]\n            left += 1\n        else:  # a[right] > last\n            moves.append('R')\n            last = a[right]\n            right -= 1\n    \n    print(len(moves))\n    print(''.join(moves))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.576146602630615}
{"eval_index": 173, "problem_id": 1302, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Special cases\n    if k == n:\n        # Need all positions to have gcd(i, p_i) > 1\n        # This is impossible for n > 1 because position 1 must have gcd(1, x) = 1\n        # For n = 1, k=1 is impossible because gcd(1,1)=1\n        print(-1)\n        return\n    \n    # Create identity permutation initially\n    perm = list(range(1, n + 1))\n    \n    # We'll make positions good by swapping elements\n    # Strategy: For position i, we want gcd(i, perm[i-1]) > 1\n    # We can swap elements to achieve this\n    \n    good_count = 0\n    # Track which positions are already good\n    good_positions = set()\n    \n    # First, handle positions that are already good in identity permutation\n    for i in range(1, n + 1):\n        if math.gcd(i, i) > 1:\n            good_count += 1\n            good_positions.add(i - 1)  # 0-indexed\n    \n    # If we already have exactly k good elements, output identity\n    if good_count == k:\n        print(' '.join(map(str, perm)))\n        return\n    \n    # We need to adjust the number of good elements\n    # We can increase good count by making bad positions good\n    # Or decrease good count by making good positions bad\n    \n    if good_count < k:\n        # Need to add more good positions\n        needed = k - good_count\n        added = 0\n        \n        # Try to make bad positions good by swapping with other bad positions\n        for i in range(n):\n            if added >= needed:\n                break\n            pos = i + 1  # 1-indexed position\n            if i in good_positions:\n                continue  # Already good\n            \n            # Find another position j to swap with\n            for j in range(i + 1, n):\n                if j in good_positions:\n                    continue  # Don't mess with already good positions\n                \n                # Check if swapping makes position i good\n                if math.gcd(pos, perm[j]) > 1:\n                    # Also check if position j becomes good or stays bad\n                    # We want to increase good count, so ideally j should become good too\n                    if math.gcd(j + 1, perm[i]) > 1:\n                        # Both become good - great!\n                        perm[i], perm[j] = perm[j], perm[i]\n                        good_positions.add(i)\n                        good_positions.add(j)\n                        added += 2\n                        break\n                    elif added + 1 <= needed:\n                        # Only i becomes good, that's still helpful\n                        perm[i], perm[j] = perm[j], perm[i]\n                        good_positions.add(i)\n                        added += 1\n                        break\n            \n            if added >= needed:\n                break\n        \n        if added >= needed:\n            print(' '.join(map(str, perm)))\n            return\n        else:\n            print(-1)\n            return\n    \n    else:  # good_count > k\n        # Need to reduce good positions\n        to_remove = good_count - k\n        removed = 0\n        \n        # Try to make good positions bad by swapping with other positions\n        good_list = list(good_positions)\n        \n        for idx in good_list:\n            if removed >= to_remove:\n                break\n            pos = idx + 1\n            \n            # Find a position to swap with that makes this position bad\n            for j in range(n):\n                if j == idx:\n                    continue\n                if math.gcd(pos, perm[j]) == 1:\n                    # Swapping would make position idx bad\n                    # Check what happens to position j\n                    if j in good_positions and math.gcd(j + 1, perm[idx]) > 1:\n                        # j stays good, so we only reduce by 1\n                        perm[idx], perm[j] = perm[j], perm[idx]\n                        good_positions.remove(idx)\n                        removed += 1\n                        break\n                    elif j not in good_positions and math.gcd(j + 1, perm[idx]) == 1:\n                        # Both become bad, reducing by 1 (since idx was good, j was bad)\n                        perm[idx], perm[j] = perm[j], perm[idx]\n                        good_positions.remove(idx)\n                        removed += 1\n                        break\n        \n        if removed >= to_remove:\n            print(' '.join(map(str, perm)))\n            return\n        else:\n            print(-1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 96.83460116386414}
{"eval_index": 174, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 123.18163108825684}
{"eval_index": 175, "problem_id": 4516, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.48569440841675}
{"eval_index": 176, "problem_id": 1457, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    ai = data[0]\n    phone = data[1]\n    n = len(ai)\n    m = len(phone)\n    if m > n:\n        print(0)\n        return\n    \n    # Precompute prefix function for KMP\n    def compute_prefix(pattern):\n        lps = [0] * m\n        length = 0\n        i = 1\n        while i < m:\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n    \n    lps = compute_prefix(phone)\n    \n    # Find all occurrences using KMP\n    occurrences = []\n    i = j = 0\n    while i < n:\n        if ai[i] == phone[j]:\n            i += 1\n            j += 1\n        if j == m:\n            occurrences.append(i - j)\n            j = lps[j - 1]\n        elif i < n and ai[i] != phone[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    if not occurrences:\n        print(0)\n        return\n    \n    # Greedy interval covering\n    intervals = []\n    for start in occurrences:\n        intervals.append((start, start + m - 1))\n    \n    intervals.sort(key=lambda x: x[1])\n    count = 0\n    last_end = -1\n    for start, end in intervals:\n        if start > last_end:\n            count += 1\n            last_end = end\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.266125917434692}
{"eval_index": 177, "problem_id": 3820, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    s = data[2]\n    t = data[3]\n    \n    # Find position of '*' if it exists\n    star_pos = s.find('*')\n    \n    # Case 1: No wildcard\n    if star_pos == -1:\n        if s == t:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n        return\n    \n    # Case 2: With wildcard\n    # Check if m < n-1 (since '*' can be empty, but we need at least n-1 chars)\n    if m < n - 1:\n        print(\"NO\")\n        return\n    \n    # Split s into prefix and suffix around '*'\n    prefix = s[:star_pos]\n    suffix = s[star_pos+1:]\n    \n    # Check prefix matches\n    if t[:len(prefix)] != prefix:\n        print(\"NO\")\n        return\n    \n    # Check suffix matches\n    if t[m-len(suffix):] != suffix:\n        print(\"NO\")\n        return\n    \n    # Check that prefix and suffix don't overlap in t\n    if len(prefix) + len(suffix) > m:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.475304126739502}
{"eval_index": 178, "problem_id": 4104, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 177.97424340248108}
{"eval_index": 179, "problem_id": 1031, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.20684218406677}
{"eval_index": 180, "problem_id": 3199, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 161.1056878566742}
{"eval_index": 181, "problem_id": 4877, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, h = map(int, data)\n    \n    # If the worm doesn't slip (b == 0), it's just ceiling division\n    if b == 0:\n        # (h + a - 1) // a gives ceil(h/a)\n        print((h + a - 1) // a)\n        return\n    \n    # Effective progress per crawl: a - b\n    effective = a - b\n    \n    # The last crawl doesn't have a slip, so we need to reach at least h\n    # We need to find smallest n such that: (n-1)*(a-b) + a >= h\n    # Rearranged: n >= (h - a + (a-b) - 1) // (a-b) + 1\n    # Simplified: n >= (h - b - 1) // (a-b) + 1\n    \n    # Calculate using integer ceiling division\n    n = (h - b - 1) // (a - b) + 1\n    \n    # Ensure n is at least 1\n    if n < 1:\n        n = 1\n    \n    print(n)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.854126453399658}
{"eval_index": 182, "problem_id": 584, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    max_outside_len = 0\n    inside_count = 0\n    \n    i = 0\n    inside_parentheses = False\n    \n    while i < n:\n        if s[i] == '(':\n            inside_parentheses = True\n            i += 1\n            continue\n        elif s[i] == ')':\n            inside_parentheses = False\n            i += 1\n            continue\n        \n        # If we encounter a letter, it's the start of a word\n        if s[i].isalpha():\n            word_len = 0\n            start = i\n            while i < n and s[i].isalpha():\n                word_len += 1\n                i += 1\n            \n            if inside_parentheses:\n                inside_count += 1\n            else:\n                max_outside_len = max(max_outside_len, word_len)\n        else:\n            # Skip underscores\n            i += 1\n    \n    print(f\"{max_outside_len} {inside_count}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.85262370109558}
{"eval_index": 183, "problem_id": 3541, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    a = [int(next(it)) for _ in range(N)]\n    b = [int(next(it)) for _ in range(N)]\n    \n    # For each candy, compute the difference d_i = a_i - b_i\n    # We want to minimize |sum_{i in A} a_i - sum_{i in B} b_i|\n    # Let total_diff = sum_{i in A} d_i - sum_{i in B} d_i? Actually:\n    # Let S_A = sum_{i in A} a_i + sum_{i in B} b_i? Wait, careful.\n    # Actually, we can think of assigning each candy to Alf or Beata.\n    # If candy i goes to Alf, contribution to difference is a_i - b_i? Not exactly.\n    # Let's define: if candy i goes to Alf, contribution to Alf's sum is a_i, to Beata's sum is 0 for that candy.\n    # But we want to minimize |sum_{Alf} a_i - sum_{Beata} b_i|.\n    # Alternatively, let x_i = 1 if candy goes to Alf, 0 if to Beata.\n    # Then difference = sum_i (x_i * a_i - (1-x_i) * b_i) = sum_i (x_i*(a_i+b_i) - b_i)\n    # So difference = sum_i x_i*(a_i+b_i) - sum_i b_i.\n    # Let total_b = sum_i b_i, constant.\n    # We want to minimize |sum_i x_i*(a_i+b_i) - total_b|.\n    # Let c_i = a_i + b_i. Then we choose subset S of candies to give to Alf to minimize |sum_{i in S} c_i - total_b|.\n    # This is a subset sum problem with target total_b, but we want closest to total_b.\n    \n    total_b = sum(b)\n    c = [a[i] + b[i] for i in range(N)]\n    \n    # DP to find achievable sums of c_i for subsets\n    # Since N <= 100 and c_i in [-200, 200], sum range is [-20000, 20000]\n    # Shift index by 20000 to handle negative sums\n    OFFSET = 20000\n    max_sum = OFFSET * 2 + 1\n    dp = [False] * (max_sum + 1)\n    dp[OFFSET] = True  # sum 0\n    \n    # Also track the lexicographically smallest assignment for each sum\n    # For each achievable sum, store the assignment string so far\n    assignment = [\"\"] * (max_sum + 1)\n    assignment[OFFSET] = \"\"\n    \n    for i in range(N):\n        new_dp = [False] * (max_sum + 1)\n        new_assignment = [\"\"] * (max_sum + 1)\n        for s in range(max_sum + 1):\n            if dp[s]:\n                # Not taking candy i (give to Beata)\n                if not new_dp[s] or (new_assignment[s] > assignment[s] + \"B\"):\n                    new_dp[s] = True\n                    new_assignment[s] = assignment[s] + \"B\"\n                \n                # Taking candy i (give to Alf)\n                ns = s + c[i]\n                if 0 <= ns <= max_sum:\n                    if not new_dp[ns] or (new_assignment[ns] > assignment[s] + \"A\"):\n                        new_dp[ns] = True\n                        new_assignment[ns] = assignment[s] + \"A\"\n        dp, assignment = new_dp, new_assignment\n    \n    # Find the sum closest to total_b + OFFSET\n    target = total_b + OFFSET\n    best_diff = float('inf')\n    best_assignment = \"\"\n    for s in range(max_sum + 1):\n        if dp[s]:\n            diff = abs(s - target)\n            if diff < best_diff or (diff == best_diff and assignment[s] < best_assignment):\n                best_diff = diff\n                best_assignment = assignment[s]\n    \n    print(best_assignment)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 108.6553807258606}
{"eval_index": 184, "problem_id": 4701, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # DP approach: dp[i] = min value after i operations\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 1  # Start with value 1 before any operations\n    \n    for i in range(N):\n        # Operation A: double\n        dp[i + 1] = min(dp[i + 1], dp[i] * 2)\n        # Operation B: add K\n        dp[i + 1] = min(dp[i + 1], dp[i] + K)\n    \n    print(dp[N])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.087601661682129}
{"eval_index": 185, "problem_id": 1887, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    row1 = [int(next(it)) for _ in range(n)]\n    row2 = [int(next(it)) for _ in range(n)]\n    \n    # dp0: max sum ending at position i, last taken from row1\n    # dp1: max sum ending at position i, last taken from row2\n    dp0 = dp1 = 0\n    \n    for i in range(n):\n        new_dp0 = max(dp0, dp1 + row1[i])  # take from row1\n        new_dp1 = max(dp1, dp0 + row2[i])  # take from row2\n        dp0, dp1 = new_dp0, new_dp1\n    \n    print(max(dp0, dp1))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 42.35855054855347}
{"eval_index": 186, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 109.32711124420166}
{"eval_index": 187, "problem_id": 4380, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Check if there exists C in {1,2,3} such that A*B*C is odd\n    # A*B*C is odd iff all three numbers are odd\n    # Since C must be 1, 2, or 3, we just need to check if A and B are odd\n    # (because if either A or B is even, no odd C can make product odd)\n    # If both A and B are odd, we can choose C=1 (or any odd C)\n    \n    if A % 2 == 1 and B % 2 == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 50.029611587524414}
{"eval_index": 188, "problem_id": 2825, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef min_crossing_time(times):\n    \"\"\"Return minimum time to get all people across.\"\"\"\n    times.sort()\n    n = len(times)\n    total = 0\n    \n    # While more than 3 people remain at gate\n    while n > 3:\n        # Strategy 1: Two fastest shuttle\n        # A,B go, A returns, slowest two go, B returns\n        strategy1 = times[1] + times[0] + times[n-1] + times[1]\n        \n        # Strategy 2: Fastest shuttles slowest two\n        # A,slowest go, A returns, A,second-slowest go, A returns\n        strategy2 = times[n-1] + times[0] + times[n-2] + times[0]\n        \n        total += min(strategy1, strategy2)\n        n -= 2  # Two slowest crossed\n    \n    # Base cases\n    if n == 3:\n        total += times[0] + times[1] + times[2]\n    elif n == 2:\n        total += times[1]\n    else:  # n == 1\n        total += times[0]\n    \n    return total\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    times = list(map(int, data[1:1+n]))\n    \n    result = min_crossing_time(times)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 23.81891369819641}
{"eval_index": 189, "problem_id": 3150, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.10703587532043}
{"eval_index": 190, "problem_id": 4132, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # The minimum possible final health is the GCD of all health values\n    # This is because we can simulate attacks as GCD operations\n    g = arr[0]\n    for i in range(1, n):\n        g = math.gcd(g, arr[i])\n        if g == 1:\n            break\n    \n    print(g)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.610000610351562}
{"eval_index": 191, "problem_id": 2545, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        idx += 2\n        # Conditions for YES:\n        # 1. (a + b) must be divisible by 3\n        # 2. Neither a nor b can be more than twice the other\n        if (a + b) % 3 == 0 and max(a, b) <= 2 * min(a, b):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.805651426315308}
{"eval_index": 192, "problem_id": 3406, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.24810600280762}
{"eval_index": 193, "problem_id": 4555, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B, K = map(int, data)\n    \n    # Calculate total count of integers between A and B inclusive\n    total = B - A + 1\n    \n    # If K is larger than or equal to total, all numbers satisfy the condition\n    if K >= total:\n        result = list(range(A, B + 1))\n    else:\n        # Get the K smallest numbers\n        smallest = list(range(A, A + K))\n        # Get the K largest numbers\n        largest = list(range(B - K + 1, B + 1))\n        # Combine and remove duplicates while preserving order\n        combined = sorted(set(smallest + largest))\n        result = combined\n    \n    # Print each number on a separate line\n    for num in result:\n        print(num)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.383000135421753}
{"eval_index": 194, "problem_id": 2931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 177.86368107795715}
{"eval_index": 195, "problem_id": 3851, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 139.57798528671265}
{"eval_index": 196, "problem_id": 4235, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.5254476070404}
{"eval_index": 197, "problem_id": 659, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.93548917770386}
{"eval_index": 198, "problem_id": 3515, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input().strip())\n    cities = []\n    for i in range(N):\n        y, d, r = map(int, input().split())\n        cities.append((y, d, r, i))  # store original index\n    \n    # Sort cities by y-coordinate\n    cities.sort(key=lambda x: x[0])\n    \n    # Map from original index to sorted position\n    pos_in_sorted = [0] * N\n    for idx, (_, _, _, orig_idx) in enumerate(cities):\n        pos_in_sorted[orig_idx] = idx\n    \n    # Extract arrays for easier access\n    y_vals = [c[0] for c in cities]\n    d_vals = [c[1] for c in cities]\n    r_vals = [c[2] for c in cities]\n    orig_indices = [c[3] for c in cities]\n    \n    # Dijkstra's algorithm\n    INF = 10**18\n    dist = [INF] * N\n    start_pos = pos_in_sorted[0]  # city 1 in sorted order\n    dist[start_pos] = 0\n    \n    # Min-heap: (distance, city_position_in_sorted)\n    heap = [(0, start_pos)]\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n        \n        y_u = y_vals[u]\n        d_u = d_vals[u]\n        r_u = r_vals[u]\n        \n        # Find reachable cities to the left\n        # Need |y_u - y_v| >= d_u, so y_v <= y_u - d_u or y_v >= y_u + d_u\n        \n        # Left side: y_v <= y_u - d_u\n        left_bound = y_u - d_u\n        # Use binary search to find the rightmost city with y <= left_bound\n        lo, hi = 0, u\n        left_idx = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if y_vals[mid] <= left_bound:\n                left_idx = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        # Right side: y_v >= y_u + d_u\n        right_bound = y_u + d_u\n        lo, hi = u + 1, N - 1\n        right_idx = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if y_vals[mid] >= right_bound:\n                right_idx = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        # Process left reachable cities\n        if left_idx != -1:\n            # All cities from 0 to left_idx are reachable\n            for v in range(left_idx + 1):\n                new_dist = current_dist + r_u + abs(y_u - y_vals[v])\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heapq.heappush(heap, (new_dist, v))\n        \n        # Process right reachable cities\n        if right_idx != -1:\n            # All cities from right_idx to N-1 are reachable\n            for v in range(right_idx, N):\n                new_dist = current_dist + r_u + abs(y_u - y_vals[v])\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heapq.heappush(heap, (new_dist, v))\n    \n    # Prepare output in original order (excluding city 1)\n    result = []\n    for orig_idx in range(1, N):  # skip city 1\n        pos = pos_in_sorted[orig_idx]\n        if dist[pos] == INF:\n            result.append(-1)\n        else:\n            result.append(dist[pos])\n    \n    print('\\n'.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 46.579577922821045}
{"eval_index": 199, "problem_id": 4326, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.readline\n    N = int(input().strip())\n    # For N students, we want to maximize groups of size >= 3\n    # The optimal strategy is to make as many groups of 3 as possible,\n    # then adjust if remainder is 1 or 2.\n    # If remainder is 1, we can convert one group of 3 into 4 (3+1) to use all students.\n    # If remainder is 2, we can convert one group of 3 into 5 (3+2) to use all students.\n    # This yields the maximum number of groups >= 3.\n    groups_of_3 = N // 3\n    remainder = N % 3\n    if remainder == 0:\n        ans = groups_of_3\n    elif remainder == 1:\n        # Example: N=4 -> groups: 4 (one group)\n        # But with our formula: groups_of_3=1, remainder=1 -> ans=1\n        # Actually, we can have one group of 4, which is >=3, so ans=1.\n        # Check if groups_of_3 > 0 to adjust.\n        if groups_of_3 > 0:\n            # Convert one 3-group to 4-group, total groups remains same.\n            ans = groups_of_3\n        else:\n            # N=1,2,3? For N=1 or 2, no groups >=3 possible.\n            # But N=1 gives groups_of_3=0, remainder=1 -> ans=0\n            ans = 0\n    else:  # remainder == 2\n        if groups_of_3 > 0:\n            # Convert one 3-group to 5-group, total groups remains same.\n            ans = groups_of_3\n        else:\n            # N=2 -> no groups >=3\n            ans = 0\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 56.565815925598145}
{"eval_index": 200, "problem_id": 2089, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs(start, n, adj):\n    dist = [-1] * (n + 1)\n    q = deque([start])\n    dist[start] = 0\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    s = int(next(it))\n    t = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    road_set = set()\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n        road_set.add((min(u, v), max(u, v)))\n    \n    dist_s = bfs(s, n, adj)\n    dist_t = bfs(t, n, adj)\n    original_dist = dist_s[t]\n    \n    # Count pairs (u, v) where adding edge (u, v) does not decrease distance\n    count = 0\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if (u, v) in road_set:\n                continue\n            # Check if adding edge (u, v) would create a shorter path\n            # New possible distance via u-v: dist_s[u] + 1 + dist_t[v]\n            # or dist_s[v] + 1 + dist_t[u]\n            new_dist_via_uv = min(dist_s[u] + 1 + dist_t[v], dist_s[v] + 1 + dist_t[u])\n            if new_dist_via_uv >= original_dist:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.601242065429688}
{"eval_index": 201, "problem_id": 3684, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 102.1064920425415}
{"eval_index": 202, "problem_id": 4015, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data)\n    \n    if m % n != 0:\n        print(-1)\n        return\n    \n    quotient = m // n\n    moves = 0\n    \n    while quotient % 2 == 0:\n        quotient //= 2\n        moves += 1\n    \n    while quotient % 3 == 0:\n        quotient //= 3\n        moves += 1\n    \n    if quotient == 1:\n        print(moves)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.602869272232056}
{"eval_index": 203, "problem_id": 2964, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 55.43138337135315}
{"eval_index": 204, "problem_id": 3924, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    a = list(map(int, data[2:2+n]))\n    \n    bags = 0\n    carry = 0  # garbage carried over from previous day\n    \n    for i in range(n):\n        # Combine current day's garbage with carry from previous day\n        total = a[i] + carry\n        \n        # Calculate bags needed for today\n        bags_needed = total // k\n        remainder = total % k\n        \n        # If remainder > 0, we need one more bag for it\n        # But we might postpone some garbage to next day if it helps\n        if remainder > 0:\n            # If this is not the last day, we can postpone remainder to next day\n            # unless remainder is 0 (then no need for extra bag)\n            if i < n-1:\n                # Check if postponing helps: if remainder <= a[i], we can postpone\n                # But we need to ensure we don't leave garbage after last day\n                if remainder <= a[i]:\n                    # Postpone remainder to next day\n                    carry = remainder\n                    bags += bags_needed\n                else:\n                    # Can't postpone all remainder, need extra bag\n                    bags += bags_needed + 1\n                    carry = 0\n            else:\n                # Last day: must dispose all remainder\n                bags += bags_needed + 1\n                carry = 0\n        else:\n            # No remainder\n            bags += bags_needed\n            carry = 0\n    \n    print(bags)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 73.15462923049927}
{"eval_index": 205, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Helper function for BFS to mark visited land cells\n    def bfs(start_i, start_j):\n        from collections import deque\n        q = deque()\n        q.append((start_i, start_j))\n        visited[start_i][start_j] = True\n        while q:\n            i, j = q.popleft()\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < r and 0 <= nj < c and not visited[ni][nj] and grid[ni][nj] in ('L', 'C'):\n                    visited[ni][nj] = True\n                    q.append((ni, nj))\n    \n    visited = [[False] * c for _ in range(r)]\n    islands = 0\n    \n    # First, count islands from definite land cells\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'L' and not visited[i][j]:\n                islands += 1\n                bfs(i, j)\n    \n    # For clouds, we can treat them as water to minimize islands\n    # Since we already counted islands from 'L', remaining clouds can be water\n    # No additional islands needed from clouds\n    \n    print(islands)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 34.346954584121704}
{"eval_index": 206, "problem_id": 2595, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    out_lines = []\n    idx = 1\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1])\n        idx += 2\n        \n        if a == b:\n            out_lines.append('0')\n            continue\n        \n        # Check if b is reachable from a via multiplication/division by powers of 2\n        # Let's find the ratio and ensure it's a power of 2\n        if a > b:\n            # Need division: a must be divisible by b and the quotient must be power of 2\n            if a % b != 0:\n                out_lines.append('-1')\n                continue\n            q = a // b\n            # Check if q is power of 2 and <= 8 (since max division factor is 8)\n            # Actually we can divide multiple times, so q can be product of powers of 2 (2,4,8)\n            # i.e., q must be of form 2^k where k >= 0, and we can achieve it via sequence of divisions by 2,4,8\n            # Equivalent: q must have only factor 2 in its prime factorization\n            while q % 2 == 0:\n                q //= 2\n            if q != 1:\n                out_lines.append('-1')\n                continue\n            # Now compute minimal operations to reduce a to b via divisions by 2,4,8\n            # We need to express (a/b) as product of numbers from {2,4,8}\n            # Since each division reduces by factor 2,4, or 8, we want minimal number of such factors\n            # Greedy: use largest possible divisor each time\n            ops = 0\n            cur = a\n            while cur > b:\n                if cur % 8 == 0 and cur // 8 >= b:\n                    cur //= 8\n                elif cur % 4 == 0 and cur // 4 >= b:\n                    cur //= 4\n                elif cur % 2 == 0 and cur // 2 >= b:\n                    cur //= 2\n                else:\n                    # Should not happen if we checked above\n                    ops = -1\n                    break\n                ops += 1\n            out_lines.append(str(ops))\n        else:\n            # Need multiplication: b must be divisible by a and the quotient must be power of 2\n            if b % a != 0:\n                out_lines.append('-1')\n                continue\n            q = b // a\n            while q % 2 == 0:\n                q //= 2\n            if q != 1:\n                out_lines.append('-1')\n                continue\n            # Minimal operations to multiply a to b via factors 2,4,8\n            ops = 0\n            cur = a\n            while cur < b:\n                if cur * 8 <= b:\n                    cur *= 8\n                elif cur * 4 <= b:\n                    cur *= 4\n                elif cur * 2 <= b:\n                    cur *= 2\n                else:\n                    ops = -1\n                    break\n                ops += 1\n            out_lines.append(str(ops))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 42.17712044715881}
{"eval_index": 207, "problem_id": 3806, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.73965406417847}
{"eval_index": 208, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    X, A, B = map(int, sys.stdin.readline().split())\n    \n    # Days from best-by date to eating day\n    # Bought A days before best-by, ate B days after buying\n    # So ate (B - A) days after best-by date\n    days_after_best_by = B - A\n    \n    if days_after_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_after_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.29263162612915}
{"eval_index": 209, "problem_id": 254, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "TLE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.11545205116272}
{"eval_index": 210, "problem_id": 3754, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.36510252952576}
{"eval_index": 211, "problem_id": 4422, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    S = data[2]\n    \n    # Ensure K is within bounds (1-indexed)\n    if 1 <= K <= N:\n        # Convert K to 0-index for Python string indexing\n        idx = K - 1\n        # Create new string with K-th character lowercased\n        result = S[:idx] + S[idx].lower() + S[idx+1:]\n        print(result)\n    else:\n        # This case shouldn't happen per constraints, but handle gracefully\n        print(S)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.283315896987915}
{"eval_index": 212, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.66098237037659}
{"eval_index": 213, "problem_id": 3816, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.93809938430786}
{"eval_index": 214, "problem_id": 4597, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    \n    # Calculate factorial modulo MOD\n    result = 1\n    for i in range(1, N + 1):\n        result = (result * i) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.655384302139282}
{"eval_index": 215, "problem_id": 1542, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    prices = list(map(int, data[1:1+n]))\n    q = int(data[1+n])\n    queries = list(map(int, data[2+n:2+n+q]))\n    \n    # Sort prices to enable binary search\n    prices.sort()\n    \n    # Precompute answers using binary search for each query\n    results = []\n    for m in queries:\n        # Find the rightmost index where price <= m\n        count = bisect.bisect_right(prices, m)\n        results.append(str(count))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.3136568069458}
{"eval_index": 216, "problem_id": 3353, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    P = int(next(it))\n    R = int(next(it))\n    L = int(next(it))\n    \n    # Node mapping: left bank = 0, right bank = 1, boulders = 2 to R+1\n    n = R + 2\n    adj = [[] for _ in range(n)]\n    \n    for _ in range(L):\n        u = int(next(it))\n        v = int(next(it))\n        # Convert to internal indices\n        if u == -2:\n            u = 0\n        elif u == -1:\n            u = 1\n        else:\n            u = u + 2\n        if v == -2:\n            v = 0\n        elif v == -1:\n            v = 1\n        else:\n            v = v + 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # BFS to find shortest path from left to right\n    def bfs():\n        if 0 == 1:\n            return []  # left and right are same? shouldn't happen\n        dist = [-1] * n\n        parent = [-1] * n\n        q = deque([0])\n        dist[0] = 0\n        while q:\n            u = q.popleft()\n            if u == 1:\n                break\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    parent[v] = u\n                    q.append(v)\n        if dist[1] == -1:\n            return None\n        # Reconstruct path\n        path = []\n        cur = 1\n        while cur != 0:\n            prev = parent[cur]\n            path.append((prev, cur))\n            cur = prev\n        path.reverse()\n        return path\n    \n    total_time = 0\n    people_crossed = 0\n    \n    for person in range(P):\n        path = bfs()\n        if path is None:\n            # No path for this person\n            left_behind = P - people_crossed\n            print(f\"{left_behind} people left behind\")\n            return\n        # This person crosses, taking len(path) seconds\n        total_time += len(path)\n        people_crossed += 1\n        # Remove edges used in this path\n        for u, v in path:\n            adj[u].remove(v)\n            adj[v].remove(u)\n    \n    print(total_time)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 140.3591866493225}
{"eval_index": 217, "problem_id": 4633, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef digit_sum(x):\n    \"\"\"Return sum of digits of x.\"\"\"\n    return sum(int(d) for d in str(x))\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    out_lines = []\n    idx = 1\n    for _ in range(t):\n        n = int(data[idx])\n        s = int(data[idx + 1])\n        idx += 2\n        \n        # If current digit sum already <= s, no moves needed\n        if digit_sum(n) <= s:\n            out_lines.append('0')\n            continue\n        \n        # Find the smallest number >= n with digit sum <= s\n        # Strategy: increment n until digit sum condition is met\n        # But direct increment could be too slow for large n.\n        # Instead, find the next number where all digits after some position become 0\n        # and the digit at that position increases by 1 (carry).\n        # This reduces digit sum significantly.\n        \n        # Convert n to list of digits for easier manipulation\n        digits = list(map(int, str(n)))\n        length = len(digits)\n        \n        # Try to find the smallest k such that digit_sum(n + k) <= s\n        # We'll find the first position from the right where we can apply a carry\n        # to reduce the digit sum.\n        \n        # Start from the rightmost digit\n        for i in range(length - 1, -1, -1):\n            # Temporarily set digits from i to end to 0 and increase digit[i-1] by 1 if i>0\n            # or add a new leading digit if i==0.\n            temp_digits = digits.copy()\n            # Set current digit and all to the right to 0\n            for j in range(i, length):\n                temp_digits[j] = 0\n            # Increase the digit to the left by 1, if exists\n            if i > 0:\n                temp_digits[i-1] += 1\n                # Handle carry propagation if needed (though unlikely beyond one digit here)\n                # Since we're only increasing by 1, simple addition works.\n            else:\n                # i == 0, need to add a new leading digit 1\n                temp_digits = [1] + temp_digits\n            # Convert back to integer\n            new_n = int(''.join(map(str, temp_digits)))\n            if digit_sum(new_n) <= s:\n                # Found a candidate, compute moves needed\n                moves = new_n - n\n                out_lines.append(str(moves))\n                break\n        else:\n            # Should not happen given problem constraints, but fallback\n            # Increment n until condition met (very slow, but safe)\n            moves = 0\n            while digit_sum(n) > s:\n                n += 1\n                moves += 1\n            out_lines.append(str(moves))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 45.192962884902954}
{"eval_index": 218, "problem_id": 2488, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.readline\n    N, D, A = map(int, input().split())\n    monsters = []\n    for _ in range(N):\n        x, h = map(int, input().split())\n        monsters.append((x, h))\n    monsters.sort()\n    \n    X = [x for x, _ in monsters]\n    H = [h for _, h in monsters]\n    \n    ans = 0\n    damage = [0] * (N + 1)\n    cur_damage = 0\n    \n    for i in range(N):\n        cur_damage += damage[i]\n        remaining = H[i] - cur_damage * A\n        if remaining <= 0:\n            continue\n        bombs_needed = (remaining + A - 1) // A\n        ans += bombs_needed\n        cur_damage += bombs_needed\n        \n        # Find the rightmost monster affected by bombs at X[i] + D\n        left = i\n        right = N - 1\n        target = X[i] + 2 * D\n        while left <= right:\n            mid = (left + right) // 2\n            if X[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        end_idx = right\n        \n        if end_idx + 1 < N:\n            damage[end_idx + 1] -= bombs_needed\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.389840364456177}
{"eval_index": 219, "problem_id": 3489, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.63943409919739}
{"eval_index": 220, "problem_id": 4077, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.8575255870819}
{"eval_index": 221, "problem_id": 282, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    d = int(data[1])\n    s = data[2]\n    \n    # DP array: dp[i] = min jumps to reach position i (1-indexed)\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0  # start at position 1\n    \n    for i in range(1, n + 1):\n        if s[i-1] == '0' or dp[i] == float('inf'):\n            continue  # no lily here or unreachable\n        \n        # try all possible jumps from i\n        for jump in range(1, d + 1):\n            next_pos = i + jump\n            if next_pos > n:\n                break\n            if s[next_pos-1] == '1':  # lily exists at next position\n                dp[next_pos] = min(dp[next_pos], dp[i] + 1)\n    \n    result = dp[n]\n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.760770797729492}
{"eval_index": 222, "problem_id": 3697, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    m = int(next(it))\n    a = int(next(it))\n    votes = [0] * n\n    last_vote = [-1] * n\n    for idx in range(a):\n        cand = int(next(it)) - 1\n        votes[cand] += 1\n        last_vote[cand] = idx\n    remaining = m - a\n    result = [3] * n\n    # Determine guaranteed winners\n    if k == n:\n        for i in range(n):\n            if votes[i] > 0:\n                result[i] = 1\n    else:\n        # Sort candidates by votes descending, then last_vote ascending\n        cands = list(range(n))\n        cands.sort(key=lambda x: (-votes[x], last_vote[x]))\n        # Check each candidate for guarantee\n        for i in range(n):\n            cand = cands[i]\n            if votes[cand] == 0:\n                continue\n            # Simulate worst case: all remaining votes go to candidates after this one\n            worst_votes = votes.copy()\n            worst_last = last_vote.copy()\n            rem = remaining\n            # Distribute votes to candidates after current in ranking\n            for j in range(i + 1, n):\n                other = cands[j]\n                needed = votes[cand] - worst_votes[other] + 1\n                if worst_votes[other] == votes[cand]:\n                    if last_vote[cand] < worst_last[other]:\n                        needed = 1\n                    else:\n                        needed = 0\n                if needed <= 0:\n                    continue\n                give = min(rem, needed)\n                worst_votes[other] += give\n                worst_last[other] = m  # later than any existing vote\n                rem -= give\n                if rem == 0:\n                    break\n            # Re-sort with worst-case votes\n            worst_cands = list(range(n))\n            worst_cands.sort(key=lambda x: (-worst_votes[x], worst_last[x]))\n            # Check if candidate is still in top k\n            pos = worst_cands.index(cand)\n            if pos < k:\n                result[cand] = 1\n    # Determine candidates with chance\n    for i in range(n):\n        if result[i] == 1:\n            continue\n        # Try to make this candidate win\n        # Give all remaining votes to this candidate\n        test_votes = votes.copy()\n        test_last = last_vote.copy()\n        test_votes[i] += remaining\n        if remaining > 0:\n            test_last[i] = m  # later than any existing vote\n        # Sort candidates\n        test_cands = list(range(n))\n        test_cands.sort(key=lambda x: (-test_votes[x], test_last[x]))\n        pos = test_cands.index(i)\n        if pos < k and test_votes[i] > 0:\n            result[i] = 2\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 142.88805675506592}
{"eval_index": 223, "problem_id": 4480, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 16.24165964126587}
{"eval_index": 224, "problem_id": 2505, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.86704993247986}
{"eval_index": 225, "problem_id": 3244, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.78894305229187}
{"eval_index": 226, "problem_id": 4823, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read the input line\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    cards = line.split()\n    \n    # Extract ranks from the cards (first character of each string)\n    ranks = [card[0] for card in cards]\n    \n    # Count frequency of each rank\n    freq = {}\n    for rank in ranks:\n        freq[rank] = freq.get(rank, 0) + 1\n    \n    # The strength is the maximum frequency\n    strength = max(freq.values())\n    \n    # Output the result\n    print(strength)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.790125608444214}
{"eval_index": 227, "problem_id": 2095, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    matrix = []\n    idx = 1\n    for i in range(n):\n        row = list(map(int, data[idx:idx+n]))\n        matrix.append(row)\n        idx += n\n    \n    good_cars = []\n    for i in range(n):\n        is_good = True\n        for j in range(n):\n            if i == j:\n                continue\n            val = matrix[i][j]\n            if val == 1 or val == 3:\n                is_good = False\n                break\n        if is_good:\n            good_cars.append(i+1)\n    \n    print(len(good_cars))\n    if good_cars:\n        print(' '.join(map(str, good_cars)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.31013250350952}
{"eval_index": 228, "problem_id": 3927, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.39915919303894}
{"eval_index": 229, "problem_id": 4644, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        arr = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        # Count parity of elements\n        odd_count = sum(1 for x in arr if x % 2 == 1)\n        even_count = n - odd_count\n        \n        # Conditions for possible odd sum:\n        # 1. There must be at least one odd number\n        # 2. If n == 1, the single element must be odd\n        # 3. If n > 1 and all numbers are odd, n must be odd (sum of odd count odd numbers is odd)\n        # 4. If n > 1 and there are both odd and even numbers, always possible\n        \n        possible = False\n        if odd_count > 0:\n            if n == 1:\n                possible = (arr[0] % 2 == 1)\n            elif odd_count == n:\n                possible = (n % 2 == 1)\n            else:\n                possible = True\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.687066555023193}
{"eval_index": 230, "problem_id": 2495, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We need to ensure:\n    # 1. All prefix sums are non-zero\n    # 2. Consecutive prefix sums have opposite signs\n    \n    # We'll try two starting patterns:\n    # Pattern 1: prefix sums alternate starting with positive\n    # Pattern 2: prefix sums alternate starting with negative\n    \n    def min_operations_for_pattern(start_sign):\n        \"\"\"Calculate min operations for alternating prefix sums starting with given sign\"\"\"\n        operations = 0\n        current_sum = 0\n        \n        for i in range(n):\n            current_sum += a[i]\n            \n            # Determine what the current prefix sum should be\n            if i % 2 == 0:\n                # Even index (0-based) should have start_sign\n                target_sign = start_sign\n            else:\n                # Odd index should have opposite sign\n                target_sign = -start_sign\n            \n            # We need current_sum to have target_sign and be non-zero\n            if target_sign > 0:\n                # Should be positive\n                if current_sum <= 0:\n                    # Need to make it at least 1\n                    diff = 1 - current_sum\n                    operations += diff\n                    current_sum = 1\n            else:\n                # Should be negative\n                if current_sum >= 0:\n                    # Need to make it at most -1\n                    diff = current_sum - (-1)\n                    operations += diff\n                    current_sum = -1\n            \n            # Note: We don't need to adjust if already correct sign and non-zero\n            # because the conditions only care about sign, not magnitude\n        \n        return operations\n    \n    # Try both patterns and take minimum\n    ops1 = min_operations_for_pattern(1)   # Start with positive\n    ops2 = min_operations_for_pattern(-1)  # Start with negative\n    \n    print(min(ops1, ops2))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 90.63444805145264}
{"eval_index": 231, "problem_id": 3797, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.15898275375366}
{"eval_index": 232, "problem_id": 4731, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    words = data[1:1+n]\n    \n    seen = set()\n    \n    for i, word in enumerate(words):\n        # Check if word has been used before\n        if word in seen:\n            # Determine which player violated\n            # Player 1 goes first (index 0), so even indices are player 1\n            player = 1 if i % 2 == 0 else 2\n            print(f\"Player {player} lost\")\n            return\n        \n        # Check linking rule (except for first word)\n        if i > 0:\n            prev_word = words[i-1]\n            if word[0] != prev_word[-1]:\n                player = 1 if i % 2 == 0 else 2\n                print(f\"Player {player} lost\")\n                return\n        \n        seen.add(word)\n    \n    print(\"Fair Game\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.619749784469604}
{"eval_index": 233, "problem_id": 1687, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the minimum element\n    min_val = min(arr)\n    \n    # Check if all elements are divisible by min_val\n    for num in arr:\n        if num % min_val != 0:\n            print(-1)\n            return\n    \n    # Check if min_val exists in the array (it always does since we took min)\n    print(min_val)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.955432176589966}
{"eval_index": 234, "problem_id": 3572, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.82329487800598}
{"eval_index": 235, "problem_id": 4781, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 71.87215089797974}
{"eval_index": 236, "problem_id": 72, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.74092125892639}
{"eval_index": 237, "problem_id": 3277, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N, K, S = map(int, data[:3])\n    arr = list(map(int, data[3:3+N]))\n    \n    # For K-smoothness, the array must have a repeating pattern of length K\n    # So we need to decide what the pattern should be (length K)\n    # Then we can compute how many changes needed to match arr to that pattern\n    \n    # We'll try all possible patterns (each element between 0 and S)\n    # But that's too many: (S+1)^K possibilities\n    # Instead, note that for each position i in the pattern (0 <= i < K),\n    # the pattern value p[i] appears at positions i, i+K, i+2K, ... in the array\n    # So we can decide p[i] independently for each i\n    # For each i, we look at all positions j where j % K == i\n    # We want to choose p[i] to minimize the number of changes among those positions\n    # A change is needed if arr[j] != p[i]\n    # So for each i, we choose p[i] to be the value that appears most frequently\n    # among arr[i], arr[i+K], arr[i+2K], ... (within 0..S)\n    # But we must also ensure that sum(p) == S\n    # Because each window of K consecutive elements sums to S\n    # So we have an additional constraint: sum(p[0..K-1]) == S\n    \n    # Approach:\n    # 1. For each i in 0..K-1, collect values from positions i, i+K, i+2K, ...\n    # 2. For each i, we can compute the cost if we set p[i] = v for v in 0..S\n    #    cost[i][v] = number of positions where arr[pos] != v\n    # 3. We need to choose one value v_i for each i such that sum(v_i) == S\n    #    and minimize total cost = sum(cost[i][v_i])\n    # This is a knapsack-like DP:\n    # dp[i][sum] = minimum total cost for first i pattern indices (0..i-1)\n    #               achieving sum 'sum'\n    # dp[0][0] = 0\n    # dp[i+1][sum+v] = min(dp[i+1][sum+v], dp[i][sum] + cost[i][v]) for v in 0..S\n    # Answer is dp[K][S]\n    \n    # Build cost table\n    cost = [[0]*(S+1) for _ in range(K)]\n    for i in range(K):\n        # Count frequency of each value at positions i, i+K, ...\n        freq = [0]*(S+1)\n        cnt = 0\n        pos = i\n        while pos < N:\n            val = arr[pos]\n            freq[val] += 1\n            cnt += 1\n            pos += K\n        # For each possible v, cost = cnt - freq[v] (number of mismatches)\n        for v in range(S+1):\n            cost[i][v] = cnt - freq[v]\n    \n    # DP\n    INF = 10**9\n    dp = [[INF]*(S+1) for _ in range(K+1)]\n    dp[0][0] = 0\n    for i in range(K):\n        for s in range(S+1):\n            if dp[i][s] == INF:\n                continue\n            for v in range(S+1):\n                ns = s + v\n                if ns > S:\n                    break\n                new_cost = dp[i][s] + cost[i][v]\n                if new_cost < dp[i+1][ns]:\n                    dp[i+1][ns] = new_cost\n    \n    print(dp[K][S])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 135.98336124420166}
{"eval_index": 238, "problem_id": 4335, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    S = data[1]\n    \n    # Check if N is even\n    if N % 2 != 0:\n        print(\"No\")\n        return\n    \n    half = N // 2\n    # Compare first half with second half\n    if S[:half] == S[half:]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 11.857924699783325}
{"eval_index": 239, "problem_id": 1894, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.65455961227417}
{"eval_index": 240, "problem_id": 3833, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.52454495429993}
{"eval_index": 241, "problem_id": 4875, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel (a, e, i, o, u, or y).\"\"\"\n    return c in 'aeiouy'\n\ndef pig_latin_word(word):\n    \"\"\"Convert a single word to Pig Latin.\"\"\"\n    # Find index of first vowel\n    for i, ch in enumerate(word):\n        if is_vowel(ch):\n            break\n    \n    if i == 0:  # Word begins with vowel\n        return word + 'yay'\n    else:  # Word begins with consonant(s)\n        return word[i:] + word[:i] + 'ay'\n\ndef main():\n    \"\"\"Read input and output Pig Latin translation.\"\"\"\n    output_lines = []\n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            output_lines.append('')\n            continue\n        \n        words = line.split()\n        translated_words = [pig_latin_word(word) for word in words]\n        output_lines.append(' '.join(translated_words))\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 17.649840116500854}
{"eval_index": 242, "problem_id": 1650, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.71482014656067}
{"eval_index": 243, "problem_id": 3099, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 103.34234690666199}
{"eval_index": 244, "problem_id": 4049, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a1, a2, a3 = int(data[1]), int(data[2]), int(data[3])\n    b1, b2, b3 = int(data[4]), int(data[5]), int(data[6])\n    \n    # Maximum wins: Alice wins when her move beats Bob's move\n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n    \n    # Minimum wins: Consider worst-case arrangement\n    # Alice loses when Bob's move beats her move\n    # Draws don't count as wins\n    # We want to minimize Alice's wins, so we try to maximize her losses and draws\n    # But we must respect the counts a1,a2,a3 and b1,b2,b3\n    # Equivalent to: total rounds - (max possible non-wins for Alice)\n    # Non-wins = losses + draws\n    # We can compute max non-wins by pairing Alice's moves with Bob's moves that don't result in Alice winning\n    # That is: pair a1 with (b1 or b3), a2 with (b1 or b2), a3 with (b2 or b3)\n    # But we need to maximize these pairings subject to counts\n    # This is equivalent to: n - min(a1, b1+b3) - min(a2, b1+b2) - min(a3, b2+b3) ??? Not exactly\n    # Better approach: min_wins = max(0, a1 - b1 - b3, a2 - b1 - b2, a3 - b2 - b3) ??? Not correct\n    # Actually, we can compute min_wins by considering the complement:\n    # min_wins = max(0, a1 - b1 - b3, a2 - b1 - b2, a3 - b2 - b3) is wrong\n    # Correct formula from known solution: min_wins = n - min(a1, b2+b3) - min(a2, b1+b3) - min(a3, b1+b2)\n    # But wait, that gives non-wins, so wins = n - that\n    # Let's derive: total rounds n\n    # Non-wins for Alice = losses + draws\n    # Losses occur when: Alice rock vs Bob paper, Alice scissors vs Bob rock, Alice paper vs Bob scissors\n    # Draws occur when same moves\n    # So for Alice's a1 rocks: can pair with Bob's b2 (scissors, Alice wins) or b1 (rock, draw) or b3 (paper, Alice loses)\n    # To minimize wins, we want to avoid pairing a1 with b2 as much as possible\n    # So max non-wins from a1 = min(a1, b1 + b3)  # b1 for draws, b3 for losses\n    # Similarly for a2: avoid pairing with b3, so max non-wins = min(a2, b1 + b2)\n    # For a3: avoid pairing with b1, so max non-wins = min(a3, b2 + b3)\n    # Then total non-wins = min(a1, b1+b3) + min(a2, b1+b2) + min(a3, b2+b3)\n    # But this sum might exceed n, so we take min with n\n    # Then min_wins = n - min(n, min(a1, b1+b3) + min(a2, b1+b2) + min(a3, b2+b3))\n    # Actually since a1+a2+a3=n and b1+b2+b3=n, the sum won't exceed n? Let's check\n    # Example: n=2, a=(0,1,1), b=(1,1,0)\n    # min(a1,b1+b3)=min(0,1+0)=0\n    # min(a2,b1+b2)=min(1,1+1)=1\n    # min(a3,b2+b3)=min(1,1+0)=1\n    # Sum=2, n=2, so min_wins=2-2=0 correct\n    # Another: n=15, a=(5,5,5), b=(5,5,5)\n    # min(5,5+5)=5, min(5,5+5)=5, min(5,5+5)=5, sum=15, min_wins=0 correct\n    # Third: n=3, a=(0,0,3), b=(3,0,0)\n    # min(0,3+0)=0, min(0,3+0)=0, min(3,0+0)=0, sum=0, min_wins=3 correct\n    # So formula works\n    \n    non_wins = min(a1, b1 + b3) + min(a2, b1 + b2) + min(a3, b2 + b3)\n    min_wins = n - min(n, non_wins)  # min with n for safety\n    \n    print(f\"{min_wins} {max_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 58.91654825210571}
{"eval_index": 245, "problem_id": 569, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = data[1]\n    \n    # If n > 26, impossible because we have only 26 letters\n    # and we need distinct substrings of length 1\n    if n > 26:\n        print(-1)\n        return\n    \n    # Count frequency of each character\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    \n    # For each character that appears more than once,\n    # we need to change all but one occurrence\n    changes = 0\n    for count in freq:\n        if count > 1:\n            changes += count - 1\n    \n    print(changes)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.638641357421875}
{"eval_index": 246, "problem_id": 3782, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 97.38956451416016}
{"eval_index": 247, "problem_id": 4079, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def is_diverse(s):\n    # Convert each character to its position in alphabet (0-25)\n    positions = [ord(ch) - ord('a') for ch in s]\n    \n    # Check for duplicates using set length\n    if len(set(positions)) != len(positions):\n        return False\n    \n    # Check if positions form a contiguous segment\n    min_pos = min(positions)\n    max_pos = max(positions)\n    \n    # The range should be exactly (max_pos - min_pos + 1) and equal to length\n    expected_range = max_pos - min_pos + 1\n    return expected_range == len(positions)\n\nn = int(input().strip())\nfor _ in range(n):\n    s = input().strip()\n    if is_diverse(s):\n        print(\"Yes\")\n    else:\n        print(\"No\")", "complexity_estimate": null, "runtime_sec": 18.11228847503662}
{"eval_index": 248, "problem_id": 2738, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 123.92040157318115}
{"eval_index": 249, "problem_id": 3371, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.78279495239258}
{"eval_index": 250, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    \n    # Special case: 1 is the strongest, then 13, 12, ..., 2\n    # We can map cards to a strength value where higher is stronger\n    def strength(x):\n        # Map 1 to 13, 2 to 1, 3 to 2, ..., 13 to 12\n        if x == 1:\n            return 13\n        else:\n            return x - 1\n    \n    a_strength = strength(A)\n    b_strength = strength(B)\n    \n    if a_strength > b_strength:\n        print(\"Alice\")\n    elif a_strength < b_strength:\n        print(\"Bob\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.528332948684692}
{"eval_index": 251, "problem_id": 1823, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    a = list(map(int, data[2:2+n]))\n    \n    # Count stresses for each possible excluded genre\n    best_genre = 1\n    min_stresses = float('inf')\n    \n    for excluded in range(1, k+1):\n        stresses = 0\n        prev = -1  # previous genre watched (after filtering)\n        \n        for genre in a:\n            if genre == excluded:\n                continue  # skip this movie\n            if prev == -1:\n                prev = genre\n            elif genre != prev:\n                stresses += 1\n                prev = genre\n            # if genre == prev, no stress, keep same prev\n        \n        if stresses < min_stresses or (stresses == min_stresses and excluded < best_genre):\n            min_stresses = stresses\n            best_genre = excluded\n    \n    print(best_genre)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.539060831069946}
{"eval_index": 252, "problem_id": 3473, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.947491645813}
{"eval_index": 253, "problem_id": 4590, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    B = [int(next(it)) for _ in range(M)]\n    \n    # Prefix sums for both desks\n    prefix_a = [0] * (N + 1)\n    for i in range(N):\n        prefix_a[i + 1] = prefix_a[i] + A[i]\n    \n    prefix_b = [0] * (M + 1)\n    for i in range(M):\n        prefix_b[i + 1] = prefix_b[i] + B[i]\n    \n    # Try taking i books from desk A, then as many as possible from desk B\n    ans = 0\n    j = M  # pointer for desk B\n    for i in range(N + 1):\n        if prefix_a[i] > K:\n            break\n        # Reduce j while total time exceeds K\n        while j >= 0 and prefix_a[i] + prefix_b[j] > K:\n            j -= 1\n        ans = max(ans, i + j)\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.60958766937256}
{"eval_index": 254, "problem_id": 793, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 75.56865167617798}
{"eval_index": 255, "problem_id": 3198, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 49.20201921463013}
{"eval_index": 256, "problem_id": 4886, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 110.44482088088989}
{"eval_index": 257, "problem_id": 2724, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef manhattan_distance(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef can_pair_with_max_distance(students, tutors, max_dist):\n    \"\"\"Check if a perfect bipartite matching exists with all distances <= max_dist.\"\"\"\n    n = len(students)\n    # Build adjacency list: student i can be matched with tutor j if distance <= max_dist\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if manhattan_distance(students[i], tutors[j]) <= max_dist:\n                adj[i].append(j)\n    \n    # Hopcroft-Karp for bipartite matching\n    match_u = [-1] * n  # match for students\n    match_v = [-1] * n  # match for tutors\n    dist = [0] * n\n    \n    def bfs():\n        from collections import deque\n        q = deque()\n        for u in range(n):\n            if match_u[u] == -1:\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = float('inf')\n        found = False\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if match_v[v] == -1:\n                    found = True\n                elif dist[match_v[v]] == float('inf'):\n                    dist[match_v[v]] = dist[u] + 1\n                    q.append(match_v[v])\n        return found\n    \n    def dfs(u):\n        for v in adj[u]:\n            if match_v[v] == -1 or (dist[match_v[v]] == dist[u] + 1 and dfs(match_v[v])):\n                match_u[u] = v\n                match_v[v] = u\n                return True\n        dist[u] = float('inf')\n        return False\n    \n    matching = 0\n    while bfs():\n        for u in range(n):\n            if match_u[u] == -1 and dfs(u):\n                matching += 1\n    return matching == n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    students = [(int(next(it)), int(next(it))) for _ in range(n)]\n    tutors = [(int(next(it)), int(next(it))) for _ in range(n)]\n    \n    # Collect all possible distances\n    distances = set()\n    for s in students:\n        for t in tutors:\n            distances.add(manhattan_distance(s, t))\n    distances = sorted(distances)\n    \n    # Binary search on the answer\n    left, right = 0, len(distances) - 1\n    answer = distances[-1]  # worst-case maximum distance\n    while left <= right:\n        mid = (left + right) // 2\n        if can_pair_with_max_distance(students, tutors, distances[mid]):\n            answer = distances[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 38.49136805534363}
{"eval_index": 258, "problem_id": 3897, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 133.89323019981384}
{"eval_index": 259, "problem_id": 4617, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'def main():\\r\\n    # Read two lines of input\\r\\n    row1 = input().strip()\\r\\n    row2 = input().strip()\\r\\n    \\r\\n    # Check if the grid is symmetric under 180-degree rotation\\r\\n    # For a 2x3 grid, rotating 180 degrees means:\\r\\n    # (1,1)  (2,3), (1,2)  (2,2), (1,3)  (2,1)\\r\\n    if (row1[0] == row2[2] and\\r\\n        row1[1] == row2[1] and\\r\\n        row1[2] == row2[0]):\\r\\n        print(\"YES\")\\r\\n    else:\\r\\n        print(\"NO\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()', 233, 234, 'illegal multibyte sequence')", "runtime_sec": 14.600409030914307}
{"eval_index": 260, "problem_id": 2036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 63.47354245185852}
{"eval_index": 261, "problem_id": 3322, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    # For each antique, store (shop_original, price_original, shop_knockoff, price_knockoff)\n    antiques = []\n    for _ in range(n):\n        a = int(next(it)) - 1  # 0-indexed\n        p = int(next(it))\n        b = int(next(it)) - 1  # 0-indexed\n        q = int(next(it))\n        antiques.append((a, p, b, q))\n    \n    # DP state: dp[mask][shop_set] = min cost\n    # mask: bitmask of antiques collected (0..2^n-1)\n    # shop_set: bitmask of shops visited (0..2^m-1)\n    INF = 10**18\n    dp = [[INF] * (1 << m) for _ in range(1 << n)]\n    dp[0][0] = 0\n    \n    # Precompute for each antique and each shop, the minimum cost to get that antique if visiting that shop\n    # min_cost[antique][shop] = min price if antique can be bought at shop, else INF\n    min_cost = [[INF] * m for _ in range(n)]\n    for idx, (a, p, b, q) in enumerate(antiques):\n        min_cost[idx][a] = min(min_cost[idx][a], p)\n        min_cost[idx][b] = min(min_cost[idx][b], q)\n    \n    # Iterate over all subsets of antiques and shops\n    for mask in range(1 << n):\n        for shop_mask in range(1 << m):\n            if dp[mask][shop_mask] == INF:\n                continue\n            # Try to add a new shop\n            for new_shop in range(m):\n                if shop_mask & (1 << new_shop):\n                    continue\n                new_shop_mask = shop_mask | (1 << new_shop)\n                # For each antique not yet collected, if it can be bought at new_shop, consider buying it\n                new_mask = mask\n                added_cost = 0\n                for idx in range(n):\n                    if mask & (1 << idx):\n                        continue\n                    if min_cost[idx][new_shop] < INF:\n                        new_mask |= (1 << idx)\n                        added_cost += min_cost[idx][new_shop]\n                # Update DP\n                dp[new_mask][new_shop_mask] = min(dp[new_mask][new_shop_mask], dp[mask][shop_mask] + added_cost)\n            # Also consider not adding any new shop (base case propagation)\n            # This is already covered by the loop structure\n    \n    # Find answer: minimum cost among states with all antiques collected and at most k shops\n    full_mask = (1 << n) - 1\n    ans = INF\n    for shop_mask in range(1 << m):\n        if bin(shop_mask).count('1') <= k:\n            ans = min(ans, dp[full_mask][shop_mask])\n    \n    if ans == INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 58.70702791213989}
{"eval_index": 262, "problem_id": 4455, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    \n    skills = [int(next(it)) for _ in range(n)]\n    \n    # Count how many programmers have strictly lower skill for each skill value\n    from collections import Counter\n    skill_count = Counter(skills)\n    sorted_skills = sorted(skill_count.keys())\n    \n    # Prefix sum of counts for skills strictly less than current\n    prefix_sum = {}\n    total = 0\n    for skill in sorted_skills:\n        prefix_sum[skill] = total\n        total += skill_count[skill]\n    \n    # Initial answer: all programmers with strictly lower skill\n    answer = [prefix_sum[skill] for skill in skills]\n    \n    # Adjust for quarrels\n    quarrel_set = set()\n    for _ in range(k):\n        x = int(next(it)) - 1  # convert to 0-based\n        y = int(next(it)) - 1\n        quarrel_set.add((x, y))\n        \n        # If x has higher skill than y, x loses y as potential mentee\n        if skills[x] > skills[y]:\n            answer[x] -= 1\n        # If y has higher skill than x, y loses x as potential mentee\n        if skills[y] > skills[x]:\n            answer[y] -= 1\n    \n    # Output the result\n    print(' '.join(map(str, answer)))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.004001140594482}
{"eval_index": 263, "problem_id": 1322, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.6942527294159}
{"eval_index": 264, "problem_id": 3744, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.15496969223022}
{"eval_index": 265, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    if m < 1729:\n        return \"none\"\n    \n    # Dictionary to store count of ways for each sum\n    ways_count = {}\n    \n    # We only need to consider cubes up to cube root of m\n    max_i = int(m ** (1/3)) + 1\n    \n    # Generate all sums of two positive cubes\n    for i in range(1, max_i + 1):\n        i_cubed = i * i * i\n        if i_cubed > m:\n            break\n        \n        for j in range(i, max_i + 1):\n            j_cubed = j * j * j\n            sum_cubes = i_cubed + j_cubed\n            \n            if sum_cubes > m:\n                break\n            \n            # Count this representation\n            ways_count[sum_cubes] = ways_count.get(sum_cubes, 0) + 1\n    \n    # Find the largest number with at least 2 representations\n    largest_bus = 0\n    for num, count in ways_count.items():\n        if count >= 2 and num <= m and num > largest_bus:\n            largest_bus = num\n    \n    return str(largest_bus) if largest_bus > 0 else \"none\"\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m = int(data[0])\n    result = find_largest_bus_number(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.461254596710205}
{"eval_index": 266, "problem_id": 725, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Check all pixels starting from index 2\n    for i in range(2, len(data)):\n        pixel = data[i]\n        if pixel in {'C', 'M', 'Y'}:\n            print(\"#Color\")\n            return\n    \n    print(\"#Black&White\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.825789451599121}
{"eval_index": 267, "problem_id": 3636, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 145.0007004737854}
{"eval_index": 268, "problem_id": 4151, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\nMOD = 998244353\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    n = int(data[0])\\r\\n    a = list(map(int, data[1:1+n]))\\r\\n    \\r\\n    # Map each value to its first and last occurrence indices (1based)\\r\\n    first = {}\\r\\n    last = {}\\r\\n    for i, val in enumerate(a, 1):\\r\\n        if val not in first:\\r\\n            first[val] = i\\r\\n        last[val] = i\\r\\n    \\r\\n    # Merge intervals: sort by first occurrence\\r\\n    intervals = []\\r\\n    for val in first:\\r\\n        intervals.append((first[val], last[val]))\\r\\n    intervals.sort()\\r\\n    \\r\\n    # Merge overlapping intervals\\r\\n    merged = []\\r\\n    cur_l, cur_r = intervals[0]\\r\\n    for l, r in intervals[1:]:\\r\\n        if l <= cur_r:\\r\\n            cur_r = max(cur_r, r)\\r\\n        else:\\r\\n            merged.append((cur_l, cur_r))\\r\\n            cur_l, cur_r = l, r\\r\\n    merged.append((cur_l, cur_r))\\r\\n    \\r\\n    # Count segments\\r\\n    seg_count = len(merged)\\r\\n    # Each segment can be either same as previous or +1\\r\\n    # For the first segment, b starts at 0, so only one choice.\\r\\n    # For each additional segment, we have 2 choices.\\r\\n    ans = pow(2, seg_count - 1, MOD)\\r\\n    print(ans)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 255, 256, 'illegal multibyte sequence')", "runtime_sec": 26.273655891418457}
{"eval_index": 269, "problem_id": 1022, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 87.92489218711853}
{"eval_index": 270, "problem_id": 3316, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 81.24111366271973}
{"eval_index": 271, "problem_id": 4734, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if len(data) != 2:\n        return\n    Y, P = data[0], data[1]\n    \n    vowels = set('aeiou')\n    \n    if Y.endswith('ex'):\n        result = Y + P\n    elif Y[-1] == 'e':\n        result = Y + 'x' + P\n    elif Y[-1] in vowels:\n        result = Y[:-1] + 'ex' + P\n    else:\n        result = Y + 'ex' + P\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 13.76722526550293}
{"eval_index": 272, "problem_id": 962, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.94537138938904}
{"eval_index": 273, "problem_id": 3882, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.31295943260193}
{"eval_index": 274, "problem_id": 4107, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # dp[i] = min cost to cover first i rooms (1-indexed, i from 0 to n)\n    INF = 10**18\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        # Option 1: Connect room i directly\n        dp[i] = min(dp[i], dp[i - 1] + i)\n        \n        # Option 2: Place router at position i if possible\n        if s[i - 1] == '1':\n            left = max(1, i - k)\n            # The cost to cover up to left-1 rooms plus router cost i\n            prev = dp[left - 1] if left - 1 >= 0 else 0\n            # This router covers up to min(n, i + k)\n            cover_end = min(n, i + k)\n            # Update dp for all positions covered by this router\n            for j in range(left, cover_end + 1):\n                dp[j] = min(dp[j], prev + i)\n    \n    print(dp[n])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.079564094543457}
{"eval_index": 275, "problem_id": 1999, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Min-heap to track smallest value with at least 2 occurrences\n    heap = []\n    # Dictionary to store positions of each value\n    positions = {}\n    \n    # Initialize positions dictionary\n    for i, val in enumerate(arr):\n        if val not in positions:\n            positions[val] = []\n        positions[val].append(i)\n    \n    # Initialize heap with values that have at least 2 occurrences\n    for val, pos_list in positions.items():\n        if len(pos_list) >= 2:\n            heapq.heappush(heap, val)\n    \n    # Process operations\n    while heap:\n        x = heapq.heappop(heap)\n        # Check if x still has at least 2 occurrences (might have changed)\n        if x not in positions or len(positions[x]) < 2:\n            continue\n        \n        # Get the first two occurrences\n        pos1 = positions[x][0]\n        pos2 = positions[x][1]\n        \n        # Remove the left occurrence\n        arr[pos1] = None\n        # Replace right occurrence with 2*x\n        arr[pos2] = 2 * x\n        \n        # Update positions\n        # Remove pos1 from positions[x]\n        positions[x].pop(0)\n        # Remove pos2 from positions[x] (it's now 2*x)\n        positions[x].pop(0)\n        \n        # If positions[x] becomes empty, remove it\n        if not positions[x]:\n            del positions[x]\n        \n        # Add new value 2*x to positions\n        new_val = 2 * x\n        if new_val not in positions:\n            positions[new_val] = []\n        # Insert pos2 in sorted order\n        import bisect\n        bisect.insort(positions[new_val], pos2)\n        \n        # Check if new_val now has at least 2 occurrences\n        if len(positions[new_val]) >= 2:\n            heapq.heappush(heap, new_val)\n        \n        # Check if x still has at least 2 occurrences\n        if x in positions and len(positions[x]) >= 2:\n            heapq.heappush(heap, x)\n    \n    # Build final array\n    result = [val for val in arr if val is not None]\n    \n    # Output\n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.766995906829834}
{"eval_index": 276, "problem_id": 3502, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 175.94077849388123}
{"eval_index": 277, "problem_id": 4165, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    lengths = list(map(int, data[1:1+n]))\n    \n    max_length = max(lengths)\n    sum_others = sum(lengths) - max_length\n    \n    if max_length < sum_others:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.981876373291016}
{"eval_index": 278, "problem_id": 1437, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 10**9 + 7\n\n# Mapping from character to its base-64 value (0-63)\ndef char_to_val(c):\n    if '0' <= c <= '9':\n        return ord(c) - ord('0')\n    elif 'A' <= c <= 'Z':\n        return ord(c) - ord('A') + 10\n    elif 'a' <= c <= 'z':\n        return ord(c) - ord('a') + 36\n    elif c == '-':\n        return 62\n    else:  # c == '_'\n        return 63\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # For each character position, count how many pairs (a,b) of base-64 digits\n    # satisfy (a & b) == target_val\n    # Since positions are independent, multiply counts for all positions\n    \n    result = 1\n    for ch in s:\n        target = char_to_val(ch)\n        cnt = 0\n        # Try all possible pairs (a,b) where a,b in [0,63]\n        for a in range(64):\n            for b in range(64):\n                if (a & b) == target:\n                    cnt += 1\n        result = (result * cnt) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.05567979812622}
{"eval_index": 279, "problem_id": 3863, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\nMOD = 10**9 + 7\\r\\n\\r\\ndef mod_pow(a, b, mod):\\r\\n    \"\"\"Compute a^b mod mod using binary exponentiation.\"\"\"\\r\\n    result = 1\\r\\n    a %= mod\\r\\n    while b > 0:\\r\\n        if b & 1:\\r\\n            result = (result * a) % mod\\r\\n        a = (a * a) % mod\\r\\n        b >>= 1\\r\\n    return result\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    N = int(data[0])\\r\\n    K = int(data[1])\\r\\n    \\r\\n    # Case 1: N is odd\\r\\n    if N % 2 == 1:\\r\\n        # For odd N, all palindromes are distinct under rotation\\r\\n        # Number of palindromes: K^((N+1)//2)\\r\\n        result = mod_pow(K, (N + 1) // 2, MOD)\\r\\n    else:\\r\\n        # For even N, palindromes can be symmetric\\r\\n        # Count distinct under rotation using Burnside\\'s lemma\\r\\n        # For rotation by d positions, we need palindromes invariant under that rotation\\r\\n        # For even N, we consider divisors of N\\r\\n        # But N can be up to 1e9, so we need efficient counting\\r\\n        \\r\\n        # For even N, the number of distinct sequences after rotation\\r\\n        # equals number of necklaces of length N with K colors\\r\\n        # that are palindromic. This is given by:\\r\\n        # (K^(N/2) + K^(N/2 + 1)) / 2 for even N? Let\\'s derive properly.\\r\\n        \\r\\n        # Actually, for even N, we can think of constructing first half\\r\\n        # then mirroring. But rotations can make some equivalent.\\r\\n        # Using Burnside\\'s lemma for cyclic group of size N:\\r\\n        # For rotation by d, we need sequences where a[i] = a[(i+d) mod N]\\r\\n        # and also palindrome condition a[i] = a[N-1-i]\\r\\n        # This leads to constraints that depend on gcd(d, N)\\r\\n        \\r\\n        # However, there\\'s a known formula for number of distinct\\r\\n        # palindromic necklaces: (K^(N/2) + K^(N/2)) / 2\\r\\n        # But this needs adjustment for divisibility.\\r\\n        \\r\\n        # Let\\'s implement the known correct formula:\\r\\n        # For even N: result = (K^(N/2) + K^(N/2 + 1)) / 2\\r\\n        # Wait, check with sample: N=4, K=2\\r\\n        # K^(N/2) = 2^2 = 4\\r\\n        # K^(N/2 + 1) = 2^3 = 8\\r\\n        # (4+8)/2 = 6, which matches sample output.\\r\\n        \\r\\n        half = N // 2\\r\\n        term1 = mod_pow(K, half, MOD)\\r\\n        term2 = mod_pow(K, half + 1, MOD)\\r\\n        # Modular division by 2: multiply by inverse of 2 mod MOD\\r\\n        inv2 = (MOD + 1) // 2  # Since MOD is prime and 2\\'s inverse is (MOD+1)//2\\r\\n        result = (term1 + term2) % MOD\\r\\n        result = (result * inv2) % MOD\\r\\n    \\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 1761, 1762, 'illegal multibyte sequence')", "runtime_sec": 73.93729376792908}
{"eval_index": 280, "problem_id": 4569, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "S = input().strip()\nif S == \"Sunny\":\n    print(\"Cloudy\")\nelif S == \"Cloudy\":\n    print(\"Rainy\")\nelif S == \"Rainy\":\n    print(\"Sunny\")\nelse:\n    print(\"Invalid input\")", "complexity_estimate": null, "runtime_sec": 8.736375093460083}
{"eval_index": 281, "problem_id": 1428, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    it = iter(input)\n    N = int(next(it))\n    C = int(next(it))\n    \n    # Read D matrix\n    D = [[0] * (C + 1) for _ in range(C + 1)]\n    for i in range(1, C + 1):\n        for j in range(1, C + 1):\n            D[i][j] = int(next(it))\n    \n    # Read initial colors\n    init = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            init[i][j] = int(next(it))\n    \n    # Count how many cells of each initial color are in each modulo-3 group\n    # Groups: 0, 1, 2 for (i+j) % 3\n    cnt = [[0] * (C + 1) for _ in range(3)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            group = (i + j) % 3\n            color = init[i][j]\n            cnt[group][color] += 1\n    \n    # Precompute cost for each group to be painted with each final color\n    # cost[group][final_color] = sum over all initial colors of cnt[group][init_color] * D[init_color][final_color]\n    cost = [[0] * (C + 1) for _ in range(3)]\n    for g in range(3):\n        for fc in range(1, C + 1):\n            total = 0\n            for ic in range(1, C + 1):\n                total += cnt[g][ic] * D[ic][fc]\n            cost[g][fc] = total\n    \n    # Find minimum total cost where all three groups get different final colors\n    ans = float('inf')\n    for c1 in range(1, C + 1):\n        for c2 in range(1, C + 1):\n            if c1 == c2:\n                continue\n            for c3 in range(1, C + 1):\n                if c3 == c1 or c3 == c2:\n                    continue\n                total_cost = cost[0][c1] + cost[1][c2] + cost[2][c3]\n                if total_cost < ans:\n                    ans = total_cost\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 36.05576944351196}
{"eval_index": 282, "problem_id": 3317, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    s = data[0]\n    q = int(data[1])\n    queries = []\n    idx = 2\n    for _ in range(q):\n        i = int(data[idx])\n        j = int(data[idx+1])\n        queries.append((i, j))\n        idx += 2\n    \n    n = len(s)\n    # Precompute longest common prefix (LCP) using dynamic programming\n    # dp[i][j] = LCP starting at positions i and j\n    # Since n up to 100k, we cannot store full n x n matrix.\n    # Instead, we answer queries by direct comparison with early stop.\n    \n    results = []\n    for i, j in queries:\n        length = 0\n        pos_i, pos_j = i, j\n        while pos_i < n and pos_j < n and s[pos_i] == s[pos_j]:\n            length += 1\n            pos_i += 1\n            pos_j += 1\n        results.append(str(length))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 22.36514377593994}
{"eval_index": 283, "problem_id": 4247, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    count = 0\n    for i in range(1, n-1):\n        triple = [p[i-1], p[i], p[i+1]]\n        sorted_triple = sorted(triple)\n        if p[i] == sorted_triple[1]:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.614170789718628}
{"eval_index": 284, "problem_id": 552, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.84443426132202}
{"eval_index": 285, "problem_id": 3451, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.1918020248413}
{"eval_index": 286, "problem_id": 4428, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    left = 0\n    right = n - 1\n    sum1 = 0\n    sum3 = 0\n    best = 0\n    \n    while left <= right:\n        if sum1 < sum3:\n            sum1 += arr[left]\n            left += 1\n        elif sum1 > sum3:\n            sum3 += arr[right]\n            right -= 1\n        else:\n            best = sum1  # sum1 == sum3\n            if left < right:\n                sum1 += arr[left]\n                left += 1\n            else:\n                break\n        \n        if sum1 == sum3:\n            best = max(best, sum1)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.814088821411133}
{"eval_index": 287, "problem_id": 2325, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 128.76048350334167}
{"eval_index": 288, "problem_id": 3494, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.95378398895264}
{"eval_index": 289, "problem_id": 4916, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    \n    # positions[i] will store list of (x, y) positions for number i+1\n    positions = [[] for _ in range(k)]\n    \n    for i in range(n):\n        for j in range(n):\n            val = int(next(it))\n            if val <= k:\n                positions[val-1].append((i, j))\n    \n    # Check if any number from 1 to k has no tiles\n    for i in range(k):\n        if not positions[i]:\n            print(-1)\n            return\n    \n    # DP[i][j] = min distance to reach tile j of number i+1\n    # Initialize DP for number 1\n    dp_prev = [0] * len(positions[0])\n    \n    # Process numbers 2 to k\n    for num in range(1, k):\n        dp_curr = [math.inf] * len(positions[num])\n        for j_curr, (x_curr, y_curr) in enumerate(positions[num]):\n            for j_prev, (x_prev, y_prev) in enumerate(positions[num-1]):\n                dist = abs(x_curr - x_prev) + abs(y_curr - y_prev)\n                dp_curr[j_curr] = min(dp_curr[j_curr], dp_prev[j_prev] + dist)\n        dp_prev = dp_curr\n    \n    # Answer is min distance to reach any tile of number k\n    print(min(dp_prev))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 56.385523080825806}
{"eval_index": 290, "problem_id": 1842, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 51.47648787498474}
{"eval_index": 291, "problem_id": 3753, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 152.13637375831604}
{"eval_index": 292, "problem_id": 4847, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef triangle_area(x1, y1, x2, y2, x3, y3):\n    \"\"\"Calculate area of triangle using given formula\"\"\"\n    return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0\n\ndef point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    \"\"\"Check if point (px,py) is inside or on border of triangle\"\"\"\n    # Calculate area of main triangle\n    area_abc = triangle_area(x1, y1, x2, y2, x3, y3)\n    \n    # Calculate areas of three subtriangles formed with point\n    area_pbc = triangle_area(px, py, x2, y2, x3, y3)\n    area_apc = triangle_area(x1, y1, px, py, x3, y3)\n    area_abp = triangle_area(x1, y1, x2, y2, px, py)\n    \n    # Point is inside or on border if sum of subtriangle areas equals main area\n    # Use small epsilon for floating point comparison\n    return abs(area_abc - (area_pbc + area_apc + area_abp)) < 1e-9\n\ndef main():\n    # Read triangle vertices\n    x1, y1 = map(int, sys.stdin.readline().split())\n    x2, y2 = map(int, sys.stdin.readline().split())\n    x3, y3 = map(int, sys.stdin.readline().split())\n    \n    # Read number of trees\n    n = int(sys.stdin.readline().strip())\n    \n    # Calculate triangle area\n    area = triangle_area(x1, y1, x2, y2, x3, y3)\n    \n    # Count trees inside triangle\n    count = 0\n    for _ in range(n):\n        px, py = map(int, sys.stdin.readline().split())\n        if point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n            count += 1\n    \n    # Output results\n    print(f\"{area:.1f}\")\n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 28.899633646011353}
{"eval_index": 293, "problem_id": 2782, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 88.81582641601562}
{"eval_index": 294, "problem_id": 3949, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.61256337165833}
{"eval_index": 295, "problem_id": 4172, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.17158961296082}
{"eval_index": 296, "problem_id": 2108, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 132.88972544670105}
{"eval_index": 297, "problem_id": 3392, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 115.03164315223694}
{"eval_index": 298, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    it = iter(input_data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n        edges.append((x, y, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute shortest distances from all nodes\n    dist_from = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dist_from[i] = dijkstra(n, adj, i)\n    \n    # Compute original total cost\n    original_total = 0\n    for a, b in routes:\n        original_total += dist_from[a][b]\n    \n    # Try making each road zero cost\n    best_total = original_total\n    for x, y, w in edges:\n        # Temporarily set this edge weight to 0\n        # We'll compute the effect without modifying the graph\n        # For each route, new distance = min(original, dist[a][x] + dist[y][b], dist[a][y] + dist[x][b])\n        total = 0\n        for a, b in routes:\n            original = dist_from[a][b]\n            via_x_y = dist_from[a][x] + dist_from[y][b]\n            via_y_x = dist_from[a][y] + dist_from[x][b]\n            best_with_zero = min(original, via_x_y, via_y_x)\n            total += best_with_zero\n        best_total = min(best_total, total)\n    \n    print(best_total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 35.01088309288025}
{"eval_index": 299, "problem_id": 1473, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 80.76908159255981}
{"eval_index": 300, "problem_id": 3651, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 146.47297978401184}
{"eval_index": 301, "problem_id": 4339, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 77.15190720558167}
{"eval_index": 302, "problem_id": 2461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nsys.setrecursionlimit(300000)\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = [0] + list(map(int, sys.stdin.readline().split()))\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    ans = [0] * (n + 1)\n    \n    def dfs(u, parent, gcd_path, gcd_without_one):\n        # gcd_path: GCD along current path without any zero change\n        # gcd_without_one: GCD along path if we changed one ancestor to 0\n        \n        # Update gcd_path with current vertex\n        new_gcd_path = math.gcd(gcd_path, a[u])\n        \n        # For gcd_without_one, we have two possibilities:\n        # 1. We already changed some ancestor to 0, so we continue with current vertex\n        # 2. We change current vertex to 0, so we take gcd_path from parent\n        \n        # Initialize possibilities for this node\n        possibilities = []\n        \n        # If we haven't changed any vertex yet, we can change current to 0\n        if gcd_without_one == 0:\n            possibilities.append(gcd_path)  # Change current to 0\n        else:\n            possibilities.append(math.gcd(gcd_without_one, a[u]))  # Continue with previous change\n        \n        # Also consider changing current to 0 even if we already changed one\n        # (but we can only change one vertex total, so this is only valid if we haven't changed yet)\n        # Actually, we can only change one vertex, so if gcd_without_one != 0, we already used our change\n        \n        # The maximum beauty for this vertex is max of:\n        # 1. GCD along path without any change (new_gcd_path)\n        # 2. Best GCD if we changed one vertex to 0 (max of possibilities)\n        ans[u] = max(new_gcd_path, max(possibilities))\n        \n        # Prepare for children\n        # For children, we pass:\n        # 1. new_gcd_path (continuing without change)\n        # 2. The best gcd_without_one for children\n        #    Children can either inherit our current gcd_without_one (if we already changed)\n        #    OR if we haven't changed yet, they can either:\n        #       - Use our change (by taking gcd_path as their gcd_without_one)\n        #       - Or wait to change later\n        \n        # We need to track the best gcd_without_one we can pass to children\n        # It's the maximum of:\n        # 1. If we already changed an ancestor (gcd_without_one != 0), continue with it\n        # 2. If we haven't changed yet, children can either:\n        #    a) Use our change now (gcd_path)\n        #    b) Wait to change later (0 means no change yet)\n        \n        best_without = 0\n        if gcd_without_one != 0:\n            best_without = math.gcd(gcd_without_one, a[u])\n        else:\n            # We haven't changed yet, so children can either:\n            # 1. Take our gcd_path as if we changed current to 0\n            # 2. Continue with 0 (meaning no change yet)\n            best_without = max(gcd_path, 0)\n        \n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u, new_gcd_path, best_without)\n    \n    # Start DFS from root (vertex 1)\n    dfs(1, 0, 0, 0)\n    \n    # Output results\n    print(' '.join(str(ans[i]) for i in range(1, n + 1)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.742488384246826}
{"eval_index": 303, "problem_id": 3124, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.03803396224976}
{"eval_index": 304, "problem_id": 4456, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 159.75005102157593}
{"eval_index": 305, "problem_id": 1183, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); x = int(data[idx+1]); idx += 2\n        a = list(map(int, data[idx:idx+n])); idx += n\n        seen = set(a)\n        v = 1\n        while True:\n            if v not in seen:\n                if x == 0:\n                    break\n                x -= 1\n            v += 1\n        results.append(str(v-1))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.880219221115112}
{"eval_index": 306, "problem_id": 3591, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 94.39898300170898}
{"eval_index": 307, "problem_id": 4713, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    x = 0\n    max_x = 0\n    for ch in S:\n        if ch == 'I':\n            x += 1\n        else:  # ch == 'D'\n            x -= 1\n        max_x = max(max_x, x)\n    print(max_x)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 12.50495171546936}
{"eval_index": 308, "problem_id": 1323, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.7193911075592}
{"eval_index": 309, "problem_id": 3796, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 98.31249618530273}
{"eval_index": 310, "problem_id": 4513, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 53.74869966506958}
{"eval_index": 311, "problem_id": 2275, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        k = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        \n        max_time = 0\n        i = 0\n        while i < k:\n            if s[i] == 'A':\n                j = i + 1\n                while j < k and s[j] == 'P':\n                    j += 1\n                max_time = max(max_time, j - i - 1)\n                i = j\n            else:\n                i += 1\n        results.append(str(max_time))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 18.683950185775757}
{"eval_index": 312, "problem_id": 3529, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if xroot == yroot:\n        return False\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n    return True\n\ndef kruskal_with_color_constraint(n, edges, k):\n    # Sort edges: blue edges first, then red edges\n    edges.sort(key=lambda x: (0 if x[0] == 'B' else 1, x[1], x[2]))\n    \n    # First, try to include as many blue edges as possible\n    parent = list(range(n+1))\n    rank = [0]*(n+1)\n    blue_count = 0\n    mst_edges = []\n    \n    for color, u, v in edges:\n        if union(parent, rank, u, v):\n            mst_edges.append((color, u, v))\n            if color == 'B':\n                blue_count += 1\n    \n    # If we have less than k blue edges in the MST with max blues, impossible\n    if blue_count < k:\n        return 0\n    \n    # Now try to get exactly k blue edges\n    # Reset and try to include as few blue edges as possible\n    parent = list(range(n+1))\n    rank = [0]*(n+1)\n    blue_count = 0\n    mst_edges = []\n    \n    # Sort edges: red edges first, then blue edges\n    edges.sort(key=lambda x: (1 if x[0] == 'B' else 0, x[1], x[2]))\n    \n    for color, u, v in edges:\n        if union(parent, rank, u, v):\n            mst_edges.append((color, u, v))\n            if color == 'B':\n                blue_count += 1\n    \n    # If we have more than k blue edges in the MST with min blues, impossible\n    if blue_count > k:\n        return 0\n    \n    # k is between min_blues and max_blues, so possible\n    return 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    edges = []\n    for _ in range(m):\n        color = data[idx]; idx += 1\n        u = int(data[idx]); idx += 1\n        v = int(data[idx]); idx += 1\n        edges.append((color, u, v))\n    \n    result = kruskal_with_color_constraint(n, edges, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 34.32619261741638}
{"eval_index": 313, "problem_id": 4432, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        arr = list(map(int, input_data[idx:idx+n]))\n        idx += n\n        \n        # Find maximum length alternating subsequence sum\n        # We'll process each contiguous segment of same sign\n        total_sum = 0\n        i = 0\n        \n        while i < n:\n            # Find the maximum element in current segment of same sign\n            segment_max = arr[i]\n            j = i\n            while j < n and ((arr[i] > 0 and arr[j] > 0) or (arr[i] < 0 and arr[j] < 0)):\n                segment_max = max(segment_max, arr[j])\n                j += 1\n            \n            total_sum += segment_max\n            i = j  # Move to next segment with opposite sign\n        \n        results.append(str(total_sum))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.357174396514893}
{"eval_index": 314, "problem_id": 1066, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Count of odd numbers from 1 to n\n    odd_count = (n + 1) // 2\n    \n    if k <= odd_count:\n        # Position is in the odd part: 1, 3, 5, ...\n        # k-th odd number = 2*k - 1\n        result = 2 * k - 1\n    else:\n        # Position is in the even part: 2, 4, 6, ...\n        # Adjust k to be position within even part\n        pos_in_even = k - odd_count\n        # pos_in_even-th even number = 2 * pos_in_even\n        result = 2 * pos_in_even\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.466171979904175}
{"eval_index": 315, "problem_id": 3789, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.34251761436462}
{"eval_index": 316, "problem_id": 4298, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    D = int(data[1])\n    \n    # Greedy approach: place inspector at the leftmost uncovered tree + D\n    inspectors = 0\n    i = 1\n    while i <= N:\n        inspectors += 1\n        # Place inspector at position i + D (but not exceeding N)\n        pos = min(i + D, N)\n        # This inspector covers up to pos + D\n        i = pos + D + 1\n    print(inspectors)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.069483518600464}
{"eval_index": 317, "problem_id": 942, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.28539061546326}
{"eval_index": 318, "problem_id": 3536, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.49177026748657}
{"eval_index": 319, "problem_id": 4933, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def find_fourth_number(a, b, c):\n    # Sort the three numbers to handle any order\n    nums = sorted([a, b, c])\n    x, y, z = nums[0], nums[1], nums[2]\n    \n    # Check if the sorted numbers form an arithmetic progression\n    # There are two possibilities for the missing number:\n    # 1. It could be before x (making progression x-d, x, y, z)\n    # 2. It could be after z (making progression x, y, z, z+d)\n    # 3. It could be between x and y or between y and z\n    \n    # Calculate differences\n    d1 = y - x\n    d2 = z - y\n    \n    # Case 1: Missing number is before x (smallest)\n    if d1 == d2:\n        # Already an AP with 3 numbers, so missing could be before or after\n        # According to problem, output any valid number\n        return z + d1  # Return the number after z\n    \n    # Case 2: Missing number is between x and y\n    if d1 > d2:\n        # The larger gap is between x and y, so missing number is in between\n        return x + d2\n    \n    # Case 3: Missing number is between y and z\n    if d1 < d2:\n        # The larger gap is between y and z, so missing number is in between\n        return y + d1\n    \n    # Case 4: Missing number is after z\n    # This is covered by the first case when d1 == d2\n    \n    # Should never reach here given problem constraints\n    return None\n\n# Read input\nimport sys\ndef main():\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    a, b, c = map(int, line.split())\n    result = find_fourth_number(a, b, c)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 25.418155431747437}
{"eval_index": 320, "problem_id": 1072, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    table = data[2:2 + n]\n    \n    # dp[i] = True if column i is kept in the final table\n    # Initially, all columns are considered kept\n    kept = [True] * m\n    \n    # For each pair of consecutive rows, we need to ensure row[i] <= row[i+1]\n    # We'll process columns from left to right\n    for col in range(m):\n        # Check if keeping this column violates lexicographic order for any consecutive rows\n        # We need to compare rows pairwise with the current set of kept columns\n        valid = True\n        for row in range(n - 1):\n            # Compare row and row+1 up to current column\n            # We only care about columns that are kept so far\n            for c in range(col + 1):\n                if not kept[c]:\n                    continue\n                if table[row][c] < table[row + 1][c]:\n                    # Already in correct order for this column, no need to check further\n                    break\n                elif table[row][c] > table[row + 1][c]:\n                    # Violation found: we must remove this column\n                    valid = False\n                    break\n                # If equal, continue to next column\n            if not valid:\n                break\n        \n        if not valid:\n            kept[col] = False\n    \n    # Count removed columns\n    removed = sum(1 for k in kept if not k)\n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.51180076599121}
{"eval_index": 321, "problem_id": 3798, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef digit_sum_base_b(n, b):\n    \"\"\"Return sum of digits of n in base b.\"\"\"\n    total = 0\n    while n > 0:\n        total += n % b\n        n //= b\n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s = int(data[1])\n    \n    # Case 1: b > n\n    # When b > n, f(b,n) = n (since n < b)\n    if n == s:\n        # Smallest b is n+1 (since b > n and b >= 2)\n        # But need to check if n+1 >= 2\n        if n + 1 >= 2:\n            print(n + 1)\n            return\n    \n    # Case 2: b <= sqrt(n)\n    # Brute force for small b\n    for b in range(2, int(n**0.5) + 1):\n        if digit_sum_base_b(n, b) == s:\n            print(b)\n            return\n    \n    # Case 3: b > sqrt(n)\n    # When b > sqrt(n), n in base b has at most 2 digits\n    # n = p*b + q, where p = n//b, q = n%b, and p < b\n    # f(b,n) = p + q = s\n    # So we have: p + q = s and n = p*b + q\n    # => n = p*b + (s - p) = p*(b-1) + s\n    # => b = (n - s)/p + 1\n    # Since p = n//b and b > sqrt(n), we have p <= sqrt(n)\n    # Also p >= 1 (since b <= n for this case)\n    # And q = s - p must satisfy 0 <= q < b\n    \n    candidates = []\n    for p in range(1, int(n**0.5) + 1):\n        if (n - s) % p != 0:\n            continue\n        b = (n - s) // p + 1\n        if b < 2:\n            continue\n        # Verify conditions:\n        # 1. p = n//b\n        if n // b != p:\n            continue\n        # 2. q = n % b = s - p\n        q = n % b\n        if q != s - p:\n            continue\n        # 3. 0 <= q < b\n        if not (0 <= q < b):\n            continue\n        # 4. p < b (implied by b > sqrt(n) and p <= sqrt(n))\n        if p >= b:\n            continue\n        candidates.append(b)\n    \n    if candidates:\n        print(min(candidates))\n        return\n    \n    # No solution found\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 47.45440077781677}
{"eval_index": 322, "problem_id": 4462, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count numbers divisible by 4, divisible by 2 but not 4, and odd numbers\n    cnt4 = 0\n    cnt2 = 0\n    cnt_odd = 0\n    \n    for num in arr:\n        if num % 4 == 0:\n            cnt4 += 1\n        elif num % 2 == 0:\n            cnt2 += 1\n        else:\n            cnt_odd += 1\n    \n    # If there are numbers divisible by 2 but not 4, they must be placed together\n    # So we can treat them as a single block that doesn't need 4-multiples next to them\n    # except at the boundaries\n    \n    # After grouping all cnt2 numbers together, we have:\n    # - cnt_odd odd numbers\n    # - cnt4 numbers divisible by 4\n    # - 1 group of cnt2 numbers (if cnt2 > 0)\n    \n    # For the sequence to be valid, each odd number must be adjacent to a number divisible by 4\n    # (since odd * odd = odd, not multiple of 4; odd * even_not_div_by_4 = even but not multiple of 4)\n    \n    # The cnt2 group can be placed at the end or beginning, reducing the need for 4-multiples\n    \n    if cnt2 > 0:\n        # With cnt2 group, we need at least (cnt_odd) numbers divisible by 4\n        # because each odd needs a 4-multiple neighbor\n        if cnt4 >= cnt_odd:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        # Without cnt2 group, we need at least (cnt_odd - 1) numbers divisible by 4\n        # because we can arrange: 4, odd, 4, odd, ... with 4's at both ends\n        if cnt_odd == 0:\n            print(\"Yes\")\n        elif cnt4 >= cnt_odd - 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 100.09893012046814}
{"eval_index": 323, "problem_id": 2431, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.0761206150055}
{"eval_index": 324, "problem_id": 3419, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    s1 = int(data[1])\n    s2 = int(data[2])\n    t = list(map(int, data[3:3+n]))\n    \n    # DP table: dp[i][a] = maximum customers served using first i customers with s1 remaining time a\n    # s2 remaining time can be derived as we track total time used\n    # We'll use -1 to indicate unreachable state\n    dp = [[-1] * (s1 + 1) for _ in range(n + 1)]\n    dp[0][s1] = s2  # initial state: 0 customers processed, s1 full, s2 full\n    \n    for i in range(n):\n        for a in range(s1 + 1):\n            if dp[i][a] < 0:\n                continue\n            b = dp[i][a]\n            \n            # Option 1: assign customer i to counter 1\n            if a >= t[i]:\n                new_a = a - t[i]\n                if dp[i+1][new_a] < b:\n                    dp[i+1][new_a] = b\n            \n            # Option 2: assign customer i to counter 2\n            if b >= t[i]:\n                new_b = b - t[i]\n                if dp[i+1][a] < new_b:\n                    dp[i+1][a] = new_b\n            \n            # Option 3: skip customer i (and all subsequent)\n            # This is automatically handled by not updating dp[i+1] for this path\n    \n    # Find maximum i where any state is reachable\n    max_customers = 0\n    for i in range(n, -1, -1):\n        for a in range(s1 + 1):\n            if dp[i][a] >= 0:\n                max_customers = i\n                break\n        if max_customers == i:\n            break\n    \n    print(max_customers)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.47304606437683}
{"eval_index": 325, "problem_id": 4609, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    numbers = list(map(int, data[1:1+n]))\n    \n    # Use a set to track numbers currently on the sheet\n    sheet = set()\n    \n    for num in numbers:\n        if num in sheet:\n            sheet.remove(num)\n        else:\n            sheet.add(num)\n    \n    # The answer is the size of the set\n    print(len(sheet))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.508096694946289}
{"eval_index": 326, "problem_id": 384, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "n = int(input())\ns = input().strip()\n\nresult = []\ncount = 0\n\nfor i in range(n):\n    if s[i] == 'B':\n        count += 1\n    else:\n        if count > 0:\n            result.append(count)\n            count = 0\n\nif count > 0:\n    result.append(count)\n\nprint(len(result))\nif result:\n    print(' '.join(map(str, result)))", "complexity_estimate": null, "runtime_sec": 13.498796701431274}
{"eval_index": 327, "problem_id": 3240, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    k = int(data[0])\n    v = int(data[1])\n    \n    probs = []\n    ballots = []\n    idx = 2\n    for _ in range(v - 1):\n        p = float(data[idx])\n        b = int(data[idx + 1])\n        probs.append(p)\n        ballots.append(b)\n        idx += 2\n    \n    max_ballots = (1 << k) - 1\n    \n    # Precompute probability distribution of total ballots from other voters\n    # Use DP over bits to handle up to 2^k possible totals efficiently\n    total_states = 1 << k\n    prob_dist = [0.0] * total_states\n    prob_dist[0] = 1.0\n    \n    for p, b in zip(probs, ballots):\n        new_prob = [0.0] * total_states\n        for s in range(total_states):\n            if prob_dist[s] == 0:\n                continue\n            # voter doesn't vote\n            new_prob[s] += prob_dist[s] * (1 - p)\n            # voter votes with b ballots\n            new_s = (s + b) & (total_states - 1)  # modulo 2^k\n            new_prob[new_s] += prob_dist[s] * p\n        prob_dist = new_prob\n    \n    best_expected = -1.0\n    best_choice = 0\n    \n    # Try all possible ballots we can cast\n    for my_ballots in range(max_ballots + 1):\n        expected = 0.0\n        # For each possible state from other voters\n        for s in range(total_states):\n            if prob_dist[s] == 0:\n                continue\n            total = (s + my_ballots) & (total_states - 1)\n            # Count positions where Yraglac wins (bit = 1)\n            yraglac_wins = 0\n            for bit in range(k):\n                if (total >> bit) & 1:\n                    yraglac_wins += 1\n            expected += prob_dist[s] * yraglac_wins\n        \n        if expected > best_expected:\n            best_expected = expected\n            best_choice = my_ballots\n    \n    print(best_choice)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 71.37665128707886}
{"eval_index": 328, "problem_id": 4025, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    \n    # Weekly consumption pattern\n    # Days: Mon Tue Wed Thu Fri Sat Sun\n    # Fish: Mon, Thu, Sun -> 3 per week\n    # Rabbit: Tue, Sat -> 2 per week\n    # Chicken: Wed, Fri -> 2 per week\n    \n    # Calculate full weeks we can feed\n    weeks_fish = a // 3\n    weeks_rabbit = b // 2\n    weeks_chicken = c // 2\n    full_weeks = min(weeks_fish, weeks_rabbit, weeks_chicken)\n    \n    # Remaining food after full weeks\n    rem_a = a - full_weeks * 3\n    rem_b = b - full_weeks * 2\n    rem_c = c - full_weeks * 2\n    \n    # Try all 7 possible starting days\n    max_days = full_weeks * 7\n    \n    # Weekly pattern for each food type starting from each day\n    # Represent as 7-day cycles\n    patterns = [\n        [1, 0, 0, 1, 0, 0, 1],  # Fish: days 0,3,6\n        [0, 1, 0, 0, 0, 1, 0],  # Rabbit: days 1,5\n        [0, 0, 1, 0, 1, 0, 0]   # Chicken: days 2,4\n    ]\n    \n    best_extra = 0\n    for start in range(7):\n        cur_a, cur_b, cur_c = rem_a, rem_b, rem_c\n        extra_days = 0\n        \n        # Check days after full weeks\n        for offset in range(7):\n            day = (start + offset) % 7\n            if patterns[0][day]:\n                if cur_a <= 0:\n                    break\n                cur_a -= 1\n            elif patterns[1][day]:\n                if cur_b <= 0:\n                    break\n                cur_b -= 1\n            else:  # patterns[2][day]\n                if cur_c <= 0:\n                    break\n                cur_c -= 1\n            extra_days += 1\n        \n        best_extra = max(best_extra, extra_days)\n    \n    result = max_days + best_extra\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.67256307601929}
{"eval_index": 329, "problem_id": 1288, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    a = list(map(int, data[2:2+n]))\n    \n    # Binary search on the answer\n    def can_achieve(limit):\n        # Try to pick subsequence of size k where both odd and even max <= limit\n        # Greedy: pick elements alternately for odd/even positions\n        # Strategy 1: start with odd position\n        cnt = 0\n        i = 0\n        while i < n:\n            if a[i] <= limit:\n                cnt += 1\n                i += 1  # move to next element for even position\n                if i < n:\n                    cnt += 1  # we can take any element for even position\n                    i += 1\n                else:\n                    break\n            else:\n                i += 1\n        if cnt >= k:\n            return True\n        \n        # Strategy 2: start with even position (skip first element)\n        cnt = 1  # we skip first, so count 1 for even position implicitly\n        i = 1\n        while i < n:\n            if a[i] <= limit:\n                cnt += 1\n                i += 1  # move to next for odd position\n                if i < n:\n                    cnt += 1  # take any for odd position\n                    i += 1\n                else:\n                    break\n            else:\n                i += 1\n        return cnt >= k\n    \n    lo, hi = 1, 10**9\n    ans = hi\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if can_achieve(mid):\n            ans = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.120540380477905}
{"eval_index": 330, "problem_id": 3944, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.75648498535156}
{"eval_index": 331, "problem_id": 4719, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print()\n        return\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    # Count frequency of each character in each string\n    freq_list = []\n    for s in strings:\n        freq = [0]*26\n        for ch in s:\n            freq[ord(ch)-97] += 1\n        freq_list.append(freq)\n    \n    # For each character, find the minimum count across all strings\n    min_freq = [0]*26\n    for i in range(26):\n        min_val = float('inf')\n        for f in freq_list:\n            min_val = min(min_val, f[i])\n        min_freq[i] = min_val\n    \n    # Build the result string\n    result_chars = []\n    for i in range(26):\n        ch = chr(97 + i)\n        result_chars.append(ch * min_freq[i])\n    \n    result = ''.join(result_chars)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.38147521018982}
{"eval_index": 332, "problem_id": 1471, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 58.58486843109131}
{"eval_index": 333, "problem_id": 3634, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 127.5465190410614}
{"eval_index": 334, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    P, Q, R = map(int, input().split())\n    # The route consists of exactly two flights between three airports\n    # All possible sums of two distinct flight times\n    sums = [P + Q, Q + R, R + P]\n    print(min(sums))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.02748703956604}
{"eval_index": 335, "problem_id": 2840, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 84.63014602661133}
{"eval_index": 336, "problem_id": 3540, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 91.93409609794617}
{"eval_index": 337, "problem_id": 4629, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_good_number(x):\n    \"\"\"Check if x can be represented as sum of distinct powers of 3.\"\"\"\n    while x > 0:\n        if x % 3 == 2:\n            return False\n        x //= 3\n    return True\n\ndef next_good_number(n):\n    \"\"\"Find smallest good number >= n.\"\"\"\n    while True:\n        if is_good_number(n):\n            return n\n        n += 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    results = []\n    for i in range(1, q + 1):\n        n = int(data[i])\n        results.append(str(next_good_number(n)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.12609100341797}
{"eval_index": 338, "problem_id": 2831, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 107.64420437812805}
{"eval_index": 339, "problem_id": 3215, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef min_shuffles(n, permutation):\n    \"\"\"\n    Returns the minimum number of riffle shuffles needed to achieve the given permutation.\n    The approach is based on analyzing the permutation as a sequence of rising sequences.\n    \"\"\"\n    # Convert permutation to 0-based indexing for easier calculations\n    pos = [0] * n\n    for i, val in enumerate(permutation):\n        pos[val - 1] = i\n    \n    # Count the number of rising sequences\n    rising_sequences = 1\n    for i in range(1, n):\n        if pos[i] < pos[i - 1]:\n            rising_sequences += 1\n    \n    # The minimum number of shuffles is ceil(log2(rising_sequences))\n    # We compute this by finding the smallest k such that 2^k >= rising_sequences\n    k = 0\n    while (1 << k) < rising_sequences:\n        k += 1\n    return k\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    permutation = list(map(int, data[1:1+n]))\n    result = min_shuffles(n, permutation)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 40.23748540878296}
{"eval_index": 340, "problem_id": 4477, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    idx = 1\n    for _ in range(t):\n        x = data[idx]\n        idx += 1\n        digit = int(x[0])\n        length = len(x)\n        # Calculate total keypresses\n        total = 0\n        # For each digit from 1 to (digit-1), add presses for lengths 1 to 4\n        for d in range(1, digit):\n            total += 10  # 1+2+3+4 = 10 for each previous digit\n        # For the current digit, add presses for lengths 1 to (length-1)\n        for l in range(1, length):\n            total += l\n        # Add presses for the current apartment itself\n        total += length\n        results.append(str(total))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.704373359680176}
{"eval_index": 341, "problem_id": 1625, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 79.39057302474976}
{"eval_index": 342, "problem_id": 3748, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 106.0578339099884}
{"eval_index": 343, "problem_id": 4988, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef last_digit_factorial(n):\n    \"\"\"Return last digit of n!\"\"\"\n    if n == 0:\n        return 1  # 0! = 1\n    # For n <= 10, we can compute directly\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % 10  # Keep only last digit\n    return result\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    outputs = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        outputs.append(str(last_digit_factorial(n)))\n    sys.stdout.write('\\n'.join(outputs))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 29.366279125213623}
{"eval_index": 344, "problem_id": 67, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    x, y, z = map(int, data)\n    \n    # Determine the range of possible upvotes\n    min_up = x\n    max_up = x + z\n    \n    # Determine the range of possible downvotes\n    min_down = y\n    max_down = y + z\n    \n    # Check if result is certain\n    # For '+' to be certain: min_up > max_down\n    # For '-' to be certain: min_down > max_up\n    # For '0' to be certain: min_up == max_up == min_down == max_down\n    \n    if min_up > max_down:\n        print('+')\n    elif min_down > max_up:\n        print('-')\n    elif min_up == max_up and min_down == max_down and min_up == min_down:\n        print('0')\n    else:\n        print('?')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.603670358657837}
{"eval_index": 345, "problem_id": 3486, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.53490853309631}
{"eval_index": 346, "problem_id": 4830, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    words = data[1:1+n]\n    s = data[1+n]\n    \n    # T9 mapping\n    key_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    count = 0\n    for word in words:\n        if len(word) != len(s):\n            continue\n        \n        valid = True\n        for i, ch in enumerate(word):\n            key = s[i]\n            if ch not in key_map[key]:\n                valid = False\n                break\n        \n        if valid:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 38.38970327377319}
{"eval_index": 347, "problem_id": 1446, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 170.67886185646057}
{"eval_index": 348, "problem_id": 3331, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 160.3657500743866}
{"eval_index": 349, "problem_id": 4985, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 50.645726919174194}
{"eval_index": 350, "problem_id": 2838, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport itertools\n\n# Read input\nexpr = sys.stdin.readline().strip()\n\n# Step 1: Find all bracket pairs\nstack = []\npairs = []  # each pair is (open_index, close_index)\nfor i, ch in enumerate(expr):\n    if ch == '(':\n        stack.append(i)\n    elif ch == ')':\n        open_idx = stack.pop()\n        pairs.append((open_idx, i))\n\n# Step 2: Generate all subsets of bracket pairs to remove\nn = len(pairs)\nresults = set()\n# We must remove at least one pair, and at most all pairs\nfor mask in range(1, 1 << n):  # from 1 to 2^n - 1\n    # Build new expression by removing selected brackets\n    new_expr_chars = list(expr)\n    for i in range(n):\n        if mask & (1 << i):\n            open_idx, close_idx = pairs[i]\n            new_expr_chars[open_idx] = ''\n            new_expr_chars[close_idx] = ''\n    new_expr = ''.join(new_expr_chars)\n    results.add(new_expr)\n\n# Step 3: Sort lexicographically and output\nfor res in sorted(results):\n    print(res)", "complexity_estimate": null, "runtime_sec": 44.68300008773804}
{"eval_index": 351, "problem_id": 3756, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 108.59989619255066}
{"eval_index": 352, "problem_id": 4582, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    a, b = sys.stdin.read().strip().split()\n    # Truth table analysis:\n    # If a='H' (AtCoDeer honest):\n    #   - If b='H': TopCoDeer honest (truth)\n    #   - If b='D': TopCoDeer dishonest (truth)\n    # If a='D' (AtCoDeer dishonest):\n    #   - If b='H': TopCoDeer dishonest (lie about honesty)\n    #   - If b='D': TopCoDeer honest (lie about dishonesty)\n    if a == 'H':\n        print(b)  # Honest tells truth\n    else:\n        # Dishonest lies, so invert b's claim\n        print('H' if b == 'D' else 'D')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.961249351501465}
{"eval_index": 353, "problem_id": 2084, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    n = int(data[0])\\r\\n    k = int(data[1])\\r\\n    a = list(map(int, data[2:2+n]))\\r\\n    \\r\\n    # Sort the array in non-decreasing order\\r\\n    a.sort()\\r\\n    \\r\\n    # We need to choose k elements such that the sum of differences\\r\\n    # between consecutive chosen elements is minimized.\\r\\n    # This is equivalent to selecting k elements with minimal \"gap cost\".\\r\\n    # We can think of it as: we want to minimize the total \"spread\" of selected elements.\\r\\n    # Since we can choose any k elements, the optimal strategy is to pick\\r\\n    # k consecutive elements in the sorted array to minimize the sum of differences.\\r\\n    \\r\\n    # Compute prefix sums for efficient calculation of sum of differences\\r\\n    # For a window of size k, the sum of differences between consecutive elements\\r\\n    # can be computed as: (a[i+k-1] - a[i]) + (a[i+k-2] - a[i]) + ... ?\\r\\n    # Actually, for a sorted array, the sum of differences between consecutive elements\\r\\n    # in a window [l, r] is simply a[r] - a[l] for each pair? Let\\'s derive:\\r\\n    # For window indices i, i+1, ..., i+k-1:\\r\\n    # Sum of differences = (a[i+1]-a[i]) + (a[i+2]-a[i+1]) + ... + (a[i+k-1]-a[i+k-2])\\r\\n    # This telescopes to a[i+k-1] - a[i]\\r\\n    # Wait, that\\'s just the difference between first and last! That seems too simple.\\r\\n    # Let\\'s test with example: a=[1,2,3,4], k=3, window [1,2,3]:\\r\\n    # Differences: (2-1)+(3-2) = 1+1=2, and a[2]-a[0]=3-1=2. Yes!\\r\\n    # So for any window of k consecutive elements in sorted array,\\r\\n    # the sum of differences between consecutive elements is simply\\r\\n    # a[i+k-1] - a[i]\\r\\n    \\r\\n    # But the problem asks for \"output one number\" - what number?\\r\\n    # From examples: \\r\\n    # Example 1: n=8,k=5, all ones, output=5. If we take window of 5 ones,\\r\\n    # sum of differences=0, but output is 5. So not that.\\r\\n    # Example 2: n=10,k=3, output=7. Let\\'s check sorted array:\\r\\n    # Sorted: [1,2,4,8,16,32,64,128,256,512]\\r\\n    # Try window [1,2,4]: differences sum=1+2=3, not 7.\\r\\n    # Try window [2,4,8]: differences sum=2+4=6, not 7.\\r\\n    # Try window [4,8,16]: differences sum=4+8=12, not 7.\\r\\n    # So my assumption is wrong.\\r\\n    \\r\\n    # Let\\'s re-examine examples more carefully:\\r\\n    # Example 1: all ones, k=5, output=5. This suggests output might be\\r\\n    # the sum of the k chosen elements? But if we choose any 5 ones, sum=5.\\r\\n    # Example 4: all sixes, k=6, output=36 = 6*6, which is sum of all elements.\\r\\n    # Example 5: single element 100, output=100.\\r\\n    # Example 3: n=5,k=1, output=10. Sorted: [10,20,30,46,50]\\r\\n    # If we choose k=1 element, we choose the smallest? 10 gives output 10.\\r\\n    # So output seems to be the minimum possible sum of k chosen elements?\\r\\n    \\r\\n    # But wait, example 2: sorted array [1,2,4,8,16,32,64,128,256,512], k=3\\r\\n    # If we choose smallest 3: 1+2+4=7, which matches output 7!\\r\\n    # So indeed, output = minimum possible sum of k elements.\\r\\n    \\r\\n    # But is that always true? Let\\'s think: we can choose any k elements.\\r\\n    # To minimize sum, we choose the k smallest elements.\\r\\n    # So answer = sum of k smallest elements.\\r\\n    \\r\\n    # Verify with example 1: k smallest = 5 ones, sum=5 \\r\\n    # Example 3: k=1, smallest=10, sum=10 \\r\\n    # Example 4: k=6, smallest 6 elements are all sixes, sum=36 \\r\\n    # Example 5: k=1, only element 100, sum=100 \\r\\n    \\r\\n    # Therefore solution is straightforward:\\r\\n    a.sort()\\r\\n    result = sum(a[:k])\\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 3232, 3233, 'illegal multibyte sequence')", "runtime_sec": 77.845543384552}
{"eval_index": 354, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.98519587516785}
{"eval_index": 355, "problem_id": 4946, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Dictionary to store last occurrence index for each language\n    last_pos = {}\n    min_distance = n  # Initialize with n (max possible)\n    \n    for i, lang in enumerate(arr):\n        if lang in last_pos:\n            distance = i - last_pos[lang]\n            if distance < min_distance:\n                min_distance = distance\n        last_pos[lang] = i\n    \n    print(min_distance)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.442281007766724}
{"eval_index": 356, "problem_id": 1238, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    a.sort()\n    \n    # The original sequence was consecutive integers starting from some x\n    # The remaining indices are a subset of that sequence\n    # Minimum stolen = (max_remaining - min_remaining + 1) - n\n    # This counts missing numbers in the range [min_remaining, max_remaining]\n    min_val = a[0]\n    max_val = a[-1]\n    total_in_range = max_val - min_val + 1\n    missing_in_range = total_in_range - n\n    \n    # But we need to consider that the original sequence could extend beyond\n    # the range of remaining keyboards. However, to minimize stolen keyboards,\n    # we should choose x such that the range [min_remaining, max_remaining]\n    # contains as many original keyboards as possible.\n    # The minimal stolen count is simply the missing numbers within the\n    # span covered by the remaining keyboards.\n    print(missing_in_range)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.764546155929565}
{"eval_index": 357, "problem_id": 3167, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    \n    # Count how many times each index is incremented\n    freq = [0] * (N + 1)  # 1-indexed for easier prefix sums\n    for _ in range(K):\n        jump = int(next(it))\n        # For each multiple of jump within array bounds\n        for idx in range(0, N, jump):\n            freq[idx] += 1\n    \n    # Build prefix sums of freq\n    prefix = [0] * (N + 1)\n    for i in range(N):\n        prefix[i + 1] = prefix[i] + freq[i]\n    \n    Q = int(next(it))\n    out_lines = []\n    for _ in range(Q):\n        L = int(next(it))\n        R = int(next(it))\n        # Sum from L to R inclusive\n        total = prefix[R + 1] - prefix[L]\n        out_lines.append(str(total))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 46.629976749420166}
{"eval_index": 358, "problem_id": 4273, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    if not input:\n        return\n    n = int(input[0])\n    names = input[1:]\n    \n    # Count names starting with M, A, R, C, H\n    counts = {'M': 0, 'A': 0, 'R': 0, 'C': 0, 'H': 0}\n    for name in names:\n        if name[0] in counts:\n            counts[name[0]] += 1\n    \n    # Get non-zero counts\n    values = [counts[letter] for letter in ['M', 'A', 'R', 'C', 'H'] if counts[letter] > 0]\n    \n    # If less than 3 letters have names, answer is 0\n    if len(values) < 3:\n        print(0)\n        return\n    \n    # Calculate combinations of 3 letters from available letters\n    # Then multiply the counts for those letters\n    from itertools import combinations\n    \n    total = 0\n    letters = ['M', 'A', 'R', 'C', 'H']\n    # Filter to letters with count > 0\n    available_letters = [letter for letter in letters if counts[letter] > 0]\n    \n    # Generate all combinations of 3 letters from available letters\n    for combo in combinations(available_letters, 3):\n        product = 1\n        for letter in combo:\n            product *= counts[letter]\n        total += product\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 39.33166265487671}
{"eval_index": 359, "problem_id": 958, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 67.99571990966797}
{"eval_index": 360, "problem_id": 3091, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport itertools\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return 0\\r\\n    \\r\\n    n = int(data[0])\\r\\n    m = int(data[1])\\r\\n    t = int(data[2])\\r\\n    op = data[3]\\r\\n    \\r\\n    cells = []\\r\\n    idx = 4\\r\\n    for _ in range(m):\\r\\n        r = int(data[idx]) - 1  # 0based\\r\\n        c = int(data[idx+1]) - 1\\r\\n        cells.append((r, c))\\r\\n        idx += 2\\r\\n    \\r\\n    # all permutations of m distinct numbers from 1..n\\r\\n    numbers = list(range(1, n+1))\\r\\n    count = 0\\r\\n    \\r\\n    for perm in itertools.permutations(numbers, m):\\r\\n        # check row/col uniqueness within the section\\r\\n        rows_used = set()\\r\\n        cols_used = set()\\r\\n        ok = True\\r\\n        for (r, c), val in zip(cells, perm):\\r\\n            if r in rows_used or c in cols_used:\\r\\n                ok = False\\r\\n                break\\r\\n            rows_used.add(r)\\r\\n            cols_used.add(val)  # wait, careful: column uniqueness is about column index c, not value\\r\\n        # Actually, column uniqueness means no two cells in the same column get the same value.\\r\\n        # But here we are checking that values are distinct across the whole section anyway (permutation).\\r\\n        # The real constraint is: no two cells in the same row/column (of the whole grid) can have the same value.\\r\\n        # Since we are only filling this section, we must ensure that within the section,\\r\\n        # no two cells share a row or a column.\\r\\n        # But the problem says: \"no number appears more than once in any row or column\" of the whole puzzle.\\r\\n        # For just this section, that means: within the section, each row index appears at most once,\\r\\n        # and each column index appears at most once.\\r\\n        # So we must check that the cells themselves have distinct rows and distinct columns.\\r\\n        # Let\\'s verify that from the input.\\r\\n        # Actually, the input guarantees connectedness, but not necessarily distinct rows/cols.\\r\\n        # Example 2 mentions you cannot swap 1 and 4 because that would put two 1\\'s in same column.\\r\\n        # That implies two cells in the section can be in the same column (or row).\\r\\n        # So the constraint is: the values placed in cells that share a row must be different,\\r\\n        # and values placed in cells that share a column must be different.\\r\\n        # Since we are assigning a permutation of distinct numbers to the m cells,\\r\\n        # if two cells share a row, they automatically get different values (because all values are distinct).\\r\\n        # Same for columns. So the only potential violation is if two cells share the same row AND\\r\\n        # we assign the same value to both, but that can\\'t happen with a permutation.\\r\\n        # Wait, but the example says: \"you could not swap the 1 and 4 in the first row, since that would result in two 1s in the same column.\"\\r\\n        # That means: cell A and cell B are in different rows but same column.\\r\\n        # If we swap values between them, one column would get duplicate values.\\r\\n        # So the constraint is: values in the same column must be distinct.\\r\\n        # Since we are assigning a permutation to the m cells, if two cells share a column,\\r\\n        # they get different values automatically.\\r\\n        # Therefore, the row/col constraint is automatically satisfied for any permutation\\r\\n        # because all assigned values are distinct.\\r\\n        # But is that true? Consider m=3, cells at (1,1), (1,2), (2,1).\\r\\n        # Permutation (a,b,c) assigns a to (1,1), b to (1,2), c to (2,1).\\r\\n        # Row 1 has a and b (different), row 2 has c (ok).\\r\\n        # Column 1 has a and c (different), column 2 has b (ok).\\r\\n        # So yes, distinct values guarantee no row/col duplicates within the section.\\r\\n        # Therefore, we only need to check the arithmetic condition.\\r\\n        \\r\\n        if not ok:\\r\\n            continue\\r\\n        \\r\\n        # arithmetic check\\r\\n        if op == \\'+\\':\\r\\n            if sum(perm) == t:\\r\\n                count += 1\\r\\n        elif op == \\'-\\':\\r\\n            # subtraction: two numbers a,b such that |a-b| = t\\r\\n            # order matters because cells are ordered as given.\\r\\n            # The problem doesn\\'t specify order for subtraction/division.\\r\\n            # In KenKen, subtraction/division sections are usually two cells,\\r\\n            # and the operation is applied to the two numbers in either order\\r\\n            # to get the target. So |a-b| = t for subtraction.\\r\\n            # For m>2 with \\'-\\'? The problem says sections with - or / can consist of only two grid squares.\\r\\n            # So we assume m=2 for \\'-\\' and \\'/\\'.\\r\\n            if m == 2:\\r\\n                a, b = perm\\r\\n                if abs(a - b) == t:\\r\\n                    count += 1\\r\\n        elif op == \\'*\\':\\r\\n            prod = 1\\r\\n            for val in perm:\\r\\n                prod *= val\\r\\n            if prod == t:\\r\\n                count += 1\\r\\n        elif op == \\'/\\':\\r\\n            if m == 2:\\r\\n                a, b = perm\\r\\n                if max(a, b) / min(a, b) == t:\\r\\n                    count += 1\\r\\n        # else: invalid op, but input guarantees one of the four\\r\\n    \\r\\n    print(count)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 311, 312, 'illegal multibyte sequence')", "runtime_sec": 113.57399249076843}
{"eval_index": 361, "problem_id": 4756, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    xs = []\n    ys = []\n    idx = 1\n    for _ in range(n):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        xs.append(x)\n        ys.append(y)\n        idx += 2\n    \n    # Transform coordinates: line is y = x + a\n    # Distance from point (x_i, y_i) to line y = x + a is |y_i - x_i - a| / sqrt(2)\n    # Square of distance is (y_i - x_i - a)^2 / 2\n    # Sum over all points: minimize sum_i (y_i - x_i - a)^2\n    # Let d_i = y_i - x_i\n    # Minimize sum_i (d_i - a)^2\n    # This is minimized when a = mean of d_i\n    \n    d_vals = [y - x for x, y in zip(xs, ys)]\n    a = sum(d_vals) / n\n    \n    # Output with sufficient precision\n    print(f\"{a:.6f}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 51.00083541870117}
{"eval_index": 362, "problem_id": 232, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    colors = [int(next(it)) for _ in range(n)]\n    k = [int(next(it)) for _ in range(m)]\n    \n    # Precompute prefix sums for each color\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n    for idx, col in enumerate(colors, 1):\n        for c in range(1, m + 1):\n            prefix[c][idx] = prefix[c][idx - 1]\n        prefix[col][idx] += 1\n    \n    # Try all possible intervals\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            match = True\n            for c in range(1, m + 1):\n                cnt = prefix[c][r] - prefix[c][l - 1]\n                if cnt != k[c - 1]:\n                    match = False\n                    break\n            if match:\n                print(\"YES\")\n                return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.238137245178223}
{"eval_index": 363, "problem_id": 3827, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    s = input().strip()\n    n = len(s)\n    \n    # Check if string contains only 'a', 'b', 'c' and has at least one 'a' and one 'b'\n    if not all(c in 'abc' for c in s):\n        print(\"NO\")\n        return\n    \n    # Find the transition points\n    # The string should be in format: a...a b...b c...c\n    # Find first 'b' after 'a's\n    i = 0\n    while i < n and s[i] == 'a':\n        i += 1\n    \n    # Find first 'c' after 'b's\n    j = i\n    while j < n and s[j] == 'b':\n        j += 1\n    \n    # Check if remaining are all 'c's\n    k = j\n    while k < n and s[k] == 'c':\n        k += 1\n    \n    # If we didn't reach the end, or any section is empty\n    if k != n or i == 0 or j == i:\n        print(\"NO\")\n        return\n    \n    # Count occurrences\n    cnt_a = i\n    cnt_b = j - i\n    cnt_c = n - j\n    \n    # Check the condition: cnt_c equals cnt_a OR cnt_b (or both)\n    if cnt_c == cnt_a or cnt_c == cnt_b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.797913789749146}
{"eval_index": 364, "problem_id": 4993, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    P = int(data[0])\n    N = int(data[1])\n    parts = data[2:2+N]\n    \n    seen = set()\n    last_replacement_day = -1\n    \n    for day in range(N):\n        part = parts[day]\n        if part not in seen:\n            seen.add(part)\n            if len(seen) == P:\n                last_replacement_day = day + 1  # 1-based day numbering\n                break\n    \n    if last_replacement_day != -1:\n        print(last_replacement_day)\n    else:\n        print(\"paradox avoided\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.974564790725708}
{"eval_index": 365, "problem_id": 2450, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx]); m = int(data[idx+1])\n        x = int(data[idx+2]); y = int(data[idx+3])\n        idx += 4\n        total_cost = 0\n        for i in range(n):\n            row = data[idx]\n            idx += 1\n            j = 0\n            while j < m:\n                if row[j] == '*':\n                    j += 1\n                    continue\n                # Count consecutive white cells\n                start = j\n                while j < m and row[j] == '.':\n                    j += 1\n                length = j - start\n                # Calculate minimal cost for this segment\n                if y < 2 * x:\n                    # Use as many 1x2 tiles as possible\n                    pairs = length // 2\n                    singles = length % 2\n                    total_cost += pairs * y + singles * x\n                else:\n                    # 1x1 tiles are cheaper per cell\n                    total_cost += length * x\n        results.append(str(total_cost))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.424396753311157}
{"eval_index": 366, "problem_id": 3075, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    g = int(next(it))\n    stations = []\n    for _ in range(n):\n        d = int(next(it))\n        c = int(next(it))\n        stations.append((d, c))\n    stations.sort()\n    # Add destination as a station with cost 0\n    stations.append((stations[-1][0], 0))\n    n += 1\n    \n    # Check if any gap between consecutive stations exceeds tank capacity\n    for i in range(1, n):\n        if stations[i][0] - stations[i-1][0] > g:\n            print(\"cancel road trip\")\n            return\n    \n    # Min-heap for stations we can reach with current fuel\n    heap = []\n    cost = 0\n    fuel = g  # start with full tank\n    prev_pos = 0\n    \n    for i in range(n):\n        dist = stations[i][0] - prev_pos\n        fuel -= dist\n        # Refuel from passed stations to maintain non-negative fuel\n        while fuel < 0 and heap:\n            cheapest_price, cheapest_pos = heapq.heappop(heap)\n            # Fuel needed to reach current station\n            needed = -fuel\n            # Can't refuel more than tank capacity allows\n            max_refuel = g - (prev_pos - cheapest_pos)  # fuel we could have added at cheapest_pos\n            refuel = min(needed, max_refuel)\n            cost += refuel * cheapest_price\n            fuel += refuel\n            # If we didn't take all possible fuel from this station, push back remaining\n            if refuel < max_refuel:\n                heapq.heappush(heap, (cheapest_price, cheapest_pos))\n        if fuel < 0:\n            print(\"cancel road trip\")\n            return\n        # Add current station to heap for future refueling\n        heapq.heappush(heap, (stations[i][1], stations[i][0]))\n        prev_pos = stations[i][0]\n    \n    print(cost)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 93.96198296546936}
{"eval_index": 367, "problem_id": 4245, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B = map(int, sys.stdin.readline().split())\n    # Start with 1 socket (the original one)\n    sockets = 1\n    strips = 0\n    # Keep adding strips until we have at least B sockets\n    while sockets < B:\n        # Each strip adds A sockets but uses up 1 socket to plug in\n        # So net gain is A-1 sockets per strip\n        sockets += (A - 1)\n        strips += 1\n    print(strips)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.247265815734863}
{"eval_index": 368, "problem_id": 884, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data)\n    \n    # Precompute factorials and inverse factorials up to max(a,b,c)\n    max_n = max(a, b, c)\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    # Fermat's little theorem for modular inverse\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD\n    \n    # Count ways to connect between two clusters with constraint: no same-color distance < 3\n    # This means between two clusters, we can have:\n    # 1. No edges between them\n    # 2. A matching (set of disjoint edges) between them\n    # Because if there were a vertex with degree >= 2, it would create distance 2 between same-color vertices\n    \n    def count_ways(x, y):\n        # x islands in first cluster, y in second\n        total = 0\n        # k = number of edges in the matching\n        for k in range(0, min(x, y) + 1):\n            # Choose k vertices from x, k from y, match them in k! ways\n            ways = comb(x, k) * comb(y, k) % MOD\n            ways = ways * fact[k] % MOD\n            total = (total + ways) % MOD\n        return total\n    \n    # Count ways for each pair of clusters\n    ways_ab = count_ways(a, b)\n    ways_ac = count_ways(a, c)\n    ways_bc = count_ways(b, c)\n    \n    # Total ways: multiply independent choices for each pair\n    result = ways_ab * ways_ac % MOD\n    result = result * ways_bc % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 36.711299896240234}
{"eval_index": 369, "problem_id": 3399, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.7059450149536}
{"eval_index": 370, "problem_id": 4995, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    total_sl_minutes = 0.0\n    total_real_minutes = 0.0\n    \n    for i in range(n):\n        m = int(data[2*i + 1])\n        s = int(data[2*i + 2])\n        total_sl_minutes += m\n        total_real_minutes += s / 60.0\n    \n    if total_sl_minutes == 0:\n        print(\"measurement error\")\n        return\n    \n    avg_length = total_real_minutes / total_sl_minutes\n    \n    if avg_length <= 1.0:\n        print(\"measurement error\")\n    else:\n        print(f\"{avg_length:.9f}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.15076208114624}
{"eval_index": 371, "problem_id": 288, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 70.15355777740479}
{"eval_index": 372, "problem_id": 3107, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.52880764007568}
{"eval_index": 373, "problem_id": 4909, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    D = list(map(int, data[1:1+n]))\n    \n    # Condition 1: sum of degrees must be 2*(N-1) for a tree\n    if sum(D) != 2 * (n - 1):\n        print(\"NO\")\n        return\n    \n    # Condition 2: degree of root (room 1) must be at least 1\n    if D[0] < 1:\n        print(\"NO\")\n        return\n    \n    # Condition 3: For a valid increasing path tree, we can think of it as a rooted tree\n    # where each node's children have larger indices. This imposes constraints on degrees.\n    # We'll simulate building the tree from root 1.\n    \n    # Sort degrees of non-root nodes in descending order for processing\n    non_root_degrees = sorted(D[1:], reverse=True)\n    \n    # Available \"slots\" to attach children: start with degree of root\n    slots = D[0]\n    \n    for deg in non_root_degrees:\n        if slots == 0:\n            # No available slots to attach this node as child\n            print(\"NO\")\n            return\n        # Attach this node as child to some parent\n        slots -= 1\n        # This node itself provides (deg-1) new slots for its children\n        slots += (deg - 1)\n    \n    # After processing all nodes, slots should be 0\n    if slots == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 29.655420064926147}
{"eval_index": 374, "problem_id": 247, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 186.20252346992493}
{"eval_index": 375, "problem_id": 3070, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 140.9852089881897}
{"eval_index": 376, "problem_id": 4064, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    h = int(next(it))\n    l = int(next(it))\n    r = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    \n    # dp[i][t] = max good sleeps after first i sleeps, ending at time t mod h\n    dp = [[-1] * h for _ in range(n + 1)]\n    dp[0][0] = 0  # start at time 0\n    \n    for i in range(n):\n        for t in range(h):\n            if dp[i][t] == -1:\n                continue\n            # option 1: sleep after a_i hours\n            nt1 = (t + a[i]) % h\n            good1 = 1 if l <= nt1 <= r else 0\n            dp[i + 1][nt1] = max(dp[i + 1][nt1], dp[i][t] + good1)\n            \n            # option 2: sleep after a_i - 1 hours\n            nt2 = (t + a[i] - 1) % h\n            good2 = 1 if l <= nt2 <= r else 0\n            dp[i + 1][nt2] = max(dp[i + 1][nt2], dp[i][t] + good2)\n    \n    ans = max(dp[n])\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 23.689335823059082}
{"eval_index": 377, "problem_id": 366, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    S = int(data[1])\n    \n    # If n >= S, we can use one coin of value S\n    if n >= S:\n        print(1)\n        return\n    \n    # Use as many coins of value n as possible\n    coins_needed = S // n\n    remainder = S % n\n    \n    # If remainder is 0, we're done\n    if remainder == 0:\n        print(coins_needed)\n        return\n    \n    # Otherwise, we need one more coin for the remainder\n    # Since remainder < n and we have coin values 1..n, we can always use one coin for remainder\n    print(coins_needed + 1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 19.092173099517822}
{"eval_index": 378, "problem_id": 3665, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 124.85037016868591}
{"eval_index": 379, "problem_id": 4799, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    G, S, C = map(int, data[:3])\n    \n    # Calculate buying power\n    buying_power = G * 3 + S * 2 + C * 1\n    \n    # Determine best victory card\n    if buying_power >= 8:\n        best_victory = \"Province\"\n    elif buying_power >= 5:\n        best_victory = \"Duchy\"\n    elif buying_power >= 2:\n        best_victory = \"Estate\"\n    else:\n        best_victory = None\n    \n    # Determine best treasure card\n    if buying_power >= 6:\n        best_treasure = \"Gold\"\n    elif buying_power >= 3:\n        best_treasure = \"Silver\"\n    else:\n        best_treasure = \"Copper\"\n    \n    # Format output\n    if best_victory:\n        print(f\"{best_victory} or {best_treasure}\")\n    else:\n        print(best_treasure)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.353187561035156}
{"eval_index": 380, "problem_id": 903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    a.sort()\n    mid = n // 2\n    median_idx = mid\n    ops_used = 0\n    target = a[median_idx]\n    \n    for i in range(median_idx + 1, n):\n        if ops_used >= k:\n            break\n        diff = a[i] - target\n        gap = i - median_idx\n        needed = diff * gap\n        if ops_used + needed <= k:\n            ops_used += needed\n            target = a[i]\n        else:\n            can_add = (k - ops_used) // gap\n            target += can_add\n            ops_used += can_add * gap\n            break\n    else:\n        remaining = k - ops_used\n        can_add = remaining // (mid + 1)\n        target += can_add\n    \n    print(target)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 21.045691967010498}
{"eval_index": 381, "problem_id": 3241, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.24133801460266}
{"eval_index": 382, "problem_id": 4819, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    distinct_mods = set()\n    for _ in range(10):\n        num = int(sys.stdin.readline().strip())\n        distinct_mods.add(num % 42)\n    print(len(distinct_mods))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 8.988308429718018}
{"eval_index": 383, "problem_id": 2380, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.938772439956665}
{"eval_index": 384, "problem_id": 3512, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    dist = [[0]*N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            dist[i][j] = int(next(it))\n    \n    # dp[mask][last] = min cost to visit cities in mask ending at last\n    # mask is bitmask of visited cities (0-indexed)\n    INF = 10**9\n    dp = [[INF]*N for _ in range(1<<N)]\n    for i in range(N):\n        dp[1<<i][i] = 0  # start at city i\n    \n    for mask in range(1<<N):\n        # For each possible last city in current mask\n        for last in range(N):\n            if dp[mask][last] == INF:\n                continue\n            # Try to add a new city 'nxt' not in mask\n            for nxt in range(N):\n                if mask & (1<<nxt):\n                    continue\n                # Check the condition: for city K = nxt+1 (1-indexed),\n                # all smaller cities must be either all visited or all unvisited\n                # This translates to: all bits 0..nxt-1 must be either all 0 or all 1 in mask\n                ok = True\n                for k in range(nxt):\n                    if (mask >> k) & 1 != (mask >> (nxt-1)) & 1:\n                        ok = False\n                        break\n                if not ok:\n                    continue\n                new_mask = mask | (1<<nxt)\n                new_cost = dp[mask][last] + dist[last][nxt]\n                if new_cost < dp[new_mask][nxt]:\n                    dp[new_mask][nxt] = new_cost\n    \n    full_mask = (1<<N) - 1\n    ans = min(dp[full_mask][i] for i in range(N))\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.505042791366577}
{"eval_index": 385, "problem_id": 4138, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_digits(n):\n    \"\"\"Return number of digits in n\"\"\"\n    return len(str(n))\n\ndef total_digits_up_to(n):\n    \"\"\"Total digits from 1 to n inclusive\"\"\"\n    if n <= 0:\n        return 0\n    \n    total = 0\n    length = 1\n    start = 1\n    \n    while start <= n:\n        end = min(n, 10**length - 1)\n        count = end - start + 1\n        total += count * length\n        start = 10**length\n        length += 1\n    \n    return total\n\ndef find_block(k):\n    \"\"\"Find which block contains position k\"\"\"\n    low, high = 1, 10**9  # Upper bound for block number\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Calculate total digits up to block mid\n        total = 0\n        length = 1\n        start = 1\n        \n        while start <= mid:\n            end = min(mid, 10**length - 1)\n            count = end - start + 1\n            \n            # Sum of arithmetic series: count * (first + last) // 2\n            first = total_digits_up_to(start - 1) + length\n            last = total_digits_up_to(end - 1) + length\n            total += count * (first + last) // 2\n            \n            start = 10**length\n            length += 1\n        \n        if total < k:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return low\n\ndef find_digit_in_number(num, pos):\n    \"\"\"Find digit at position pos in number num (1-indexed)\"\"\"\n    s = str(num)\n    return int(s[pos - 1])\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    q = int(data[0])\n    results = []\n    \n    for i in range(1, q + 1):\n        k = int(data[i])\n        \n        # Step 1: Find which block contains position k\n        block_num = find_block(k)\n        \n        # Step 2: Find position within this block\n        # Calculate total digits before this block\n        total_before = 0\n        if block_num > 1:\n            length = 1\n            start = 1\n            \n            while start <= block_num - 1:\n                end = min(block_num - 1, 10**length - 1)\n                count = end - start + 1\n                \n                first = total_digits_up_to(start - 1) + length\n                last = total_digits_up_to(end - 1) + length\n                total_before += count * (first + last) // 2\n                \n                start = 10**length\n                length += 1\n        \n        pos_in_block = k - total_before\n        \n        # Step 3: Find which number in the block contains this position\n        low, high = 1, block_num\n        \n        while low <= high:\n            mid = (low + high) // 2\n            digits_up_to_mid = total_digits_up_to(mid)\n            \n            if digits_up_to_mid < pos_in_block:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        num_in_block = low\n        \n        # Step 4: Find position within this number\n        digits_before_num = total_digits_up_to(num_in_block - 1)\n        pos_in_num = pos_in_block - digits_before_num\n        \n        # Step 5: Extract the digit\n        digit = find_digit_in_number(num_in_block, pos_in_num)\n        results.append(str(digit))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 45.70472598075867}
{"eval_index": 386, "problem_id": 57, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    points = []\n    idx = 1\n    for _ in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        points.append((x, y))\n        idx += 2\n    \n    if n == 1:\n        print(-1)\n        return\n    \n    # Collect all distinct x and y coordinates\n    xs = set()\n    ys = set()\n    for x, y in points:\n        xs.add(x)\n        ys.add(y)\n    \n    # For a rectangle with sides parallel to axes, we need exactly 2 distinct x's and 2 distinct y's\n    if len(xs) == 2 and len(ys) == 2:\n        # Compute side lengths\n        x_list = sorted(xs)\n        y_list = sorted(ys)\n        width = x_list[1] - x_list[0]\n        height = y_list[1] - y_list[0]\n        area = width * height\n        print(area)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.452850341796875}
{"eval_index": 387, "problem_id": 3802, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.5933895111084}
{"eval_index": 388, "problem_id": 4111, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Precompute prefix sums for odd and even positions\n    prefix_odd = [0] * (n + 2)  # 1-indexed, extra padding\n    prefix_even = [0] * (n + 2)\n    \n    for i in range(1, n + 1):\n        prefix_odd[i] = prefix_odd[i-1]\n        prefix_even[i] = prefix_even[i-1]\n        if i % 2 == 1:\n            prefix_odd[i] += a[i-1]\n        else:\n            prefix_even[i] += a[i-1]\n    \n    count = 0\n    for i in range(1, n + 1):\n        # If candy i is given to dad\n        # Candies before i keep their parity\n        # Candies after i shift parity\n        odd_sum = prefix_odd[i-1]  # odd-indexed candies before i\n        even_sum = prefix_even[i-1]  # even-indexed candies before i\n        \n        # For candies after i: they shift parity\n        # Original odd positions become even, original even become odd\n        odd_sum += prefix_even[n] - prefix_even[i]  # original evens after i\n        even_sum += prefix_odd[n] - prefix_odd[i]   # original odds after i\n        \n        if odd_sum == even_sum:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 87.53395462036133}
{"eval_index": 389, "problem_id": 35, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Check if n is divisible by 3 for vertical stripes\n    if n % 3 == 0:\n        h = n // 3\n        # Check each stripe has uniform color\n        colors = []\n        valid = True\n        for i in range(3):\n            stripe_color = grid[i * h][0]\n            # Check all cells in this stripe\n            for r in range(i * h, (i + 1) * h):\n                for c in range(m):\n                    if grid[r][c] != stripe_color:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if not valid:\n                break\n            colors.append(stripe_color)\n        if valid:\n            # Check all three colors are present and distinct\n            if set(colors) == {'R', 'G', 'B'}:\n                print(\"YES\")\n                return\n    \n    # Check if m is divisible by 3 for horizontal stripes\n    if m % 3 == 0:\n        w = m // 3\n        # Check each stripe has uniform color\n        colors = []\n        valid = True\n        for i in range(3):\n            stripe_color = grid[0][i * w]\n            # Check all cells in this stripe\n            for c in range(i * w, (i + 1) * w):\n                for r in range(n):\n                    if grid[r][c] != stripe_color:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if not valid:\n                break\n            colors.append(stripe_color)\n        if valid:\n            # Check all three colors are present and distinct\n            if set(colors) == {'R', 'G', 'B'}:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 55.12911629676819}
{"eval_index": 390, "problem_id": 3383, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.6908311843872}
{"eval_index": 391, "problem_id": 4754, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:1+2*n]))\n    \n    # Check if each sock type appears an even number of times\n    from collections import Counter\n    cnt = Counter(socks)\n    for v in cnt.values():\n        if v % 2 != 0:\n            print(\"impossible\")\n            return\n    \n    # Simulate the process\n    original = socks[::-1]  # bottom to top for easier pop\n    auxiliary = []\n    moves = 0\n    paired = 0\n    \n    while original:\n        # Move from original to auxiliary\n        auxiliary.append(original.pop())\n        moves += 1\n        \n        # Try to pair as much as possible\n        while auxiliary and original and auxiliary[-1] == original[-1]:\n            auxiliary.pop()\n            original.pop()\n            moves += 1  # pairing move\n            paired += 1\n            \n            # After pairing, check if auxiliary top matches new original top\n            while auxiliary and original and auxiliary[-1] == original[-1]:\n                auxiliary.pop()\n                original.pop()\n                moves += 1\n                paired += 1\n    \n    # If auxiliary is empty, all socks are paired\n    if not auxiliary:\n        print(moves)\n    else:\n        print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.915032863616943}
{"eval_index": 392, "problem_id": 1690, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We'll process from right to left\n    # For each position i, we can take at most min(a[i], prev + 1)\n    # where prev is the maximum we took at position i+1\n    # But we need to ensure the condition holds for all j < i\n    # Actually, we can think of building a non-decreasing sequence\n    # from right to left, where each element is at most a[i]\n    # and we want to maximize sum\n    \n    # Initialize with the last element\n    prev = a[-1]\n    total = prev\n    \n    # Process from second last to first\n    for i in range(n-2, -1, -1):\n        # We can take at most min(a[i], prev - 1)\n        # But we need to ensure x_i > x_j for j < i if both are non-zero\n        # Actually, if we take x_i, then for all j < i, either x_j = 0 or x_j < x_i\n        # So we can take a decreasing sequence from right to left\n        # Wait, let's think carefully\n        \n        # The condition says: for all j < i, either x_j = 0 or x_j < x_i\n        # This means if we take x_i > 0, then all x_j for j < i must be either 0 or < x_i\n        # So we can think of taking a strictly decreasing sequence from right to left\n        # But we want to maximize sum, so we want to take as large as possible\n        \n        # Let's try: we process from right to left, keeping track of the maximum\n        # we can take at current position given what we took at the next position\n        # If we took 'prev' at position i+1, then at position i we can take\n        # at most min(a[i], prev - 1) if we want x_i < x_{i+1}\n        # But we could also take 0\n        \n        # Actually, the optimal strategy is to take a strictly decreasing sequence\n        # from right to left, where each element is as large as possible\n        # but not exceeding a[i] and being less than the previous one\n        \n        current = min(a[i], prev - 1)\n        if current < 0:\n            current = 0\n        total += current\n        prev = current\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 67.52578449249268}
{"eval_index": 393, "problem_id": 3542, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.13034009933472}
{"eval_index": 394, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into positive and negative b_i\n    pos = []\n    neg = []\n    for a, b in projects:\n        if b >= 0:\n            pos.append((a, b))\n        else:\n            neg.append((a, b))\n    \n    # Sort positive projects by required rating a_i (ascending)\n    pos.sort(key=lambda x: x[0])\n    \n    # Process positive projects first\n    for a, b in pos:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # For negative projects, sort by (a_i + b_i) descending\n    # This is equivalent to sorting by (a_i - (-b_i)) or by (a_i + b_i)\n    # We want to maximize remaining rating after completion\n    neg.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    for a, b in neg:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 28.532696962356567}
{"eval_index": 395, "problem_id": 1991, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        arr = [int(next(it)) for _ in range(n)]\n        \n        # Count how many positions are already correct\n        correct = 0\n        for i in range(n):\n            if arr[i] == i + 1:\n                correct += 1\n        \n        # If all positions are correct, answer is 0\n        if correct == n:\n            out_lines.append(\"0\")\n            continue\n        \n        # Find first incorrect position from left\n        left = 0\n        while left < n and arr[left] == left + 1:\n            left += 1\n        \n        # Find first incorrect position from right\n        right = n - 1\n        while right >= 0 and arr[right] == right + 1:\n            right -= 1\n        \n        # Check if there's any correct element between left and right\n        has_correct_middle = False\n        for i in range(left, right + 1):\n            if arr[i] == i + 1:\n                has_correct_middle = True\n                break\n        \n        if has_correct_middle:\n            out_lines.append(\"2\")\n        else:\n            out_lines.append(\"1\")\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 69.72136068344116}
{"eval_index": 396, "problem_id": 3410, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.53699493408203}
{"eval_index": 397, "problem_id": 4766, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 42.3508939743042}
{"eval_index": 398, "problem_id": 2498, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    \n    N = int(data[0])\n    M = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    # Step 1: Transform each a_k to b_k = a_k // 2\n    b = [x // 2 for x in a]\n    \n    # Step 2: Compute LCM of all b_k\n    lcm_val = 1\n    for val in b:\n        lcm_val = lcm_val * val // math.gcd(lcm_val, val)\n        # Early exit if LCM exceeds M or becomes too large\n        if lcm_val > M:\n            print(0)\n            return\n    \n    # Step 3: Check parity condition\n    # For X to be valid, X must be odd multiple of lcm_val\n    # Since X = lcm_val * (2*t + 1) for integer t >= 0\n    # We need lcm_val to be odd (because if lcm_val is even, X would be even, \n    # but X must be odd to satisfy X = a_k*(p+0.5) where a_k is even)\n    # Actually, let's verify: X = a_k*(p+0.5) = (2*b_k)*(p+0.5) = b_k*(2p+1)\n    # So X must be odd multiple of b_k for each k.\n    # Therefore, X must be odd multiple of LCM of all b_k.\n    # So lcm_val must be odd. If lcm_val is even, no solution.\n    \n    # Check if all b_k have the same parity of (lcm_val // b_k)\n    # Actually simpler: X = lcm_val * (2*t + 1) for integer t >= 0\n    # For this to satisfy X = b_k*(2p+1) for each k, we need:\n    # lcm_val * (2*t + 1) = b_k * (2p + 1) for some integer p\n    # This means (2*t + 1) must be multiple of (b_k / gcd(b_k, lcm_val))\n    # But since lcm_val is LCM, b_k divides lcm_val, so b_k / gcd(b_k, lcm_val) = b_k / b_k = 1\n    # So condition reduces to: lcm_val must be odd (because 2*t+1 is odd)\n    \n    if lcm_val % 2 == 0:\n        print(0)\n        return\n    \n    # Step 4: Count valid X = lcm_val * (2*t + 1) <= M\n    # Number of non-negative integers t such that lcm_val*(2*t+1) <= M\n    # => 2*t + 1 <= M // lcm_val\n    # => t <= (M // lcm_val - 1) // 2\n    max_t = (M // lcm_val - 1) // 2\n    count = max_t + 1 if max_t >= 0 else 0\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 77.5417914390564}
{"eval_index": 399, "problem_id": 3964, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.21562838554382}
{"eval_index": 400, "problem_id": 4942, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    t = list(map(int, data[1:1+n]))\n    \n    # Sort in descending order\n    t.sort(reverse=True)\n    \n    max_day = 0\n    for i, days in enumerate(t):\n        # Planting day = i + 1 (1-indexed days)\n        # Growth completes at planting_day + days\n        completion_day = (i + 1) + days\n        if completion_day > max_day:\n            max_day = completion_day\n    \n    # Party is day after last tree grows\n    print(max_day + 1)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 15.58785629272461}
{"eval_index": 401, "problem_id": 1817, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Sort the array\n    arr.sort()\n    \n    # If n is odd, first player picks the median\n    # If n is even, first player picks the smaller of the two middle elements\n    # After sorting, the answer is arr[(n-1)//2]\n    \n    result = arr[(n-1)//2]\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.718887329101562}
{"eval_index": 402, "problem_id": 3445, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef manhattan_distance(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if xroot == yroot:\n        return\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    points = []\n    idx = 1\n    for i in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        points.append((x, y, i))\n        idx += 2\n    \n    # Create all edges with Manhattan distances\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = manhattan_distance(points[i], points[j])\n            edges.append((dist, i, j))\n    edges.sort()\n    \n    # Kruskal's algorithm to build MST\n    parent = list(range(n))\n    rank = [0] * n\n    mst_edges = []\n    for dist, u, v in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, u, v)\n            mst_edges.append((dist, u, v))\n            if len(mst_edges) == n-1:\n                break\n    \n    # Remove the longest edge from MST to create two components\n    mst_edges.sort()\n    longest_edge = mst_edges[-1]\n    \n    # Build two components after removing longest edge\n    parent = list(range(n))\n    rank = [0] * n\n    for dist, u, v in mst_edges:\n        if (dist, u, v) == longest_edge:\n            continue\n        union(parent, rank, u, v)\n    \n    # Find which points belong to each component\n    comp1 = []\n    comp2 = []\n    root1 = find(parent, 0)\n    for i in range(n):\n        if find(parent, i) == root1:\n            comp1.append(points[i])\n        else:\n            comp2.append(points[i])\n    \n    # Calculate maximum distance within each component\n    def max_distance_in_component(comp):\n        if len(comp) <= 1:\n            return 0\n        max_dist = 0\n        for i in range(len(comp)):\n            for j in range(i+1, len(comp)):\n                dist = manhattan_distance(comp[i], comp[j])\n                max_dist = max(max_dist, dist)\n        return max_dist\n    \n    max1 = max_distance_in_component(comp1)\n    max2 = max_distance_in_component(comp2)\n    \n    print(max(max1, max2))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 75.03061580657959}
{"eval_index": 403, "problem_id": 4793, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    s, v1, v2 = map(int, data)\n    \n    # Try all possible counts of v1 bottles\n    max_v1 = s // v1\n    best_v1 = -1\n    best_v2 = -1\n    min_total = float('inf')\n    \n    for n1 in range(max_v1, -1, -1):\n        remaining = s - n1 * v1\n        if remaining % v2 == 0:\n            n2 = remaining // v2\n            total = n1 + n2\n            if total < min_total:\n                min_total = total\n                best_v1 = n1\n                best_v2 = n2\n    \n    if best_v1 == -1:\n        print(\"Impossible\")\n    else:\n        print(f\"{best_v1} {best_v2}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.853281736373901}
{"eval_index": 404, "problem_id": 146, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    tabs = list(map(int, data[2:2+n]))\n    \n    max_diff = 0\n    # Try all possible starting points b from 1 to n\n    for b in range(1, n+1):\n        # Simulate closing tabs for this b\n        closed_indices = set()\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_indices.add(c-1)  # Convert to 0-based index\n                i += 1\n            else:\n                break\n        i = -1\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_indices.add(c-1)\n                i -= 1\n            else:\n                break\n        \n        # Calculate remaining tabs\n        e = 0  # test tabs\n        s = 0  # social tabs\n        for idx in range(n):\n            if idx not in closed_indices:\n                if tabs[idx] == 1:\n                    e += 1\n                else:  # tabs[idx] == -1\n                    s += 1\n        \n        diff = abs(e - s)\n        if diff > max_diff:\n            max_diff = diff\n    \n    print(max_diff)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.687563180923462}
{"eval_index": 405, "problem_id": 3606, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport bisect\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    sys.exit(0)\n\n# Parse N and K\nidx = 0\nN = int(input_data[idx]); idx += 1\nK = int(input_data[idx]); idx += 1\n\n# Parse direction sequence\ndirections = input_data[idx]; idx += 1\n\n# Parse plant coordinates\nplants = []\nfor _ in range(N):\n    x = int(input_data[idx]); idx += 1\n    y = int(input_data[idx]); idx += 1\n    plants.append((x, y))\n\n# Sort plants by x, then y for efficient lookup\nplants.sort()\n\n# Create mapping from coordinates to index in sorted list\ncoord_to_idx = {coord: i for i, coord in enumerate(plants)}\n\n# Current position (initial plant)\ncurrent_x, current_y = plants[0]\ncurrent_idx = 0\n\n# Helper function to find next plant in a given direction\ndef find_next_plant(x, y, direction):\n    \"\"\"Return index of next plant in direction, or -1 if none\"\"\"\n    if direction == 'A':  # (x+P, y+P)\n        # Need plant with x > current_x and y > current_y and (x - current_x) == (y - current_y)\n        # Since plants are sorted by x, we can binary search\n        lo = bisect.bisect_right(plants, (x, y))\n        for i in range(lo, N):\n            nx, ny = plants[i]\n            if nx > x and ny > y and (nx - x) == (ny - y):\n                return i\n        return -1\n    elif direction == 'B':  # (x+P, y-P)\n        # Need plant with x > current_x and y < current_y and (x - current_x) == (current_y - y)\n        lo = bisect.bisect_right(plants, (x, y))\n        for i in range(lo, N):\n            nx, ny = plants[i]\n            if nx > x and ny < y and (nx - x) == (y - ny):\n                return i\n        return -1\n    elif direction == 'C':  # (x-P, y+P)\n        # Need plant with x < current_x and y > current_y and (current_x - x) == (y - current_y)\n        hi = bisect.bisect_left(plants, (x, y))\n        for i in range(hi-1, -1, -1):\n            nx, ny = plants[i]\n            if nx < x and ny > y and (x - nx) == (ny - y):\n                return i\n        return -1\n    elif direction == 'D':  # (x-P, y-P)\n        # Need plant with x < current_x and y < current_y and (current_x - x) == (current_y - y)\n        hi = bisect.bisect_left(plants, (x, y))\n        for i in range(hi-1, -1, -1):\n            nx, ny = plants[i]\n            if nx < x and ny < y and (x - nx) == (y - ny):\n                return i\n        return -1\n    return -1\n\n# Process each jump direction\nfor direction in directions:\n    next_idx = find_next_plant(current_x, current_y, direction)\n    if next_idx != -1:\n        # Jump to the found plant\n        current_x, current_y = plants[next_idx]\n        current_idx = next_idx\n        # Remove the plant we jumped from (simulate sinking)\n        # Since we're using indices, we'll mark it as removed by setting to None\n        # and adjust future searches to skip None values\n        plants[current_idx] = None\n        # Rebuild coord_to_idx without the removed plant\n        plants_without_none = [p for p in plants if p is not None]\n        plants[:] = plants_without_none\n        N = len(plants)\n        coord_to_idx = {coord: i for i, coord in enumerate(plants)}\n        # Update current_idx to new position in updated list\n        if plants:\n            current_idx = coord_to_idx.get((current_x, current_y), 0)\n    # If no plant found, Barica stays put (no change)\n\n# Output final coordinates\nprint(f\"{current_x} {current_y}\")", "complexity_estimate": null, "runtime_sec": 104.5253529548645}
{"eval_index": 406, "problem_id": 4788, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef minimum_distance(current, target):\n    \"\"\"Calculate shortest rotation distance between two compass directions.\"\"\"\n    # Calculate clockwise distance\n    if target >= current:\n        clockwise = target - current\n    else:\n        clockwise = 360 - current + target\n    \n    # Calculate counterclockwise distance\n    counterclockwise = 360 - clockwise\n    \n    # Choose the shortest path\n    # If distances are equal (180 vs -180), choose clockwise (positive 180)\n    if clockwise <= counterclockwise:\n        return clockwise\n    else:\n        return -counterclockwise\n\ndef main():\n    # Read input\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    \n    n1 = int(data[0])  # current direction\n    n2 = int(data[1])  # target direction\n    \n    # Calculate and print result\n    result = minimum_distance(n1, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 19.74347233772278}
{"eval_index": 407, "problem_id": 2121, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.82433700561523}
{"eval_index": 408, "problem_id": 3884, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 90.6561713218689}
{"eval_index": 409, "problem_id": 4008, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 76.70669198036194}
{"eval_index": 410, "problem_id": 2131, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 93.22326993942261}
{"eval_index": 411, "problem_id": 3759, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport math\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    n = int(data[0])\\r\\n    \\r\\n    # For n = 0, special points are just the origin\\r\\n    if n == 0:\\r\\n        print(0)\\r\\n        return\\r\\n    \\r\\n    # For n >= 1, we need to block points at distance n+1 from origin\\r\\n    # that are adjacent to special points at distance n\\r\\n    # These are points where one coordinate is (n+1) and the other is between -n and n\\r\\n    # Or vice versa: one coordinate between -n and n, other is (n+1)\\r\\n    \\r\\n    # Count points at Manhattan distance n+1 from origin\\r\\n    # Actually we need points at Chebyshev distance n+1 (max(|x|,|y|) = n+1)\\r\\n    # that are adjacent to points at Chebyshev distance n\\r\\n    \\r\\n    # The boundary points at distance n form a square with side length 2n+1\\r\\n    # We need to block points just outside this square that are 4-connected to it\\r\\n    # This forms a larger square with side length 2(n+1)+1 = 2n+3\\r\\n    # The number of new points to block is perimeter of inner square + 4 corners\\r\\n    \\r\\n    # Perimeter of square at distance n: 8n\\r\\n    # But we only need to block points at distance n+1 that are adjacent\\r\\n    # Actually simpler: count points where max(|x|,|y|) = n+1\\r\\n    # and min(|x|,|y|) <= n\\r\\n    \\r\\n    # This equals 8*(n+1) - 4 = 8n + 4\\r\\n    # Wait, let\\'s verify with examples:\\r\\n    # n=1: 8*1+4=12, but answer is 4\\r\\n    # Need to reconsider\\r\\n    \\r\\n    # Looking at examples:\\r\\n    # n=1  output 4\\r\\n    # n=2  output 8\\r\\n    # n=3  output 16\\r\\n    \\r\\n    # Pattern seems to be 4 * 2^(n-1) for n>=1\\r\\n    # Let\\'s test: n=1: 4*1=4 , n=2: 4*2=8 , n=3: 4*4=16 \\r\\n    \\r\\n    # So formula appears to be 4 * (2**(n-1)) for n>=1\\r\\n    # But for large n up to 4e7, we need efficient computation\\r\\n    \\r\\n    # Actually, looking more carefully at the problem:\\r\\n    # We need to prevent 4-connection between special points (distance  n)\\r\\n    # and non-special points (distance > n)\\r\\n    # The minimal blocking is to block all points at distance exactly n+1\\r\\n    # that are adjacent to points at distance n\\r\\n    \\r\\n    # Points at distance n form a diamond (circle in L1 metric)\\r\\n    # Actually Euclidean distance, so circle radius n\\r\\n    \\r\\n    # But we\\'re dealing with integer grid points\\r\\n    # The special points are those with x^2 + y^2  n^2\\r\\n    \\r\\n    # We need to find minimal points to block so no special point\\r\\n    # is 4-connected to non-special point\\r\\n    \\r\\n    # The critical points are those at distance n+1 from origin\\r\\n    # that are adjacent (4-connected) to points at distance  n\\r\\n    \\r\\n    # Actually, let\\'s think about the boundary:\\r\\n    # For each special point on the boundary (distance  n),\\r\\n    # we might need to block non-special points adjacent to it\\r\\n    \\r\\n    # But we can block strategically to minimize count\\r\\n    # The examples suggest the answer is 4 * 2^(n-1)\\r\\n    \\r\\n    # Let\\'s implement with modular exponentiation for large n\\r\\n    \\r\\n    MOD = 10**9 + 7  # Not needed for this problem but good practice\\r\\n    \\r\\n    if n == 0:\\r\\n        result = 0\\r\\n    else:\\r\\n        # Compute 2^(n-1) efficiently\\r\\n        # Note: for n up to 4e7, 2^(n-1) is huge, but we just need the value\\r\\n        # Python can handle big integers\\r\\n        result = 4 * (2 ** (n - 1))\\r\\n    \\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 1613, 1614, 'illegal multibyte sequence')", "runtime_sec": 167.16486024856567}
{"eval_index": 412, "problem_id": 4903, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read two lines from standard input\n    lines = sys.stdin.read().strip().split('\\n')\n    if len(lines) < 2:\n        return\n    \n    jon_ah = lines[0].strip()\n    doc_ah = lines[1].strip()\n    \n    # Count the number of 'a's in each string\n    jon_a_count = jon_ah.count('a')\n    doc_a_count = doc_ah.count('a')\n    \n    # Check if Jon's 'a' count is at least as many as the doctor's\n    if jon_a_count >= doc_a_count:\n        print(\"go\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.307604789733887}
{"eval_index": 413, "problem_id": 1829, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    poland_words = set(data[2:2+n])\n    enemy_words = set(data[2+n:2+n+m])\n    \n    common = poland_words & enemy_words\n    unique_poland = len(poland_words) - len(common)\n    unique_enemy = len(enemy_words) - len(common)\n    \n    # Game logic: common words are effectively removed from both players\n    # PolandBall starts, optimal play means both will use unique words first\n    # The player who runs out of unique words first loses\n    \n    # If PolandBall has more unique words than EnemyBall, PolandBall wins\n    # If PolandBall has fewer unique words, PolandBall loses\n    # If equal, depends on who goes first and common words\n    \n    if unique_poland > unique_enemy:\n        print(\"YES\")\n    elif unique_poland < unique_enemy:\n        print(\"NO\")\n    else:\n        # When unique counts are equal, common words determine outcome\n        # PolandBall starts, so if there are common words, PolandBall can use one\n        # Then EnemyBall uses one, alternating until common words run out\n        # The player who cannot move after common words run out loses\n        # With equal unique counts, PolandBall gets the last common word if count is odd\n        if len(common) % 2 == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.505087852478027}
{"eval_index": 414, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 137.30126452445984}
{"eval_index": 415, "problem_id": 4153, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    S = sys.stdin.readline().strip()\n    # Count red (0) and blue (1) cubes\n    red_count = S.count('0')\n    blue_count = S.count('1')\n    # Each operation removes one red and one blue cube\n    # Maximum operations = min(red_count, blue_count)\n    # Each operation removes 2 cubes\n    max_removed = 2 * min(red_count, blue_count)\n    print(max_removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.539692640304565}
{"eval_index": 416, "problem_id": 2287, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    idx = 1\n    for _ in range(t):\n        s = data[idx]\n        idx += 1\n        # Find first and last occurrence of '1'\n        first_one = -1\n        last_one = -1\n        for i, ch in enumerate(s):\n            if ch == '1':\n                if first_one == -1:\n                    first_one = i\n                last_one = i\n        # If no '1's, answer is 0\n        if first_one == -1:\n            results.append(0)\n            continue\n        # Count zeros between first and last '1'\n        zeros_to_remove = 0\n        for i in range(first_one, last_one + 1):\n            if s[i] == '0':\n                zeros_to_remove += 1\n        results.append(zeros_to_remove)\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 16.31764531135559}
{"eval_index": 417, "problem_id": 3143, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 101.28758144378662}
{"eval_index": 418, "problem_id": 4090, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 92.26090788841248}
{"eval_index": 419, "problem_id": 2445, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 52.451411724090576}
{"eval_index": 420, "problem_id": 3795, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    d = int(data[1])\n    e = int(data[2])\n    \n    # Dollar bills available: 1, 2, 5, 10, 20, 50, 100\n    # Euro bills available: 5, 10, 20, 50, 100, 200\n    \n    # We need to minimize remaining rubles after buying some combination of dollar and euro bills\n    # Equivalent to maximizing total rubles spent on bills, subject to not exceeding n\n    \n    # Since n can be up to 1e8, we can't try all combinations directly\n    # But note: d and e are between 30 and 100, and bill denominations are small\n    # We can try all possible numbers of euro bills (since euro bills are multiples of 5)\n    # and for each, find the best dollar combination\n    \n    best_remainder = n  # start with spending nothing\n    \n    # Try all possible euro purchases (in rubles)\n    # Euro bills: 5, 10, 20, 50, 100, 200 euros\n    # Convert to rubles: multiply by e\n    euro_bills = [5, 10, 20, 50, 100, 200]\n    \n    # We'll try spending 0 to n rubles on euros, in steps of 5*e\n    # But to avoid O(n) which could be 1e8, we note that:\n    # - We only need to try up to n rubles worth of euros\n    # - Since euro bills are multiples of 5 euros, we try multiples of 5*e rubles\n    # - But 5*e >= 150 (since e >= 30), so number of iterations is at most n/(5*e) + 1\n    # - With n up to 1e8 and 5*e >= 150, this is at most ~666667 iterations\n    \n    max_euro_rubles = n\n    step = 5 * e\n    \n    # Try all possible euro expenditures in rubles\n    for euro_rubles in range(0, max_euro_rubles + 1, step):\n        if euro_rubles > n:\n            break\n        \n        remaining_rubles = n - euro_rubles\n        \n        # Now spend as many dollars as possible with remaining rubles\n        # Dollar bills: 1, 2, 5, 10, 20, 50, 100 dollars\n        # We want to maximize dollar_rubles <= remaining_rubles\n        \n        # Since dollar bills include 1 dollar, we can spend:\n        # dollar_rubles = (remaining_rubles // d) * d\n        # But we need to check if we can actually form this amount with available bills\n        # Since we have 1 dollar bill, any multiple of d up to remaining_rubles is achievable\n        # by using enough 1-dollar bills\n        \n        max_dollar_count = remaining_rubles // d\n        dollar_rubles = max_dollar_count * d\n        \n        total_spent = euro_rubles + dollar_rubles\n        remainder = n - total_spent\n        \n        if remainder < best_remainder:\n            best_remainder = remainder\n    \n    print(best_remainder)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 43.53884482383728}
{"eval_index": 421, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    s = int(sys.stdin.readline().strip())\n    seen = {}\n    seq = []\n    current = s\n    idx = 1\n    while True:\n        if current in seen:\n            print(idx)\n            return\n        seen[current] = idx\n        seq.append(current)\n        if current % 2 == 0:\n            current = current // 2\n        else:\n            current = 3 * current + 1\n        idx += 1\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 12.951528072357178}
{"eval_index": 422, "problem_id": 1821, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 139.86493134498596}
{"eval_index": 423, "problem_id": 3865, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.0184144973755}
{"eval_index": 424, "problem_id": 4004, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # If all elements are already equal, D = 0\n    if len(set(arr)) == 1:\n        print(0)\n        return\n    \n    # We need to find a target value T such that for each a_i:\n    # a_i == T, or a_i + D == T, or a_i - D == T\n    # This means D = |T - a_i| for those that need change\n    # For unchanged ones, D = 0 (which is consistent with D >= 0)\n    \n    # Since D must be the same for all operations, we need:\n    # For each a_i, |T - a_i| must be either 0 or D\n    # So all |T - a_i| must be either 0 or the same positive value D\n    \n    # Try all possible target values T from min(arr) to max(arr)\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    best_D = float('inf')\n    \n    for T in range(min_val, max_val + 1):\n        D_set = set()\n        valid = True\n        \n        for num in arr:\n            diff = abs(num - T)\n            if diff != 0:\n                D_set.add(diff)\n            # If diff is 0, it's fine (unchanged element)\n        \n        # We can have at most 2 different D values:\n        # 0 (for unchanged) and one positive D (for changed)\n        # But actually, we need exactly one positive D (or 0 if all unchanged)\n        \n        # Remove 0 from consideration\n        D_set.discard(0)\n        \n        if len(D_set) == 0:\n            # All elements are already equal to T\n            D_candidate = 0\n        elif len(D_set) == 1:\n            D_candidate = next(iter(D_set))\n        else:\n            # More than one different non-zero difference\n            # This T won't work\n            continue\n        \n        # Verify that with this D_candidate, all operations are valid\n        # For each a_i, we must have a_i == T or a_i + D == T or a_i - D == T\n        if D_candidate == 0:\n            # Already verified above\n            valid = True\n        else:\n            valid = True\n            for num in arr:\n                if num == T or num + D_candidate == T or num - D_candidate == T:\n                    continue\n                else:\n                    valid = False\n                    break\n        \n        if valid:\n            best_D = min(best_D, D_candidate)\n    \n    if best_D == float('inf'):\n        print(-1)\n    else:\n        print(best_D)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 99.24237513542175}
{"eval_index": 425, "problem_id": 1832, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 82.5035994052887}
{"eval_index": 426, "problem_id": 3805, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef can_untangle(sequence):\n    stack = []\n    for ch in sequence:\n        if stack and stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    return \"Yes\" if not stack else \"No\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"No\")\n        return\n    result = can_untangle(data)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 43.439255714416504}
{"eval_index": 427, "problem_id": 4962, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.76354885101318}
{"eval_index": 428, "problem_id": 1511, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    # Read instructions: instructions[i][j] for core i at cycle j\n    instructions = []\n    for _ in range(n):\n        row = [int(next(it)) for _ in range(m)]\n        instructions.append(row)\n    \n    # Track locked cores and cells\n    locked_cores = [0] * n  # 0 means not locked, otherwise cycle number when locked\n    locked_cells = [False] * (k + 1)  # index 1..k, True if cell locked\n    \n    # Simulate cycle by cycle\n    for cycle in range(1, m + 1):\n        # For each core, process instruction if not already locked\n        for core in range(n):\n            if locked_cores[core] != 0:\n                continue  # already locked\n            \n            instr = instructions[core][cycle - 1]\n            if instr == 0:\n                continue  # do nothing\n            \n            # Writing to cell instr\n            cell = instr\n            if locked_cells[cell]:\n                # Cell already locked, this core locks now\n                locked_cores[core] = cycle\n            else:\n                # Check if any other core writes to same cell this cycle\n                conflict = False\n                for other_core in range(n):\n                    if other_core == core:\n                        continue\n                    if locked_cores[other_core] != 0:\n                        continue\n                    other_instr = instructions[other_core][cycle - 1]\n                    if other_instr == cell:\n                        conflict = True\n                        break\n                \n                if conflict:\n                    # All cores writing to this cell this cycle get locked\n                    locked_cells[cell] = True\n                    locked_cores[core] = cycle\n                    for other_core in range(n):\n                        if other_core == core:\n                            continue\n                        if locked_cores[other_core] != 0:\n                            continue\n                        other_instr = instructions[other_core][cycle - 1]\n                        if other_instr == cell:\n                            locked_cores[other_core] = cycle\n                # else: successful write, nothing happens\n    \n    # Output\n    for core in range(n):\n        print(locked_cores[core])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 35.47047519683838}
{"eval_index": 429, "problem_id": 3422, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 125.17443060874939}
{"eval_index": 430, "problem_id": 4441, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    n = int(input().strip())\n    if n == 1:\n        print(\"Hello World\")\n    else:\n        a = int(input().strip())\n        b = int(input().strip())\n        print(a + b)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 9.89482045173645}
{"eval_index": 431, "problem_id": 2541, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.29505586624146}
{"eval_index": 432, "problem_id": 3708, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 136.86314392089844}
{"eval_index": 433, "problem_id": 4838, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    times = list(map(int, data[1:1+n]))\n    \n    total = 0\n    running = False\n    start_time = 0\n    \n    for i in range(n):\n        current_time = times[i]\n        if running:\n            total += current_time - start_time\n            running = False\n        else:\n            start_time = current_time\n            running = True\n    \n    if running:\n        print(\"still running\")\n    else:\n        print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 14.254791975021362}
{"eval_index": 434, "problem_id": 2509, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 62.378087759017944}
{"eval_index": 435, "problem_id": 3156, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    K = int(data[idx]); idx += 1\n    \n    # inventory[store] = set of items available at that store\n    inventory = [set() for _ in range(N)]\n    # item_to_stores[item] = list of stores that have this item\n    item_to_stores = {}\n    \n    for _ in range(K):\n        parts = data[idx].split(); idx += 1\n        store = int(parts[0])\n        item = parts[1]\n        inventory[store].add(item)\n        if item not in item_to_stores:\n            item_to_stores[item] = []\n        item_to_stores[item].append(store)\n    \n    M = int(data[idx]); idx += 1\n    bought_items = []\n    for _ in range(M):\n        bought_items.append(data[idx]); idx += 1\n    \n    # DP: dp[i][store] = number of ways to buy first i items ending at store\n    # We only need previous row, so use two arrays\n    prev = [0] * N\n    \n    # Initialize for first item\n    first_item = bought_items[0]\n    if first_item not in item_to_stores:\n        print(\"impossible\")\n        return\n    for store in item_to_stores[first_item]:\n        prev[store] = 1\n    \n    total_ways = 0\n    \n    for i in range(1, M):\n        curr = [0] * N\n        item = bought_items[i]\n        if item not in item_to_stores:\n            print(\"impossible\")\n            return\n        \n        # For each store that has current item\n        for store in item_to_stores[item]:\n            # Sum ways from all previous stores <= current store\n            ways = 0\n            for prev_store in range(store + 1):\n                if prev[prev_store] > 0:\n                    ways += prev[prev_store]\n                    if ways > 2:  # We only care about 0, 1, or >1\n                        ways = 2\n                        break\n            curr[store] = ways\n        \n        prev = curr\n    \n    # Sum ways for last item\n    total_ways = 0\n    for store in range(N):\n        total_ways += prev[store]\n        if total_ways > 2:\n            total_ways = 2\n            break\n    \n    if total_ways == 0:\n        print(\"impossible\")\n    elif total_ways == 1:\n        print(\"unique\")\n    else:\n        print(\"ambiguous\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 35.141908168792725}
{"eval_index": 436, "problem_id": 4603, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B, C, D = map(int, data)\n    train_min = min(A, B)\n    bus_min = min(C, D)\n    total_min = train_min + bus_min\n    print(total_min)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 11.729687690734863}
{"eval_index": 437, "problem_id": 2407, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    idx = 0\n    q = int(input_data[idx]); idx += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(input_data[idx]); idx += 1\n        r = int(input_data[idx]); idx += 1\n        positions = list(map(int, input_data[idx:idx+n])); idx += n\n        \n        # Remove duplicates and sort in descending order\n        unique_pos = sorted(set(positions), reverse=True)\n        \n        missiles = 0\n        # Simulate optimal strategy: shoot at the largest remaining position\n        for i, pos in enumerate(unique_pos):\n            # Each missile pushes monsters to the left by r\n            # After i missiles, the position would be pos - i * r\n            # If it's <= 0, it would have been killed by trap earlier\n            # So we count missiles until all are pushed left of origin\n            if pos - missiles * r > 0:\n                missiles += 1\n            else:\n                break\n        \n        results.append(str(missiles))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 24.350741624832153}
{"eval_index": 438, "problem_id": 3517, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 119.78182768821716}
{"eval_index": 439, "problem_id": 4321, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n, k = map(int, input().split())\n    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    print(n)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 10.483407020568848}
{"eval_index": 440, "problem_id": 2500, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 154.2079679965973}
{"eval_index": 441, "problem_id": 3481, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 121.22866463661194}
{"eval_index": 442, "problem_id": 4005, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 126.4060480594635}
{"eval_index": 443, "problem_id": 37, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    \n    # Check if c is divisible by gcd(a, b)\n    import math\n    g = math.gcd(a, b)\n    if c % g != 0:\n        print(\"No\")\n        return\n    \n    # Check if there exist non-negative integers x, y such that a*x + b*y = c\n    # This is a linear Diophantine equation\n    # We can check by trying x from 0 to c//a\n    for x in range(c // a + 1):\n        remaining = c - a * x\n        if remaining >= 0 and remaining % b == 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 22.724870443344116}
{"eval_index": 444, "problem_id": 3888, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 131.20194840431213}
{"eval_index": 445, "problem_id": 4374, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.26627111434937}
{"eval_index": 446, "problem_id": 2439, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 96.51530170440674}
{"eval_index": 447, "problem_id": 3950, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.6028380393982}
{"eval_index": 448, "problem_id": 4840, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read Gunnar's dice\n    a1, b1, a2, b2 = read_ints()\n    # Read Emma's dice\n    a3, b3, a4, b4 = read_ints()\n    \n    # Calculate expected sum for each player\n    # For a die with numbers a to b, expected value is (a + b) / 2\n    gunnar_expected = (a1 + b1) / 2 + (a2 + b2) / 2\n    emma_expected = (a3 + b3) / 2 + (a4 + b4) / 2\n    \n    # Compare expected values\n    if gunnar_expected > emma_expected:\n        print(\"Gunnar\")\n    elif emma_expected > gunnar_expected:\n        print(\"Emma\")\n    else:\n        print(\"Tie\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.101784467697144}
{"eval_index": 449, "problem_id": 1074, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 104.80504703521729}
{"eval_index": 450, "problem_id": 3709, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 112.53203535079956}
{"eval_index": 451, "problem_id": 4724, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R = int(data[0])\n    G = int(data[1])\n    # From formula: G = (R + b) / 2\n    # So b = 2*G - R\n    performance = 2 * G - R\n    print(performance)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 13.148965835571289}
{"eval_index": 452, "problem_id": 299, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    chest_total = 0\n    biceps_total = 0\n    back_total = 0\n    \n    for i in range(n):\n        if i % 3 == 0:\n            chest_total += a[i]\n        elif i % 3 == 1:\n            biceps_total += a[i]\n        else:\n            back_total += a[i]\n    \n    max_total = max(chest_total, biceps_total, back_total)\n    \n    if max_total == chest_total:\n        print(\"chest\")\n    elif max_total == biceps_total:\n        print(\"biceps\")\n    else:\n        print(\"back\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.907301664352417}
{"eval_index": 453, "problem_id": 3597, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.39373588562012}
{"eval_index": 454, "problem_id": 4182, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    N, M, X, Y = map(int, data[:4])\n    x_list = list(map(int, data[4:4+N]))\n    y_list = list(map(int, data[4+N:4+N+M]))\n    \n    # Find maximum x and minimum y\n    max_x = max(x_list)\n    min_y = min(y_list)\n    \n    # Check if there exists integer Z satisfying conditions\n    # Conditions: X < Z <= Y, all x_i < Z, all y_i >= Z\n    # This is equivalent to: max_x < Z <= min_y and X < Z <= Y\n    # So we need integer Z where max_x < Z <= min_y and X < Z <= Y\n    \n    # Find lower bound for Z\n    lower_bound = max(X, max_x)\n    \n    # Find upper bound for Z\n    upper_bound = min(Y, min_y)\n    \n    # Check if there exists integer Z such that lower_bound < Z <= upper_bound\n    # Since Z must be strictly greater than lower_bound and <= upper_bound\n    if lower_bound < upper_bound:\n        # There exists at least one integer between lower_bound and upper_bound\n        # For example, Z = lower_bound + 1 if it's <= upper_bound\n        print(\"No War\")\n    else:\n        print(\"War\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 47.942421197891235}
{"eval_index": 455, "problem_id": 1235, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 45.002169132232666}
{"eval_index": 456, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.79249835014343}
{"eval_index": 457, "problem_id": 4400, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    S = input().strip()\n    max_consecutive = 0\n    current_consecutive = 0\n    \n    for char in S:\n        if char == 'R':\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    \n    print(max_consecutive)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 10.126531839370728}
{"eval_index": 458, "problem_id": 2264, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        max_l = -float('inf')\n        min_r = float('inf')\n        for _ in range(n):\n            l = int(next(it))\n            r = int(next(it))\n            max_l = max(max_l, l)\n            min_r = min(min_r, r)\n        # The minimal segment that intersects all is [max_l, min_r] if max_l <= min_r\n        # Otherwise, we need to find the minimal extra length to cover the gap\n        if max_l <= min_r:\n            out_lines.append('0')\n        else:\n            # The minimal length needed is the distance between max_l and min_r\n            out_lines.append(str(max_l - min_r))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 20.845752239227295}
{"eval_index": 459, "problem_id": 3825, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 155.42348432540894}
{"eval_index": 460, "problem_id": 4378, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 61.27439856529236}
{"eval_index": 461, "problem_id": 2480, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # We need count of subsequences where (sum % K) == (length % K)\n    # Let prefix_sum[i] = sum(A[0..i-1]) % K\n    # For subsequence A[l..r] (0-indexed, inclusive):\n    #   length = r - l + 1\n    #   sum_mod = (prefix_sum[r+1] - prefix_sum[l]) % K\n    # Condition: sum_mod == (r - l + 1) % K\n    # Rearranging: (prefix_sum[r+1] - (r+1) % K) % K == (prefix_sum[l] - l % K) % K\n    # Let B[i] = (prefix_sum[i] - i % K) % K for i from 0 to N\n    # Then we need pairs (l, r) with 0 <= l < r <= N such that B[l] == B[r]\n    # and r - l < K (since length must be < K for modulo condition to match)\n    \n    prefix_mod = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_mod[i] = (prefix_mod[i-1] + A[i-1]) % K\n    \n    B = [0] * (N + 1)\n    for i in range(N + 1):\n        B[i] = (prefix_mod[i] - (i % K)) % K\n    \n    # Sliding window count of B values for indices within K-1 distance\n    from collections import defaultdict\n    count_map = defaultdict(int)\n    ans = 0\n    \n    # Process first K indices (0 to min(K-1, N))\n    window_size = K - 1  # maximum allowed length is K-1\n    for i in range(min(K, N + 1)):\n        ans += count_map[B[i]]\n        count_map[B[i]] += 1\n    \n    # Slide window: remove leftmost when window exceeds K-1 length\n    for i in range(K, N + 1):\n        # Remove element that's now outside window\n        left_idx = i - K\n        count_map[B[left_idx]] -= 1\n        # Add current element\n        ans += count_map[B[i]]\n        count_map[B[i]] += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 33.965134143829346}
{"eval_index": 462, "problem_id": 3271, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef count_sequences(N, C):\n    if C < 0 or C > N*(N-1)//2:\n        return 0\n    \n    # dp[i][j] = number of permutations of length i with exactly j inversions\n    dp = [[0]*(C+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N+1):\n        # For length i, maximum inversions is i*(i-1)//2\n        max_inv = min(C, i*(i-1)//2)\n        prefix = [0]*(C+2)\n        \n        # Build prefix sums for previous row\n        for j in range(C+1):\n            prefix[j+1] = (prefix[j] + dp[i-1][j]) % MOD\n        \n        for j in range(max_inv+1):\n            # dp[i][j] = sum_{k=0}^{min(j, i-1)} dp[i-1][j-k]\n            # where k is number of inversions created by inserting i at position\n            min_k = max(0, j - (i-1))\n            max_k = min(j, i-1)\n            dp[i][j] = (prefix[j+1] - prefix[min_k]) % MOD\n            if dp[i][j] < 0:\n                dp[i][j] += MOD\n    \n    return dp[N][C] % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    C = int(data[1])\n    result = count_sequences(N, C)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 27.25507140159607}
{"eval_index": 463, "problem_id": 4267, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "X = int(input())\nif X >= 30:\n    print('Yes')\nelse:\n    print('No')", "complexity_estimate": null, "runtime_sec": 7.34957218170166}
{"eval_index": 464, "problem_id": 2849, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 149.82834482192993}
{"eval_index": 465, "problem_id": 3164, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 95.85231757164001}
{"eval_index": 466, "problem_id": 4019, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 143.35572910308838}
{"eval_index": 467, "problem_id": 1399, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.51103520393372}
{"eval_index": 468, "problem_id": 3272, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 172.8576090335846}
{"eval_index": 469, "problem_id": 4220, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    S = data[1]\n    if len(S) <= K:\n        print(S)\n    else:\n        print(S[:K] + \"...\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 9.870085954666138}
{"eval_index": 470, "problem_id": 1290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    cols = list(map(int, data[2:2+m]))\n    \n    # Track count of squares in each column\n    counts = [0] * (n + 1)  # 1-indexed for convenience\n    points = 0\n    \n    for c in cols:\n        counts[c] += 1\n        # Check if all columns have at least one square\n        if all(counts[i] > 0 for i in range(1, n+1)):\n            points += 1\n            # Remove one from each column\n            for i in range(1, n+1):\n                counts[i] -= 1\n    \n    print(points)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 17.52068591117859}
{"eval_index": 471, "problem_id": 3155, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 114.26854109764099}
{"eval_index": 472, "problem_id": 4372, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Find the maximum value in a\n    max_a = max(a)\n    \n    # Calculate total swords taken from each type\n    taken = [max_a - ai for ai in a]\n    \n    # Find the greatest common divisor of all positive taken values\n    g = 0\n    for val in taken:\n        if val > 0:\n            g = math.gcd(g, val)\n    \n    # If all taken values are 0, then no theft occurred\n    if g == 0:\n        print(\"0 0\")\n        return\n    \n    # Calculate total swords taken\n    total_taken = sum(taken)\n    \n    # Minimum number of people y = total_taken // g\n    y = total_taken // g\n    \n    # Number of swords each person took z = g\n    z = g\n    \n    print(f\"{y} {z}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 25.050435304641724}
{"eval_index": 473, "problem_id": 953, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 74.87487626075745}
{"eval_index": 474, "problem_id": 3915, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 86.47425270080566}
{"eval_index": 475, "problem_id": 4333, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    x1, y1, x2, y2 = map(int, sys.stdin.read().split())\n    \n    # Calculate vector from (x1,y1) to (x2,y2)\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Rotate vector 90 degrees counter-clockwise to get (x3,y3)\n    # (x3,y3) = (x2,y2) + rotated vector\n    x3 = x2 - dy\n    y3 = y2 + dx\n    \n    # Rotate vector 90 degrees counter-clockwise again to get (x4,y4)\n    # (x4,y4) = (x3,y3) + rotated vector (or directly from (x1,y1))\n    x4 = x3 - dx\n    y4 = y3 - dy\n    \n    print(f\"{x3} {y3} {x4} {y4}\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 20.5685453414917}
{"eval_index": 476, "problem_id": 801, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.70260548591614}
{"eval_index": 477, "problem_id": 3180, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 83.56558275222778}
{"eval_index": 478, "problem_id": 4861, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 79.26638889312744}
{"eval_index": 479, "problem_id": 1765, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 64.23425579071045}
{"eval_index": 480, "problem_id": 3381, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 156.0543282032013}
{"eval_index": 481, "problem_id": 4893, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 89.70285367965698}
{"eval_index": 482, "problem_id": 297, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 100.39931225776672}
{"eval_index": 483, "problem_id": 3456, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 179.33232021331787}
{"eval_index": 484, "problem_id": 4368, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    K = int(data[1])\n    \n    # Handle edge case: N=0 would have 1 digit in any base K>=2\n    # But constraints say N>=1, so we don't need special handling for 0\n    \n    count = 0\n    while N > 0:\n        N //= K\n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 14.585646629333496}
{"eval_index": 485, "problem_id": 592, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 178.3605601787567}
{"eval_index": 486, "problem_id": 3822, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 141.5230414867401}
{"eval_index": 487, "problem_id": 4911, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split('\\n')\n    if not data:\n        return\n    \n    # Parse attributes\n    attributes = data[0].split()\n    attr_index = {attr: i for i, attr in enumerate(attributes)}\n    \n    # Parse songs\n    m = int(data[1])\n    songs = []\n    for i in range(m):\n        song_data = data[2 + i].split()\n        songs.append(song_data)\n    \n    # Parse sort commands\n    n = int(data[2 + m])\n    sort_commands = []\n    for i in range(n):\n        sort_commands.append(data[3 + m + i].strip())\n    \n    # Process each sort command\n    output_lines = []\n    for sort_attr in sort_commands:\n        # Print header\n        output_lines.append(' '.join(attributes))\n        \n        # Stable sort using the current attribute\n        sort_idx = attr_index[sort_attr]\n        songs.sort(key=lambda x: x[sort_idx])\n        \n        # Print sorted songs\n        for song in songs:\n            output_lines.append(' '.join(song))\n        \n        # Add blank line between outputs (except after last)\n        if sort_attr != sort_commands[-1]:\n            output_lines.append('')\n    \n    sys.stdout.write('\\n'.join(output_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 21.5849289894104}
{"eval_index": 488, "problem_id": 1037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 165.0861279964447}
{"eval_index": 489, "problem_id": 3539, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 117.02470302581787}
{"eval_index": 490, "problem_id": 4822, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    R, S, K = map(int, data[:3])\n    grid = data[3:]\n    \n    # Precompute prefix sums for flies\n    prefix = [[0] * (S + 1) for _ in range(R + 1)]\n    for i in range(R):\n        for j in range(S):\n            prefix[i + 1][j + 1] = prefix[i + 1][j] + prefix[i][j + 1] - prefix[i][j] + (1 if grid[i][j] == '*' else 0)\n    \n    max_kills = 0\n    best_top_left = (0, 0)\n    \n    # The inner area of the racket is K-2 x K-2\n    inner_size = K - 2\n    \n    for i in range(R - K + 1):\n        for j in range(S - K + 1):\n            # Calculate flies in inner area\n            inner_kills = prefix[i + inner_size + 1][j + inner_size + 1] - prefix[i + 1][j + inner_size + 1] - prefix[i + inner_size + 1][j + 1] + prefix[i + 1][j + 1]\n            if inner_kills > max_kills:\n                max_kills = inner_kills\n                best_top_left = (i, j)\n    \n    # Output max kills\n    print(max_kills)\n    \n    # Create output grid\n    output_grid = [list(row) for row in grid]\n    top, left = best_top_left\n    \n    # Draw racket borders\n    for i in range(K):\n        for j in range(K):\n            if i == 0 or i == K - 1:\n                if j == 0 or j == K - 1:\n                    output_grid[top + i][left + j] = '+'\n                else:\n                    output_grid[top + i][left + j] = '-'\n            elif j == 0 or j == K - 1:\n                output_grid[top + i][left + j] = '|'\n    \n    # Print result\n    for row in output_grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 30.65401840209961}
{"eval_index": 491, "problem_id": 671, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def find_nth_digit(n):\n    # Handle single-digit numbers (1-9)\n    if n <= 9:\n        return str(n)\n    \n    # Subtract digits used by single-digit numbers\n    n -= 9\n    length = 2  # Start with 2-digit numbers\n    start = 10  # First 2-digit number\n    \n    while True:\n        # Total digits contributed by numbers with current length\n        count = 9 * (10 ** (length - 1)) * length\n        \n        if n <= count:\n            # Find which number contains the n-th digit\n            offset = (n - 1) // length\n            number = start + offset\n            \n            # Find which digit within the number\n            digit_index = (n - 1) % length\n            return str(number)[digit_index]\n        \n        # Move to next length\n        n -= count\n        length += 1\n        start *= 10\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(find_nth_digit(n))", "complexity_estimate": null, "runtime_sec": 22.578498601913452}
{"eval_index": 492, "problem_id": 3712, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 163.36744236946106}
{"eval_index": 493, "problem_id": 4975, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef create_playfair_table(key_phrase):\n    \"\"\"Create 5x5 Playfair table from key phrase\"\"\"\n    # Remove spaces and convert to uppercase\n    key = key_phrase.replace(' ', '').upper()\n    \n    # Create table with unique letters from key\n    table = []\n    used = set()\n    \n    for ch in key:\n        if ch not in used:\n            table.append(ch)\n            used.add(ch)\n    \n    # Add remaining letters (except Q)\n    for ch in 'ABCDEFGHIJKLMNOPRSTUVWXYZ':\n        if ch not in used:\n            table.append(ch)\n            used.add(ch)\n    \n    # Convert to 5x5 grid\n    grid = [table[i:i+5] for i in range(0, 25, 5)]\n    return grid\n\ndef find_position(grid, ch):\n    \"\"\"Find row and column of character in grid\"\"\"\n    for i in range(5):\n        for j in range(5):\n            if grid[i][j] == ch:\n                return i, j\n    return -1, -1  # Should never happen\n\ndef prepare_text(text):\n    \"\"\"Prepare text for encryption: remove spaces, uppercase, handle duplicates\"\"\"\n    # Remove spaces and convert to uppercase\n    text = text.replace(' ', '').upper()\n    \n    # Process text to form digraphs\n    result = []\n    i = 0\n    while i < len(text):\n        if i == len(text) - 1:\n            # Last single character\n            result.append(text[i] + 'X')\n            i += 1\n        elif text[i] == text[i+1]:\n            # Same letters\n            result.append(text[i] + 'X')\n            i += 1\n        else:\n            # Normal pair\n            result.append(text[i] + text[i+1])\n            i += 2\n    \n    return result\n\ndef encrypt_digraph(grid, digraph):\n    \"\"\"Encrypt a single digraph using Playfair rules\"\"\"\n    a, b = digraph[0], digraph[1]\n    row1, col1 = find_position(grid, a)\n    row2, col2 = find_position(grid, b)\n    \n    if row1 == row2:\n        # Same row: shift right\n        return grid[row1][(col1 + 1) % 5] + grid[row2][(col2 + 1) % 5]\n    elif col1 == col2:\n        # Same column: shift down\n        return grid[(row1 + 1) % 5][col1] + grid[(row2 + 1) % 5][col2]\n    else:\n        # Rectangle swap\n        return grid[row1][col2] + grid[row2][col1]\n\ndef main():\n    # Read input\n    key_phrase = sys.stdin.readline().strip()\n    plaintext = sys.stdin.readline().strip()\n    \n    # Create Playfair table\n    grid = create_playfair_table(key_phrase)\n    \n    # Prepare text into digraphs\n    digraphs = prepare_text(plaintext)\n    \n    # Encrypt each digraph\n    encrypted = []\n    for digraph in digraphs:\n        encrypted.append(encrypt_digraph(grid, digraph))\n    \n    # Output result\n    print(''.join(encrypted))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 42.6134729385376}
{"eval_index": 494, "problem_id": 2173, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Pair each rating with its original index\n    indexed = [(a[i], i) for i in range(n)]\n    # Sort by desired rating\n    indexed.sort()\n    \n    b = [0] * n\n    current = 0\n    \n    for desired, idx in indexed:\n        if desired > current:\n            current = desired\n        b[idx] = current\n        current += 1\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 15.60703992843628}
{"eval_index": 495, "problem_id": 3930, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    arr = [int(next(it)) for _ in range(n)]\n    \n    # Precompute prefix sums\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + arr[i]\n    \n    # Generate all possible powers of k that could appear as segment sums\n    powers = set()\n    if k == 1:\n        powers.add(1)\n    elif k == -1:\n        powers.add(1)\n        powers.add(-1)\n    else:\n        val = 1\n        # Bound: maximum absolute segment sum is n * max|a_i| = 10^5 * 10^9 = 10^14\n        # For |k| >= 2, k^p grows quickly, so we only need a few powers\n        while abs(val) <= 10**15:\n            powers.add(val)\n            val *= k\n    \n    # Count valid segments using a frequency map of prefix sums\n    from collections import defaultdict\n    freq = defaultdict(int)\n    freq[0] = 1  # empty prefix\n    ans = 0\n    \n    for i in range(1, n + 1):\n        current_prefix = prefix[i]\n        for p in powers:\n            target = current_prefix - p\n            ans += freq.get(target, 0)\n        freq[current_prefix] += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 38.04867148399353}
{"eval_index": 496, "problem_id": 4813, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input\n    word = sys.stdin.readline().strip()\n    permutation = sys.stdin.readline().strip()\n    \n    # Convert word to set of unique letters\n    word_letters = set(word)\n    \n    # Initialize counters\n    wrong_guesses = 0\n    max_wrong = 10\n    guessed_correctly = set()\n    \n    # Iterate through permutation\n    for letter in permutation:\n        if letter in word_letters:\n            guessed_correctly.add(letter)\n            # Check if all letters guessed\n            if guessed_correctly == word_letters:\n                print(\"WIN\")\n                return\n        else:\n            wrong_guesses += 1\n            if wrong_guesses == max_wrong:\n                print(\"LOSE\")\n                return\n    \n    # If loop completes without returning (shouldn't happen with full alphabet)\n    print(\"LOSE\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 17.244404077529907}
{"eval_index": 497, "problem_id": 1841, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    a = [int(next(it)) for _ in range(n)]\n    queries = [int(next(it)) for _ in range(m)]\n    \n    # Preprocess distinct counts from each position to the end\n    distinct_from = [0] * (n + 2)  # 1-indexed for convenience, with extra at n+1\n    seen = set()\n    \n    # Process from right to left\n    for i in range(n, 0, -1):\n        seen.add(a[i-1])  # a is 0-indexed\n        distinct_from[i] = len(seen)\n    \n    # Answer queries\n    out_lines = []\n    for l in queries:\n        out_lines.append(str(distinct_from[l]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 18.212344884872437}
{"eval_index": 498, "problem_id": 3982, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 105.29044032096863}
{"eval_index": 499, "problem_id": 4958, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = list(map(int, sys.stdin.read().split()))\n    if len(data) < 8:\n        return\n    \n    boxes = data[:6]\n    towers = data[6:8]\n    \n    # Sort boxes in descending order\n    boxes_sorted = sorted(boxes, reverse=True)\n    \n    # Try all combinations of 3 boxes for first tower\n    from itertools import combinations\n    \n    for combo in combinations(boxes_sorted, 3):\n        if sum(combo) == towers[0]:\n            # Found first tower\n            first_tower = sorted(combo, reverse=True)\n            \n            # Second tower is remaining boxes\n            remaining = list(boxes_sorted)\n            for box in combo:\n                remaining.remove(box)\n            second_tower = sorted(remaining, reverse=True)\n            \n            # Verify second tower sum matches\n            if sum(second_tower) == towers[1]:\n                # Output in required format\n                result = first_tower + second_tower\n                print(' '.join(map(str, result)))\n                return\n    \n    # Should never reach here with valid input\n    print(\"No solution found\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 26.076499462127686}

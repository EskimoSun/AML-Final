{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 276.7501583099365}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 390.93289613723755}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 162.62264943122864}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.height = 0\n\ndef insert(root, value, depth, total_depth):\n    if root is None:\n        return Node(value), depth, total_depth + depth\n    \n    if value < root.value:\n        root.left, depth, total_depth = insert(root.left, value, depth + 1, total_depth)\n    else:\n        root.right, depth, total_depth = insert(root.right, value, depth + 1, total_depth)\n    \n    return root, depth, total_depth\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    values = list(map(int, data[1:1+n]))\n    \n    root = None\n    total_depth = 0\n    results = []\n    \n    for value in values:\n        if root is None:\n            root = Node(value)\n            results.append(str(total_depth))\n        else:\n            _, depth, total_depth = insert(root, value, 0, total_depth)\n            results.append(str(total_depth))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 145.57780146598816}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 463.9862720966339}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy one cake\n    remaining = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining // B\n    remaining -= donuts_count * B\n    \n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 178.14542078971863}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 303.8722286224365}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    m = int(input().strip())\n    queries = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Step 1: Sort indices by value (descending) and then by index (ascending)\n    indices = list(range(n))\n    indices.sort(key=lambda i: (-a[i], i))\n    \n    # Step 2: Preprocess for each k: store the indices of the optimal subsequence\n    # We'll store for each k the sorted list of indices of the optimal subsequence\n    optimal_indices = {}\n    # We'll process queries sorted by k to reuse results\n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][0])\n    \n    # Current selected indices for the largest k processed so far\n    selected = []\n    last_k = 0\n    \n    answers = [0] * m\n    \n    for query_idx, (k, pos) in sorted_queries:\n        if k != last_k:\n            # Need to update selected indices for this k\n            # For optimal subsequence of length k:\n            # Take first k elements from sorted indices (by value desc, index asc)\n            # Then sort these k indices by their original position\n            selected = indices[:k]\n            selected.sort()\n            last_k = k\n        \n        # Get the element at position pos (1-based) in the optimal subsequence\n        answers[query_idx] = a[selected[pos-1]]\n    \n    # Output answers in original query order\n    sys.stdout.write('\\n'.join(map(str, answers)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 353.0099856853485}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 2192.894996881485}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 183.79708814620972}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 373.56912088394165}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 249.08144783973694}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 238.9859573841095}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    lengths = [int(next(it)) for _ in range(n)]\n    costs = [int(next(it)) for _ in range(n)]\n    \n    # Compute gcd of all lengths\n    g = 0\n    for l in lengths:\n        g = math.gcd(g, l)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting point: gcd 0 (no cards selected)\n    \n    for i in range(n):\n        l, c = lengths[i], costs[i]\n        new_dp = dp.copy()\n        for g_val, cost in dp.items():\n            new_g = math.gcd(g_val, l)\n            new_cost = cost + c\n            if new_cost < new_dp[new_g]:\n                new_dp[new_g] = new_cost\n        dp = new_dp\n    \n    result = dp.get(1, float('inf'))\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 508.8194737434387}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Compare required time (D/S) with available time T\n    # Use integer comparison to avoid floating-point issues\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 661.6732912063599}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 208.79954290390015}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 187.09331798553467}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find player start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to explore safe reachable area\n    visited = [[False] * W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while queue:\n        r, c = queue.pop(0)\n        # Collect gold if present\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        has_adjacent_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 'T':\n                has_adjacent_trap = True\n                break\n        \n        # If adjacent to trap, don't explore further from this cell\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] != '#':\n                visited[nr][nc] = True\n                queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 111.39885759353638}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 279.96497344970703}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 278.5429711341858}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 173.53481340408325}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 211.1940233707428}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    operations = 0\n    current = 0\n    \n    for i in range(n):\n        current += diff[i]\n        needed = max(0, target - (heights[i] + current))\n        if needed > 0:\n            operations += needed\n            if operations > m:\n                return False\n            current += needed\n            # Mark the end of the watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    return operations <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(high)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 345.7857732772827}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 137.8693552017212}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 281.3075532913208}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 235.07179713249207}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 158.06296467781067}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245050 tokens (243450 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 14.221925258636475}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of the 4 bags\n    for mask in range(1, 16):  # 1 to 15 (2^4-1)\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2856.3496441841125}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    seen = set()\n    result = []\n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            result.append(arr[i])\n            seen.add(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1151.8841693401337}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 206.58132529258728}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to calculate final score given fifth time\n    def calculate_final(fifth):\n        all_times = times + [fifth]\n        sorted_times = sorted(all_times)\n        # Discard best (smallest) and worst (largest)\n        middle_three = sorted_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Check if already winning with worst possible fifth time (20.00)\n    worst_fifth = 20.0\n    if calculate_final(worst_fifth) <= target:\n        print(\"infinite\")\n        return\n    \n    # Check if impossible with best possible fifth time (1.00)\n    best_fifth = 1.0\n    if calculate_final(best_fifth) > target:\n        print(\"impossible\")\n        return\n    \n    # Binary search for the maximum fifth time that still meets target\n    lo, hi = 1.0, 20.0\n    for _ in range(100):  # Sufficient precision for 2 decimal places\n        mid = (lo + hi) / 2.0\n        if calculate_final(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to 2 decimal places\n    result = round(lo, 2)\n    # Ensure proper formatting with exactly 2 decimal places\n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 152.11084842681885}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 337.64481925964355}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 315.75062561035156}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\n# Fast I/O\ninput = sys.stdin.readline\n\n# Read N\nN = int(input().strip())\n\n# Read initial strings\nstrings = [input().strip() for _ in range(N)]\n\n# Read operations\noperations = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\n# Track which strings are still active (not emptied)\nactive = [True] * N\n\n# Process operations\nfor a, b in operations:\n    # Convert to 0-based indexing\n    a_idx, b_idx = a - 1, b - 1\n    \n    # Append string b to string a\n    strings[a_idx] += strings[b_idx]\n    \n    # Empty string b\n    strings[b_idx] = \"\"\n    active[b_idx] = False\n\n# Find the only remaining non-empty string\nfor i in range(N):\n    if active[i]:\n        print(strings[i])\n        break", "complexity_estimate": null, "runtime_sec": 101.02641725540161}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data[:2])\n    # Total cost = train fare + half of bus fare\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 376.52703070640564}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    lines = data[1:]\n    \n    # Stack to track events that have actually happened\n    event_stack = []\n    # Set of events that are currently considered to have happened\n    happened_set = set()\n    # List to store output lines\n    output = []\n    \n    for line in lines:\n        parts = line.split()\n        if not parts:\n            continue\n        \n        if parts[0] == 'E':\n            # Event happens\n            event = parts[1]\n            event_stack.append(event)\n            happened_set.add(event)\n            \n        elif parts[0] == 'D':\n            # Dream: remove last r events\n            r = int(parts[1])\n            for _ in range(r):\n                if event_stack:\n                    removed_event = event_stack.pop()\n                    happened_set.remove(removed_event)\n            \n        elif parts[0] == 'S':\n            # Scenario\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current state\n            consistent = True\n            for event_spec in scenario_events:\n                if event_spec.startswith('!'):\n                    # Event should NOT have happened\n                    event_name = event_spec[1:]\n                    if event_name in happened_set:\n                        consistent = False\n                        break\n                else:\n                    # Event should have happened\n                    if event_spec not in happened_set:\n                        consistent = False\n                        break\n            \n            if consistent:\n                output.append(\"Yes\")\n                continue\n            \n            # If not consistent, check if adding a dream before scenario would make it consistent\n            # We need to find smallest r such that removing last r events makes scenario consistent\n            min_r = None\n            \n            # Create a copy of current state to simulate dreams\n            temp_stack = event_stack.copy()\n            temp_set = happened_set.copy()\n            \n            # Try removing 1, 2, ... events until we find consistency or run out of events\n            for r in range(1, len(temp_stack) + 1):\n                # Remove last r events\n                for _ in range(r):\n                    if temp_stack:\n                        removed = temp_stack.pop()\n                        temp_set.remove(removed)\n                \n                # Check consistency with this dream\n                dream_consistent = True\n                for event_spec in scenario_events:\n                    if event_spec.startswith('!'):\n                        event_name = event_spec[1:]\n                        if event_name in temp_set:\n                            dream_consistent = False\n                            break\n                    else:\n                        if event_spec not in temp_set:\n                            dream_consistent = False\n                            break\n                \n                if dream_consistent:\n                    min_r = r\n                    break\n                \n                # Reset for next iteration\n                temp_stack = event_stack.copy()\n                temp_set = happened_set.copy()\n            \n            if min_r is not None:\n                output.append(f\"{min_r} Just A Dream\")\n            else:\n                output.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 119.77486419677734}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213627 tokens (212027 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 12.96770977973938}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "def solve():\n    P, Q, R = map(int, input().split())\n    # The route consists of two flights between three airports.\n    # Since flights exist between all pairs, we can choose any two edges from the triangle.\n    # The minimum sum is the sum of the two smallest flight times.\n    times = [P, Q, R]\n    times.sort()\n    print(times[0] + times[1])\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 569.3944714069366}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 270.56750082969666}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 433.6476719379425}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 103.9908618927002}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 239.25950574874878}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 243.17509412765503}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    X = int(next(it))\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(next(it))\n        # Count days when participant eats chocolate\n        # Days: 1, A+1, 2A+1, ... while <= D\n        day = 1\n        while day <= D:\n            total_eaten += 1\n            day += A\n    \n    # Initial chocolate = eaten + remaining\n    initial = total_eaten + X\n    print(initial)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 252.7535970211029}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 384.16326665878296}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 428.45144534111023}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 363.79980969429016}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 281.1064977645874}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1276.0374200344086}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            result.append(x - 1)\n        else:\n            result.append(x)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 423.1057941913605}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    thore_index = -1\n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_index = i\n            break\n    \n    # Case 1: Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check names above Thore\n    above_names = names[:thore_index]\n    \n    # Case 2: Check if any name above has prefix \"ThoreHusfeld\" (without trailing 't')\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Case 3: Find smallest unique prefix\n    thore_name = \"ThoreHusfeldt\"\n    for prefix_len in range(1, len(thore_name) + 1):\n        prefix = thore_name[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Should never reach here given problem constraints\n    print(thore_name)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 187.16126155853271}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 332.7339720726013}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 557.2109570503235}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 238.44633650779724}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 238.1295826435089}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 186.9883360862732}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 338.21859669685364}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 237.2999291419983}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive_time, calm_time):\n    \"\"\"Return True if arrival falls within aggressive period.\"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival % cycle_length\n    # Aggressive period is from 0 to aggressive_time-1 (0-indexed minutes)\n    return position_in_cycle < aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: problem states \"during the nth minute\" means 0-indexed\n    arrivals = [P-1, M-1, G-1]\n    \n    results = []\n    for arrival in arrivals:\n        dog1_agg = is_aggressive(arrival, A, B)\n        dog2_agg = is_aggressive(arrival, C, D)\n        \n        if dog1_agg and dog2_agg:\n            results.append(\"both\")\n        elif dog1_agg or dog2_agg:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 105.56093311309814}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror-symmetric letters\n    mirror_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'}\n    \n    # Check each character and its mirror position\n    n = len(word)\n    for i in range(n // 2 + 1):\n        left = word[i]\n        right = word[n - 1 - i]\n        \n        # Both characters must be mirror-symmetric AND equal\n        if left not in mirror_letters or right not in mirror_letters:\n            return False\n        if left != right:\n            return False\n    \n    return True\n\ndef main():\n    # Read input (strip newline)\n    word = sys.stdin.readline().strip()\n    \n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 2746.707935333252}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 202.70221829414368}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    a_score = 0\n    b_score = 0\n    i = 0\n    while i < len(s):\n        player = s[i]\n        points = int(s[i+1])\n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        i += 2\n        # Check win conditions\n        if a_score >= 11 and a_score - b_score >= 2:\n            return 'A'\n        if b_score >= 11 and b_score - a_score >= 2:\n            return 'B'\n        if a_score == 10 and b_score == 10:\n            # Win by 2 rule activated\n            while True:\n                if i >= len(s):\n                    break\n                player = s[i]\n                points = int(s[i+1])\n                if player == 'A':\n                    a_score += points\n                else:\n                    b_score += points\n                i += 2\n                if a_score - b_score >= 2:\n                    return 'A'\n                if b_score - a_score >= 2:\n                    return 'B'\n    # Should never reach here for valid input\n    return 'A' if a_score > b_score else 'B'\n\nif __name__ == \"__main__\":\n    print(solve())", "complexity_estimate": null, "runtime_sec": 103.29532432556152}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 334.9009087085724}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1557.016788482666}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Map values to indices 0-5 for easier counting\n    value_to_idx = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Counters for how many of each element we can use in sequences\n    counts = [0, 0, 0, 0, 0, 0]\n    \n    for val in arr:\n        idx = value_to_idx[val]\n        if idx == 0:\n            # First element of sequence\n            counts[0] += 1\n        else:\n            # Can only use this element if we have previous element available\n            if counts[idx-1] > 0:\n                counts[idx-1] -= 1\n                counts[idx] += 1\n    \n    # The number of complete sequences formed is counts[5]\n    # Each complete sequence has 6 elements\n    good_elements = counts[5] * 6\n    removed = n - good_elements\n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 303.0608596801758}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123795 tokens (2122195 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 22.376970767974854}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 327.9576241970062}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 321.04987144470215}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 276.3666989803314}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 193.0586326122284}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller count of chips that need to change parity\n    result = min(even_count, odd_count)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1678.5762243270874}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    if n < 5:\n        print(0)\n        return\n    \n    suffixes = set()\n    \n    # Check all possible splits where root length >= 5 and suffixes are length 2 or 3\n    # We need to find all possible suffix strings that can appear at the end\n    # The word is constructed as: root + suffix1 + suffix2 + ... + suffixk\n    # where each suffix is length 2 or 3, and no two consecutive suffixes are identical\n    \n    # We'll use dynamic programming to track possible states\n    # dp[i] = set of possible last suffix strings ending at position i\n    # We'll work backwards from the end\n    \n    # Initialize dp array\n    dp = [set() for _ in range(n + 1)]\n    dp[n].add('')  # Empty string at the end\n    \n    # Work backwards from the end\n    for i in range(n - 1, -1, -1):\n        # Check if we can have a suffix of length 2 starting at i\n        if i + 2 <= n:\n            suffix2 = s[i:i+2]\n            # Check if this could be a valid suffix\n            # It's valid if after this suffix, we're at the root or at another valid suffix\n            for last_suffix in dp[i+2]:\n                if last_suffix != suffix2:  # No two consecutive identical suffixes\n                    dp[i].add(suffix2)\n        \n        # Check if we can have a suffix of length 3 starting at i\n        if i + 3 <= n:\n            suffix3 = s[i:i+3]\n            for last_suffix in dp[i+3]:\n                if last_suffix != suffix3:  # No two consecutive identical suffixes\n                    dp[i].add(suffix3)\n    \n    # Now collect all suffixes that can appear\n    # A suffix is valid if it can appear starting at some position i where i >= 5 (root length >= 5)\n    # and it leads to a valid decomposition\n    for i in range(5, n):  # i is the start position of the suffix\n        # Check suffix of length 2\n        if i + 2 <= n:\n            suffix2 = s[i:i+2]\n            if suffix2 in dp[i]:\n                suffixes.add(suffix2)\n        \n        # Check suffix of length 3\n        if i + 3 <= n:\n            suffix3 = s[i:i+3]\n            if suffix3 in dp[i]:\n                suffixes.add(suffix3)\n    \n    # Sort and output\n    result = sorted(suffixes)\n    print(len(result))\n    for suffix in result:\n        print(suffix)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1300.6831216812134}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # water[i] stores current water in vessel i+1\n    water = [0] * n\n    \n    # For each vessel, find the next vessel that is not full after overflow\n    # Initially, each vessel overflows to the next one\n    next_vessel = list(range(1, n + 1))  # 1-based, n+1 means floor\n    \n    out_lines = []\n    \n    for _ in range(m):\n        query_type = int(next(it))\n        if query_type == 1:\n            p = int(next(it)) - 1  # 0-based\n            x = int(next(it))\n            \n            # Pour water starting from vessel p\n            while p < n and x > 0:\n                # How much can be added to current vessel\n                available = capacities[p] - water[p]\n                if available > 0:\n                    add = min(available, x)\n                    water[p] += add\n                    x -= add\n                \n                # If current vessel is full, skip to next non-full vessel\n                if water[p] == capacities[p]:\n                    # Find next vessel that can accept water\n                    # Use path compression for efficiency\n                    next_p = p + 1\n                    while next_p < n and water[next_p] == capacities[next_p]:\n                        next_p += 1\n                    # Update all vessels in the chain to point to next_p\n                    temp = p\n                    while temp < next_p:\n                        next_vessel[temp] = next_p if next_p < n else n\n                        temp += 1\n                    p = next_p if next_p < n else n\n                else:\n                    break\n            \n        else:  # query_type == 2\n            k = int(next(it)) - 1  # 0-based\n            out_lines.append(str(water[k]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 271.5540225505829}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = int(data[1])\n    enemies = list(map(int, data[2:2+n]))\n    \n    # Sort enemy fleets in ascending order\n    enemies.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemies:\n        # To win, Atli needs at least enemy+1 ships\n        needed = enemy + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 95.8344099521637}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split('\\n')\n    if len(data) < 2:\n        print(\"corrupted\")\n        return\n    \n    I, O = data[0], data[1]\n    \n    # Find all positions of + and - in I\n    plus_positions = [i for i, ch in enumerate(I) if ch == '+']\n    minus_positions = [i for i, ch in enumerate(I) if ch == '-']\n    \n    # If no + or - in input, check if strings match\n    if not plus_positions and not minus_positions:\n        if I == O:\n            print(\"<any> <any>\")\n        else:\n            print(\"corrupted\")\n        return\n    \n    # Generate all possible encodings\n    results = []\n    \n    # Try all possible splits of O for + and - encodings\n    # We need to match the structure of I\n    def backtrack(i_idx, o_idx, plus_enc, minus_enc, in_plus, in_minus):\n        if i_idx == len(I) and o_idx == len(O):\n            # Valid match found\n            results.append((plus_enc, minus_enc))\n            return\n        if i_idx >= len(I) or o_idx >= len(O):\n            return\n        \n        if I[i_idx] == '+':\n            # Try all possible substrings for + encoding\n            for end in range(o_idx, len(O) + 1):\n                enc = O[o_idx:end]\n                backtrack(i_idx + 1, end, enc, minus_enc, True, in_minus)\n        elif I[i_idx] == '-':\n            # Try all possible substrings for - encoding\n            for end in range(o_idx, len(O) + 1):\n                enc = O[o_idx:end]\n                backtrack(i_idx + 1, end, plus_enc, enc, in_plus, True)\n        else:\n            # Regular character, must match exactly\n            if o_idx < len(O) and I[i_idx] == O[o_idx]:\n                backtrack(i_idx + 1, o_idx + 1, plus_enc, minus_enc, in_plus, in_minus)\n            else:\n                return\n    \n    backtrack(0, 0, \"\", \"\", False, False)\n    \n    if not results:\n        print(\"corrupted\")\n        return\n    \n    # Process results to handle special cases\n    final_results = set()\n    for plus_enc, minus_enc in results:\n        plus_str = \"<any>\" if plus_enc == \"\" and not plus_positions else (\"<empty>\" if plus_enc == \"\" else plus_enc)\n        minus_str = \"<any>\" if minus_enc == \"\" and not minus_positions else (\"<empty>\" if minus_enc == \"\" else minus_enc)\n        \n        # If no + in input, plus encoding can be anything\n        if not plus_positions:\n            plus_str = \"<any>\"\n        # If no - in input, minus encoding can be anything\n        if not minus_positions:\n            minus_str = \"<any>\"\n        \n        final_results.add((plus_str, minus_str))\n    \n    # Output all results\n    for plus_str, minus_str in sorted(final_results):\n        print(f\"{plus_str} {minus_str}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 366.7908389568329}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b.\n    # Since a and b are integers, we can iterate over possible b values.\n    # But constraints are up to 10^7, so we need O(1) solution.\n    # For each b in [x, y], a = k * b must be in [l, r].\n    # So we need to check if there exists b in [x, y] such that l <= k * b <= r.\n    # This is equivalent to checking if intervals [l/k, r/k] and [x, y] intersect.\n    # Since a and b are integers, we need integer intersection.\n    # We can find the smallest b in [x, y] that satisfies k * b >= l,\n    # and check if that b also satisfies k * b <= r.\n    # Compute b_min = max(x, (l + k - 1) // k)  # ceil(l/k)\n    # Then check if b_min <= y and k * b_min <= r.\n    b_min = max(x, (l + k - 1) // k)\n    if b_min <= y and k * b_min <= r:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 102.37349390983582}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 193.71990966796875}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s: str) -> int:\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm (O(n log n))\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev, curr = suffix[i-1], suffix[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            curr_key = (rank[curr], rank[curr + k] if curr + k < n else -1)\n            tmp[curr] = tmp[prev] + (prev_key != curr_key)\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # LCP array construction using Kasai's algorithm (O(n))\n    lcp = [0] * n\n    inv_suffix = [0] * n\n    for i in range(n):\n        inv_suffix[suffix[i]] = i\n    \n    k = 0\n    for i in range(n):\n        if inv_suffix[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv_suffix[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_suffix[i]] = k\n        if k:\n            k -= 1\n    \n    # The answer is the maximum value in LCP array\n    return max(lcp) if lcp else 0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    s = data[1]\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 146.02696561813354}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 171.39753532409668}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    # Days from purchase to eating: B\n    # Days from best-by to eating: B - A\n    days_from_best_by = B - A\n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 136.56195211410522}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Distance from pole (0,0) to the wall line\n    # Wall direction vector\n    dx = x2 - x1\n    dy = y2 - y1\n    # Distance from point to line formula: |(x2-x1)*(y1-0) - (x1-0)*(y2-y1)| / sqrt((x2-x1)^2 + (y2-y1)^2)\n    # Simplified for point (0,0): |x1*y2 - x2*y1| / sqrt(dx^2 + dy^2)\n    numerator = abs(x1 * y2 - x2 * y1)\n    denominator = math.sqrt(dx * dx + dy * dy)\n    d = numerator / denominator if denominator != 0 else 0\n    \n    # Binary search for minimal chain length r (in meters, integer)\n    low, high = 0, 20000  # Upper bound: sqrt(L/pi) + d, but safe bound\n    ans = high\n    while low <= high:\n        mid = (low + high) // 2\n        r = mid\n        # Area dog can cover: full circle minus segment blocked by wall\n        if r <= d:\n            # Wall blocks no area, full circle area\n            area = math.pi * r * r\n        else:\n            # Angle of blocked segment: 2 * arccos(d/r)\n            theta = 2 * math.acos(d / r)\n            # Area of circular segment: (r^2/2)*(theta - sin(theta))\n            segment_area = 0.5 * r * r * (theta - math.sin(theta))\n            # Accessible area = full circle - segment\n            area = math.pi * r * r - segment_area\n        if area >= L:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 110.26197504997253}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 1669.4135522842407}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    result = A * B\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 536.3813364505768}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 197.2502908706665}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().splitlines()\n    S = data[0]\n    Q = int(data[1])\n    \n    # Use deque for efficient appends at both ends\n    from collections import deque\n    dq = deque(S)\n    \n    reversed_flag = False  # Track if string is logically reversed\n    \n    for i in range(2, Q + 2):\n        query = data[i].split()\n        t = int(query[0])\n        \n        if t == 1:\n            # Reverse operation: just flip the flag\n            reversed_flag = not reversed_flag\n        else:  # t == 2\n            f = int(query[1])\n            c = query[2]\n            \n            # Determine actual position based on reversed_flag\n            if f == 1:\n                # Add to beginning\n                if not reversed_flag:\n                    dq.appendleft(c)\n                else:\n                    dq.append(c)\n            else:  # f == 2\n                # Add to end\n                if not reversed_flag:\n                    dq.append(c)\n                else:\n                    dq.appendleft(c)\n    \n    # Convert deque to string, reversing if needed\n    result = ''.join(dq)\n    if reversed_flag:\n        result = result[::-1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 138.3518991470337}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 200.16186046600342}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 280.18230724334717}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If already rested enough after first alarm\n        if b >= a:\n            results.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            results.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        remaining = a - b\n        # Sleep gained per cycle after first alarm\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (remaining + gain_per_cycle - 1) // gain_per_cycle\n        \n        total_time = b + cycles * c\n        results.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 181.26555180549622}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Initialize sieve: True means crossed out (not prime or multiple)\n    is_crossed = [False] * (N + 1)\n    is_crossed[0] = is_crossed[1] = True  # 0 and 1 are not considered\n    \n    crossed_order = []  # Store numbers in the order they are crossed out\n    \n    for p in range(2, N + 1):\n        if not is_crossed[p]:  # p is prime\n            # Cross out p itself (it's the first crossing for this prime)\n            if not is_crossed[p]:\n                is_crossed[p] = True\n                crossed_order.append(p)\n                if len(crossed_order) == K:\n                    print(p)\n                    return\n            \n            # Cross out multiples of p\n            for multiple in range(p * 2, N + 1, p):\n                if not is_crossed[multiple]:\n                    is_crossed[multiple] = True\n                    crossed_order.append(multiple)\n                    if len(crossed_order) == K:\n                        print(multiple)\n                        return\n    \n    # If K is larger than total crossed numbers (should not happen per constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 279.6548697948456}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 281.3216381072998}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 281.74438095092773}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    restaurants = []\n    \n    # Parse input\n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, score, i))  # (city, score, original_index)\n        idx += 2\n    \n    # Sort: first by city lexicographically, then by score descending\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    # Output original indices\n    for _, _, original_idx in restaurants:\n        print(original_idx)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 299.0257959365845}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\nimport heapq\n\nsys.setrecursionlimit(10**6)\n\ndef bfs(grid, start, n, m, state):\n    \"\"\"BFS to find distances from start to all cells for a given state\"\"\"\n    dist = [[float('inf')] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state:\n                dist[i][j] = 0\n                q.append((i, j))\n    \n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    while q:\n        x, y = q.popleft()\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                new_dist = dist[x][y] + (1 if grid[nx][ny] == '.' else 0)\n                if new_dist < dist[nx][ny]:\n                    dist[nx][ny] = new_dist\n                    q.append((nx, ny))\n    return dist\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Find all cells for each state\n    states = {'1': [], '2': [], '3': []}\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] in '123':\n                states[grid[i][j]].append((i, j))\n    \n    # Check if any state is empty (shouldn't happen per problem)\n    if not all(states.values()):\n        print(-1)\n        return\n    \n    # Compute distances from each state to all cells\n    dist1 = bfs(grid, states['1'][0], n, m, '1')\n    dist2 = bfs(grid, states['2'][0], n, m, '2')\n    dist3 = bfs(grid, states['3'][0], n, m, '3')\n    \n    # Find minimum connection costs between states\n    INF = float('inf')\n    # Direct connections between two states\n    cost_12 = INF\n    cost_13 = INF\n    cost_23 = INF\n    # Connections through intermediate '.' cells\n    cost_123 = INF\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            \n            d1 = dist1[i][j]\n            d2 = dist2[i][j]\n            d3 = dist3[i][j]\n            \n            # Update direct connections\n            if grid[i][j] == '1':\n                cost_12 = min(cost_12, d2)\n                cost_13 = min(cost_13, d3)\n            elif grid[i][j] == '2':\n                cost_12 = min(cost_12, d1)\n                cost_23 = min(cost_23, d3)\n            elif grid[i][j] == '3':\n                cost_13 = min(cost_13, d1)\n                cost_23 = min(cost_23, d2)\n            \n            # Update connection through intermediate cell\n            if grid[i][j] == '.':\n                cost_123 = min(cost_123, d1 + d2 + d3 - 2)  # -2 because cell counted twice\n            else:\n                # If cell belongs to a state, we need to connect the other two through it\n                if grid[i][j] == '1':\n                    cost_123 = min(cost_123, d2 + d3)\n                elif grid[i][j] == '2':\n                    cost_123 = min(cost_123, d1 + d3)\n                elif grid[i][j] == '3':\n                    cost_123 = min(cost_123, d1 + d2)\n    \n    # Consider connecting all three via two edges\n    # Option 1: Connect 1-2 and 1-3 (or 2-3)\n    option1 = cost_12 + cost_13\n    option2 = cost_12 + cost_23\n    option3 = cost_13 + cost_23\n    \n    # Option 4: Connect through intermediate cell\n    option4 = cost_123\n    \n    result = min(option1, option2, option3, option4)\n    \n    if result >= INF:\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1391.748217344284}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 275.9282157421112}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    inc = []\n    dec = []\n    for a, b in projects:\n        if b >= 0:\n            inc.append((a, b))\n        else:\n            dec.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    inc.sort(key=lambda x: x[0])\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # Equivalent to sorting by (a + b) descending\n    dec.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process increasing projects first\n    for a, b in inc:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    # Process decreasing projects\n    for a, b in dec:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1848.9344394207}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 275.290992975235}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track number of distinct difficulties currently in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add current problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 343.04571056365967}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    ans = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1529.329645872116}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 190.2718608379364}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Check if positions are in the same residue class modulo k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Determine direction and step\n    step = k if t_pos > g_pos else -k\n    \n    # Check all cells along the path\n    pos = g_pos\n    while pos != t_pos:\n        pos += step\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2702.6774277687073}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 313.08625769615173}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 261.2085852622986}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "RE": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 238.65317630767822}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite RGB pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We'll try all possible starting positions for the substring of length k\n        # For each starting position, we need to check how many characters\n        # need to be changed to match one of the three possible cyclic patterns\n        # starting with 'R', 'G', or 'B'.\n        \n        # Precompute prefix sums for each pattern to answer queries in O(1)\n        # after O(n) preprocessing.\n        # patterns[i] will be the expected character at position i in the infinite string\n        # for pattern starting with 'R', 'G', or 'B'.\n        \n        # Initialize prefix arrays for each starting character\n        pref_r = [0] * (n + 1)\n        pref_g = [0] * (n + 1)\n        pref_b = [0] * (n + 1)\n        \n        for i in range(n):\n            # For pattern starting with 'R'\n            expected_r = pattern[i % 3]\n            pref_r[i+1] = pref_r[i] + (1 if s[i] != expected_r else 0)\n            \n            # For pattern starting with 'G'\n            expected_g = pattern[(i+1) % 3]  # shift by 1\n            pref_g[i+1] = pref_g[i] + (1 if s[i] != expected_g else 0)\n            \n            # For pattern starting with 'B'\n            expected_b = pattern[(i+2) % 3]  # shift by 2\n            pref_b[i+1] = pref_b[i] + (1 if s[i] != expected_b else 0)\n        \n        # Now find minimum changes for any substring of length k\n        min_changes = float('inf')\n        for start in range(n - k + 1):\n            end = start + k\n            # Check pattern starting with 'R'\n            changes_r = pref_r[end] - pref_r[start]\n            # Check pattern starting with 'G'\n            changes_g = pref_g[end] - pref_g[start]\n            # Check pattern starting with 'B'\n            changes_b = pref_b[end] - pref_b[start]\n            \n            min_changes = min(min_changes, changes_r, changes_g, changes_b)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 112.89409899711609}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 334.4405734539032}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    table_count = 0\n    max_table = 0\n    seen = [False] * (n + 1)  # Track if first sock of a pair is on table\n    \n    for sock in socks:\n        if not seen[sock]:\n            # First sock of this pair\n            seen[sock] = True\n            table_count += 1\n            max_table = max(max_table, table_count)\n        else:\n            # Second sock of this pair\n            table_count -= 1\n    \n    print(max_table)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 420.48043298721313}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2 => R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 91.13379526138306}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 252.48631930351257}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n + 1))\n        self.size = [1] * (n + 1)\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        if self.size[x_root] < self.size[y_root]:\n            x_root, y_root = y_root, x_root\n        self.parent[y_root] = x_root\n        self.size[x_root] += self.size[y_root]\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Initialize DSU for connectivity\n    dsu = DSU(n)\n    \n    # Process edges\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        dsu.union(u, v)\n    \n    # Find connected components and their min/max nodes\n    comp_min = [n + 1] * (n + 1)\n    comp_max = [0] * (n + 1)\n    \n    for node in range(1, n + 1):\n        root = dsu.find(node)\n        comp_min[root] = min(comp_min[root], node)\n        comp_max[root] = max(comp_max[root], node)\n    \n    # Collect intervals for components with size > 1\n    intervals = []\n    for root in range(1, n + 1):\n        if comp_min[root] <= n and comp_max[root] > 0 and comp_min[root] < comp_max[root]:\n            intervals.append((comp_min[root], comp_max[root]))\n    \n    # Sort intervals by start\n    intervals.sort()\n    \n    # Merge overlapping intervals\n    merged = []\n    for start, end in intervals:\n        if not merged or start > merged[-1][1]:\n            merged.append([start, end])\n        else:\n            merged[-1][1] = max(merged[-1][1], end)\n    \n    # Calculate edges needed\n    edges_needed = 0\n    for i in range(len(merged)):\n        start, end = merged[i]\n        # Count nodes in this interval that are in different components\n        current_root = dsu.find(start)\n        for node in range(start + 1, end + 1):\n            if dsu.find(node) != current_root:\n                edges_needed += 1\n                dsu.union(node, current_root)\n                current_root = dsu.find(current_root)\n    \n    print(edges_needed)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 381.66505122184753}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    max_count = 0\n    # For each possible value, check how many elements can be adjusted to it\n    for val in set(arr):\n        # Elements that are already val\n        count = freq.get(val, 0)\n        # Elements that can become val by adding 1\n        count += freq.get(val-1, 0)\n        # Elements that can become val by subtracting 1\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 140.01947665214539}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nxs, ys, ss, ri, rf = map(int, sys.stdin.readline().split())\nxa, ya, sa = map(int, sys.stdin.readline().split())\n\n# Distance from Anthony to zone center\ndist = math.hypot(xa - xs, ya - ys)\n\n# If Anthony starts inside the final zone, no damage\nif dist <= rf:\n    print(\"0.000000\")\n    sys.exit(0)\n\n# Time for zone to shrink from ri to rf\nshrink_time = (ri - rf) / ss if ss > 0 else 0\n\n# Function to compute distance from zone edge at time t\ndef zone_radius_at_time(t):\n    return max(rf, ri - ss * t)\n\n# Function to check if Anthony can reach zone edge by time t\ndef can_reach_by_time(t):\n    # Zone radius at time t\n    r_t = zone_radius_at_time(t)\n    # Distance Anthony needs to cover to reach edge\n    travel_dist = max(0, dist - r_t)\n    # Maximum distance Anthony can travel in time t\n    max_travel = sa * t\n    return max_travel >= travel_dist\n\n# Binary search for minimum time to reach safety\nlo, hi = 0.0, shrink_time + (dist - rf) / sa  # Upper bound: time to reach final zone edge\nfor _ in range(100):  # Sufficient iterations for 1e-6 precision\n    mid = (lo + hi) / 2\n    if can_reach_by_time(mid):\n        hi = mid\n    else:\n        lo = mid\n\nmin_time = hi\n\n# If Anthony can reach before zone stops shrinking\nif min_time <= shrink_time:\n    # Damage = time spent outside zone before reaching edge\n    damage = min_time\nelse:\n    # Anthony reaches after zone stops shrinking\n    # Time to reach final zone edge\n    time_to_final_edge = (dist - rf) / sa\n    # Damage = time outside zone during shrinking + time outside final zone\n    damage = shrink_time + max(0, time_to_final_edge - shrink_time)\n\nprint(f\"{damage:.6f}\")", "complexity_estimate": null, "runtime_sec": 282.2220492362976}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 135.32913827896118}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1 + n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        g = math.gcd(lcm_val, t)\n        lcm_val = (lcm_val // g) * t\n        if lcm_val > 10**18:\n            # Early exit if LCM exceeds the guaranteed maximum\n            break\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 704.3678877353668}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 278.5284411907196}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [int(next(it)) for _ in range(q)]\n    \n    # Precompute all possible sums using at most k bills of at most 2 denominations\n    # We'll store for each sum the minimum number of bills\n    max_sum = max(queries)\n    INF = 10**9\n    dp = [INF] * (max_sum + 1)\n    dp[0] = 0\n    \n    # Try all pairs of denominations (including single denomination)\n    for i in range(n):\n        d1 = a[i]\n        # Single denomination case\n        for cnt1 in range(1, k + 1):\n            s = d1 * cnt1\n            if s > max_sum:\n                break\n            dp[s] = min(dp[s], cnt1)\n        \n        # Two denominations case\n        for j in range(i + 1, n):\n            d2 = a[j]\n            # Try all combinations of counts\n            for cnt1 in range(k + 1):\n                if cnt1 == 0:\n                    # This is covered by single denomination case for d2\n                    continue\n                for cnt2 in range(k + 1):\n                    if cnt1 + cnt2 == 0 or cnt1 + cnt2 > k:\n                        continue\n                    s = d1 * cnt1 + d2 * cnt2\n                    if s > max_sum:\n                        break\n                    dp[s] = min(dp[s], cnt1 + cnt2)\n    \n    # Answer queries\n    out_lines = []\n    for x in queries:\n        if x <= max_sum and dp[x] != INF:\n            out_lines.append(str(dp[x]))\n        else:\n            out_lines.append(\"-1\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2725.15407371521}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Pair boxes with remainder r and remainder (k-r) mod k\n    # Special cases: remainder 0 and remainder k/2 when k is even\n    ans = 0\n    \n    # Pair remainder 0 with itself\n    ans += (rem_count[0] // 2) * 2\n    \n    # If k is even, pair remainder k/2 with itself\n    if k % 2 == 0:\n        ans += (rem_count[k // 2] // 2) * 2\n    \n    # Pair remainder i with remainder k-i for i from 1 to (k-1)//2\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        if i != j:  # This is always true when k is odd, and for i < k/2 when k is even\n            pairs = min(rem_count[i], rem_count[j])\n            ans += pairs * 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 305.81613063812256}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 192.97501635551453}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 212.8424096107483}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    a = s\n    i = 1\n    while True:\n        if a in seen:\n            print(i)\n            return\n        seen[a] = i\n        a = f(a)\n        i += 1\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 498.54880452156067}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 275.16897892951965}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find first ':' after first '['\n    first_colon = -1\n    for i in range(first_open + 1, n):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ']'\n    last_close = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1 or last_close <= first_colon:\n        print(-1)\n        return\n    \n    # Find last ':' before last ']'\n    last_colon = -1\n    for i in range(last_close - 1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon + 1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2892.8659472465515}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    arr = list(map(int, data[idx:idx+n]))\n    idx += n\n    \n    freq = collections.Counter(arr)\n    max_freq = max(freq.values())\n    distinct = len(freq)\n    \n    # The maximum team size x must satisfy:\n    # 1. x <= distinct (for unique skills in first team)\n    # 2. x <= max_freq (for same skills in second team)\n    # 3. We need to check if we can actually form both teams\n    \n    # Try candidate x = min(distinct, max_freq)\n    candidate = min(distinct, max_freq)\n    \n    # If candidate is 0, answer is 0\n    if candidate == 0:\n        results.append('0')\n        continue\n    \n    # Adjust candidate: if distinct == max_freq, we need to reduce by 1\n    # because we need one extra distinct skill for the first team\n    # when the second team uses all occurrences of the most frequent skill\n    if distinct == max_freq:\n        candidate = distinct - 1\n    \n    # Ensure candidate is non-negative\n    candidate = max(0, candidate)\n    \n    results.append(str(candidate))\n\nprint('\\n'.join(results))", "complexity_estimate": null, "runtime_sec": 211.48462009429932}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the greatest common divisor of all numbers\n    g = arr[0]\n    for x in arr[1:]:\n        g = math.gcd(g, x)\n    \n    # For each number, divide by gcd and check if it's only composed of factors 2 and 3\n    for x in arr:\n        x //= g\n        # Remove all factors of 2\n        while x % 2 == 0:\n            x //= 2\n        # Remove all factors of 3\n        while x % 3 == 0:\n            x //= 3\n        # If anything else remains, it's impossible\n        if x != 1:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1358.7016611099243}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 235.4104859828949}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        edges.append((x, y, w))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(n, adj, i)\n    \n    # Compute base total cost without any zero road\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # For each route, compute new distance with road (x,y) zero\n        new_total = 0\n        for a, b in routes:\n            # New distance is min of original or going through zero road\n            # d(a,b) = min(dists[a][b], dists[a][x] + dists[y][b], dists[a][y] + dists[x][b])\n            # Since road is bidirectional and zero cost\n            cand = dists[a][b]\n            cand = min(cand, dists[a][x] + dists[y][b])\n            cand = min(cand, dists[a][y] + dists[x][b])\n            new_total += cand\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 114.02399730682373}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 345.18336391448975}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 360.45722007751465}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 318.50197887420654}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 233.2451193332672}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 2044.9026067256927}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 236.0614242553711}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 316.1275978088379}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 209.9476923942566}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # Each of the 3 positions can be any digit from 1 to N\n    # Total possibilities = N * N * N = N^3\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 376.5583863258362}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 187.05708289146423}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' from the left and consecutive '>' from the right\n        left_count = 0\n        for ch in s:\n            if ch == '<':\n                left_count += 1\n            else:\n                break\n        right_count = 0\n        for ch in reversed(s):\n            if ch == '>':\n                right_count += 1\n            else:\n                break\n        # Minimum deletions needed is the smaller of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 181.5412302017212}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X)/2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    # Check if Y - 2X is non-negative and divisible by 2\n    if (Y - 2 * X) >= 0 and (Y - 2 * X) % 2 == 0:\n        t = (Y - 2 * X) // 2\n        c = X - t\n        if c >= 0 and t >= 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 629.5352838039398}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if any row or column is completely evil\n    for i in range(n):\n        if all(grid[i][j] == 'E' for j in range(n)):\n            # This row is all evil, check if any column has a non-evil cell\n            possible = False\n            for j in range(n):\n                if any(grid[k][j] == '.' for k in range(n)):\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            # This column is all evil, check if any row has a non-evil cell\n            possible = False\n            for i in range(n):\n                if any(grid[i][k] == '.' for k in range(n)):\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    # Strategy 1: Try to find n non-evil cells in different rows and columns\n    # This would give us n spells, each covering one row and one column\n    # But we can do better if we can cover multiple rows/columns with one spell\n    \n    # Actually, the optimal solution is to cast spells on non-evil cells\n    # such that every row and every column has at least one spell cast on it\n    # (either directly on a cell in that row/column, or indirectly through\n    # a cell that shares the row/column)\n    \n    # But since spells purify entire rows and columns, the condition is:\n    # For every cell (i,j), there must exist some spell cast on a cell (r,c)\n    # such that r == i or c == j, and grid[r][c] != 'E'\n    \n    # This is equivalent to: For every row i, there exists some column c_i\n    # such that grid[i][c_i] != 'E', OR for every column j, there exists\n    # some row r_j such that grid[r_j][j] != 'E'\n    \n    # Actually, we need to cover all cells. A cell (i,j) is covered if:\n    # - There's a spell in row i (at any column with non-evil cell), OR\n    # - There's a spell in column j (at any row with non-evil cell)\n    \n    # So we need to select a set of rows R and columns C such that:\n    # 1. For each selected row r in R, we pick a column c where grid[r][c] != 'E'\n    # 2. For each selected column c in C, we pick a row r where grid[r][c] != 'E'\n    # 3. Every cell (i,j) satisfies: i in R OR j in C\n    \n    # This is a set cover problem, but we can solve it greedily:\n    # If there exists a row that's completely non-evil, we can cast spells\n    # on all cells in that row (n spells) - but that's not optimal.\n    \n    # Actually, the examples suggest a simpler approach:\n    # We can always purify all cells if for every row, there exists at least\n    # one non-evil cell, OR for every column, there exists at least one\n    # non-evil cell.\n    \n    # Check if every row has at least one non-evil cell\n    all_rows_have_non_evil = True\n    for i in range(n):\n        if all(grid[i][j] == 'E' for j in range(n)):\n            all_rows_have_non_evil = False\n            break\n    \n    if all_rows_have_non_evil:\n        # Cast spell on first non-evil cell in each row\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '.':\n                    print(i+1, j+1)\n                    break\n        return\n    \n    # Check if every column has at least one non-evil cell\n    all_cols_have_non_evil = True\n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            all_cols_have_non_evil = False\n            break\n    \n    if all_cols_have_non_evil:\n        # Cast spell on first non-evil cell in each column\n        for j in range(n):\n            for i in range(n):\n                if grid[i][j] == '.':\n                    print(i+1, j+1)\n                    break\n        return\n    \n    # If we reach here, there's at least one row with all evil cells\n    # AND at least one column with all evil cells\n    # In this case, any cell (i,j) where row i is all evil and column j\n    # is all evil cannot be purified\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1364.2525506019592}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Read inputs\n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute all possible fret positions across all strings\n    positions = []\n    for note in b:\n        note_positions = []\n        for string_val in a:\n            fret = note - string_val\n            if fret >= 1:  # fret numbers start from 1\n                note_positions.append(fret)\n        positions.append(note_positions)\n    \n    # We need to pick one position per note to minimize max-min\n    # Use two-pointer sliding window on sorted list of all (fret, note_index) pairs\n    all_pairs = []\n    for i, pos_list in enumerate(positions):\n        for fret in pos_list:\n            all_pairs.append((fret, i))\n    \n    all_pairs.sort()  # Sort by fret value\n    \n    # Sliding window to find minimal range covering all notes\n    note_count = [0] * n\n    notes_covered = 0\n    left = 0\n    min_diff = float('inf')\n    \n    for right in range(len(all_pairs)):\n        fret_val, note_idx = all_pairs[right]\n        if note_count[note_idx] == 0:\n            notes_covered += 1\n        note_count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while notes_covered == n:\n            min_diff = min(min_diff, fret_val - all_pairs[left][0])\n            left_fret, left_note_idx = all_pairs[left]\n            note_count[left_note_idx] -= 1\n            if note_count[left_note_idx] == 0:\n                notes_covered -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 309.50170278549194}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 151.83784127235413}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 309.28699374198914}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    \"\"\"\n    Count the number of ships Vasya can make using the process:\n    - Start with rectangle a x b (a > b)\n    - Cut off a square of size b x b, count 1 ship\n    - Remainder is (a-b) x b\n    - Repeat until remainder is square or zero\n    \"\"\"\n    ships = 0\n    while b > 0:\n        # Add ships from current rectangle a x b\n        ships += a // b\n        # Update a, b for next iteration\n        a, b = b, a % b\n    return ships\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    a, b = map(int, data[:2])\n    print(count_ships(a, b))", "complexity_estimate": null, "runtime_sec": 1887.6279938220978}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # The answer is LCM(2, N) = 2 * N / GCD(2, N)\n    # Since 2 is prime, GCD(2, N) is either 1 or 2\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 499.3209476470947}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nMOD = 10**9 + 9\n\ndef matmul(A, B):\n    k = len(A)\n    C = [[0]*k for _ in range(k)]\n    for i in range(k):\n        for j in range(k):\n            s = 0\n            for t in range(k):\n                s = (s + A[i][t] * B[t][j]) % MOD\n            C[i][j] = s\n    return C\n\ndef matpow(M, power):\n    k = len(M)\n    result = [[1 if i==j else 0 for j in range(k)] for i in range(k)]\n    while power > 0:\n        if power & 1:\n            result = matmul(result, M)\n        M = matmul(M, M)\n        power >>= 1\n    return result\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data)\n    \n    # All possible column states (bitmask of length n)\n    states = []\n    for mask in range(1 << n):\n        states.append(mask)\n    k = len(states)\n    \n    # Build transition matrix T where T[i][j] = 1 if state i can be followed by state j\n    T = [[0]*k for _ in range(k)]\n    for i, s1 in enumerate(states):\n        for j, s2 in enumerate(states):\n            valid = True\n            # Check if any knight in s1 attacks any in s2\n            for r1 in range(n):\n                if not (s1 >> r1) & 1:\n                    continue\n                # Knight attacks in 2x3 rectangle: (r1, c1) attacks (r2, c2) if |r1-r2|=1 and |c1-c2|=2 or |r1-r2|=2 and |c1-c2|=1\n                # Since columns are adjacent, we check attacks between column c and c+1\n                # For adjacent columns, knights attack if they are in positions forming L shape\n                # Specifically: (r1,0) attacks (r2,1) if |r1-r2|=2, or (r1,1) attacks (r2,0) if |r1-r2|=2\n                # But here we have two columns: current state s1 and next state s2\n                # We need to check all pairs (r1 in s1, r2 in s2) for knight attacks\n                for r2 in range(n):\n                    if not (s2 >> r2) & 1:\n                        continue\n                    dr = abs(r1 - r2)\n                    if dr == 1 or dr == 2:\n                        # For adjacent columns, knights attack if they are in positions that would be opposite corners of 2x3 rectangle\n                        # In adjacent columns, the column difference is 1, so we need dr=2 for attack (since 2x3: rows diff 2, cols diff 1)\n                        # Actually: knight moves (2,1) or (1,2). For adjacent columns (col diff=1), row diff must be 2.\n                        # For same column? No, knights in same column don't attack because column difference would be 0.\n                        # So we only check dr=2 for attacks between adjacent columns\n                        if dr == 2:\n                            valid = False\n                            break\n                if not valid:\n                    break\n            if valid:\n                T[i][j] = 1\n    \n    # Initial vector: ways for first column = 1 for each state\n    # We'll compute T^(m-1) and sum all entries\n    if m == 1:\n        print(k % MOD)\n        return\n    \n    TP = matpow(T, m-1)\n    total = 0\n    for i in range(k):\n        for j in range(k):\n            total = (total + TP[i][j]) % MOD\n    print(total % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 165.7522656917572}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 416.152704000473}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 91.62880158424377}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 278.4786159992218}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 311.8013174533844}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [int(next(it)) for _ in range(n)]\n    v = [int(next(it)) for _ in range(n)]\n    \n    # Pair points by (v, x) and sort\n    points = sorted(zip(v, x))\n    \n    # Fenwick tree for prefix sums of x\n    class Fenwick:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 1)\n        def update(self, idx, delta):\n            while idx <= self.n:\n                self.bit[idx] += delta\n                idx += idx & -idx\n        def query(self, idx):\n            s = 0\n            while idx > 0:\n                s += self.bit[idx]\n                idx -= idx & -idx\n            return s\n    \n    # Coordinate compression for x values\n    sorted_x = sorted(x)\n    x_to_idx = {val: i + 1 for i, val in enumerate(sorted_x)}\n    \n    fenw_count = Fenwick(n)\n    fenw_sum = Fenwick(n)\n    \n    total = 0\n    for speed, pos in points:\n        idx = x_to_idx[pos]\n        # Count of points with same speed processed so far\n        cnt = fenw_count.query(idx)\n        sum_x = fenw_sum.query(idx)\n        total += cnt * pos - sum_x\n        fenw_count.update(idx, 1)\n        fenw_sum.update(idx, pos)\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 149.5994894504547}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef build_sparse_table(arr, n):\n    \"\"\"Build sparse tables for range minimum and maximum queries.\"\"\"\n    k = n.bit_length()\n    min_st = [[0] * n for _ in range(k)]\n    max_st = [[0] * n for _ in range(k)]\n    \n    for i in range(n):\n        min_st[0][i] = arr[i]\n        max_st[0][i] = arr[i]\n    \n    j = 1\n    while (1 << j) <= n:\n        i = 0\n        while i + (1 << j) - 1 < n:\n            min_st[j][i] = min(min_st[j-1][i], min_st[j-1][i + (1 << (j-1))])\n            max_st[j][i] = max(max_st[j-1][i], max_st[j-1][i + (1 << (j-1))])\n            i += 1\n        j += 1\n    \n    return min_st, max_st\n\ndef query_min_max(min_st, max_st, l, r):\n    \"\"\"Query minimum and maximum in range [l, r] using sparse tables.\"\"\"\n    length = r - l + 1\n    k = length.bit_length() - 1\n    min_val = min(min_st[k][l], min_st[k][r - (1 << k) + 1])\n    max_val = max(max_st[k][l], max_st[k][r - (1 << k) + 1])\n    return min_val, max_val\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    arr = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [(int(next(it)) - 1, int(next(it)) - 1) for _ in range(q)]\n    \n    # Build sparse tables for RMQ\n    min_st, max_st = build_sparse_table(arr, n)\n    \n    # Precompute next and previous greater or equal elements\n    next_ge = [n] * n\n    prev_ge = [-1] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and arr[stack[-1]] <= arr[i]:\n            idx = stack.pop()\n            next_ge[idx] = i\n        if stack:\n            prev_ge[i] = stack[-1]\n        stack.append(i)\n    \n    # Precompute next and previous smaller or equal elements\n    next_le = [n] * n\n    prev_le = [-1] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and arr[stack[-1]] >= arr[i]:\n            idx = stack.pop()\n            next_le[idx] = i\n        if stack:\n            prev_le[i] = stack[-1]\n        stack.append(i)\n    \n    out_lines = []\n    for l, r in queries:\n        # Get min and max in the range\n        range_min, range_max = query_min_max(min_st, max_st, l, r)\n        \n        # Find longest magical subarray within [l, r]\n        best = 1\n        \n        # Check subarrays starting at each position\n        for start in range(l, r + 1):\n            # Find the furthest end where the subarray remains magical\n            # The magical condition: all values between first and last\n            first_val = arr[start]\n            \n            # We need to find the furthest end where:\n            # min(arr[start..end]) >= min(first_val, last_val)\n            # max(arr[start..end]) <= max(first_val, last_val)\n            \n            # Binary search for the end position\n            low, high = start, r\n            while low <= high:\n                mid = (low + high) // 2\n                sub_min, sub_max = query_min_max(min_st, max_st, start, mid)\n                \n                # Check if subarray [start, mid] is magical\n                # For magical: all values between first and last\n                # This means: min >= min(first, last) and max <= max(first, last)\n                last_val = arr[mid]\n                lower_bound = min(first_val, last_val)\n                upper_bound = max(first_val, last_val)\n                \n                if sub_min >= lower_bound and sub_max <= upper_bound:\n                    # This subarray is magical, try to extend further\n                    best = max(best, mid - start + 1)\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        \n        out_lines.append(str(best))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 218.73070621490479}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = int(data[1])  # Rabbit-Owl\n    b = int(data[2])  # Rabbit-Eeyore\n    c = int(data[3])  # Owl-Eeyore\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # For n >= 2, we need to choose optimal first move and then repeat\n    # The three possible first moves:\n    # 1. Rabbit -> Owl (cost a), then alternate between Owl and Eeyore (min(c, a+b))\n    # 2. Rabbit -> Eeyore (cost b), then alternate between Eeyore and Owl (min(c, a+b))\n    # 3. Rabbit -> Owl -> Eeyore (cost a + c) or Rabbit -> Eeyore -> Owl (cost b + c)\n    #    then alternate between the two non-Rabbit houses\n    \n    # Actually simpler: After first meal at Rabbit, we need n-1 more meals\n    # We can think of it as choosing between two strategies:\n    # Strategy 1: Stay between two houses (Rabbit and one other)\n    # Strategy 2: Alternate between all three houses\n    \n    # Let's consider the minimal cycle:\n    # The minimal cost for 2 additional meals (total 3 meals) is min(a+b, a+c, b+c, 2*min(a,b,c))\n    \n    # For n meals total:\n    # First meal at Rabbit (cost 0)\n    # Then we need n-1 more meals\n    # The minimal cost per additional meal after the first move is:\n    # min(a, b, c, (a+b+c) - max(a,b,c))  # This is the minimal edge in the triangle\n    \n    # Actually, let's think step by step:\n    # After first meal at Rabbit, we must move to another house\n    # The minimal first move is min(a, b)\n    # Then for each subsequent meal, we can either:\n    # - Return to Rabbit (cost min(a,b))\n    # - Go to the third house (cost depends on current position)\n    \n    # The optimal pattern is:\n    # 1. Start at Rabbit (meal 1)\n    # 2. Move to the closer of Owl/Eeyore (cost min(a,b))\n    # 3. For remaining n-2 meals, alternate between the two non-Rabbit houses\n    #    This costs (n-2) * min(c, a+b)  # min cost to switch between Owl and Eeyore\n    \n    # But wait, we could also consider going Rabbit->Owl->Eeyore pattern\n    # Let's compute all possibilities:\n    \n    # Pattern 1: Rabbit -> (closer neighbor) -> alternate between two non-Rabbit houses\n    first_move = min(a, b)\n    alt_cost = min(c, a + b)  # Cost to switch between Owl and Eeyore\n    total1 = first_move + (n-2) * alt_cost\n    \n    # Pattern 2: Rabbit -> farther neighbor -> alternate\n    # This might be worse but let's compute for completeness\n    second_move = max(a, b) if n > 1 else 0\n    total2 = second_move + (n-2) * alt_cost\n    \n    # Pattern 3: Complete triangle cycle\n    # Rabbit -> Owl -> Eeyore -> Rabbit -> ...\n    triangle_cost = min(a + c, b + c, a + b)  # Minimal two-edge path\n    # For n meals, we need n-1 moves\n    # The minimal repeating pattern is the minimal edge\n    min_edge = min(a, b, c)\n    \n    # Actually, let's think differently:\n    # We need n-1 moves total (since we start at Rabbit with meal 1)\n    # The problem reduces to: find minimum sum of n-1 edges in the triangle\n    # where no two consecutive edges share the same house?\n    \n    # Better approach: Dynamic programming\n    # Let dp[i][house] = min distance after i meals ending at house\n    # Houses: 0=Rabbit, 1=Owl, 2=Eeyore\n    \n    INF = 10**9\n    dp = [[INF, INF, INF] for _ in range(n+1)]\n    dp[1][0] = 0  # First meal at Rabbit\n    \n    for i in range(1, n):\n        # From Rabbit\n        dp[i+1][1] = min(dp[i+1][1], dp[i][0] + a)  # Rabbit -> Owl\n        dp[i+1][2] = min(dp[i+1][2], dp[i][0] + b)  # Rabbit -> Eeyore\n        \n        # From Owl\n        dp[i+1][0] = min(dp[i+1][0], dp[i][1] + a)  # Owl -> Rabbit\n        dp[i+1][2] = min(dp[i+1][2], dp[i][1] + c)  # Owl -> Eeyore\n        \n        # From Eeyore\n        dp[i+1][0] = min(dp[i+1][0], dp[i][2] + b)  # Eeyore -> Rabbit\n        dp[i+1][1] = min(dp[i+1][1], dp[i][2] + c)  # Eeyore -> Owl\n    \n    answer = min(dp[n][0], dp[n][1], dp[n][2])\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1996.9326226711273}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    bosses = list(map(int, data[1:]))\n    \n    subordinates = [0] * (n + 1)\n    \n    for boss in bosses:\n        subordinates[boss] += 1\n    \n    for i in range(1, n + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 135.94672560691833}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 206.94581246376038}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith('po'):\n        return 'FILIPINO'\n    elif sentence.endswith('desu') or sentence.endswith('masu'):\n        return 'JAPANESE'\n    elif sentence.endswith('mnida'):\n        return 'KOREAN'\n    else:\n        # According to problem statement, this case shouldn't occur\n        return 'UNKNOWN'\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i].strip()\n        results.append(detect_language(sentence))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 219.77041339874268}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    trains = []\n    for _ in range(N-1):\n        C = int(next(it))\n        S = int(next(it))\n        F = int(next(it))\n        trains.append((C, S, F))\n    \n    results = []\n    for start in range(N):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait until next departure\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results.append(str(current_time))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 136.71342277526855}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 326.81880259513855}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 240.83833193778992}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    H, W = map(int, data[0].split())\n    grid = data[1:1+H]\n    \n    # Directions: up, down, left, right, and four diagonals\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                    bomb_count += 1\n            row_chars.append(str(bomb_count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 136.49281573295593}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 417.8418393135071}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Determine which numbers are missing from a and b\n    present_a = set(a)\n    present_b = set(b)\n    all_numbers = set(range(1, n+1))\n    missing_a = list(all_numbers - present_a)\n    missing_b = list(all_numbers - present_b)\n    \n    # Start with a as base\n    p = a[:]\n    \n    if len(diff_positions) == 1:\n        # Only one position differs between a and b\n        pos = diff_positions[0]\n        # Try both possibilities\n        if missing_a:\n            p[pos] = missing_a[0]\n        else:\n            # If no missing number in a, use b's value\n            p[pos] = b[pos]\n    else:\n        # Two positions differ\n        pos1, pos2 = diff_positions[0], diff_positions[1]\n        \n        # Try swapping a[pos1] and a[pos2]\n        p[pos1], p[pos2] = a[pos2], a[pos1]\n        \n        # Check if this creates a valid permutation\n        if len(set(p)) != n:\n            # Try the other combination\n            p = a[:]\n            p[pos1] = b[pos1]\n            p[pos2] = b[pos2]\n            \n            # If still invalid, try mixing\n            if len(set(p)) != n:\n                p = a[:]\n                p[pos1] = b[pos1]\n                p[pos2] = a[pos2]\n                if len(set(p)) != n:\n                    p = a[:]\n                    p[pos1] = a[pos1]\n                    p[pos2] = b[pos2]\n    \n    # Final validation and output\n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2047.4759409427643}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 192.06382989883423}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import re\n\ndef is_vowel(c, next_c=None):\n    \"\"\"Check if character c is a vowel given next character.\"\"\"\n    c = c.upper()\n    if next_c:\n        next_c = next_c.upper()\n    # Y is consonant if followed by another vowel\n    if c == 'Y' and next_c and next_c in 'AEIOU':\n        return False\n    return c in 'AEIOUY'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to problem rules.\"\"\"\n    # Extract alphabetic part\n    alpha_match = re.search(r'^[A-Za-z]+', word)\n    if not alpha_match:\n        return 1  # Non-alphabetic word has at least 1 syllable\n    \n    alpha = alpha_match.group().upper()\n    n = len(alpha)\n    \n    # Apply QU rule: replace QU with Q\n    alpha = re.sub('QU', 'Q', alpha)\n    \n    # Mark vowel positions\n    vowels = []\n    for i in range(len(alpha)):\n        next_c = alpha[i+1] if i+1 < len(alpha) else None\n        if is_vowel(alpha[i], next_c):\n            vowels.append(i)\n    \n    if not vowels:\n        return 1  # At least one syllable\n    \n    # Count syllable divisions\n    syllables = 1\n    for i in range(len(vowels)-1):\n        # Check if there's at least one consonant between vowels\n        if vowels[i+1] - vowels[i] > 1:\n            syllables += 1\n    \n    # Apply silent E rule\n    if alpha[-1] == 'E':\n        if n >= 3 and alpha[-2] == 'L' and alpha[-3] not in 'AEIOUY':\n            # Keep the E syllable (e.g., 'able')\n            pass\n        else:\n            # Silent E: remove last syllable if it was counted\n            # Check if last vowel was at the end\n            if vowels and vowels[-1] == len(alpha)-1:\n                syllables = max(1, syllables-1)\n    \n    # Apply ES rule\n    if alpha.endswith('ES'):\n        if n >= 4 and alpha[-3] not in 'AEIOUY' and alpha[-4] not in 'AEIOUY':\n            # Keep the syllable (e.g., 'witches')\n            pass\n        else:\n            # ES doesn't add syllable\n            # Check if last vowel was at E position\n            if vowels and vowels[-1] == len(alpha)-2:\n                syllables = max(1, syllables-1)\n    \n    return max(1, syllables)\n\ndef split_haiku(words):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Precompute syllable counts\n    syllables = [count_syllables(w) for w in words]\n    total = sum(syllables)\n    \n    if total != 17:\n        return None  # Cannot form haiku\n    \n    # Try all possible splits\n    for i in range(1, n-1):  # First break after word i-1\n        for j in range(i+1, n):  # Second break after word j-1\n            line1 = sum(syllables[:i])\n            line2 = sum(syllables[i:j])\n            line3 = sum(syllables[j:])\n            \n            if line1 == 5 and line2 == 7 and line3 == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    \n    return None\n\ndef main():\n    import sys\n    \n    # Read input\n    line = sys.stdin.read().strip()\n    if not line:\n        return\n    \n    # Split into words (preserving punctuation)\n    words = []\n    current = ''\n    for char in line:\n        if char == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += char\n    if current:\n        words.append(current)\n    \n    # Try to form haiku\n    result = split_haiku(words)\n    \n    if result:\n        print(result[0])\n        print(result[1])\n        print(result[2])\n    else:\n        print(line)\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 207.92265796661377}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 275.1357424259186}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    # Special case: 1 is strongest, then 13, 12, ..., 2\n    if A == B:\n        print(\"Draw\")\n    elif A == 1:\n        print(\"Alice\")\n    elif B == 1:\n        print(\"Bob\")\n    elif A > B:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 418.6807174682617}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 412.92804312705994}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx]); idx += 1\n        s = input_data[idx]; idx += 1\n        \n        # Find first occurrence of different consecutive characters\n        start = 0\n        while start < n and s[start] == s[0]:\n            start += 1\n        \n        if start == n:\n            # All characters are the same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rotate string to start at first change\n        rotated = s[start:] + s[:start]\n        \n        count = 0\n        curr_len = 1\n        \n        for i in range(1, n):\n            if rotated[i] == rotated[i-1]:\n                curr_len += 1\n            else:\n                count += curr_len // 3\n                curr_len = 1\n        \n        count += curr_len // 3\n        results.append(count)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 281.5861539840698}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # Snuke changed exactly one of them to 0\n    # So we find which position has value 0\n    for i in range(5):\n        if x[i] == 0:\n            # Output the 1-based index\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 216.37052941322327}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 287.6242516040802}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 288.61880803108215}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 202.88385558128357}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    M = int(next(it))\n    N = int(next(it))\n    \n    # Initialize net balances\n    balance = [0] * M\n    \n    # Process receipts\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        p = int(next(it))\n        balance[a] -= p  # payer pays, so their balance decreases\n        balance[b] += p  # receiver gets, so their balance increases\n    \n    # Filter out people with zero balance\n    debts = [bal for bal in balance if bal != 0]\n    \n    # If no debts, no transactions needed\n    if not debts:\n        print(0)\n        return\n    \n    # Use DP to find minimum transactions\n    # dp[mask] = min transactions to settle subset represented by mask\n    # where mask bits correspond to indices in debts list\n    k = len(debts)\n    dp = [float('inf')] * (1 << k)\n    dp[0] = 0  # empty subset needs 0 transactions\n    \n    # Precompute subset sums\n    subset_sum = [0] * (1 << k)\n    for mask in range(1 << k):\n        s = 0\n        for i in range(k):\n            if mask & (1 << i):\n                s += debts[i]\n        subset_sum[mask] = s\n    \n    # Fill DP table\n    for mask in range(1 << k):\n        # Try to add a new subset that sums to 0\n        # We need to find submask such that subset_sum[submask] == 0\n        # and combine it with current mask\n        remaining = ((1 << k) - 1) ^ mask\n        sub = remaining\n        while sub:\n            if subset_sum[sub] == 0:\n                new_mask = mask | sub\n                dp[new_mask] = min(dp[new_mask], dp[mask] + (bin(sub).count('1') - 1))\n            sub = (sub - 1) & remaining\n    \n    # Answer is dp[full_mask] + (number of non-zero subsets - 1)\n    # Actually, we need to handle the case where we can't find perfect subsets\n    # The optimal solution is to settle all debts with k-1 transactions if no zero-sum subsets exist\n    # But our DP should handle it\n    \n    # Alternative simpler approach: minimum transactions is at most k-1\n    # We try to find maximum number of zero-sum subsets we can form\n    # Each zero-sum subset of size t can be settled with t-1 transactions\n    # So answer = k - (max number of zero-sum subsets)\n    \n    # Actually, the DP above computes the minimum transactions directly\n    # We just need to ensure we handle all cases\n    \n    # If DP didn't find solution (shouldn't happen), fallback to k-1\n    result = dp[(1 << k) - 1]\n    if result == float('inf'):\n        result = k - 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 301.272123336792}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return 0\\r\\n    n = int(data[0])\\r\\n    arr = list(map(int, data[1:1+n]))\\r\\n    \\r\\n    # Condition: Arrayland interval [min(|x|,|y|), max(|x|,|y|)] must be within Vectorland interval [|x-y|, |x+y|]\\r\\n    # This is equivalent to: max(|x|,|y|)  |x+y| AND min(|x|,|y|)  |x-y|\\r\\n    # Since |x+y|  max(|x|,|y|) always holds for real numbers (triangle inequality),\\r\\n    # we only need to check: min(|x|,|y|)  |x-y|\\r\\n    # Which simplifies to: min(|x|,|y|)  |x-y|\\r\\n    \\r\\n    # For unordered pairs {x,y}, we need to count pairs where min(|x|,|y|)  |x-y|\\r\\n    # Let a = |x|, b = |y|, assume a  b\\r\\n    # Condition becomes: a  |x-y|\\r\\n    # But |x-y| could be |a-b|, |a+b|, or |a-b| depending on signs\\r\\n    # Actually, we need to consider original x,y signs\\r\\n    \\r\\n    # Better approach: The condition min(|x|,|y|)  |x-y| is equivalent to:\\r\\n    # |x-y|  min(|x|,|y|)\\r\\n    # This means the distance between x and y on number line is at most the smaller absolute value\\r\\n    \\r\\n    # Let\\'s analyze cases:\\r\\n    # 1. If x and y have same sign: |x-y| = ||x|-|y|| = |a-b|\\r\\n    #    Condition: min(a,b)  |a-b|\\r\\n    #    Since a  b, this becomes: a  b-a  2a  b  b  2a\\r\\n    #    So for same sign: |y|  2*|x| (assuming |x|  |y|)\\r\\n    \\r\\n    # 2. If x and y have opposite signs: |x-y| = |x| + |y| = a+b\\r\\n    #    Condition: min(a,b)  a+b  impossible since a+b > min(a,b) for positive a,b\\r\\n    #    So opposite signs never satisfy the condition\\r\\n    \\r\\n    # Therefore, we only need to consider pairs with same sign (both positive or both negative)\\r\\n    # And for such pairs (with |x|  |y|), we need |y|  2*|x|\\r\\n    \\r\\n    # Since we\\'re counting unordered pairs, we can:\\r\\n    # 1. Separate positive and negative numbers\\r\\n    # 2. For each group, sort absolute values\\r\\n    # 3. For each element as x (smaller absolute), count how many y have |y|  2*|x|\\r\\n    # 4. Subtract 1 to exclude pairing with itself\\r\\n    \\r\\n    pos = []\\r\\n    neg = []\\r\\n    \\r\\n    for num in arr:\\r\\n        if num >= 0:\\r\\n            pos.append(num)\\r\\n        else:\\r\\n            neg.append(-num)  # Store absolute values for negatives\\r\\n    \\r\\n    def count_pairs(group):\\r\\n        if len(group) < 2:\\r\\n            return 0\\r\\n        group.sort()\\r\\n        count = 0\\r\\n        j = 0\\r\\n        for i in range(len(group)):\\r\\n            # For group[i] as x, find all j > i such that group[j]  2*group[i]\\r\\n            # Since group is sorted, we can maintain pointer j\\r\\n            while j < len(group) and group[j] <= 2 * group[i]:\\r\\n                j += 1\\r\\n            # j is first index where group[j] > 2*group[i]\\r\\n            # So indices i+1 to j-1 satisfy condition\\r\\n            valid_count = j - i - 1\\r\\n            count += valid_count\\r\\n        return count\\r\\n    \\r\\n    result = count_pairs(pos) + count_pairs(neg)\\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 1237, 1238, 'illegal multibyte sequence')", "runtime_sec": 41.37132263183594}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 225.74147033691406}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Sort values\n    a.sort()\n    \n    total = 0\n    # For each element a[i], count how many combinations where it is the maximum\n    for i in range(K-1, N):\n        # Choose K-1 elements from the i smaller elements\n        comb = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + a[i] * comb) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 148.8682141304016}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:2+r]\n    \n    # Track rows and columns that have strawberries\n    row_has_strawberry = [False]*r\n    col_has_strawberry = [False]*c\n    \n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                row_has_strawberry[i] = True\n                col_has_strawberry[j] = True\n    \n    # Count rows without strawberries\n    safe_rows = 0\n    for i in range(r):\n        if not row_has_strawberry[i]:\n            safe_rows += 1\n    \n    # Count columns without strawberries\n    safe_cols = 0\n    for j in range(c):\n        if not col_has_strawberry[j]:\n            safe_cols += 1\n    \n    # Calculate maximum cells that can be eaten\n    # All cells in safe rows + all cells in safe columns\n    # But subtract intersections counted twice\n    result = safe_rows * c + safe_cols * r - safe_rows * safe_cols\n    \n    # However, we need to ensure we don't count cells with strawberries\n    # But by definition, safe rows/cols have no strawberries, so all cells in them are '.'\n    # So the formula above is correct\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1725.5663831233978}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "complexity_estimate": null, "runtime_sec": 89.65667414665222}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach: try to place largest possible digit at each position\n    for i in range(length):\n        if k == 0:\n            break\n        # Find the largest digit from i+1 to end\n        max_idx = i\n        for j in range(i+1, length):\n            if n[j] > n[max_idx]:\n                max_idx = j\n        # If the largest digit is already at position i, continue\n        if max_idx == i:\n            continue\n        # Check if swapping would cause leading zero\n        if i == 0 and n[max_idx] == '0':\n            continue\n        # Perform swap\n        n[i], n[max_idx] = n[max_idx], n[i]\n        k -= 1\n    \n    # If k is odd and length > 1, we might need to adjust\n    # For exactly k swaps, if k > 0 after greedy, we can swap last two digits if possible\n    while k > 0 and length > 1:\n        # Find two equal digits to swap without changing the number\n        found = False\n        for i in range(length):\n            for j in range(i+1, length):\n                if n[i] == n[j]:\n                    # Swap equal digits\n                    n[i], n[j] = n[j], n[i]\n                    k -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            # If no equal digits, swap last two digits (ensuring no leading zero)\n            if length >= 2 and not (n[0] == '0' and n[1] == '0'):\n                n[-1], n[-2] = n[-2], n[-1]\n                k -= 1\n            else:\n                break\n    \n    print(''.join(n))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 220.52446675300598}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 94.21317887306213}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = [0] + [int(data[i]) for i in range(1, n+1)]  # 1-indexed\n    \n    visited = [False] * (n + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 135.5276505947113}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 277.1932272911072}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic(first, count, diff):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    if count <= 0:\n        return 0\n    last = first + (count - 1) * diff\n    total = (first + last) % MOD\n    total = (total * count) % MOD\n    # Multiply by modular inverse of 2\n    return (total * 500000004) % MOD\n\ndef sum_range(l, r):\n    \"\"\"Return sum of numbers from position l to r (1-indexed) modulo MOD.\"\"\"\n    def sum_up_to(n):\n        if n == 0:\n            return 0\n        total = 0\n        stage = 1\n        start_pos = 1\n        odd_start = 1\n        even_start = 2\n        \n        while start_pos <= n:\n            length = 1 << (stage - 1)  # 2^(stage-1)\n            actual_len = min(length, n - start_pos + 1)\n            \n            if stage % 2 == 1:  # Odd stage\n                total = (total + sum_arithmetic(odd_start, actual_len, 2)) % MOD\n                odd_start += 2 * actual_len\n            else:  # Even stage\n                total = (total + sum_arithmetic(even_start, actual_len, 2)) % MOD\n                even_start += 2 * actual_len\n            \n            start_pos += length\n            stage += 1\n        \n        return total\n    \n    return (sum_up_to(r) - sum_up_to(l - 1)) % MOD\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    result = sum_range(l, r)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 1895.5451974868774}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    xs = list(map(int, data[1:1+n]))\n    \n    # The optimal P is the integer closest to the mean of xs\n    # Since stamina is (X_i - P)^2, minimizing sum of squares\n    # is achieved when P is the mean (or nearest integer for integer constraint)\n    # We'll try all integers from min(xs) to max(xs) to be safe\n    min_x = min(xs)\n    max_x = max(xs)\n    \n    min_stamina = float('inf')\n    for p in range(min_x, max_x + 1):\n        stamina = sum((x - p) ** 2 for x in xs)\n        if stamina < min_stamina:\n            min_stamina = stamina\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 584.9872772693634}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 205.16479110717773}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs_escape(R, C, grid):\n    # Find start and destination positions\n    start = dest = None\n    water_queue = deque()\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'D':\n                dest = (i, j)\n            elif grid[i][j] == '*':\n                water_queue.append((i, j, 0))  # (row, col, time)\n    \n    if not start or not dest:\n        return \"KAKTUS\"\n    \n    # BFS for water flood times\n    water_time = [[-1] * C for _ in range(R)]\n    for i, j, t in water_queue:\n        water_time[i][j] = t\n    \n    while water_queue:\n        r, c, t = water_queue.popleft()\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if grid[nr][nc] == '.' and water_time[nr][nc] == -1:\n                    water_time[nr][nc] = t + 1\n                    water_queue.append((nr, nc, t + 1))\n    \n    # BFS for hedgehog movement\n    visited = [[False] * C for _ in range(R)]\n    queue = deque([(start[0], start[1], 0)])  # (row, col, time)\n    visited[start[0]][start[1]] = True\n    \n    while queue:\n        r, c, t = queue.popleft()\n        if (r, c) == dest:\n            return str(t)\n        \n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                # Check if cell is passable and safe from water\n                if grid[nr][nc] == '.' or grid[nr][nc] == 'D':\n                    # Check water condition: either no water or water arrives after we leave\n                    water_arrival = water_time[nr][nc]\n                    if water_arrival == -1 or water_arrival > t + 1:\n                        visited[nr][nc] = True\n                        queue.append((nr, nc, t + 1))\n    \n    return \"KAKTUS\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    R, C = map(int, data[0].split())\n    grid = [list(row.strip()) for row in data[1:1+R]]\n    \n    result = bfs_escape(R, C, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 155.0157356262207}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 168.89183163642883}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 263.06207513809204}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 288.6346974372864}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\nimport heapq\n\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            xr, yr = yr, xr\n        self.parent[yr] = xr\n        if self.rank[xr] == self.rank[yr]:\n            self.rank[xr] += 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    edges = []\n    for i in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v, i))\n    \n    edges.sort()\n    \n    dsu = DSU(n)\n    mst_edges = []\n    mst_cost = 0\n    \n    # Kruskal to find MST and collect edges by weight\n    weight_groups = {}\n    i = 0\n    while i < m:\n        w = edges[i][0]\n        group = []\n        while i < m and edges[i][0] == w:\n            _, u, v, idx = edges[i]\n            group.append((u, v, idx))\n            i += 1\n        weight_groups[w] = group\n    \n    # Re-run Kruskal to build MST and track edges\n    dsu2 = DSU(n)\n    operations = 0\n    \n    for w in sorted(weight_groups.keys()):\n        group = weight_groups[w]\n        # First pass: count how many edges in this weight can be added to MST\n        # without creating cycles\n        temp_dsu = DSU(n)\n        for u, v, idx in group:\n            if dsu2.find(u) != dsu2.find(v):\n                temp_dsu.union(u, v)\n        \n        # Second pass: actually add edges to MST and count conflicts\n        for u, v, idx in group:\n            if dsu2.find(u) != dsu2.find(v):\n                dsu2.union(u, v)\n                mst_cost += w\n            else:\n                # This edge creates a cycle with same weight edges already in MST\n                # Check if it's in the same connected component in temp_dsu\n                if temp_dsu.find(u) == temp_dsu.find(v):\n                    operations += 1\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 737.4736728668213}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 323.301815032959}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 450.0167338848114}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "TLE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 218.04693460464478}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 234.48391461372375}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 1}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    it = iter(input)\n    H = int(next(it))\n    W = int(next(it))\n    K = int(next(it))\n    x1 = int(next(it)) - 1\n    y1 = int(next(it)) - 1\n    x2 = int(next(it)) - 1\n    y2 = int(next(it)) - 1\n    \n    grid = []\n    for _ in range(H):\n        row = list(next(it))\n        grid.append(row)\n    \n    # BFS with 0-1 BFS optimization for K moves\n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # We'll use deque for 0-1 BFS\n    # Each state: (x, y, direction, remaining_steps)\n    # But simpler: maintain distance and use BFS with pruning\n    \n    # Standard BFS with optimization for K moves\n    dq = deque()\n    dq.append((x1, y1))\n    \n    # Precompute next positions for each direction\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        if x == x2 and y == y2:\n            print(current_dist)\n            return\n        \n        # Explore all four directions\n        for dx, dy in dirs:\n            # Try moves of 1 to K steps\n            for step in range(1, K + 1):\n                nx = x + dx * step\n                ny = y + dy * step\n                \n                # Check bounds\n                if nx < 0 or nx >= H or ny < 0 or ny >= W:\n                    break\n                \n                # Check if lotus leaf\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    dq.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # No need to continue in this direction if distance is not improving\n                    # This is an optimization\n                    break\n            \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 386.6546666622162}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 290.14103174209595}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\n\ndef is_consistent():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"consistent\"\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        u = int(data[idx]); idx += 1\n        op = data[idx]; idx += 1\n        v = int(data[idx]); idx += 1\n        \n        if op == '=':\n            dsu.union(u, v)\n        else:  # op == '>'\n            edges.append((u, v))\n    \n    # Build graph for topological sort\n    adj = [[] for _ in range(N)]\n    indegree = [0] * N\n    \n    for u, v in edges:\n        u_root = dsu.find(u)\n        v_root = dsu.find(v)\n        if u_root == v_root:\n            return \"inconsistent\"  # Player can't beat themselves\n        adj[u_root].append(v_root)\n        indegree[v_root] += 1\n    \n    # Kahn's algorithm for topological sort\n    queue = [i for i in range(N) if indegree[i] == 0 and dsu.find(i) == i]\n    processed = 0\n    \n    while queue:\n        node = queue.pop()\n        processed += 1\n        for neighbor in adj[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if all components were processed\n    unique_roots = set(dsu.find(i) for i in range(N))\n    return \"consistent\" if processed == len(unique_roots) else \"inconsistent\"\n\nif __name__ == \"__main__\":\n    print(is_consistent())", "complexity_estimate": null, "runtime_sec": 154.36287212371826}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    s = list(data[1])\n    for i in range(m):\n        l, r, c1, c2 = data[2 + i].split()\n        l, r = int(l), int(r)\n        for j in range(l - 1, r):\n            if s[j] == c1:\n                s[j] = c2\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 944.3464760780334}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        \n        # Check if s is k-periodic\n        valid = True\n        num_blocks = n // k\n        \n        for i in range(1, num_blocks):\n            prev_block = s[(i-1)*k : i*k]\n            curr_block = s[i*k : (i+1)*k]\n            \n            # Check if curr_block is right-rotation of prev_block\n            if curr_block != prev_block[-1] + prev_block[:-1]:\n                valid = False\n                break\n        \n        if valid:\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 178.42613434791565}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 235.4846386909485}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef fenwick_update(tree, idx, delta, n):\n    \"\"\"Update Fenwick tree: add delta to element at idx (0-based).\"\"\"\n    i = idx + 1  # convert to 1-based index for BIT\n    while i <= n:\n        tree[i] += delta\n        i += i & -i\n\ndef fenwick_query(tree, idx):\n    \"\"\"Query prefix sum up to idx (0-based, exclusive).\"\"\"\n    if idx <= 0:\n        return 0\n    i = idx  # idx is already exclusive upper bound\n    res = 0\n    while i > 0:\n        res += tree[i]\n        i -= i & -i\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    # Fenwick tree (1-indexed internally)\n    bit = [0] * (n + 1)\n    out_lines = []\n    \n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            fenwick_update(bit, i, delta, n)\n        else:  # op == '?'\n            i = int(next(it))\n            # query sum of a[0] + ... + a[i-1]\n            res = fenwick_query(bit, i)\n            out_lines.append(str(res))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 103.50320315361023}

{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 300.91822147369385}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build answer string\n    ans = []\n    cur_char = 'a'\n    i = 0\n    while i < n:\n        # Determine length of current run\n        run_len = 1\n        while run_len <= n - i and c[run_len-1] > 0:\n            # Decrement counts for all substrings starting at i\n            for k in range(1, min(run_len+1, n-i+1)):\n                if c[k-1] > 0:\n                    c[k-1] -= 1\n            run_len += 1\n        run_len -= 1  # Adjust back\n        \n        # Append run of current character\n        ans.append(cur_char * run_len)\n        i += run_len\n        \n        # Move to next character\n        cur_char = chr(ord(cur_char) + 1)\n        if cur_char > 'z':\n            cur_char = 'a'\n    \n    # Output result\n    print(''.join(ans))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 349.6647057533264}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 271.0102572441101}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(1 << 25)\n\nclass Node:\n    __slots__ = ('val', 'left', 'right', 'size')\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.size = 1\n\ndef insert(root, val, depth, total):\n    if root is None:\n        return Node(val), depth, total + depth\n    \n    root.size += 1\n    if val < root.val:\n        root.left, depth, total = insert(root.left, val, depth + 1, total)\n    else:\n        root.right, depth, total = insert(root.right, val, depth + 1, total)\n    return root, depth, total\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    seq = list(map(int, data[1:1+n]))\n    \n    root = None\n    total = 0\n    out_lines = []\n    \n    for val in seq:\n        depth = 0\n        root, depth, total = insert(root, val, depth, total)\n        out_lines.append(str(total))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 146.98698091506958}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 238.65550255775452}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Buy cake first\n    remaining_after_cake = X - A\n    \n    # Buy as many donuts as possible\n    donuts_count = remaining_after_cake // B\n    \n    # Calculate remaining money\n    remaining = remaining_after_cake - (donuts_count * B)\n    \n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 181.31737852096558}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 261.0792953968048}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\nn = int(data[idx]); idx += 1\na = list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\nqueries = []\nfor _ in range(m):\n    k = int(data[idx]); idx += 1\n    pos = int(data[idx]); idx += 1\n    queries.append((k, pos))\n\n# Pair each element with its original index\nindexed_a = [(a[i], i) for i in range(n)]\n# Sort by value descending, then by index ascending for tie-breaking\nindexed_a.sort(key=lambda x: (-x[0], x[1]))\n\n# Precompute prefix sums of sorted indices for binary search\nsorted_indices = [idx for _, idx in indexed_a]\nprefix_sums = [0] * (n + 1)\nfor i in range(n):\n    prefix_sums[i + 1] = prefix_sums[i] + sorted_indices[i]\n\nanswers = []\nfor k, pos in queries:\n    # For given k, we need the first k elements in sorted order\n    # But we must select them in original order for lexicographic minimality\n    # The optimal subsequence consists of the k largest values,\n    # and when values are equal, we pick the ones with smaller indices first\n    # Then we sort these k selected indices to maintain original order\n    selected_indices = sorted(sorted_indices[:k])\n    # pos is 1-indexed, convert to 0-indexed\n    original_idx = selected_indices[pos - 1]\n    answers.append(str(a[original_idx]))\n\nsys.stdout.write('\\n'.join(answers))", "complexity_estimate": null, "runtime_sec": 360.2515127658844}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 186.2942225933075}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 236.74282550811768}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 441.8419978618622}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 710.7558875083923}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 261.30939865112305}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    l = list(map(int, data[1:1+n]))\n    c = list(map(int, data[1+n:1+2*n]))\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP over gcd values\n    INF = 10**18\n    dp = defaultdict(lambda: INF)\n    dp[0] = 0\n    \n    for i in range(n):\n        li, ci = l[i], c[i]\n        new_dp = dp.copy()\n        for g_val, cost in dp.items():\n            new_g = math.gcd(g_val, li)\n            if cost + ci < new_dp[new_g]:\n                new_dp[new_g] = cost + ci\n        dp = new_dp\n    \n    result = dp.get(1, INF)\n    print(result if result < INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 513.9820005893707}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 666.8794875144958}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 239.43704628944397}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 194.24853682518005}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # BFS to explore safe reachable area\n    visited = [[False]*W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    # Directions: up, down, left, right\n    dirs = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    while queue:\n        r, c = queue.pop(0)\n        \n        # Collect gold if present\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent cell is a trap\n        near_trap = False\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if grid[nr][nc] == 'T':\n                    near_trap = True\n                    break\n        \n        # If near trap, don't explore further from this cell\n        if near_trap:\n            continue\n        \n        # Explore safe adjacent cells\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if not visited[nr][nc] and grid[nr][nc] != '#':\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 109.44106316566467}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 389.46442914009094}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 203.2056770324707}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 184.11392974853516}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 211.87367916107178}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height within m days.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        if current_height < target:\n            needed = target - current_height\n            if needed > m - days_used:\n                return False\n            days_used += needed\n            current += needed\n            # Mark end of watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    return days_used <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for maximum achievable minimum height\n    low = min(heights)\n    high = low + m  # Maximum possible increase\n    answer = low\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 351.46363258361816}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 139.16643357276917}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 259.7432086467743}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 223.4056420326233}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 166.674866437912}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245055 tokens (243455 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 14.05332064628601}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    for mask in range(1, 16):\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2906.408944129944}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    seen = set()\n    result = []\n    \n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    \n    result.reverse()\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1156.886948108673}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 204.3275420665741}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Calculate current best and worst among first four\n    current_best = times[0]\n    current_worst = times[3]\n    \n    # For the final score calculation:\n    # We have 5 times total: t1, t2, t3, t4, and x (last solve)\n    # After sorting all 5 times, we discard the min and max\n    # Then take average of middle 3\n    \n    # We need to find maximum x such that final_score <= target\n    # Or determine if impossible or infinite\n    \n    # Case analysis based on where x falls in sorted order\n    \n    # Helper function to calculate final score given x\n    def calculate_final_score(x):\n        all_times = sorted(times + [x])\n        # Discard min and max, average middle 3\n        middle_sum = all_times[1] + all_times[2] + all_times[3]\n        return middle_sum / 3.0\n    \n    # Check if already winning with worst possible x (20.00)\n    if calculate_final_score(20.00) <= target:\n        print(\"infinite\")\n        return\n    \n    # Check if losing with best possible x (1.00)\n    if calculate_final_score(1.00) > target:\n        print(\"impossible\")\n        return\n    \n    # Binary search for maximum x that satisfies final_score <= target\n    lo, hi = 1.00, 20.00\n    eps = 1e-9\n    \n    for _ in range(100):  # Sufficient iterations for required precision\n        mid = (lo + hi) / 2.0\n        if calculate_final_score(mid) <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to 2 decimal places\n    result = round(lo, 2)\n    # Ensure proper formatting with exactly 2 decimal places\n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 158.9725022315979}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "N = int(input().strip())\nif 100 <= N <= 999:\n    digits = str(N)\n    if digits == digits[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "complexity_estimate": null, "runtime_sec": 341.2939946651459}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    n = int(data[0])\\r\\n    a = list(map(int, data[1:1+n]))\\r\\n    \\r\\n    # Base case: n=1, no valid x exists (2*x+1 ≤ n → x≥1 gives 3≤1 false)\\r\\n    if n == 1:\\r\\n        print(-1)\\r\\n        return\\r\\n    \\r\\n    # For each x, we can take from indices x, 2*x, 2*x+1 (1‑based)\\r\\n    # Convert to 0‑based: indices x-1, 2*x-1, 2*x\\r\\n    moves = 0\\r\\n    # Process from largest x down to 1\\r\\n    for x in range(n//2, 0, -1):\\r\\n        if 2*x + 1 > n:\\r\\n            continue\\r\\n        i, j, k = x-1, 2*x-1, 2*x  # 0‑based indices\\r\\n        # Take as many coins as possible from the limiting chest\\r\\n        take = min(a[i], a[j], a[k])\\r\\n        if take > 0:\\r\\n            a[i] -= take\\r\\n            a[j] -= take\\r\\n            a[k] -= take\\r\\n            moves += take\\r\\n    \\r\\n    # After processing all x, check if all chests are empty\\r\\n    if all(v == 0 for v in a):\\r\\n        print(moves)\\r\\n    else:\\r\\n        print(-1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 363, 364, 'illegal multibyte sequence')", "runtime_sec": 192.90744376182556}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.readline\n\nN = int(input().strip())\nstrings = [input().strip() for _ in range(N)]\n\nparent = list(range(N))\nsize = [1] * N\ncontent = [s for s in strings]\n\ndef find(x):\n    while parent[x] != x:\n        parent[x] = parent[parent[x]]\n        x = parent[x]\n    return x\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    \n    root_a = find(a)\n    root_b = find(b)\n    \n    if root_a != root_b:\n        if size[root_a] < size[root_b]:\n            root_a, root_b = root_b, root_a\n        \n        content[root_a] += content[root_b]\n        content[root_b] = ''\n        parent[root_b] = root_a\n        size[root_a] += size[root_b]\n\nfinal_root = find(0)\nprint(content[final_root])", "complexity_estimate": null, "runtime_sec": 223.84476923942566}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data[:2])\n    total_cost = X + Y // 2\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 259.80311584472656}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    event_set = set()  # set of events currently considered to have happened\n    results = []\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        if parts[0] == 'E':\n            event = parts[1]\n            events_stack.append(event)\n            event_set.add(event)\n        elif parts[0] == 'D':\n            r = int(parts[1])\n            for _ in range(r):\n                if events_stack:\n                    event_set.remove(events_stack.pop())\n        elif parts[0] == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current state\n            consistent = True\n            for event_desc in scenario_events:\n                if event_desc.startswith('!'):\n                    event_name = event_desc[1:]\n                    if event_name in event_set:\n                        consistent = False\n                        break\n                else:\n                    if event_desc not in event_set:\n                        consistent = False\n                        break\n            \n            if consistent:\n                results.append(\"Yes\")\n                continue\n            \n            # Try to find smallest r that makes scenario consistent\n            # by simulating undoing r events\n            found_r = None\n            temp_stack = events_stack.copy()\n            temp_set = set(event_set)\n            \n            for r_candidate in range(1, len(events_stack) + 1):\n                # Undo r_candidate events\n                for _ in range(r_candidate):\n                    if temp_stack:\n                        temp_set.remove(temp_stack.pop())\n                \n                # Check consistency with this undone state\n                temp_consistent = True\n                for event_desc in scenario_events:\n                    if event_desc.startswith('!'):\n                        event_name = event_desc[1:]\n                        if event_name in temp_set:\n                            temp_consistent = False\n                            break\n                    else:\n                        if event_desc not in temp_set:\n                            temp_consistent = False\n                            break\n                \n                if temp_consistent:\n                    found_r = r_candidate\n                    break\n                \n                # Reset for next iteration\n                temp_stack = events_stack.copy()\n                temp_set = set(event_set)\n            \n            if found_r is not None:\n                results.append(f\"{found_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 118.54596090316772}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213632 tokens (212032 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 12.749352216720581}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data)\n    # All possible routes with 2 flights starting from each airport\n    routes = [\n        P + Q,  # A->B->C\n        P + R,  # A->C->B\n        Q + P,  # B->A->C\n        Q + R,  # B->C->A\n        R + P,  # C->A->B\n        R + Q   # C->B->A\n    ]\n    print(min(routes))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 510.0638473033905}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 265.0841097831726}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 449.44029998779297}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        candies = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        moves = 0\n        last_eaten = 0\n        current_sum = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            \n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += candies[left]\n                    left += 1\n                alice_total += current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += candies[right]\n                    right -= 1\n                bob_total += current_sum\n            \n            last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 108.72295355796814}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 214.1211655139923}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 258.7734971046448}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 174.81749844551086}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 418.17511081695557}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 240.88137125968933}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 310.3517532348633}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 228.8032329082489}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1279.254566669464}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            result.append(x - 1)\n        else:\n            result.append(x)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 424.59669399261475}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    thore_index = names.index(\"ThoreHusfeldt\")\n    \n    # Check if Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Get names above Thore\n    above_names = names[:thore_index]\n    \n    # Check for \"Thore sucks\" condition\n    thore_prefix = \"ThoreHusfeld\"  # without trailing 't'\n    for name in above_names:\n        if name.startswith(thore_prefix):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    thore_name = \"ThoreHusfeldt\"\n    for prefix_len in range(1, len(thore_name) + 1):\n        prefix = thore_name[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Fallback (shouldn't happen with given constraints)\n    print(thore_name)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 187.72627139091492}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 239.08823323249817}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 358.98233675956726}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 230.31072735786438}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 356.3939416408539}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 194.14334058761597}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 223.71682405471802}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 339.35363578796387}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive, calm):\n    \"\"\"Return True if dog is aggressive at arrival minute.\"\"\"\n    cycle = aggressive + calm\n    position_in_cycle = arrival % cycle\n    # Aggressive during first aggressive minutes of cycle\n    return position_in_cycle > 0 and position_in_cycle <= aggressive\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: minute 1 means during first minute\n    arrivals = [P, M, G]\n    \n    results = []\n    for arrival in arrivals:\n        dog1 = is_aggressive(arrival, A, B)\n        dog2 = is_aggressive(arrival, C, D)\n        if dog1 and dog2:\n            results.append('both')\n        elif dog1 or dog2:\n            results.append('one')\n        else:\n            results.append('none')\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()", "complexity_estimate": null, "runtime_sec": 104.01139092445374}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror pairs for capital letters\n    mirror_pairs = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O',\n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',\n        'Y': 'Y', '8': '8'  # Note: '8' is not in input but included for completeness\n    }\n    \n    n = len(word)\n    # Check each character and its mirror counterpart\n    for i in range((n + 1) // 2):  # Only need to check half the string\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Both characters must be mirror-symmetric themselves\n        if left_char not in mirror_pairs or right_char not in mirror_pairs:\n            return False\n        \n        # And they must be mirror pairs of each other\n        if mirror_pairs[left_char] != right_char:\n            return False\n    \n    return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    result = 'YES' if is_mirror_word(data) else 'NO'\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 2752.7146718502045}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 752.2333707809448}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 179.58332228660583}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 328.8975398540497}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1555.3236110210419}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Map values to indices for easier tracking\n    value_to_idx = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Count how many complete sequences we can form\n    counts = [0] * 6\n    \n    for num in a:\n        idx = value_to_idx[num]\n        if idx == 0:\n            # Start of a new sequence\n            counts[0] += 1\n        else:\n            # Check if we can extend the previous element\n            if counts[idx-1] > 0:\n                counts[idx-1] -= 1\n                counts[idx] += 1\n    \n    # The number of complete sequences is counts[5]\n    complete_sequences = counts[5]\n    \n    # Total elements in good array = complete_sequences * 6\n    # Elements to remove = n - (complete_sequences * 6)\n    result = n - (complete_sequences * 6)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 306.2046887874603}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123800 tokens (2122200 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 17.110865354537964}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 309.1077973842621}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 234.35597038269043}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 269.1312983036041}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 4006.987873315811}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins needed is the smaller count of chips that need to move by 1\n    # If we choose even target, all odd chips need 1 coin each\n    # If we choose odd target, all even chips need 1 coin each\n    result = min(even_count, odd_count)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1683.0979809761047}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 182.18218183517456}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nidx = 0\n\nn = int(data[idx]); idx += 1\ncapacity = [0] + list(map(int, data[idx:idx + n])); idx += n\nm = int(data[idx]); idx += 1\n\nwater = [0] * (n + 1)\n\nfor _ in range(m):\n    t = int(data[idx]); idx += 1\n    if t == 1:\n        p = int(data[idx]); idx += 1\n        x = int(data[idx]); idx += 1\n        \n        while p <= n and x > 0:\n            space = capacity[p] - water[p]\n            if x <= space:\n                water[p] += x\n                x = 0\n            else:\n                water[p] = capacity[p]\n                x -= space\n                p += 1\n    else:\n        k = int(data[idx]); idx += 1\n        print(water[k])", "complexity_estimate": null, "runtime_sec": 260.987423658371}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = int(data[1])\n    enemies = list(map(int, data[2:2+n]))\n    \n    # Sort enemy fleets in ascending order\n    enemies.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemies:\n        # To win, Atli needs at least enemy+1 ships\n        needed = enemy + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            # Can't win this battle with remaining ships\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 97.22476387023926}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split('\\n')\n    if len(data) < 2:\n        print('corrupted')\n        return\n    I, O = data[0], data[1]\n    \n    # Find all positions of + and - in I\n    plus_positions = [i for i, ch in enumerate(I) if ch == '+']\n    minus_positions = [i for i, ch in enumerate(I) if ch == '-']\n    \n    # If no + or - in I, check if I == O\n    if not plus_positions and not minus_positions:\n        if I == O:\n            print('<any> <any>')\n        else:\n            print('corrupted')\n        return\n    \n    # Generate all possible encodings\n    results = []\n    \n    # Try all possible splits of O for each + and -\n    # We need to match the structure of I\n    def backtrack(i_idx, o_idx, plus_enc, minus_enc, in_plus, in_minus):\n        if i_idx == len(I) and o_idx == len(O):\n            # Valid match found\n            results.append((plus_enc, minus_enc))\n            return\n        if i_idx >= len(I) or o_idx >= len(O):\n            return\n        \n        if I[i_idx] == '+':\n            # Try all possible substrings for this +\n            for end in range(o_idx, len(O)+1):\n                enc = O[o_idx:end]\n                backtrack(i_idx+1, end, enc if not in_plus else plus_enc, minus_enc, True, in_minus)\n        elif I[i_idx] == '-':\n            # Try all possible substrings for this -\n            for end in range(o_idx, len(O)+1):\n                enc = O[o_idx:end]\n                backtrack(i_idx+1, end, plus_enc, enc if not in_minus else minus_enc, in_plus, True)\n        else:\n            # Regular character, must match exactly\n            if I[i_idx] == O[o_idx]:\n                backtrack(i_idx+1, o_idx+1, plus_enc, minus_enc, in_plus, in_minus)\n            else:\n                return\n    \n    backtrack(0, 0, '', '', False, False)\n    \n    if not results:\n        print('corrupted')\n        return\n    \n    # Process results to handle <any> and <empty>\n    final_results = set()\n    for plus_enc, minus_enc in results:\n        plus_str = '<any>' if plus_enc == '' and len(plus_positions) == 0 else (plus_enc if plus_enc else '<empty>')\n        minus_str = '<any>' if minus_enc == '' and len(minus_positions) == 0 else (minus_enc if minus_enc else '<empty>')\n        final_results.add((plus_str, minus_str))\n    \n    # Output all unique results\n    for plus_str, minus_str in sorted(final_results):\n        print(f'{plus_str} {minus_str}')\n\nif __name__ == '__main__':\n    solve()", "complexity_estimate": null, "runtime_sec": 277.5452387332916}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "l, r, x, y, k = map(int, input().split())\nfound = False\nfor b in range(x, y + 1):\n    a = k * b\n    if l <= a <= r:\n        found = True\n        break\nprint('YES' if found else 'NO')", "complexity_estimate": null, "runtime_sec": 91.84053301811218}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 229.340740442276}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s):\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev, curr = suffix[i-1], suffix[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            curr_key = (rank[curr], rank[curr + k] if curr + k < n else -1)\n            tmp[curr] = tmp[prev] + (prev_key != curr_key)\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # LCP array construction using Kasai's algorithm\n    lcp = [0] * n\n    inv_suffix = [0] * n\n    for i in range(n):\n        inv_suffix[suffix[i]] = i\n    \n    k = 0\n    for i in range(n):\n        if inv_suffix[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv_suffix[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_suffix[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # Maximum LCP value is the answer\n    return max(lcp) if lcp else 0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    s = data[1]\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 144.61767601966858}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 3817.9567580223083}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    X, A, B = map(int, sys.stdin.read().split())\n    days_before_best_by = A\n    days_after_purchase = B\n    days_after_best_by = days_after_purchase - days_before_best_by\n    \n    if days_after_best_by <= 0:\n        print(\"delicious\")\n    elif days_after_best_by <= X:\n        print(\"safe\")\n    else:\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 135.44180250167847}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Calculate wall line parameters: ax + by + c = 0\n    a = y2 - y1\n    b = x1 - x2\n    c = x2*y1 - x1*y2\n    \n    # Distance from pole (0,0) to wall\n    dist_to_wall = abs(c) / math.hypot(a, b) if (a != 0 or b != 0) else 0\n    \n    # Function to calculate area covered with chain length r\n    def area_with_chain(r):\n        if r <= dist_to_wall:\n            # Full circle area\n            return math.pi * r * r\n        else:\n            # Circle minus segment blocked by wall\n            d = dist_to_wall\n            # Angle of the blocked segment (twice the angle from center to intersection)\n            theta = 2 * math.acos(d / r)\n            # Area of circular segment: (1/2)*r^2*(theta - sin(theta))\n            segment_area = 0.5 * r * r * (theta - math.sin(theta))\n            # Full circle minus the blocked segment\n            return math.pi * r * r - segment_area\n    \n    # Binary search for minimal integer r giving area >= L\n    low, high = 0, 100000  # Upper bound large enough for L up to 10000\n    while low < high:\n        mid = (low + high) // 2\n        if area_with_chain(mid) >= L:\n            high = mid\n        else:\n            low = mid + 1\n    \n    print(low)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 106.9661009311676}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 355.5838165283203}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    result = A * B\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 535.8122954368591}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 189.82637238502502}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().splitlines()\n    S = data[0]\n    Q = int(data[1])\n    queries = data[2:]\n    \n    # Use two deques to handle front and back additions efficiently\n    from collections import deque\n    front = deque()\n    back = deque(S)\n    reversed_flag = False\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            # Toggle reversed flag\n            reversed_flag = not reversed_flag\n        else:\n            # parts[0] == '2'\n            F = int(parts[1])\n            C = parts[2]\n            \n            # Determine actual position considering reversed state\n            if reversed_flag:\n                # When reversed, front and back swap conceptually\n                if F == 1:\n                    # Add to beginning when reversed = add to end normally\n                    back.append(C)\n                else:  # F == 2\n                    # Add to end when reversed = add to beginning normally\n                    front.appendleft(C)\n            else:\n                # Normal orientation\n                if F == 1:\n                    front.appendleft(C)\n                else:  # F == 2\n                    back.append(C)\n    \n    # Construct final string\n    front_str = ''.join(front)\n    back_str = ''.join(back)\n    result = front_str + back_str\n    \n    # Reverse if needed\n    if reversed_flag:\n        result = result[::-1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 246.6719150543213}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 198.8314962387085}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 286.90262627601624}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            out_lines.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            out_lines.append(\"-1\")\n            continue\n        \n        # Calculate needed additional sleep after first alarm\n        need = a - b\n        # Sleep gained per cycle (c - d minutes of actual sleep)\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        \n        # Total time = first alarm + cycles * c\n        total_time = b + cycles * c\n        out_lines.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 181.9344756603241}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Initialize sieve: True means not crossed out (prime candidate), False means crossed out\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    crossed_out_count = 0\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # Cross out p itself (it's prime, but we cross it out as per algorithm)\n            if is_prime[p]:\n                is_prime[p] = False\n                crossed_out_count += 1\n                if crossed_out_count == K:\n                    print(p)\n                    return\n            \n            # Cross out multiples of p\n            for multiple in range(p * p, N + 1, p):\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out_count += 1\n                    if crossed_out_count == K:\n                        print(multiple)\n                        return\n    \n    # If K is larger than total crossed out numbers (shouldn't happen per constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 422.59986567497253}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, enemy kills one gnome per turn regardless of grouping\n    if k == 1:\n        # Sum of 1 through n\n        print(n * (n + 1) // 2)\n        return\n    \n    # If m is large enough to make each group size <= k-1\n    # Then enemy can only kill one group per turn (since group size < k)\n    # We want to maximize turns by having as many groups as possible\n    # But groups must be non-empty, so max groups = min(m, n)\n    max_groups = min(m, n)\n    \n    # If we can make all groups size <= k-1\n    if max_groups * (k - 1) >= n:\n        # Distribute gnomes as evenly as possible among max_groups groups\n        # Each group size <= k-1\n        # Enemy kills one group per turn\n        # Damage = sum of remaining gnomes each turn\n        # This is equivalent to sum from n down to 0 in steps of 1\n        # But actually we need to simulate the optimal enemy strategy\n        # When all groups <= k-1, enemy kills smallest group first\n        # So we should make groups as equal as possible\n        \n        # Calculate group sizes\n        base_size = n // max_groups\n        remainder = n % max_groups\n        groups = [base_size + 1] * remainder + [base_size] * (max_groups - remainder)\n        \n        # Simulate turns\n        total_damage = 0\n        while groups:\n            # Damage this turn\n            total_damage += sum(groups)\n            # Enemy kills smallest group\n            groups.sort()\n            groups.pop(0)\n        \n        print(total_damage)\n        return\n    \n    # Otherwise, we need some groups of size >= k\n    # Optimal strategy: create one large group and many small groups\n    # The large group should be as large as possible to maximize initial damage\n    # Small groups should be size 1 to maximize number of turns\n    \n    # Number of small groups (size 1) we can create\n    small_groups = min(m - 1, n)\n    if small_groups < 0:\n        small_groups = 0\n    \n    # Size of large group\n    large_group = n - small_groups\n    if large_group < 0:\n        large_group = 0\n    \n    # If large_group == 0, then all groups are small\n    if large_group == 0:\n        # All groups size 1\n        total_damage = 0\n        remaining = n\n        for i in range(n):\n            total_damage += remaining\n            remaining -= 1\n        print(total_damage)\n        return\n    \n    # Simulate battle with one large group and small_groups groups of size 1\n    total_damage = 0\n    current_large = large_group\n    current_small = small_groups\n    \n    # Phase 1: Large group is being reduced by k each turn\n    while current_large >= k:\n        total_damage += current_large + current_small\n        current_large -= k\n    \n    # Phase 2: Large group is now size < k\n    # Combine with small groups\n    all_groups = []\n    if current_large > 0:\n        all_groups.append(current_large)\n    all_groups.extend([1] * current_small)\n    \n    # Enemy kills one group per turn (all groups now < k)\n    while all_groups:\n        total_damage += sum(all_groups)\n        all_groups.sort()\n        all_groups.pop(0)\n    \n    print(total_damage)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 124.13530969619751}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 257.32358503341675}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, -score, i))  # Store negative score for descending order\n        idx += 2\n    \n    # Sort by city (lexicographical) and then by negative score (descending)\n    restaurants.sort(key=lambda x: (x[0], x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 297.1409113407135}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"RE": 1}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs(grid, start, state_id, n, m):\n    \"\"\"BFS to find distances from state cells to all '.' cells.\"\"\"\n    dist = [[-1] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state_id:\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        x, y = q.popleft()\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                if dist[nx][ny] == -1:\n                    dist[nx][ny] = dist[x][y] + (1 if grid[nx][ny] == '.' else 0)\n                    q.append((nx, ny))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Compute distances from each state to all cells\n    dist1 = bfs(grid, '1', '1', n, m)\n    dist2 = bfs(grid, '2', '2', n, m)\n    dist3 = bfs(grid, '3', '3', n, m)\n    \n    # Find minimum connection cost between each pair of states\n    INF = 10**9\n    min_12 = min_13 = min_23 = INF\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                d1, d2, d3 = dist1[i][j], dist2[i][j], dist3[i][j]\n                if d1 != -1 and d2 != -1:\n                    cost = d1 + d2 - (1 if grid[i][j] == '.' else 0)\n                    min_12 = min(min_12, cost)\n                if d1 != -1 and d3 != -1:\n                    cost = d1 + d3 - (1 if grid[i][j] == '.' else 0)\n                    min_13 = min(min_13, cost)\n                if d2 != -1 and d3 != -1:\n                    cost = d2 + d3 - (1 if grid[i][j] == '.' else 0)\n                    min_23 = min(min_23, cost)\n    \n    # Check if any pair is unreachable\n    if min_12 == INF or min_13 == INF or min_23 == INF:\n        print(-1)\n        return\n    \n    # Consider three connection strategies:\n    # 1. Connect all three via a single meeting point\n    best = INF\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                d1, d2, d3 = dist1[i][j], dist2[i][j], dist3[i][j]\n                if d1 != -1 and d2 != -1 and d3 != -1:\n                    cost = d1 + d2 + d3 - (2 if grid[i][j] == '.' else 0)\n                    best = min(best, cost)\n    \n    # 2. Connect via two meeting points (chain)\n    best = min(best, min_12 + min_13)\n    best = min(best, min_12 + min_23)\n    best = min(best, min_13 + min_23)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 1253.039885520935}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 221.90520787239075}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into positive and negative b_i\n    pos = []\n    neg = []\n    for a, b in projects:\n        if b >= 0:\n            pos.append((a, b))\n        else:\n            neg.append((a, b))\n    \n    # Sort positive projects by required rating ascending\n    pos.sort(key=lambda x: x[0])\n    \n    # Process positive projects first\n    for a, b in pos:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # Sort negative projects by (required rating + rating change) descending\n    # Equivalent to sorting by (a + b) descending\n    neg.sort(key=lambda x: -(x[0] + x[1]))\n    \n    # Process negative projects\n    for a, b in neg:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1849.9316551685333}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 278.54874563217163}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    freq = [0] * (n + 1)\n    distinct_count = 0\n    result = []\n    \n    for difficulty in a:\n        if freq[difficulty] == 0:\n            distinct_count += 1\n        freq[difficulty] += 1\n        \n        if distinct_count == n:\n            result.append('1')\n            # Remove one from each difficulty\n            for d in range(1, n + 1):\n                freq[d] -= 1\n                if freq[d] == 0:\n                    distinct_count -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 366.6509907245636}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    ans = 0\n    for A in range(1, N + 1):\n        max_B = N // A\n        for B in range(1, max_B + 1):\n            product = A * B\n            if product >= N:\n                break\n            C = N - product\n            if C > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1526.3797070980072}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "RE": 1, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 197.49399256706238}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    g = s.find('G')\n    t = s.find('T')\n    if g > t:\n        g, t = t, g\n    if (t - g) % k != 0:\n        print(\"NO\")\n        return\n    for i in range(g, t + 1, k):\n        if s[i] == '#':\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 3378.5605969429016}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef min_islands(grid, r, c):\n    # First, treat all 'C' as water to minimize islands\n    # Create a copy where C -> W\n    temp_grid = [list(row) for row in grid]\n    for i in range(r):\n        for j in range(c):\n            if temp_grid[i][j] == 'C':\n                temp_grid[i][j] = 'W'\n    \n    # Count islands in this configuration (all C as water)\n    visited = [[False]*c for _ in range(r)]\n    \n    def dfs(i, j):\n        if i < 0 or i >= r or j < 0 or j >= c:\n            return\n        if visited[i][j] or temp_grid[i][j] != 'L':\n            return\n        visited[i][j] = True\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if temp_grid[i][j] == 'L' and not visited[i][j]:\n                count += 1\n                dfs(i, j)\n    \n    # Now, we need to consider if making some C into L could reduce islands\n    # Actually, making C into L can only potentially merge islands if:\n    # 1. The C connects existing L regions\n    # 2. The C is adjacent to multiple L regions from different islands\n    \n    # But to minimize islands, we want to maximize merging\n    # So we should treat C as L when it helps connect islands\n    \n    # Approach: treat all C as L first, then count islands\n    # But we must ensure we don't create land where water is required\n    # Actually, we can treat C as either L or W, but W is already covered above\n    # So the minimum islands is min(islands_with_all_C_as_W, islands_with_all_C_as_L)\n    \n    # Count islands with all C as L\n    temp_grid2 = [list(row) for row in grid]\n    for i in range(r):\n        for j in range(c):\n            if temp_grid2[i][j] == 'C':\n                temp_grid2[i][j] = 'L'\n    \n    visited2 = [[False]*c for _ in range(r)]\n    \n    def dfs2(i, j):\n        if i < 0 or i >= r or j < 0 or j >= c:\n            return\n        if visited2[i][j] or temp_grid2[i][j] != 'L':\n            return\n        visited2[i][j] = True\n        dfs2(i+1, j)\n        dfs2(i-1, j)\n        dfs2(i, j+1)\n        dfs2(i, j-1)\n    \n    count2 = 0\n    for i in range(r):\n        for j in range(c):\n            if temp_grid2[i][j] == 'L' and not visited2[i][j]:\n                count2 += 1\n                dfs2(i, j)\n    \n    # The actual minimum is min(count, count2)\n    # But wait, we need to be careful: C can be either L or W independently\n    # So we need to find the assignment that minimizes islands\n    \n    # Actually, the optimal strategy is:\n    # 1. All C as W gives some number of islands\n    # 2. Changing C to L can only reduce islands if it connects existing L regions\n    # So the minimum is achieved by treating C as L whenever it connects L regions\n    \n    # We can use union-find to find connected components of L\n    # Then for each C, check if it's adjacent to multiple components\n    # If yes, we can merge those components by making that C L\n    \n    # But actually, the problem is simpler: we just need the minimum possible\n    # Since C can be either L or W, the minimum islands is when we maximize merging\n    # This happens when we treat all C as L (to potentially connect islands)\n    # But we must respect that W cells cannot be changed\n    \n    # Actually, let me think: if we have L...C...L, making C L connects them\n    # So islands_with_all_C_as_L <= islands_with_all_C_as_W\n    # Therefore min(islands_with_all_C_as_L, islands_with_all_C_as_W) = islands_with_all_C_as_L\n    \n    # Wait, but what if making C L creates new islands?\n    # Example: isolated C surrounded by W - making it L creates new island\n    # But that would increase islands, not decrease\n    # So for minimization, we wouldn't do that\n    \n    # Actually, the correct approach: treat all C as L, then count islands\n    # This gives the minimum possible because:\n    # 1. Any C treated as W instead of L cannot reduce island count (only potentially increase)\n    # 2. Treating C as L allows maximum connectivity\n    \n    return min(count, count2)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    r, c = map(int, data[0].split())\n    grid = data[1:1+r]\n    result = min_islands(grid, r, c)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 134.7486093044281}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 252.3809745311737}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 1148.8665533065796}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 187.474933385849}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 356.8690810203552}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    table_count = 0\n    max_table = 0\n    seen = set()\n    \n    for sock in socks:\n        if sock in seen:\n            table_count -= 1\n            seen.remove(sock)\n        else:\n            table_count += 1\n            seen.add(sock)\n            if table_count > max_table:\n                max_table = table_count\n    \n    print(max_table)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 420.75497698783875}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    R1, S = map(int, data[:2])\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 90.74619626998901}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 215.41066813468933}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 229.72772121429443}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    max_count = 0\n    # For each possible value, consider it as X and count how many elements can be made equal to X\n    for val in set(arr):\n        # Count elements that are already val, or can become val by +/-1\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 138.04930210113525}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 240.5237741470337}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(input[idx])\n        b = int(input[idx + 1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 134.8220784664154}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    times = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all T_i\n    lcm_result = 1\n    for t in times:\n        # Compute GCD using math.gcd (Python 3.5+)\n        g = math.gcd(lcm_result, t)\n        # Update LCM: lcm = lcm * t // gcd(lcm, t)\n        # Check for potential overflow beyond 10^18\n        if lcm_result > 10**18 // (t // g):\n            lcm_result = 10**18 + 1  # Exceeds limit\n            break\n        lcm_result = lcm_result * (t // g)\n    \n    # Output result if within limit, else output 10^18 (as per problem statement)\n    if lcm_result <= 10**18:\n        print(lcm_result)\n    else:\n        print(10**18)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 708.673903465271}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 242.31128811836243}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read().split()\nn, k = map(int, input[:2])\ndenoms = list(map(int, input[2:2+n]))\nq = int(input[2+n])\nqueries = list(map(int, input[3+n:3+n+q]))\n\n# Precompute all possible sums with at most k bills and at most 2 denominations\n# dp[count][sum] = True if achievable with exactly 'count' bills\n# We'll use two denominations at a time\nmax_sum = max(queries)\nINF = 10**9\nbest = [INF] * (max_sum + 1)\nbest[0] = 0  # 0 sum requires 0 bills\n\n# Try all pairs of denominations (including same denomination twice)\nfor i in range(n):\n    d1 = denoms[i]\n    for j in range(i, n):\n        d2 = denoms[j]\n        # Generate all combinations with at most k bills\n        # Use BFS-like approach for two denominations\n        # We can have a bills of d1 and b bills of d2 where a+b <= k\n        for a in range(k+1):\n            if a * d1 > max_sum:\n                break\n            remaining_k = k - a\n            for b in range(remaining_k+1):\n                total = a * d1 + b * d2\n                if total > max_sum:\n                    break\n                bills = a + b\n                if bills > 0 and bills <= k:\n                    if bills < best[total]:\n                        best[total] = bills\n\n# Also consider single denomination case (already covered when i=j)\n# But we need to handle when only one denomination is used with up to k bills\n# This is already covered in the loops above when i=j\n\n# Answer queries\nresults = []\nfor x in queries:\n    if x <= max_sum and best[x] != INF:\n        results.append(str(best[x]))\n    else:\n        results.append(\"-1\")\n\nprint(\"\\n\".join(results))", "complexity_estimate": null, "runtime_sec": 3785.1337010860443}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Count pairs\n    ans = 0\n    \n    # Handle remainder 0 separately\n    ans += (rem_count[0] // 2) * 2\n    \n    # For k even, handle remainder k//2 separately\n    if k % 2 == 0:\n        ans += (rem_count[k // 2] // 2) * 2\n    \n    # Pair remainders i and k-i for i from 1 to (k-1)//2\n    for i in range(1, (k + 1) // 2):\n        if i != k - i:  # This is always true when k is odd, and for even k we skip the middle\n            pairs = min(rem_count[i], rem_count[k - i])\n            ans += pairs * 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 309.13549971580505}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 325.1856224536896}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "COMPLEXITY": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 249.42871975898743}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    s = int(input().strip())\n    seen = {}\n    current = s\n    index = 1\n    \n    while True:\n        if current in seen:\n            print(index)\n            return\n        seen[current] = index\n        \n        if current % 2 == 0:\n            current = current // 2\n        else:\n            current = 3 * current + 1\n        \n        index += 1\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 497.8825352191925}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 1, "COMPLEXITY": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 350.26084184646606}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open+1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close-1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon+1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 4039.4476130008698}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 313.723304271698}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the greatest common divisor of all numbers\n    g = arr[0]\n    for num in arr[1:]:\n        g = math.gcd(g, num)\n    \n    # For each number, divide by gcd and check if it's only composed of factors 2 and 3\n    for num in arr:\n        x = num // g\n        # Remove all factors of 2\n        while x % 2 == 0:\n            x //= 2\n        # Remove all factors of 3\n        while x % 3 == 0:\n            x //= 3\n        # If anything remains other than 1, it's not possible\n        if x != 1:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1361.6646173000336}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 225.26910042762756}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n        edges.append((x, y, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(n, adj, i)\n    \n    # Compute base total cost\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # For each route, compute new distance with this edge zero\n        new_total = 0\n        for a, b in routes:\n            # New distance is min of:\n            # 1. Original distance\n            # 2. Path through zero edge: min(d[a][x] + d[y][b], d[a][y] + d[x][b])\n            original = dists[a][b]\n            through_edge = min(dists[a][x] + dists[y][b], dists[a][y] + dists[x][b])\n            new_total += min(original, through_edge)\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 112.64309024810791}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(200000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    rx, ry = find(x, parent), find(y, parent)\n    if rx == ry:\n        return\n    if size[rx] < size[ry]:\n        rx, ry = ry, rx\n    parent[ry] = rx\n    size[rx] += size[ry]\n\ndef bfs(start, adj):\n    visited = [False] * len(adj)\n    queue = [(start, 0)]\n    visited[start] = True\n    farthest_node, max_dist = start, 0\n    while queue:\n        node, dist = queue.pop(0)\n        if dist > max_dist:\n            farthest_node, max_dist = node, dist\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append((neighbor, dist + 1))\n    return farthest_node, max_dist\n\ndef tree_diameter(adj, component_nodes):\n    if not component_nodes:\n        return 0\n    start = next(iter(component_nodes))\n    farthest, _ = bfs(start, adj)\n    _, diameter = bfs(farthest, adj)\n    return diameter\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    c, l = int(data[0]), int(data[1])\n    edges = []\n    idx = 2\n    for _ in range(l):\n        a, b = int(data[idx]), int(data[idx + 1])\n        edges.append((a, b))\n        idx += 2\n    \n    parent = list(range(c))\n    size = [1] * c\n    adj = [[] for _ in range(c)]\n    for a, b in edges:\n        union(a, b, parent, size)\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    components = {}\n    for i in range(c):\n        root = find(i, parent)\n        if root not in components:\n            components[root] = []\n        components[root].append(i)\n    \n    diameters = []\n    for nodes in components.values():\n        diameters.append(tree_diameter(adj, nodes))\n    \n    diameters.sort(reverse=True)\n    if len(diameters) == 1:\n        print(diameters[0])\n    else:\n        max_d = diameters[0]\n        second_d = diameters[1]\n        result = max(max_d, (max_d + 1) // 2 + (second_d + 1) // 2 + 1)\n        for i in range(2, len(diameters)):\n            result = max(result, (diameters[i] + 1) // 2 + 1 + (max_d + 1) // 2)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 114.92659497261047}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 501.85783433914185}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 241.3552439212799}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 250.94323229789734}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    def max_beauty(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    result = max(max_beauty('a'), max_beauty('b'))\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 2043.4545896053314}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 246.07846474647522}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 237.64083695411682}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef rotate_90_cw(x, y, n, m):\n    return y, n - x + 1, m, n\n\ndef rotate_90_ccw(x, y, n, m):\n    return m - y + 1, x, m, n\n\ndef horizontal_flip(x, y, n, m):\n    return x, m - y + 1, n, m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        \n        # Apply transformations\n        curr_n, curr_m = n, m\n        \n        # x clockwise rotations\n        for _ in range(x % 4):\n            xi, yi, curr_n, curr_m = rotate_90_cw(xi, yi, curr_n, curr_m)\n        \n        # y horizontal flips\n        for _ in range(y % 2):\n            xi, yi, curr_n, curr_m = horizontal_flip(xi, yi, curr_n, curr_m)\n        \n        # z counterclockwise rotations\n        for _ in range(z % 4):\n            xi, yi, curr_n, curr_m = rotate_90_ccw(xi, yi, curr_n, curr_m)\n        \n        results.append(f\"{xi} {yi}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 1164.8735756874084}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    # Each character can be any digit from 1 to N, and there are 3 characters\n    # So total possibilities = N * N * N = N^3\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 374.0178575515747}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 288.3124899864197}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' from the left and consecutive '>' from the right\n        left_count = 0\n        for ch in s:\n            if ch == '<':\n                left_count += 1\n            else:\n                break\n        right_count = 0\n        for ch in reversed(s):\n            if ch == '>':\n                right_count += 1\n            else:\n                break\n        # The answer is the minimum of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 185.48568058013916}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data)\n    # Check if Y is even (since each animal contributes an even number of legs)\n    if Y % 2 != 0:\n        print(\"No\")\n        return\n    # Let c be number of cranes, t be number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: from first equation, t = X - c\n    # Substitute: 2c + 4(X - c) = Y => 2c + 4X - 4c = Y => -2c = Y - 4X => c = (4X - Y) / 2\n    # c must be non-negative integer\n    numerator = 4 * X - Y\n    if numerator < 0:\n        print(\"No\")\n        return\n    if numerator % 2 != 0:\n        print(\"No\")\n        return\n    c = numerator // 2\n    t = X - c\n    if t < 0:\n        print(\"No\")\n        return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 626.5437355041504}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    grid = [list(row.strip()) for row in data[1:1+n]]\n    \n    # Check if any row is all 'E'\n    all_e_rows = []\n    for i in range(n):\n        if all(cell == 'E' for cell in grid[i]):\n            all_e_rows.append(i)\n    \n    # Check if any column is all 'E'\n    all_e_cols = []\n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            all_e_cols.append(j)\n    \n    # If there's both a full 'E' row and full 'E' column, impossible\n    if all_e_rows and all_e_cols:\n        print(-1)\n        return\n    \n    # Strategy: pick cells that are not 'E'\n    spells = []\n    \n    # If there's at least one row without all 'E', use that row\n    if not all_e_rows:\n        for i in range(n):\n            # Find first non-'E' in this row\n            for j in range(n):\n                if grid[i][j] != 'E':\n                    spells.append((i+1, j+1))\n                    break\n    else:\n        # All rows have at least one non-'E', but we need to avoid full 'E' columns\n        # Use columns instead\n        for j in range(n):\n            # Find first non-'E' in this column\n            for i in range(n):\n                if grid[i][j] != 'E':\n                    spells.append((i+1, j+1))\n                    break\n    \n    # Verify coverage\n    purified = [[False]*n for _ in range(n)]\n    for r, c in spells:\n        ri, ci = r-1, c-1\n        # Purify row\n        for j in range(n):\n            purified[ri][j] = True\n        # Purify column\n        for i in range(n):\n            purified[i][ci] = True\n    \n    # Check if all cells are covered\n    for i in range(n):\n        for j in range(n):\n            if not purified[i][j]:\n                print(-1)\n                return\n    \n    # Output\n    if not spells:\n        print(-1)\n    else:\n        for r, c in spells:\n            print(f\"{r} {c}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 965.5972752571106}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # Generate all possible (fret, note_index) pairs\n    pairs = []\n    for note_idx, note in enumerate(b):\n        for string_val in a:\n            if note > string_val:\n                fret = note - string_val\n                pairs.append((fret, note_idx))\n    \n    # Sort by fret value\n    pairs.sort()\n    \n    # Sliding window to find minimal range covering all notes\n    m = len(pairs)\n    freq = [0] * n  # frequency of notes in current window\n    notes_in_window = 0\n    min_diff = float('inf')\n    \n    left = 0\n    for right in range(m):\n        fret_val, note_idx = pairs[right]\n        if freq[note_idx] == 0:\n            notes_in_window += 1\n        freq[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while notes_in_window == n:\n            min_diff = min(min_diff, fret_val - pairs[left][0])\n            left_fret, left_note_idx = pairs[left]\n            freq[left_note_idx] -= 1\n            if freq[left_note_idx] == 0:\n                notes_in_window -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 306.5842192173004}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 150.0913016796112}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nsys.setrecursionlimit(200000)\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    n = int(data[0])\\r\\n    p = [0] * (n + 1)\\r\\n    for i in range(2, n + 1):\\r\\n        p[i] = int(data[i - 1])\\r\\n    \\r\\n    # Step 1: Compute depths of all nodes\\r\\n    depth = [0] * (n + 1)\\r\\n    for i in range(2, n + 1):\\r\\n        depth[i] = depth[p[i]] + 1\\r\\n    \\r\\n    # Step 2: Group nodes by depth\\r\\n    max_depth = max(depth)\\r\\n    nodes_at_depth = [[] for _ in range(max_depth + 1)]\\r\\n    for i in range(1, n + 1):\\r\\n        nodes_at_depth[depth[i]].append(i)\\r\\n    \\r\\n    # Step 3: Process from deepest to shallowest\\r\\n    # count[i] = number of apples that will reach node i (mod 2)\\r\\n    count = [0] * (n + 1)\\r\\n    for d in range(max_depth, -1, -1):\\r\\n        for node in nodes_at_depth[d]:\\r\\n            # Each node starts with 1 apple\\r\\n            current = 1\\r\\n            # Add contributions from children\\r\\n            # We need to find children efficiently\\r\\n            # Since we process from deep to shallow, children are already processed\\r\\n            # But we don\\'t have children list, so we\\'ll handle differently\\r\\n            # Actually, we can propagate counts upward\\r\\n            # For each node, after processing its depth, we add its count to parent\\r\\n            pass\\r\\n    \\r\\n    # Better approach: Process nodes in reverse order (n down to 1)\\r\\n    # This ensures children are processed before parents\\r\\n    count = [0] * (n + 1)\\r\\n    for i in range(n, 0, -1):\\r\\n        # Start with 1 apple at this node\\r\\n        current = 1\\r\\n        # Add counts from all direct children\\r\\n        # To find children efficiently, we need adjacency list\\r\\n        \\r\\n    # Let\\'s build children list\\r\\n    children = [[] for _ in range(n + 1)]\\r\\n    for i in range(2, n + 1):\\r\\n        children[p[i]].append(i)\\r\\n    \\r\\n    count = [0] * (n + 1)\\r\\n    def dfs(node):\\r\\n        total = 1  # apple at this node\\r\\n        for child in children[node]:\\r\\n            total += dfs(child)\\r\\n        # Mod 2: only parity matters for annihilation\\r\\n        count[node] = total % 2\\r\\n        return count[node]\\r\\n    \\r\\n    dfs(1)\\r\\n    \\r\\n    # Apples collected = sum of count[i] where i is collected\\r\\n    # Actually, apples are collected only at node 1\\r\\n    # The apple from node i reaches node 1 if count[i] = 1 along the path\\r\\n    # But with annihilation, we need to simulate flow to root\\r\\n    \\r\\n    # New insight: The process is equivalent to:\\r\\n    # For each node, if the XOR (parity) of apples in its subtree is 1,\\r\\n    # then 1 apple will eventually reach this node from below.\\r\\n    # Then this apple propagates upward, combining with others.\\r\\n    \\r\\n    # Actually simpler: The final result is just the parity of number of nodes\\r\\n    # at each depth! Because apples at same depth reach root at same time.\\r\\n    \\r\\n    # Let\\'s verify with examples:\\r\\n    # Example 1: n=3, depths: [0,1,1] -> parities: depth0:1, depth1:2->0 -> total=1 ✓\\r\\n    # Example 2: n=5, depths: [0,1,2,2,2] -> parities: d0:1, d1:1, d2:3->1 -> total=3 ✓\\r\\n    # Example 3: Let\\'s compute...\\r\\n    \\r\\n    # So algorithm:\\r\\n    # 1. Compute depth of each node\\r\\n    # 2. Count nodes at each depth\\r\\n    # 3. Sum (count_at_depth % 2) for all depths\\r\\n    \\r\\n    depth = [0] * (n + 1)\\r\\n    for i in range(2, n + 1):\\r\\n        depth[i] = depth[p[i]] + 1\\r\\n    \\r\\n    max_depth = max(depth)\\r\\n    cnt_at_depth = [0] * (max_depth + 1)\\r\\n    for i in range(1, n + 1):\\r\\n        cnt_at_depth[depth[i]] += 1\\r\\n    \\r\\n    result = 0\\r\\n    for cnt in cnt_at_depth:\\r\\n        result += cnt % 2\\r\\n    \\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 2931, 2932, 'illegal multibyte sequence')", "runtime_sec": 144.30053615570068}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    ships = 0\n    while b > 0:\n        ships += a // b\n        a, b = b, a % b\n    return ships\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(0)\n    else:\n        a, b = map(int, data[:2])\n        print(count_ships(a, b))", "complexity_estimate": null, "runtime_sec": 1881.8946120738983}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    # If N is even, answer is N (since N is divisible by both 2 and N)\n    # If N is odd, answer is 2*N (since 2*N is divisible by both 2 and N)\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 501.5865910053253}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 1, "COMPLEXITY": 1, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 259.06385803222656}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 311.49394059181213}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m = int(data[0])\n    # n is not needed for the decision\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 93.52491283416748}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 278.59879994392395}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 274.40467405319214}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 262.4109437465668}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 239.50291919708252}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # Sort distances to find the two smallest edges\n    edges = [a, b, c]\n    edges.sort()\n    min1, min2 = edges[0], edges[1]\n    \n    # For n >= 2: first meal at Rabbit's (distance 0)\n    # Then we need (n-1) transitions between houses\n    # Strategy: use the smallest edge repeatedly, but may need to use second smallest\n    # depending on starting position and parity\n    \n    # After first meal at Rabbit's, we can go to either Owl or Eeyore\n    # We'll choose the cheaper of a or b initially\n    first_step = min(a, b)\n    remaining = n - 2  # transitions after the first move\n    \n    # For remaining transitions, we can alternate between the two smallest edges\n    # The optimal pattern depends on which house we're in after first step\n    # But we can compute minimum by considering both possibilities\n    \n    # Option 1: Start with a (Rabbit->Owl)\n    if a <= b:\n        # After at Owl, we can alternate between min(a,c) and min(b,c)\n        # Actually simpler: we need (n-2) additional moves after first\n        # Each additional move costs min(min1, min2) if we can alternate properly\n        total1 = a + (n - 2) * min(min1, min2)\n    else:\n        total1 = float('inf')\n    \n    # Option 2: Start with b (Rabbit->Eeyore)\n    if b <= a:\n        total2 = b + (n - 2) * min(min1, min2)\n    else:\n        total2 = float('inf')\n    \n    # Actually, we need to be more careful about alternating pattern\n    # The optimal is: first move with min(a,b), then alternate between\n    # the two smallest available edges from current position\n    # But since we can always choose the minimum edge from current vertex,\n    # and the graph is triangle with edges a,b,c,\n    # the minimum total = min(a,b) + (n-2)*min(min1, min2)\n    \n    result = min(a, b) + (n - 2) * min(min1, min2)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 1980.1758949756622}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    N = int(input[0])\n    A = list(map(int, input[1:]))\n    \n    subordinates = [0] * (N + 1)\n    \n    for i in range(2, N + 1):\n        boss = A[i - 2]\n        subordinates[boss] += 1\n    \n    for i in range(1, N + 1):\n        print(subordinates[i])\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 135.25815892219543}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 221.82769751548767}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith('po'):\n        return 'FILIPINO'\n    elif sentence.endswith('desu') or sentence.endswith('masu'):\n        return 'JAPANESE'\n    elif sentence.endswith('mnida'):\n        return 'KOREAN'\n    else:\n        # According to problem statement, this case shouldn't occur\n        return 'UNKNOWN'\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i]\n        results.append(detect_language(sentence))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 224.3442347049713}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    trains = []\n    idx = 1\n    for _ in range(N-1):\n        C = int(data[idx]); S = int(data[idx+1]); F = int(data[idx+2])\n        trains.append((C, S, F))\n        idx += 3\n    \n    results = []\n    for start in range(N):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait until next departure\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results.append(str(current_time))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 139.4979009628296}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 265.78236627578735}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 275.80885314941406}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    H, W = map(int, data[:2])\n    grid = data[2:]\n    \n    # Directions for 8 adjacent cells\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n                continue\n            \n            count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                    count += 1\n            row_chars.append(str(count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 139.84502840042114}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 236.8964011669159}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 220.891437292099}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 1342.790647983551}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import re\n\ndef is_vowel(c, next_char=None):\n    \"\"\"Check if character c is a vowel, considering Y rules.\"\"\"\n    c = c.upper()\n    if c == 'Y':\n        if next_char and next_char.upper() in 'AEIOU':\n            return False  # Y is consonant when followed by another vowel\n        return True\n    return c in 'AEIOU'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to the given rules.\"\"\"\n    # Extract alphabetic part\n    alpha_match = re.match(r'^([A-Za-z]*)', word)\n    if not alpha_match:\n        return 1  # Shouldn't happen per problem definition\n    alpha = alpha_match.group(1).upper()\n    if not alpha:\n        return 1  # Non-alphabetic word has 1 syllable\n    \n    # Handle QU as single consonant\n    alpha = re.sub('QU', 'Q', alpha)\n    \n    # Mark vowels\n    vowels = []\n    for i, ch in enumerate(alpha):\n        next_ch = alpha[i+1] if i+1 < len(alpha) else None\n        vowels.append(is_vowel(ch, next_ch))\n    \n    # Apply silent E rule\n    if len(alpha) >= 1 and alpha[-1] == 'E':\n        if len(alpha) >= 3 and alpha[-2] == 'L' and not is_vowel(alpha[-3], None):\n            pass  # Keep the E (e.g., 'able')\n        else:\n            vowels[-1] = False  # Silent E\n    \n    # Apply ES rule\n    if len(alpha) >= 2 and alpha[-2:] == 'ES':\n        if len(alpha) >= 4 and not is_vowel(alpha[-3], None) and not is_vowel(alpha[-4], None):\n            pass  # Keep ES as syllable (e.g., 'witches')\n        else:\n            # Remove potential syllable from ES\n            if vowels[-2]:  # If E was marked as vowel\n                vowels[-2] = False\n            if vowels[-1]:  # If S was marked as vowel (shouldn't happen)\n                vowels[-1] = False\n    \n    # Count syllable divisions\n    syllables = 0\n    in_consonant_group = False\n    has_vowel_before = False\n    \n    for i, is_v in enumerate(vowels):\n        if is_v:\n            if in_consonant_group and has_vowel_before:\n                syllables += 1\n                has_vowel_before = True\n            else:\n                has_vowel_before = True\n            in_consonant_group = False\n        else:\n            if has_vowel_before:\n                in_consonant_group = True\n    \n    if has_vowel_before:\n        syllables += 1\n    \n    return max(1, syllables)\n\ndef find_haiku(words):\n    \"\"\"Try to split words into 5-7-5 syllable lines.\"\"\"\n    n = len(words)\n    syllable_counts = [count_syllables(w) for w in words]\n    \n    # DP to find valid splits\n    # dp[i][j] = True if first i words can form j syllables in current line\n    # We need lines with exactly 5, 7, 5 syllables\n    \n    # Try all possible splits\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            # First line: words[0:i], syllables = sum(syllable_counts[0:i])\n            first_syllables = sum(syllable_counts[0:i])\n            if first_syllables != 5:\n                continue\n            \n            # Second line: words[i:j], syllables = sum(syllable_counts[i:j])\n            second_syllables = sum(syllable_counts[i:j])\n            if second_syllables != 7:\n                continue\n            \n            # Third line: words[j:], syllables = sum(syllable_counts[j:])\n            third_syllables = sum(syllable_counts[j:])\n            if third_syllables != 5:\n                continue\n            \n            # Found valid split\n            line1 = ' '.join(words[0:i])\n            line2 = ' '.join(words[i:j])\n            line3 = ' '.join(words[j:])\n            return f\"{line1}\\n{line2}\\n{line3}\"\n    \n    return None\n\ndef main():\n    import sys\n    line = sys.stdin.read().rstrip('\\n')\n    \n    # Split into words while preserving punctuation\n    words = []\n    current = ''\n    for ch in line:\n        if ch == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += ch\n    if current:\n        words.append(current)\n    \n    result = find_haiku(words)\n    if result:\n        print(result)\n    else:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 213.7343773841858}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 281.40706491470337}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "A, B = map(int, input().split())\nif A == B:\n    print(\"Draw\")\nelif A == 1:\n    print(\"Alice\")\nelif B == 1:\n    print(\"Bob\")\nelif A > B:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")", "complexity_estimate": null, "runtime_sec": 414.5178608894348}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 315.97503304481506}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    s = data[idx]\n    idx += 1\n    \n    # Find first occurrence of different consecutive characters\n    start = 0\n    while start < n and s[start] == s[0]:\n        start += 1\n    \n    if start == n:\n        # All characters are the same\n        results.append((n + 2) // 3)\n        continue\n    \n    # Rotate string so it starts with the first change\n    s_rotated = s[start:] + s[:start]\n    \n    count = 0\n    i = 0\n    while i < n:\n        j = i\n        while j < n and s_rotated[j] == s_rotated[i]:\n            j += 1\n        length = j - i\n        count += length // 3\n        i = j\n    \n    results.append(count)\n\nprint('\\n'.join(map(str, results)))", "complexity_estimate": null, "runtime_sec": 222.82646417617798}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "x = list(map(int, input().split()))\nfor i in range(5):\n    if x[i] == 0:\n        print(i + 1)\n        break", "complexity_estimate": null, "runtime_sec": 210.09518122673035}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 221.49760484695435}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 240.6941213607788}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 230.8236439228058}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\n\ndef min_transactions(M, debts):\n    # Filter out zero balances\n    balances = [debts[i] for i in range(M) if debts[i] != 0]\n    n = len(balances)\n    \n    # DP array: dp[mask] = min transactions for subset represented by mask\n    dp = [float('inf')] * (1 << n)\n    dp[0] = 0\n    \n    # Precompute subset sums\n    subset_sum = [0] * (1 << n)\n    for mask in range(1 << n):\n        s = 0\n        for i in range(n):\n            if mask & (1 << i):\n                s += balances[i]\n        subset_sum[mask] = s\n    \n    # DP transition: try to settle subsets with zero sum\n    for mask in range(1 << n):\n        # Try to add a submask that sums to zero\n        sub = mask\n        while sub > 0:\n            if subset_sum[sub] == 0:\n                dp[mask] = min(dp[mask], dp[mask ^ sub] + (bin(sub).count('1') - 1))\n            sub = (sub - 1) & mask\n    \n    return dp[(1 << n) - 1] if n > 0 else 0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    M = int(data[0])\n    N = int(data[1])\n    \n    debts = [0] * M\n    idx = 2\n    for _ in range(N):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        p = int(data[idx+2])\n        idx += 3\n        debts[a] -= p\n        debts[b] += p\n    \n    result = min_transactions(M, debts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 213.6788308620453}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', '#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nint main() {\\r\\n    ios_base::sync_with_stdio(false);\\r\\n    cin.tie(nullptr);\\r\\n    \\r\\n    int n;\\r\\n    cin >> n;\\r\\n    vector<long long> a(n);\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        cin >> a[i];\\r\\n    }\\r\\n    \\r\\n    // Transform to absolute values and sort\\r\\n    vector<long long> abs_vals;\\r\\n    for (long long val : a) {\\r\\n        abs_vals.push_back(abs(val));\\r\\n    }\\r\\n    sort(abs_vals.begin(), abs_vals.end());\\r\\n    \\r\\n    // Count pairs where max(|x|,|y|) <= min(|x-y|,|x+y|) and min(|x|,|y|) >= max(|x-y|,|x+y|)\\r\\n    // But actually: Arrayland interval [min(|x|,|y|), max(|x|,|y|)]\\r\\n    // Vectorland interval [min(|x-y|,|x+y|), max(|x-y|,|x+y|)]\\r\\n    // Condition: Arrayland ⊆ Vectorland\\r\\n    // So: min(|x|,|y|) >= min(|x-y|,|x+y|) AND max(|x|,|y|) <= max(|x-y|,|x+y|)\\r\\n    \\r\\n    // For any x,y: |x-y| ≤ |x|+|y| and |x+y| ≤ |x|+|y|\\r\\n    // Also: |x-y| ≥ ||x|-|y|| and |x+y| ≥ ||x|-|y||\\r\\n    \\r\\n    // Let A = min(|x|,|y|), B = max(|x|,|y|)\\r\\n    // Then min(|x-y|,|x+y|) = ||x|-|y|| = B-A\\r\\n    // And max(|x-y|,|x+y|) = |x|+|y| = A+B\\r\\n    \\r\\n    // Condition becomes: A ≥ B-A AND B ≤ A+B\\r\\n    // First inequality: A ≥ B-A → 2A ≥ B → B ≤ 2A\\r\\n    // Second inequality: B ≤ A+B is always true (B ≥ 0)\\r\\n    \\r\\n    // So condition simplifies to: B ≤ 2A where A = min(|x|,|y|), B = max(|x|,|y|)\\r\\n    \\r\\n    long long count = 0;\\r\\n    \\r\\n    // For each value as potential A (the smaller absolute value)\\r\\n    // Count how many values B satisfy: A < B ≤ 2A\\r\\n    // Since values are distinct, we need to consider unordered pairs\\r\\n    \\r\\n    for (int i = 0; i < n; i++) {\\r\\n        long long A = abs_vals[i];\\r\\n        // Find first index where value > 2A\\r\\n        auto it = upper_bound(abs_vals.begin(), abs_vals.end(), 2*A);\\r\\n        int end_idx = it - abs_vals.begin();\\r\\n        // Count values strictly greater than A and ≤ 2A\\r\\n        int valid_count = max(0, end_idx - (i + 1));\\r\\n        count += valid_count;\\r\\n    }\\r\\n    \\r\\n    cout << count << endl;\\r\\n    \\r\\n    return 0;\\r\\n}', 724, 725, 'illegal multibyte sequence')", "runtime_sec": 35.58061623573303}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 260.9358642101288}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K == 0:\n        print(0)\n        return\n    \n    a.sort()\n    \n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    total = 0\n    for i in range(N):\n        # Count combinations where a[i] is maximum\n        # Need to choose K-1 smaller elements from the i elements before it\n        comb = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + a[i] * comb) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 146.06442975997925}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 2}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = int(data[0]), int(data[1])\n    grid = data[2:]\n    \n    # Track rows and columns that are safe (no 'S')\n    safe_rows = [True] * r\n    safe_cols = [True] * c\n    \n    # Mark unsafe rows and columns\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                safe_rows[i] = False\n                safe_cols[j] = False\n    \n    # Count cells in safe rows and columns\n    eaten = 0\n    for i in range(r):\n        if safe_rows[i]:\n            eaten += c\n    for j in range(c):\n        if safe_cols[j]:\n            eaten += r\n    \n    # Subtract double-counted cells (intersections of safe rows and columns)\n    for i in range(r):\n        for j in range(c):\n            if safe_rows[i] and safe_cols[j]:\n                eaten -= 1\n    \n    print(eaten)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 3490.0162420272827}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "complexity_estimate": null, "runtime_sec": 89.49937605857849}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Helper to find max digit from position i to end\n    def find_max_from(pos):\n        max_digit = n[pos]\n        max_idx = pos\n        for i in range(pos + 1, length):\n            if n[i] > max_digit:\n                max_digit = n[i]\n                max_idx = i\n        return max_digit, max_idx\n    \n    swaps_done = 0\n    pos = 0\n    \n    while swaps_done < k and pos < length:\n        max_digit, max_idx = find_max_from(pos)\n        if max_idx != pos:\n            # Perform swap\n            n[pos], n[max_idx] = n[max_idx], n[pos]\n            swaps_done += 1\n        pos += 1\n    \n    # If we have swaps left, try to improve further\n    if swaps_done < k:\n        # Count remaining swaps\n        remaining = k - swaps_done\n        # If there are duplicate digits, we can swap them to use up swaps\n        # without changing the number\n        has_duplicate = len(set(n)) < length\n        if has_duplicate:\n            # We can waste swaps by swapping identical digits\n            pass\n        else:\n            # If no duplicates and remaining swaps is odd,\n            # swap last two digits if length >= 2\n            if remaining % 2 == 1 and length >= 2:\n                n[-1], n[-2] = n[-2], n[-1]\n    \n    result = ''.join(n)\n    # Ensure no leading zero\n    if result[0] == '0':\n        # Find first non-zero digit and swap with first position\n        for i in range(1, length):\n            if result[i] != '0':\n                result_list = list(result)\n                result_list[0], result_list[i] = result_list[i], result_list[0]\n                result = ''.join(result_list)\n                break\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 149.02553462982178}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 68.5197479724884}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    a = [0] + [int(x) for x in data[1:]]  # 1-indexed\n    visited = [False] * (N + 1)\n    current = 1\n    steps = 0\n    while not visited[current]:\n        if current == 2:\n            print(steps)\n            return\n        visited[current] = True\n        current = a[current]\n        steps += 1\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 132.47345852851868}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"COMPLEXITY": 1, "WA": 2}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 240.6333451271057}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 2, "RE": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 273.5614938735962}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    x = list(map(int, data[1:1+n]))\n    \n    # The function f(P) = sum((X_i - P)^2) is convex.\n    # For integer P, the minimum occurs at floor(mean) or ceil(mean).\n    mean = sum(x) / n\n    candidates = [int(mean), int(mean) + 1]\n    \n    min_stamina = float('inf')\n    for p in candidates:\n        stamina = sum((xi - p) ** 2 for xi in x)\n        if stamina < min_stamina:\n            min_stamina = stamina\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 583.9501473903656}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 249.08386135101318}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs_water(R, C, grid, water_queue):\n    water_time = [[-1] * C for _ in range(R)]\n    queue = deque(water_queue)\n    for r, c in water_queue:\n        water_time[r][c] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if grid[nr][nc] == '.' and water_time[nr][nc] == -1:\n                    water_time[nr][nc] = water_time[r][c] + 1\n                    queue.append((nr, nc))\n    return water_time\n\ndef bfs_hedgehogs(R, C, grid, start, den, water_time):\n    visited = [[False] * C for _ in range(R)]\n    queue = deque([(start[0], start[1], 0)])\n    visited[start[0]][start[1]] = True\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        r, c, time = queue.popleft()\n        if (r, c) == den:\n            return time\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                if grid[nr][nc] == '.' or grid[nr][nc] == 'D':\n                    if water_time[nr][nc] == -1 or time + 1 < water_time[nr][nc]:\n                        visited[nr][nc] = True\n                        queue.append((nr, nc, time + 1))\n    return -1\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    R, C = map(int, data[0].split())\n    grid = [list(row.strip()) for row in data[1:1+R]]\n    water_queue = []\n    start = None\n    den = None\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'S':\n                start = (r, c)\n            elif grid[r][c] == 'D':\n                den = (r, c)\n            elif grid[r][c] == '*':\n                water_queue.append((r, c))\n    water_time = bfs_water(R, C, grid, water_queue)\n    result = bfs_hedgehogs(R, C, grid, start, den, water_time)\n    print(result if result != -1 else \"KAKTUS\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 155.40183663368225}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 164.25951075553894}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 215.39725255966187}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', \"import sys\\r\\nimport math\\r\\n\\r\\ninput = sys.stdin.read\\r\\ndata = input().split()\\r\\nidx = 0\\r\\nn = int(data[idx]); idx += 1\\r\\nq = int(data[idx]); idx += 1\\r\\nN = 1 << n\\r\\n\\r\\na = [0] * (N + 1)\\r\\nfor i in range(1, N + 1):\\r\\n    a[i] = int(data[idx]); idx += 1\\r\\n\\r\\n# Fenwick tree for prefix sums\\r\\nbit = [0] * (N + 1)\\r\\n\\r\\ndef update(i, delta):\\r\\n    while i <= N:\\r\\n        bit[i] += delta\\r\\n        i += i & -i\\r\\n\\r\\ndef query(i):\\r\\n    s = 0\\r\\n    while i > 0:\\r\\n        s += bit[i]\\r\\n        i -= i & -i\\r\\n    return s\\r\\n\\r\\n# Initialize BIT\\r\\nfor i in range(1, N + 1):\\r\\n    update(i, a[i])\\r\\n\\r\\n# Track applied transformations\\r\\nrev_mask = 0  # bits indicate reversed levels\\r\\nswap_mask = 0  # bits indicate swapped levels\\r\\n\\r\\n# Helper to map logical index to physical index\\r\\ndef get_physical(pos):\\r\\n    # pos is 1‑based logical index\\r\\n    phy = pos - 1  # 0‑based\\r\\n    # Apply swaps then reverses\\r\\n    for k in range(n):\\r\\n        if swap_mask >> k & 1:\\r\\n            # Swap halves within block of size 2^(k+1)\\r\\n            block_size = 1 << (k + 1)\\r\\n            block = phy // block_size\\r\\n            offset = phy % block_size\\r\\n            if offset < (block_size >> 1):\\r\\n                phy = block * block_size + offset + (block_size >> 1)\\r\\n            else:\\r\\n                phy = block * block_size + offset - (block_size >> 1)\\r\\n    for k in range(n):\\r\\n        if rev_mask >> k & 1:\\r\\n            # Reverse within block of size 2^k\\r\\n            block_size = 1 << k\\r\\n            if block_size == 0:\\r\\n                continue\\r\\n            block = phy // block_size\\r\\n            offset = phy % block_size\\r\\n            phy = block * block_size + (block_size - 1 - offset)\\r\\n    return phy + 1  # back to 1‑based\\r\\n\\r\\nout_lines = []\\r\\nfor _ in range(q):\\r\\n    t = int(data[idx]); idx += 1\\r\\n    if t == 1:\\r\\n        x = int(data[idx]); idx += 1\\r\\n        k = int(data[idx]); idx += 1\\r\\n        phys = get_physical(x)\\r\\n        old = a[phys]\\r\\n        delta = k - old\\r\\n        a[phys] = k\\r\\n        update(phys, delta)\\r\\n    elif t == 2:\\r\\n        k = int(data[idx]); idx += 1\\r\\n        rev_mask ^= (1 << k)\\r\\n    elif t == 3:\\r\\n        k = int(data[idx]); idx += 1\\r\\n        swap_mask ^= (1 << k)\\r\\n    else:\\r\\n        l = int(data[idx]); idx += 1\\r\\n        r = int(data[idx]); idx += 1\\r\\n        # Convert logical range to physical\\r\\n        sum_val = 0\\r\\n        for pos in range(l, r + 1):\\r\\n            phys = get_physical(pos)\\r\\n            sum_val += a[phys]\\r\\n        out_lines.append(str(sum_val))\\r\\n\\r\\nsys.stdout.write('\\\\n'.join(out_lines))\\r\\n\", 774, 775, 'illegal multibyte sequence')", "runtime_sec": 40.742613077163696}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 2, "repeat_n": 3, "failure_type_counts": {"WA": 1}, "first_failure": null, "final_code": "import sys\nimport heapq\n\nsys.setrecursionlimit(300000)\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if xroot == yroot:\n        return False\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n    return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v))\n    \n    edges.sort()\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n    mst_edges = []\n    i = 0\n    while i < m:\n        j = i\n        while j < m and edges[j][0] == edges[i][0]:\n            j += 1\n        \n        # Count how many edges in this weight group can be added to MST\n        count_added = 0\n        for k in range(i, j):\n            w, u, v = edges[k]\n            if find(parent, u) != find(parent, v):\n                count_added += 1\n        \n        # Actually add edges to MST\n        for k in range(i, j):\n            w, u, v = edges[k]\n            if union(parent, rank, u, v):\n                mst_edges.append((w, u, v))\n        \n        i = j\n    \n    # Now we need to find edges that could replace MST edges\n    # Reset DSU for MST edges only\n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Build MST first\n    mst_set = set()\n    for w, u, v in mst_edges:\n        union(parent, rank, u, v)\n        mst_set.add((min(u, v), max(u, v), w))\n    \n    # Reset DSU for processing edges by weight again\n    parent = list(range(n))\n    rank = [0] * n\n    \n    operations = 0\n    i = 0\n    while i < m:\n        j = i\n        while j < m and edges[j][0] == edges[i][0]:\n            j += 1\n        \n        # For each weight group, check if there are multiple edges that could connect same components\n        # We need to count edges that are NOT in MST but could replace MST edges\n        potential_replacements = 0\n        edges_in_group = []\n        \n        for k in range(i, j):\n            w, u, v = edges[k]\n            edges_in_group.append((u, v, w))\n            \n        # First, count how many edges in this group connect different components\n        # These are candidates for MST edges\n        candidate_count = 0\n        for u, v, w in edges_in_group:\n            if find(parent, u) != find(parent, v):\n                candidate_count += 1\n        \n        # Now actually add MST edges from this group\n        added_count = 0\n        for u, v, w in edges_in_group:\n            if union(parent, rank, u, v):\n                added_count += 1\n        \n        # If there are more candidates than actually added, we need operations\n        # Each extra candidate edge that could replace an MST edge needs to be increased\n        if candidate_count > added_count:\n            operations += (candidate_count - added_count)\n        \n        i = j\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 442.29034996032715}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    N = int(data[0])\n    L = int(data[1])\n    W = int(data[2])\n    positions = list(map(int, data[3:3+N]))\n    return N, L, W, positions\n\n# Main solution\ndef solve():\n    data = read_input()\n    if data is None:\n        return\n    N, L, W, positions = data\n    \n    # Sort positions\n    positions.sort()\n    \n    # Calculate target positions for left and right sides\n    # Left side: positions at 0, 2, 4,... indices after sorting\n    # Right side: positions at 1, 3, 5,... indices after sorting\n    # But we need to assign trees to minimize total movement\n    # This is a bipartite matching problem: assign N/2 trees to left side and N/2 to right side\n    \n    # Target positions for left side: evenly spaced along left side from 0 to L\n    # There are N/2 trees on each side\n    n_half = N // 2\n    spacing = L / (n_half - 1) if n_half > 1 else 0\n    left_targets = [i * spacing for i in range(n_half)]\n    right_targets = [i * spacing for i in range(n_half)]  # Same spacing along right side\n    \n    # DP for optimal assignment\n    # dp[i][j] = min total distance when considering first i trees and assigning j to left side\n    INF = float('inf')\n    dp = [[INF] * (n_half + 1) for _ in range(N + 1)]\n    dp[0][0] = 0.0\n    \n    for i in range(1, N + 1):\n        tree_pos = positions[i-1]\n        for j in range(max(0, i - n_half), min(i, n_half) + 1):\n            # Option 1: assign current tree to left side (if j > 0)\n            if j > 0:\n                left_dist = math.hypot(tree_pos - left_targets[j-1], 0)\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + left_dist)\n            \n            # Option 2: assign current tree to right side (if i - j <= n_half)\n            if i - j <= n_half:\n                right_dist = math.hypot(tree_pos - right_targets[i-j-1], W)\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + right_dist)\n    \n    # Result is dp[N][n_half]\n    result = dp[N][n_half]\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 118.81168031692505}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"TLE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 435.3349847793579}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 203.16039061546326}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 2, "WA": 1}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 227.12680649757385}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x1 -= 1; y1 -= 1; x2 -= 1; y2 -= 1\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    if grid[x1][y1] == '@' or grid[x2][y2] == '@':\n        print(-1)\n        return\n    \n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # BFS with 0-1 BFS optimization for K jumps\n    dq = collections.deque()\n    dq.append((x1, y1))\n    \n    # Precompute reachable positions in each direction\n    # We'll use BFS that explores up to K steps in each direction\n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        # Explore four directions\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            steps = 1\n            while steps <= K and 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.':\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    dq.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # No need to continue in this direction if we already found a better path\n                    break\n                nx += dx\n                ny += dy\n                steps += 1\n    \n    result = dist[x2][y2]\n    print(result if result != INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 148.73491621017456}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"WA": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 279.38293743133545}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return\n        if self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        a = int(next(it))\n        op = next(it)\n        b = int(next(it))\n        \n        if op == '=':\n            dsu.union(a, b)\n        else:  # '>'\n            edges.append((a, b))\n    \n    # Build graph with components as nodes\n    comp_id = {}\n    comps = []\n    for i in range(N):\n        root = dsu.find(i)\n        if root not in comp_id:\n            comp_id[root] = len(comps)\n            comps.append([])\n        comps[comp_id[root]].append(i)\n    \n    C = len(comps)\n    adj = [[] for _ in range(C)]\n    indeg = [0] * C\n    \n    for a, b in edges:\n        ca = comp_id[dsu.find(a)]\n        cb = comp_id[dsu.find(b)]\n        if ca == cb:\n            print(\"inconsistent\")\n            return\n        adj[ca].append(cb)\n        indeg[cb] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    q = deque([i for i in range(C) if indeg[i] == 0])\n    processed = 0\n    \n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    if processed == C:\n        print(\"consistent\")\n    else:\n        print(\"inconsistent\")\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 153.76810836791992}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    s = list(data[1])\n    for i in range(m):\n        l, r, c1, c2 = data[2 + i].split()\n        l, r = int(l), int(r)\n        for j in range(l - 1, r):\n            if s[j] == c1:\n                s[j] = c2\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "complexity_estimate": null, "runtime_sec": 945.7754857540131}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": true, "gate_allowed": true, "attempts_used": 1, "repeat_n": 3, "failure_type_counts": {}, "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        \n        # Check if s is k-periodic\n        valid = True\n        num_blocks = n // k\n        \n        for i in range(1, num_blocks):\n            # Current block: s[i*k : (i+1)*k]\n            # Previous block: s[(i-1)*k : i*k]\n            \n            # Check if current block is right-rotation of previous block\n            prev = s[(i-1)*k : i*k]\n            curr = s[i*k : (i+1)*k]\n            \n            # Right-rotation: last char of prev becomes first char of curr\n            # and the rest of curr matches the beginning of prev\n            if curr != prev[-1] + prev[:-1]:\n                valid = False\n                break\n        \n        if valid:\n            print(k)\n            return\n    \n    # If no k found (shouldn't happen for valid strings)\n    print(n)\n\nif __name__ == \"__main__\":\n    solve()", "complexity_estimate": null, "runtime_sec": 181.94550228118896}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 207.9940595626831}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_repeated", "passed": false, "gate_allowed": false, "attempts_used": 3, "repeat_n": 3, "failure_type_counts": {"RE": 3}, "first_failure": null, "final_code": "", "complexity_estimate": null, "runtime_sec": 194.9430594444275}

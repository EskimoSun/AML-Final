{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.18395280838013}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build result string\n    result = []\n    current_char = 'a'\n    i = 0\n    \n    while i < n:\n        # Find the maximum length where c[length] > 0\n        max_len = 1\n        for length in range(1, n - i + 1):\n            if length <= n and c[length-1] > 0:\n                max_len = length\n            else:\n                break\n        \n        # Add max_len characters of current_char\n        result.extend([current_char] * max_len)\n        \n        # Update c values\n        for length in range(1, max_len + 1):\n            c[length-1] -= (max_len - length + 1)\n        \n        # Move to next character\n        current_char = chr(ord(current_char) + 1)\n        i += max_len\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 306.90554094314575}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a = int(data)\n    # Check if the number is prime\n    if a < 2:\n        print(0)\n        return\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            print(0)\n            return\n    # Check if the sum of digits is prime\n    digit_sum = sum(int(d) for d in str(a))\n    if digit_sum < 2:\n        print(0)\n        return\n    for i in range(2, int(digit_sum**0.5) + 1):\n        if digit_sum % i == 0:\n            print(0)\n            return\n    print(1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.232680320739746}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    values = list(map(int, data[1:1+n]))\n    \n    # Fenwick tree for order statistics\n    size = n + 2\n    bit = [0] * size\n    \n    def bit_update(idx, delta):\n        while idx < size:\n            bit[idx] += delta\n            idx += idx & -idx\n    \n    def bit_query(idx):\n        s = 0\n        while idx > 0:\n            s += bit[idx]\n            idx -= idx & -idx\n        return s\n    \n    # Track inserted nodes\n    inserted = [False] * (n + 1)\n    \n    # For each insertion, find how many nodes are in the path\n    # Path length = number of ancestors visited during search\n    # We can simulate BST search using order statistics\n    \n    out_lines = []\n    total_depth = 0\n    \n    for val in values:\n        # Find position among inserted values\n        left_count = bit_query(val - 1)  # smaller inserted values\n        right_count = bit_query(n) - bit_query(val)  # larger inserted values\n        \n        # The depth of new node = 1 + max(depth of last node in search path)\n        # But we need cumulative sum\n        # Actually, we can think differently:\n        # When inserting val, we compare with existing nodes\n        # The search path visits nodes where val would be compared\n        # The number of comparisons = number of ancestors in final tree\n        # This equals the number of inserted values that are in the\n        # range between val and the boundary where search stops\n        \n        # Simpler: depth = number of inserted values that would be ancestors\n        # An ancestor is any inserted value where val is in its subtree\n        # For BST, val's ancestors are exactly those inserted values\n        # where min_ancestor < val < max_ancestor for that ancestor's subtree\n        \n        # Actually, let's simulate the BST insertion to count depth\n        # We need to know for each inserted value, what subtree it belongs to\n        \n        # Alternative approach: track predecessor and successor\n        # Depth of new node = 1 + max(depth(predecessor), depth(successor))\n        # where predecessor is largest inserted value < val\n        # and successor is smallest inserted value > val\n        \n        # We'll maintain depths in arrays\n        depth = [0] * (n + 1)\n        \n        # Find predecessor and successor among inserted values\n        pred = 0\n        succ = n + 1\n        \n        # Check left side (predecessor)\n        if left_count > 0:\n            # Binary search on BIT to find largest inserted < val\n            lo, hi = 1, val - 1\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                if bit_query(mid) == left_count:\n                    pred = mid\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n        \n        # Check right side (successor)\n        if right_count > 0:\n            # Binary search on BIT to find smallest inserted > val\n            lo, hi = val + 1, n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                if bit_query(mid) - bit_query(val) > 0:\n                    succ = mid\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n        \n        # Calculate depth of new node\n        new_depth = 0\n        if pred > 0:\n            new_depth = max(new_depth, depth[pred])\n        if succ <= n:\n            new_depth = max(new_depth, depth[succ])\n        new_depth += 1\n        \n        depth[val] = new_depth\n        total_depth += new_depth\n        out_lines.append(str(total_depth))\n        \n        # Mark as inserted\n        inserted[val] = True\n        bit_update(val, 1)\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 88.29212617874146}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We'll simulate binary addition of powers of 2\n    # Use a dictionary to track counts of each power\n    count = {}\n    for val in a:\n        count[val] = count.get(val, 0) + 1\n    \n    # Process from smallest to largest power\n    powers = sorted(count.keys())\n    added = 0\n    \n    for p in powers:\n        cnt = count[p]\n        # Carry over to higher powers\n        while cnt > 1:\n            cnt -= 2\n            count[p+1] = count.get(p+1, 0) + 1\n            added += 1  # We need to add one number to combine two into one higher power\n        \n        # If cnt == 1, leave it as is\n        # If cnt == 0, nothing to do\n        count[p] = cnt\n    \n    # After processing, we have at most one of each power\n    # We need to fill gaps to make a continuous sequence from 0 to max_power\n    remaining_powers = [p for p, c in count.items() if c == 1]\n    if not remaining_powers:\n        print(0)\n        return\n    \n    max_power = max(remaining_powers)\n    # Count missing powers from 0 to max_power\n    missing = 0\n    for i in range(max_power + 1):\n        if i not in count or count[i] == 0:\n            missing += 1\n    \n    print(missing + added)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 72.5290014743805}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy one cake\n    remaining_after_cake = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining_after_cake // B\n    remaining_after_donuts = remaining_after_cake - (donuts_count * B)\n    \n    print(remaining_after_donuts)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 178.65162086486816}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom itertools import permutations\n\ndef solve():\n    # Read input\n    ratios = []\n    for _ in range(12):\n        line = sys.stdin.readline().strip()\n        if not line:\n            continue\n        n_str, d_str = line.split('/')\n        n, d = int(n_str), int(d_str)\n        g = math.gcd(n, d)\n        ratios.append((n // g, d // g))\n    \n    # Try all possible front sprocket pairs (u1, u2) where u1 < u2\n    for u1 in range(1, 10001):\n        for u2 in range(u1 + 1, 10001):\n            # For each front sprocket, compute possible rear sprockets from ratios\n            possible_rear_for_u1 = set()\n            possible_rear_for_u2 = set()\n            \n            for n, d in ratios:\n                # Check if ratio n/d can come from u1/v or u2/v\n                # For u1/v = n/d => v = u1*d/n must be integer\n                if n > 0 and (u1 * d) % n == 0:\n                    v = (u1 * d) // n\n                    if 1 <= v <= 10000:\n                        possible_rear_for_u1.add(v)\n                \n                if n > 0 and (u2 * d) % n == 0:\n                    v = (u2 * d) // n\n                    if 1 <= v <= 10000:\n                        possible_rear_for_u2.add(v)\n            \n            # We need exactly 6 distinct rear sprockets total\n            all_rear = possible_rear_for_u1.union(possible_rear_for_u2)\n            if len(all_rear) != 6:\n                continue\n            \n            # Check if all 12 ratios can be generated\n            generated_ratios = set()\n            for v in all_rear:\n                # Simplify u1/v and u2/v\n                g1 = math.gcd(u1, v)\n                g2 = math.gcd(u2, v)\n                generated_ratios.add((u1 // g1, v // g1))\n                generated_ratios.add((u2 // g2, v // g2))\n            \n            # Compare with input ratios\n            if generated_ratios == set(ratios):\n                # Output solution\n                rear_sorted = sorted(all_rear, reverse=True)\n                print(f\"{u1} {u2}\")\n                print(\" \".join(map(str, rear_sorted)))\n                return\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 116.86124897003174}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    m = int(input().strip())\n    queries = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Step 1: Sort indices by value (descending) and then by index (ascending)\n    indices = list(range(n))\n    indices.sort(key=lambda i: (-a[i], i))\n    \n    # Step 2: Preprocess for each k: store the indices of the optimal subsequence\n    # We'll store for each k the sorted list of indices of the optimal subsequence\n    # Since k ranges from 1 to n, we can compute for all k efficiently\n    \n    # First, for each k, the optimal subsequence consists of the k largest values,\n    # and among equal values, we take the earliest possible positions\n    # to maintain lexicographic minimality.\n    \n    # We'll compute prefix of sorted indices for each k\n    prefix_indices = []\n    current = []\n    for idx in indices:\n        current.append(idx)\n        current.sort()  # Keep indices sorted to maintain original order\n        prefix_indices.append(current.copy())\n    \n    # Now prefix_indices[k-1] gives the indices for optimal subsequence of length k\n    \n    # Step 3: Answer queries\n    results = []\n    for k, pos in queries:\n        # Get the indices for optimal subsequence of length k\n        optimal_indices = prefix_indices[k-1]\n        # The pos-th element in the subsequence corresponds to original index optimal_indices[pos-1]\n        results.append(str(a[optimal_indices[pos-1]]))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 356.0641567707062}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data)\n    \n    # Check if solution exists\n    if k == 1 or n > k * (k - 1):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using two sequences\n    # Men: 1,2,3,...,k,1,2,3,... (cyclic)\n    # Women: 2,3,4,...,k,1,2,3,... (shifted by 1)\n    # This ensures b_i != g_i and consecutive differences\n    \n    # We'll generate all possible distinct pairs (b,g) with b != g\n    # Then take first n of them\n    pairs = []\n    for start in range(1, k + 1):\n        for offset in range(1, k):\n            b = start\n            g = ((start + offset - 1) % k) + 1\n            pairs.append((b, g))\n            if len(pairs) == n:\n                break\n        if len(pairs) == n:\n            break\n    \n    # Output the pairs\n    for b, g in pairs:\n        print(f\"{b} {g}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.78056812286377}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    guests = []\n    idx = 1\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        idx += 2\n        guests.append((l, r))\n    \n    # Sort guests by (l_i - r_i) descending\n    guests.sort(key=lambda x: x[1] - x[0])\n    \n    total_chairs = 0\n    for i, (l, r) in enumerate(guests):\n        # For each guest, we need at least max(l, r) chairs in their circle\n        # But when placing in sequence, we need to consider neighbors\n        if i == 0:\n            # First guest in circle\n            total_chairs += max(l, r) + 1\n        else:\n            # For subsequent guests, we need to satisfy both their requirements\n            # and the previous guest's requirements\n            prev_l, prev_r = guests[i-1]\n            # The gap between guests i-1 and i must be at least max(prev_r, l)\n            total_chairs += max(prev_r, l)\n            # Add the chair for current guest\n            total_chairs += 1\n    \n    # Close the circle: last guest's right requirement with first guest's left requirement\n    first_l, first_r = guests[0]\n    last_l, last_r = guests[-1]\n    total_chairs += max(last_r, first_l)\n    \n    print(total_chairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 70.12209606170654}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef prime_factors(n):\n    \"\"\"Return prime factorization of n as dict {prime: exponent}\"\"\"\n    factors = defaultdict(int)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1 if d == 2 else 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Collect all prime factors across all numbers\n    total_factors = defaultdict(int)\n    for num in arr:\n        pf = prime_factors(num)\n        for p, exp in pf.items():\n            total_factors[p] += exp\n    \n    # Step 2: Determine maximum possible GCD\n    # For each prime, we can redistribute exponents among numbers\n    # The maximum GCD will have floor(total_exponents / n) of each prime\n    max_gcd = 1\n    for p, total_exp in total_factors.items():\n        per_num = total_exp // n\n        if per_num > 0:\n            max_gcd *= p ** per_num\n    \n    # Step 3: Calculate minimum operations needed\n    # For each prime, we need to move exponents to achieve target per_num in each number\n    operations = 0\n    for p, total_exp in total_factors.items():\n        target_per_num = total_exp // n\n        if target_per_num == 0:\n            continue\n        \n        # Count how many exponents each number currently has\n        current_exps = []\n        for num in arr:\n            exp = 0\n            temp = num\n            while temp % p == 0:\n                exp += 1\n                temp //= p\n            current_exps.append(exp)\n        \n        # For numbers with excess exponents, we need to move them to deficient numbers\n        excess = 0\n        for exp in current_exps:\n            if exp > target_per_num:\n                excess += exp - target_per_num\n        operations += excess\n    \n    print(f\"{max_gcd} {operations}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 72.86440873146057}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    f = list(map(int, data[1:1+n]))\n    \n    # Step 1: Build initial assignment and track used receivers\n    used = [False] * (n + 1)  # 1-indexed\n    for i, val in enumerate(f, 1):\n        if val != 0:\n            used[val] = True\n    \n    # Step 2: Collect indices where f[i] == 0 (unknown givers)\n    unknown_givers = []\n    for i in range(1, n+1):\n        if f[i-1] == 0:\n            unknown_givers.append(i)\n    \n    # Step 3: Collect available receivers (not used and not self)\n    available_receivers = []\n    for i in range(1, n+1):\n        if not used[i]:\n            available_receivers.append(i)\n    \n    # Step 4: Match unknown givers with available receivers\n    # Avoid self-gifting by swapping if needed\n    result = f[:]\n    for giver in unknown_givers:\n        # Find a receiver that is not the giver itself\n        receiver = available_receivers.pop()\n        if receiver == giver:\n            # If only one left, swap with previous assignment\n            if not available_receivers:\n                # Find another unknown giver to swap with\n                for other in unknown_givers:\n                    if other != giver and result[other-1] != giver:\n                        # Swap receivers\n                        result[giver-1], result[other-1] = result[other-1], receiver\n                        break\n            else:\n                # Take another receiver and put this one back\n                other_receiver = available_receivers.pop()\n                available_receivers.append(receiver)\n                receiver = other_receiver\n        result[giver-1] = receiver\n    \n    # Step 5: Output\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 111.22486066818237}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.73967266082764}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    l = list(map(int, data[1:1+n]))\n    c = list(map(int, data[1+n:1+2*n]))\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd_value] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting point: gcd=0 (no cards selected)\n    \n    for i in range(n):\n        li, ci = l[i], c[i]\n        # Need to iterate over a copy since we modify dp during iteration\n        items = list(dp.items())\n        for g_val, cost in items:\n            new_g = math.gcd(g_val, li)\n            if cost + ci < dp[new_g]:\n                dp[new_g] = cost + ci\n    \n    # Answer is minimal cost to achieve gcd=1\n    ans = dp.get(1, float('inf'))\n    print(ans if ans != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 512.2920093536377}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Compare required time (D/S) with available time T\n    # Use integer comparison to avoid floating-point issues\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 661.9980216026306}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    k = int(next(it))\n    n = int(next(it))\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        d = int(next(it))\n        for _ in range(d):\n            neighbor = int(next(it)) - 1  # Convert to 0-index\n            adj[i].append(neighbor)\n    \n    # DP on tree (forest) using bipartite matching concept\n    # dp[node][0] = max drones in subtree when node not selected\n    # dp[node][1] = max drones in subtree when node selected\n    dp0 = [0] * n\n    dp1 = [0] * n\n    visited = [False] * n\n    \n    def dfs(u, parent):\n        visited[u] = True\n        # Initialize: if selected, count 1 drone at u\n        dp1[u] = 1\n        dp0[u] = 0\n        \n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u)\n            # If u not selected, take max of child selected/not\n            dp0[u] += max(dp0[v], dp1[v])\n            # If u selected, children must not be selected\n            dp1[u] += dp0[v]\n    \n    # Handle forest (multiple connected components)\n    max_drones = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1)\n            max_drones += max(dp0[i], dp1[i])\n    \n    # Check if k is achievable\n    if k <= max_drones:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 71.4431483745575}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\nn = int(lines[0])\nc = list(map(int, lines[1:1+n]))\n\n# Total number of people\nP = sum(c)\n\n# Precompute factorials and log factorials up to max(P, 365)\nmax_val = max(P, 365)\nlog_fact = [0.0] * (max_val + 1)\nfor i in range(1, max_val + 1):\n    log_fact[i] = log_fact[i-1] + math.log10(i)\n\n# Compute log probability\nlog_prob = 0.0\n\n# First term: choose birthdays for each group\nlog_prob += log_fact[365] - log_fact[365 - n]\n\n# Second term: multinomial coefficient for distributing people into groups\nlog_prob -= log_fact[P]\nfor ci in c:\n    log_prob += log_fact[ci]\n\n# Third term: account for permutations of groups with same size\n# Count frequencies of each group size\nfreq = {}\nfor ci in c:\n    freq[ci] = freq.get(ci, 0) + 1\nfor f in freq.values():\n    log_prob -= log_fact[f]\n\n# Fourth term: divide by total possibilities (365^P)\nlog_prob -= P * math.log10(365)\n\nprint(f\"{log_prob:.15f}\")", "runtime_sec": 65.97141408920288}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find player start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to explore reachable safe squares\n    visited = [[False] * W for _ in range(H)]\n    queue = [start]\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while queue:\n        r, c = queue.pop(0)\n        # Collect gold if present\n        if grid[r][c] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent square is a trap\n        safe_to_move = True\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                if grid[nr][nc] == 'T':\n                    safe_to_move = False\n                    break\n        \n        # If safe, explore adjacent squares\n        if safe_to_move:\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc]:\n                    # Only move to non-wall squares\n                    if grid[nr][nc] != '#':\n                        visited[nr][nc] = True\n                        queue.append((nr, nc))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 112.39070105552673}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    d, b, f, t0, t1, t2 = map(int, data)\n    \n    # Normal fruits: sell for 100, plant to get tree that yields 3 fruits every 3 days\n    # Exotic fruits: buy for 400, sell for 500, plant to get exotic tree that yields 3 exotic fruits every 3 days\n    # At most one exotic fruit purchase per day\n    \n    # We'll simulate day by day\n    # State: (normal_fruits, exotic_fruits, normal_trees_by_age[3], exotic_trees_by_age[3], bling)\n    # Age: 0 = yields today, 1 = yields in 1 day, 2 = yields in 2 days\n    \n    # Initialize\n    normal_fruits = f\n    exotic_fruits = 0\n    normal_trees = [t0, t1, t2]  # trees that yield in 0,1,2 days\n    exotic_trees = [0, 0, 0]\n    bling = b\n    \n    for day in range(d):\n        # Harvest fruits from trees that yield today\n        harvest_normal = normal_trees[0]\n        harvest_exotic = exotic_trees[0]\n        normal_fruits += harvest_normal * 3\n        exotic_fruits += harvest_exotic * 3\n        \n        # Age the trees\n        normal_trees = [normal_trees[1], normal_trees[2], harvest_normal]\n        exotic_trees = [exotic_trees[1], exotic_trees[2], harvest_exotic]\n        \n        # Now we have fruits available to use today\n        # We need to decide optimal actions for this day\n        # Strategy: always buy exotic fruit if we can afford it and it's profitable\n        # Then decide whether to plant or sell based on remaining days\n        \n        # Try to buy exotic fruit\n        if bling >= 400:\n            # Check if buying is profitable\n            days_left = d - day - 1\n            # If we plant it, it will yield after 3 days\n            # Each yield gives 3 exotic fruits worth 500 each = 1500\n            # But we need to consider opportunity cost\n            \n            # Simple heuristic: if days_left >= 3, planting might be better\n            # We'll evaluate both options and take max\n            \n            # Option 1: Buy and sell immediately\n            option1_bling = bling - 400 + 500\n            \n            # Option 2: Buy and plant\n            # We need to simulate planting\n            temp_exotic_trees = exotic_trees.copy()\n            temp_exotic_trees[2] += 1  # Planted today, will yield in 3 days\n            \n            # Simulate remaining days with this tree\n            temp_bling = bling - 400\n            temp_normal_fruits = normal_fruits\n            temp_exotic_fruits = exotic_fruits\n            temp_normal_trees = normal_trees.copy()\n            \n            for future_day in range(day + 1, d):\n                # Harvest\n                harvest_n = temp_normal_trees[0]\n                harvest_e = temp_exotic_trees[0]\n                temp_normal_fruits += harvest_n * 3\n                temp_exotic_fruits += harvest_e * 3\n                \n                # Age trees\n                temp_normal_trees = [temp_normal_trees[1], temp_normal_trees[2], harvest_n]\n                temp_exotic_trees = [temp_exotic_trees[1], temp_exotic_trees[2], harvest_e]\n                \n                # Sell all fruits at the end of each day (optimal for max bling)\n                temp_bling += temp_normal_fruits * 100 + temp_exotic_fruits * 500\n                temp_normal_fruits = 0\n                temp_exotic_fruits = 0\n            \n            option2_bling = temp_bling\n            \n            if option2_bling > option1_bling:\n                # Plant it\n                exotic_trees[2] += 1\n                bling -= 400\n            else:\n                # Sell it\n                bling = option1_bling\n        \n        # Now decide what to do with normal fruits\n        # Plant normal fruits if profitable\n        days_left = d - day - 1\n        if days_left >= 3:\n            # Each planted fruit yields 3 fruits every 3 days\n            # Worth 300 bling per cycle\n            # Better to plant if we have enough days\n            plantable = normal_fruits\n            normal_trees[2] += plantable\n            normal_fruits = 0\n        else:\n            # Sell all normal fruits\n            bling += normal_fruits * 100\n            normal_fruits = 0\n        \n        # Sell all exotic fruits (if any)\n        bling += exotic_fruits * 500\n        exotic_fruits = 0\n    \n    # Final sell of any remaining fruits\n    bling += normal_fruits * 100 + exotic_fruits * 500\n    \n    print(bling)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 131.94911360740662}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data)\n    \n    # Find maximum k such that sum(1..k) <= a+b\n    total = a + b\n    k = 0\n    low, high = 0, int(2e9)  # Upper bound for k\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * (mid + 1) // 2 <= total:\n            k = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Generate all notes from 1 to k\n    notes = list(range(1, k + 1))\n    \n    # Greedy assignment: try to assign largest notes to first day\n    first_day = []\n    second_day = []\n    remaining_a = a\n    \n    for note in reversed(notes):\n        if note <= remaining_a:\n            first_day.append(note)\n            remaining_a -= note\n        else:\n            second_day.append(note)\n    \n    # Output\n    print(len(first_day))\n    if first_day:\n        print(' '.join(map(str, first_day)))\n    else:\n        print()\n    \n    print(len(second_day))\n    if second_day:\n        print(' '.join(map(str, second_day)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 108.74932098388672}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # Check if n is a power of two\n    # If (n & (n - 1)) == 0, then n is power of two\n    if (n & (n - 1)) == 0:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\n        # Find the largest power of two less than n\n        # This will be a winning move for Alice\n        power_of_two = 1\n        while power_of_two * 2 < n:\n            power_of_two *= 2\n        print(power_of_two)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.05654191970825}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    Q = int(data[0])\n    idx = 1\n    \n    # Fenwick tree for prefix sums\n    class FenwickTree:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 1)\n        \n        def update(self, i, delta):\n            while i <= self.n:\n                self.bit[i] += delta\n                i += i & -i\n        \n        def query(self, i):\n            s = 0\n            while i > 0:\n                s += self.bit[i]\n                i -= i & -i\n            return s\n        \n        def find_kth(self, k):\n            # Find smallest i such that prefix sum >= k\n            pos = 0\n            bit_mask = 1 << (self.n.bit_length() - 1)\n            while bit_mask:\n                next_pos = pos + bit_mask\n                if next_pos <= self.n and self.bit[next_pos] < k:\n                    k -= self.bit[next_pos]\n                    pos = next_pos\n                bit_mask >>= 1\n            return pos + 1\n    \n    # Maximum possible movies: Q insertions\n    ft = FenwickTree(Q + 5)\n    creation_order = []\n    plot_to_creation = {}\n    creation_counter = 1\n    \n    out_lines = []\n    \n    for _ in range(Q):\n        q = int(data[idx]); idx += 1\n        x = int(data[idx]); idx += 1\n        \n        if q == 1:\n            # Insert movie at plot position x\n            # Find the actual position in the BIT\n            pos = ft.find_kth(x)\n            ft.update(pos, 1)\n            plot_to_creation[pos] = creation_counter\n            creation_counter += 1\n        else:\n            # Query creation index for plot position x\n            pos = ft.find_kth(x)\n            out_lines.append(str(plot_to_creation[pos]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 70.18914985656738}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    current = 0\n    days_used = 0\n    \n    for i in range(n):\n        current += diff[i]\n        current_height = heights[i] + current\n        \n        if current_height < target:\n            needed = target - current_height\n            if needed > m - days_used:\n                return False\n            days_used += needed\n            current += needed\n            # Mark the end of the watering range\n            if i + w < n:\n                diff[i + w] -= needed\n    \n    return days_used <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for the maximum achievable minimum height\n    low = min(heights)\n    high = min(heights) + m  # Upper bound: we can at most add m to the smallest\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(high)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 349.6960656642914}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 139.7975435256958}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.38765907287598}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.18131279945374}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    total = 0.0\n    \n    # Process each gift\n    for i in range(n):\n        x = float(data[1 + 2*i])  # Convert to float to handle decimal BTC values\n        unit = data[2 + 2*i]\n        \n        if unit == \"JPY\":\n            total += x\n        else:  # unit == \"BTC\"\n            total += x * 380000.0\n    \n    # Print result with sufficient precision\n    print(f\"{total:.10f}\".rstrip('0').rstrip('.'))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 56.45516085624695}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245050 tokens (243450 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 13.345593214035034}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of bags\n    for mask in range(1, 16):  # 2^4 - 1 = 15 non-empty subsets\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2813.8766329288483}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    seen = set()\n    result = []\n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1153.0954535007477}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**6 + 7\n\ndef modinv(a, mod=MOD):\n    \"\"\"Return modular inverse using Fermat's little theorem\"\"\"\n    return pow(a, mod-2, mod)\n\ndef nCr_mod(n, r, mod=MOD):\n    \"\"\"Compute nCr modulo mod using factorial and modular inverse\"\"\"\n    if r < 0 or r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Use iterative computation to avoid recursion depth issues\n    numerator = 1\n    denominator = 1\n    \n    # Compute numerator: n * (n-1) * ... * (n-r+1)\n    for i in range(r):\n        numerator = (numerator * (n - i)) % mod\n    \n    # Compute denominator: r!\n    for i in range(1, r+1):\n        denominator = (denominator * i) % mod\n    \n    # Multiply by modular inverse of denominator\n    return (numerator * modinv(denominator, mod)) % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N, M, K = map(int, data[:3])\n    \n    # If K > N*M, impossible to take K objects\n    if K > N * M:\n        print(0)\n        return\n    \n    # Use inclusion-exclusion principle\n    result = 0\n    for i in range(N+1):\n        # Choose i types to have at least M+1 copies\n        term = nCr_mod(N, i) * nCr_mod(K - i*(M+1) + N - 1, N - 1)\n        term %= MOD\n        \n        # Inclusion-exclusion: add for even i, subtract for odd i\n        if i % 2 == 0:\n            result = (result + term) % MOD\n        else:\n            result = (result - term + MOD) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 74.15864586830139}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to calculate final score given fifth time\n    def calculate_final(fifth):\n        all_times = times + [fifth]\n        sorted_times = sorted(all_times)\n        # Discard best (smallest) and worst (largest)\n        middle_three = sorted_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Case 1: Check if already winning regardless of fifth time\n    # For the worst case (fifth time = 20.0, maximum possible)\n    worst_final = calculate_final(20.0)\n    if worst_final <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 2: Check if impossible to win\n    # For the best case (fifth time = 1.0, minimum possible)\n    best_final = calculate_final(1.0)\n    if best_final > target:\n        print(\"impossible\")\n        return\n    \n    # Case 3: Binary search for maximum fifth time that still achieves target\n    lo, hi = 1.0, 20.0\n    eps = 1e-9\n    \n    for _ in range(100):  # Sufficient iterations for precision\n        mid = (lo + hi) / 2.0\n        final_score = calculate_final(mid)\n        if final_score <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Round to two decimal places\n    result = round(lo, 2)\n    # Ensure exactly two decimal places in output\n    print(f\"{result:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 154.51294112205505}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 378.18180203437805}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.06836223602295}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\n# Fast I/O\ninput = sys.stdin.readline\n\n# Read N\nN = int(input().strip())\n\n# Read initial strings\nstrings = [input().strip() for _ in range(N)]\n\n# Read operations\noperations = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\n# Track which strings are still active (not emptied)\nactive = [True] * N\n\n# Process operations\nfor a, b in operations:\n    # Convert to 0-based indexing\n    a_idx, b_idx = a - 1, b - 1\n    \n    # Append string b to string a\n    strings[a_idx] += strings[b_idx]\n    \n    # Empty string b\n    strings[b_idx] = \"\"\n    active[b_idx] = False\n\n# Find the only remaining non-empty string\nfor i in range(N):\n    if active[i]:\n        print(strings[i])\n        break", "runtime_sec": 102.35133504867554}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y = map(int, data[:2])\n    # Total cost = train fare + half of bus fare\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 379.1045551300049}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    events_stack = []  # stack of events that have happened\n    event_set = set()  # set of events currently considered to have happened\n    results = []\n    \n    for i in range(1, n + 1):\n        line = data[i].strip()\n        if not line:\n            continue\n        parts = line.split()\n        if parts[0] == 'E':\n            event = parts[1]\n            events_stack.append(event)\n            event_set.add(event)\n        elif parts[0] == 'D':\n            r = int(parts[1])\n            for _ in range(r):\n                if events_stack:\n                    event_set.remove(events_stack.pop())\n        elif parts[0] == 'S':\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current state\n            consistent = True\n            for ev in scenario_events:\n                if ev.startswith('!'):\n                    actual_event = ev[1:]\n                    if actual_event in event_set:\n                        consistent = False\n                        break\n                else:\n                    if ev not in event_set:\n                        consistent = False\n                        break\n            \n            if consistent:\n                results.append(\"Yes\")\n                continue\n            \n            # Find smallest r such that scenario would be consistent after D r\n            min_r = None\n            # Try all possible r from 1 to len(events_stack)\n            for r in range(1, len(events_stack) + 1):\n                # Simulate removing last r events\n                temp_set = event_set.copy()\n                temp_stack = events_stack.copy()\n                for _ in range(r):\n                    if temp_stack:\n                        temp_set.remove(temp_stack.pop())\n                \n                # Check consistency with this hypothetical state\n                temp_consistent = True\n                for ev in scenario_events:\n                    if ev.startswith('!'):\n                        actual_event = ev[1:]\n                        if actual_event in temp_set:\n                            temp_consistent = False\n                            break\n                    else:\n                        if ev not in temp_set:\n                            temp_consistent = False\n                            break\n                \n                if temp_consistent:\n                    min_r = r\n                    break\n            \n            if min_r is not None:\n                results.append(f\"{min_r} Just A Dream\")\n            else:\n                results.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 116.70954275131226}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213627 tokens (212027 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 12.871214151382446}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data[:3])\n    # All possible routes with 2 flights (starting at any airport)\n    # Since flights are bidirectional, we can consider all permutations of 3 airports\n    # But we only need the minimum of the three possible sums of two consecutive flights\n    # The three possible sums are: P+Q, Q+R, R+P\n    # However, we must consider that the route involves exactly 2 flights between different airports\n    # The minimum will be the smallest sum of any two of the three flight times\n    # Because we can always choose the starting airport to minimize the sum\n    # For example, if we want P+Q, start at A, go to B (P), then to C (Q)\n    # If we want Q+R, start at B, go to C (Q), then to A (R)\n    # If we want R+P, start at C, go to A (R), then to B (P)\n    result = min(P + Q, Q + R, R + P)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 512.1585047245026}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.85187768936157}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    boys = list(map(int, data[1:1+N]))\n    A, B = map(int, data[1+N:1+N+2])\n    \n    # Sort boys for binary search\n    boys.sort()\n    \n    # Helper to find min distance from X to any boy\n    def min_distance(x):\n        from bisect import bisect_left\n        idx = bisect_left(boys, x)\n        dist = float('inf')\n        if idx < N:\n            dist = min(dist, abs(boys[idx] - x))\n        if idx > 0:\n            dist = min(dist, abs(boys[idx-1] - x))\n        return dist\n    \n    # Consider all candidate odd numbers in [A, B]\n    best_x = -1\n    best_dist = -1\n    \n    # Generate odd numbers in range\n    start = A if A % 2 == 1 else A + 1\n    for x in range(start, B + 1, 2):\n        d = min_distance(x)\n        if d > best_dist:\n            best_dist = d\n            best_x = x\n    \n    print(best_x)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 147.6757836341858}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        alice_move_sum = 0\n        bob_move_sum = 0\n        moves = 0\n        last_eaten = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            if turn_alice:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n                alice_move_sum = current_sum\n                last_eaten = current_sum\n            else:\n                while left <= right and current_sum <= last_eaten:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n                bob_move_sum = current_sum\n                last_eaten = current_sum\n            turn_alice = not turn_alice\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 105.99128866195679}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, A, B = map(int, data)\n    \n    # Check necessary condition: A * B >= N and A + B <= N + 1\n    if A * B < N or A + B > N + 1:\n        print(-1)\n        return\n    \n    # Construct sequence using block decomposition\n    result = []\n    remaining = N\n    \n    # First, create B blocks where each block is decreasing\n    # The first A-1 blocks will have size B, the last block will have the remaining elements\n    block_sizes = [B] * (A - 1)\n    remaining -= B * (A - 1)\n    \n    # Distribute remaining elements to the first blocks\n    idx = 0\n    while remaining > 0:\n        add = min(B - 1, remaining)  # Add at most B-1 to keep block size <= B\n        block_sizes[idx] += add\n        remaining -= add\n        idx += 1\n        if idx == A - 1:\n            idx = 0\n    \n    # If we still have remaining elements, add as the last block\n    if remaining > 0:\n        block_sizes.append(remaining)\n    else:\n        block_sizes.append(0)\n    \n    # Remove zero-sized blocks\n    block_sizes = [size for size in block_sizes if size > 0]\n    \n    # Build the sequence\n    current = 1\n    for size in block_sizes:\n        # Each block is decreasing\n        block_end = current + size - 1\n        for val in range(block_end, current - 1, -1):\n            result.append(val)\n        current = block_end + 1\n    \n    # Verify we used exactly N elements\n    if len(result) != N:\n        # Fallback: create sequence with exactly A increasing and B decreasing\n        # This handles edge cases where block decomposition might fail\n        result = []\n        # Create A groups, each of size at most B\n        groups = []\n        rem = N\n        for i in range(A):\n            size = min(B, rem - (A - i - 1))\n            groups.append(size)\n            rem -= size\n        \n        current = 1\n        for size in groups:\n            end = current + size - 1\n            for val in range(end, current - 1, -1):\n                result.append(val)\n            current = end + 1\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 75.02283430099487}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 95.89116334915161}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    X = int(next(it))\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(next(it))\n        # Count days when participant eats chocolate: day 1, A+1, 2A+1, ...  D\n        # This is equivalent to counting k such that k*A + 1  D, where k starts from 0\n        # So k  (D-1)//A\n        days_count = (D - 1) // A + 1  # +1 for k=0 (day 1)\n        total_eaten += days_count\n    \n    # Total prepared = eaten + remaining\n    result = total_eaten + X\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.836196422576904}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(300000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank):\n    rx, ry = find(x, parent), find(y, parent)\n    if rx == ry:\n        return False\n    if rank[rx] < rank[ry]:\n        parent[rx] = ry\n    elif rank[rx] > rank[ry]:\n        parent[ry] = rx\n    else:\n        parent[ry] = rx\n        rank[rx] += 1\n    return True\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    capacity = [int(data[idx + i]) for i in range(n)]\n    idx += n\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Count existing connections per server\n    current_conn = [0] * n\n    \n    # Process existing edges\n    for _ in range(m):\n        u = int(data[idx]); idx += 1\n        v = int(data[idx]); idx += 1\n        current_conn[u] += 1\n        current_conn[v] += 1\n        union(u, v, parent, rank)\n    \n    # Find connected components\n    comps = {}\n    for i in range(n):\n        root = find(i, parent)\n        comps.setdefault(root, []).append(i)\n    \n    # Calculate needed edits\n    needed_edits = 0\n    \n    # First, ensure each component is internally feasible\n    for nodes in comps.values():\n        comp_size = len(nodes)\n        if comp_size == 1:\n            continue\n        \n        # Check if component can be a tree (needs at least comp_size-1 edges)\n        # Count existing edges within component\n        # We don't have exact count, but we know each edge contributes to 2 nodes\n        # So total edges in component = sum(current_conn[node] for node in nodes) // 2\n        total_edges_in_comp = sum(current_conn[node] for node in nodes) // 2\n        \n        # Minimum edges needed for connectivity in this component\n        min_edges_needed = comp_size - 1\n        \n        if total_edges_in_comp < min_edges_needed:\n            # Need to add edges within component\n            needed_edits += min_edges_needed - total_edges_in_comp\n        elif total_edges_in_comp > min_edges_needed:\n            # Need to remove extra edges (cycles)\n            needed_edits += total_edges_in_comp - min_edges_needed\n    \n    # Now connect components together\n    num_components = len(comps)\n    if num_components > 1:\n        # Need at least (num_components - 1) edges to connect all components\n        needed_edits += num_components - 1\n    \n    # Check socket capacity constraints\n    for i in range(n):\n        # After edits, degree must be <= capacity[i]\n        # Current degree is current_conn[i]\n        # In worst case, we might add edges to this node when connecting components\n        # Maximum possible additional connections to this node is when it's used\n        # to connect all components (but we can distribute connections)\n        # For safety, we check if current_conn[i] <= capacity[i]\n        if current_conn[i] > capacity[i]:\n            print(\"no\")\n            return\n    \n    # The above calculation gives minimum edits needed\n    # We need to check if we can achieve this with k edits\n    if needed_edits <= k:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 167.84800267219543}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in a:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct_nums[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (first robot's number)\n    for i in range(m):\n        p = distinct_nums[i]\n        # Find the rightmost position where p appears\n        # Since robots move from ends, first robot stops at first occurrence from left\n        # We need to find how many numbers are strictly to the right of this position\n        \n        # Count of numbers to the right of first occurrence of p\n        # First occurrence is at position: prefix_sum[i] (0-based)\n        # Numbers to the right: n - (prefix_sum[i] + 1)\n        # But we need distinct numbers q that appear in this right segment\n        \n        # For each q, we need to check if its last occurrence is to the right of first occurrence of p\n        # Precompute last occurrence positions for each distinct number\n        last_pos = {}\n        for idx, num in enumerate(a):\n            last_pos[num] = idx\n        \n        # For current p, find valid q's\n        first_pos_p = a.index(p)  # first occurrence of p\n        \n        # Count how many distinct q have last occurrence > first_pos_p\n        valid_q_count = 0\n        for j in range(m):\n            q = distinct_nums[j]\n            if last_pos[q] > first_pos_p:\n                valid_q_count += 1\n        \n        total_pairs += valid_q_count\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 243.76355290412903}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = list(map(int, data[2:2+n]))\n    \n    # Count frequencies of each element in s\n    freq = {}\n    for num in s:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # We need to choose k elements for t\n    # Strategy: sort elements by frequency, then greedily take the most frequent ones\n    # But we need to consider that we can take multiple copies of the same element\n    # The maximum number of copies we can cut is limited by floor(freq[element] / count_in_t)\n    \n    # Convert freq dict to list of (value, frequency)\n    items = list(freq.items())\n    items.sort(key=lambda x: (-x[1], x[0]))  # sort by frequency descending, then value\n    \n    # We'll use binary search to find the maximum possible number of copies\n    # For a given number of copies m, we need to check if we can select k elements\n    # such that for each selected element, freq[element] >= m * (how many times it appears in t)\n    \n    # Since t can have duplicates, we need to decide how many times each element appears in t\n    # This is essentially: we have frequencies f_i, we need to select k items (with repetition)\n    # to maximize min_i floor(f_i / x_i) where x_i is how many times element i appears in t\n    # and sum_i x_i = k\n    \n    # Alternative approach: binary search on answer m\n    # For a given m, we can take at most floor(f_i / m) copies of element i in t\n    # If sum_i floor(f_i / m) >= k, then m is feasible\n    \n    def can_achieve(m):\n        if m == 0:\n            return True\n        total = 0\n        for _, f in items:\n            total += f // m\n            if total >= k:\n                return True\n        return total >= k\n    \n    # Binary search for maximum m\n    low, high = 0, n // k  # maximum possible copies\n    best_m = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid):\n            best_m = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Now construct t using best_m\n    t = []\n    for val, f in items:\n        if len(t) >= k:\n            break\n        # We can use this element up to f // best_m times in t\n        count_in_t = min(f // best_m, k - len(t))\n        t.extend([val] * count_in_t)\n    \n    # If best_m is 0 (shouldn't happen since k >= 1 and n >= k), just take any k elements\n    if not t:\n        t = s[:k]\n    \n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 125.04364943504333}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    a, b, c = map(float, line.split())\n    \n    # Check if distances can form a triangle with the stain inside\n    # Using law of cosines to find angles at stain\n    # For distances a,b,c from stain to vertices, we need to check if\n    # they can correspond to a point inside an equilateral triangle\n    \n    # Sort distances to make calculations easier\n    sides = sorted([a, b, c])\n    x, y, z = sides\n    \n    # Check triangle inequality for the distances themselves\n    # The distances must satisfy triangle inequality since they're from a point to vertices\n    if x + y <= z:\n        print(-1)\n        continue\n    \n    # For an equilateral triangle with side length s,\n    # distances d1,d2,d3 from an interior point satisfy:\n    # d1^2 + d2^2 + d3^2 = 3*(s^2/3 + r^2) where r is distance from point to centroid\n    # But we need a direct method\n    \n    # Alternative approach: Use law of cosines to find angles at the stain\n    # Then check if sum of angles = 360 degrees (2 radians)\n    \n    # Calculate angles using law of cosines\n    try:\n        # Avoid domain errors for acos\n        def safe_acos(val):\n            if val >= 1:\n                return 0.0\n            if val <= -1:\n                return math.pi\n            return math.acos(val)\n        \n        # Angles between lines from stain to vertices\n        alpha = safe_acos((b*b + c*c - a*a) / (2*b*c))\n        beta = safe_acos((a*a + c*c - b*b) / (2*a*c))\n        gamma = safe_acos((a*a + b*b - c*c) / (2*a*b))\n        \n        # Sum should be 2 for point inside triangle\n        angle_sum = alpha + beta + gamma\n        \n        # Allow small floating point tolerance\n        if abs(angle_sum - 2*math.pi) > 1e-9:\n            print(-1)\n            continue\n        \n        # Now compute side length of equilateral triangle\n        # Using formula: s^2 = (a^2 + b^2 + c^2)/3 + (2/3)*(3*(a^2*b^2 + b^2*c^2 + c^2*a^2) - (a^4 + b^4 + c^4))\n        # This comes from solving system of equations for distances in equilateral triangle\n        \n        a2, b2, c2 = a*a, b*b, c*c\n        \n        # Calculate the discriminant\n        disc = 3*(a2*b2 + b2*c2 + c2*a2) - (a2*a2 + b2*b2 + c2*c2)\n        \n        if disc < 0:\n            print(-1)\n            continue\n        \n        sqrt_disc = math.sqrt(disc)\n        \n        # Calculate side length squared\n        s_squared = (a2 + b2 + c2)/3 + (2*sqrt_disc)/3\n        \n        if s_squared <= 0:\n            print(-1)\n            continue\n        \n        s = math.sqrt(s_squared)\n        \n        # Calculate area of equilateral triangle\n        area = (math.sqrt(3)/4) * s * s\n        \n        print(f\"{area:.6f}\")\n        \n    except (ValueError, ZeroDivisionError):\n        print(-1)", "runtime_sec": 83.19207382202148}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1277.9660956859589}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            # Even numbers: subtract 1\n            result.append(x - 1)\n        else:\n            # Odd numbers: remain unchanged\n            result.append(x)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 417.94515800476074}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    thore_index = names.index(\"ThoreHusfeldt\")\n    \n    # Check if Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Get names above Thore\n    above_names = names[:thore_index]\n    \n    # Check if any name above has \"ThoreHusfeld\" as prefix\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    thore = \"ThoreHusfeldt\"\n    for prefix_len in range(1, len(thore) + 1):\n        prefix = thore[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Should never reach here since ThoreHusfeldt itself is unique\n    print(thore)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 180.96566796302795}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef count_pairs_less_equal(mid, arr, n):\n    \"\"\"Count number of pairs with product <= mid\"\"\"\n    count = 0\n    \n    # Separate positive, negative and zero values\n    pos = [x for x in arr if x > 0]\n    neg = [x for x in arr if x < 0]\n    zeros = [x for x in arr if x == 0]\n    \n    pos.sort()\n    neg.sort()\n    \n    # Count pairs with product <= mid\n    \n    # Case 1: Both numbers positive\n    if pos:\n        for i in range(len(pos)):\n            if pos[i] == 0:\n                continue\n            # Find max j such that pos[i] * pos[j] <= mid\n            if mid >= 0:\n                # For positive mid, all pairs with pos[j] <= mid/pos[i]\n                max_val = mid // pos[i]\n                if mid % pos[i] != 0 and mid >= 0:\n                    max_val += 1 if mid > 0 else 0\n                j = bisect.bisect_right(pos, max_val)\n                count += max(0, j - i - 1)\n            else:\n                # For negative mid, no positive*positive pairs can be <= negative mid\n                pass\n    \n    # Case 2: Both numbers negative\n    if neg:\n        # Sort negatives in reverse for easier calculation\n        neg_rev = sorted(neg, reverse=True)\n        for i in range(len(neg_rev)):\n            # For negative*negative, product is positive\n            # We need neg_rev[i] * neg_rev[j] <= mid\n            if mid >= 0:\n                # For positive mid, find j such that neg_rev[j] >= mid/neg_rev[i]\n                # Since both are negative\n                if neg_rev[i] == 0:\n                    continue\n                min_val = mid // neg_rev[i]\n                if mid % neg_rev[i] != 0:\n                    min_val += 1\n                j = bisect.bisect_left(neg_rev, min_val, key=lambda x: -x)\n                count += max(0, len(neg_rev) - j - i - 1)\n            else:\n                # For negative mid, all negative*negative pairs are positive, so none <= negative mid\n                pass\n    \n    # Case 3: One positive, one negative\n    if pos and neg:\n        for p in pos:\n            if p == 0:\n                continue\n            # We need p * n <= mid => n <= mid/p\n            max_neg = mid // p\n            if mid % p != 0 and ((mid > 0 and p > 0) or (mid < 0 and p < 0)):\n                max_neg += 1\n            # Count negatives <= max_neg\n            count += bisect.bisect_right(neg, max_neg)\n    \n    # Case 4: Pairs involving zeros\n    zero_count = len(zeros)\n    if zero_count > 0:\n        # Zero with any other number gives product 0\n        # Count pairs with zero\n        count += zero_count * (n - zero_count) + (zero_count * (zero_count - 1)) // 2\n        # But we only want those where product <= mid\n        if mid < 0:\n            # If mid is negative, zero products are not <= mid\n            count -= zero_count * (n - zero_count) + (zero_count * (zero_count - 1)) // 2\n    \n    return count\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    n = int(input_data[0])\n    k = int(input_data[1])\n    arr = list(map(int, input_data[2:2+n]))\n    \n    # Edge case: all zeros\n    if all(x == 0 for x in arr):\n        print(0)\n        return\n    \n    # Binary search for the K-th smallest product\n    # Range: from min possible product to max possible product\n    min_val = -10**18\n    max_val = 10**18\n    \n    # Adjust bounds based on actual values\n    sorted_arr = sorted(arr)\n    min_possible = min(sorted_arr[0] * sorted_arr[1], \n                      sorted_arr[0] * sorted_arr[-1],\n                      sorted_arr[-1] * sorted_arr[-2])\n    max_possible = max(sorted_arr[0] * sorted_arr[1],\n                      sorted_arr[0] * sorted_arr[-1],\n                      sorted_arr[-1] * sorted_arr[-2])\n    \n    left = min(min_possible, min_val)\n    right = max(max_possible, max_val)\n    \n    result = 0\n    while left <= right:\n        mid = (left + right) // 2\n        count = count_pairs_less_equal(mid, arr, n)\n        \n        if count >= k:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 127.57665634155273}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef min_moves_to_divisible_by_25(n_str):\n    \"\"\"Return minimum adjacent swaps to make number divisible by 25, or -1 if impossible.\"\"\"\n    n = n_str.strip()\n    length = len(n)\n    \n    # A number is divisible by 25 if its last two digits are 00, 25, 50, or 75\n    target_endings = [\"00\", \"25\", \"50\", \"75\"]\n    \n    min_moves = float('inf')\n    \n    for ending in target_endings:\n        # We need to find positions of the two required digits\n        # We'll move them to the last two positions\n        pos1 = -1  # position of first digit of ending\n        pos2 = -1  # position of second digit of ending\n        \n        # Find the rightmost occurrence of the second digit\n        for i in range(length - 1, -1, -1):\n            if n[i] == ending[1]:\n                pos2 = i\n                break\n        \n        if pos2 == -1:\n            continue  # second digit not found\n        \n        # Find the rightmost occurrence of the first digit before pos2\n        for i in range(pos2 - 1, -1, -1):\n            if n[i] == ending[0]:\n                pos1 = i\n                break\n        \n        if pos1 == -1:\n            continue  # first digit not found before second digit\n        \n        # Calculate moves to bring these digits to the end\n        # Moves to bring pos2 to last position (index length-1)\n        moves = (length - 1) - pos2\n        \n        # Moves to bring pos1 to second last position (index length-2)\n        # But if pos1 was originally after pos2, after moving pos2, pos1's index changes\n        if pos1 > pos2:\n            # This shouldn't happen with our search, but handle just in case\n            moves += (length - 2) - pos1\n        else:\n            # pos1 is before pos2\n            # After moving pos2 to the end, pos1's position doesn't change relative to other digits\n            # unless it was originally at position > length-2\n            moves += (length - 2) - pos1\n            # But we need to account that pos2 was moved past pos1\n            if pos1 > pos2:\n                moves -= 1  # correction\n        \n        # Check for leading zero after moving digits\n        # We need to ensure the first digit is not '0' after swaps\n        # Create a list representation to simulate\n        digits = list(n)\n        \n        # Move pos2 to end\n        for i in range(pos2, length - 1):\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n        \n        # Update pos1 if it was after the original pos2\n        if pos1 > pos2:\n            pos1 -= 1\n        \n        # Move pos1 to second last\n        target_pos = length - 2\n        for i in range(pos1, target_pos):\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n        \n        # Check for leading zero\n        if digits[0] == '0':\n            # Try to find a non-zero digit to swap to front\n            # We can only swap adjacent digits, so we need to find the first non-zero\n            # and count swaps to bring it to front\n            first_non_zero = -1\n            for i in range(1, length):\n                if digits[i] != '0':\n                    first_non_zero = i\n                    break\n            \n            if first_non_zero == -1:\n                # All digits are zero, which means original number was all zeros\n                # But problem guarantees first digit is not zero, so this shouldn't happen\n                continue\n            \n            # Add swaps to bring first non-zero to front\n            moves += first_non_zero\n            \n            # After bringing non-zero to front, the last two digits might change\n            # But they should still be our target ending since we only moved digits\n            # from positions before length-2\n            \n        min_moves = min(min_moves, moves)\n    \n    return -1 if min_moves == float('inf') else min_moves\n\nif __name__ == \"__main__\":\n    n_str = sys.stdin.readline()\n    result = min_moves_to_divisible_by_25(n_str)\n    print(result)", "runtime_sec": 124.36910152435303}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef cross(o, a, b):\n    \"\"\"Cross product (a-o) x (b-o)\"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    \"\"\"Andrew's monotone chain algorithm\"\"\"\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef collinear(a, b, c):\n    \"\"\"Check if three points are collinear\"\"\"\n    return cross(a, b, c) == 0\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    points = []\n    for i in range(n):\n        x = int(data[2*i + 1])\n        y = int(data[2*i + 2])\n        points.append((x, y))\n    \n    # Get convex hull (all points are on boundary, so hull = all points in order)\n    hull = convex_hull(points)\n    m = len(hull)\n    \n    # DP for minimum lines covering convex polygon vertices\n    # dp[i][j] = min lines to cover vertices from i to j (inclusive) in circular order\n    # Initialize with large values\n    INF = 10**9\n    dp = [[INF] * m for _ in range(m)]\n    \n    # Base cases\n    for i in range(m):\n        dp[i][i] = 1  # Single point needs one line\n    \n    # Fill DP for increasing lengths\n    for length in range(2, m + 1):\n        for i in range(m):\n            j = (i + length - 1) % m\n            \n            # Try all possible splits\n            for k in range(i, i + length - 1):\n                k_mod = k % m\n                next_k = (k + 1) % m\n                \n                # Check if points i, k_mod, next_k are collinear\n                if collinear(hull[i], hull[k_mod], hull[next_k]):\n                    # They can be covered by same line\n                    dp[i][j] = min(dp[i][j], dp[i][k_mod] + dp[next_k][j] - 1)\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i][k_mod] + dp[next_k][j])\n    \n    # Find minimum over all starting points\n    result = INF\n    for i in range(m):\n        result = min(result, dp[i][(i + m - 1) % m])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 77.76272630691528}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n = int(data[idx]); x = int(data[idx+1]); y = int(data[idx+2])\n        idx += 3\n        total = x + y\n        # Minimum place: count participants with total < total_nikolay\n        # We can assign others the worst possible scores to minimize ties\n        # Participants with total < total_nikolay: at most total-2 (since x,y >=1)\n        # But limited by n-1 other participants\n        min_place = 1\n        if total > n + 1:\n            # When total > n+1, we can make all others have higher total\n            min_place = total - n\n            if min_place < 1:\n                min_place = 1\n        else:\n            # total <= n+1: we can have at most total-2 participants with strictly lower total\n            min_place = max(1, total - 1)\n        \n        # Maximum place: count participants with total <= total_nikolay\n        # We can assign others the best possible scores to maximize ties\n        # Participants with total <= total_nikolay: at most total-1 (since x,y <= n)\n        # But limited by n\n        max_place = min(n, total - 1)\n        if max_place < 1:\n            max_place = 1\n        \n        out_lines.append(f\"{min_place} {max_place}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.42249298095703}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    \"\"\"Find the largest bus number  m.\"\"\"\n    if m < 1729:\n        return \"none\"\n    \n    # Dictionary to store count of ways for each sum\n    ways_count = {}\n    max_bus = -1\n    \n    # Upper bound for i: cube root of m\n    max_i = int(m ** (1/3)) + 1\n    \n    for i in range(1, max_i + 1):\n        i_cube = i * i * i\n        if i_cube > m:\n            break\n        \n        for j in range(i, max_i + 1):\n            j_cube = j * j * j\n            s = i_cube + j_cube\n            if s > m:\n                break\n            \n            # Count this representation\n            ways_count[s] = ways_count.get(s, 0) + 1\n            \n            # Update max_bus if we have at least 2 ways\n            if ways_count[s] >= 2 and s > max_bus:\n                max_bus = s\n    \n    return str(max_bus) if max_bus != -1 else \"none\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    result = find_largest_bus_number(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 61.75686049461365}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(1000000)\n\nMOD = 1000003\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"begin repairs\"\n    \n    Y = int(data[0])\n    X = int(data[1])\n    x_init = int(data[2])\n    \n    grid = []\n    idx = 3\n    for _ in range(Y):\n        row = data[idx]\n        idx += 1\n        grid.append(row)\n    \n    # Find castle position\n    castle_pos = None\n    for y in range(Y):\n        for x in range(X):\n            if grid[y][x] == '@':\n                castle_pos = (y, x)\n                break\n        if castle_pos:\n            break\n    \n    # DP table: dp[y][x] = number of ways to reach castle from (y, x)\n    dp = [[-1] * X for _ in range(Y)]\n    \n    def dfs(y, x):\n        if y < 0 or y >= Y or x < 0 or x >= X:\n            return 0\n        if grid[y][x] == '#':\n            return 0\n        \n        # If already computed\n        if dp[y][x] != -1:\n            return dp[y][x]\n        \n        # If at castle\n        if (y, x) == castle_pos:\n            dp[y][x] = 1\n            return 1\n        \n        # If we're on a current tile, we must follow it\n        if grid[y][x] == '>':\n            # Move right according to current\n            res = dfs(y, x + 1)\n            dp[y][x] = res % MOD\n            return res\n        elif grid[y][x] == '<':\n            # Move left according to current\n            res = dfs(y, x - 1)\n            dp[y][x] = res % MOD\n            return res\n        \n        # On open sea '~' or starting position (which could be '~' or current)\n        # We have two choices:\n        # 1. Move north (up) by lowering sails\n        # 2. Move east/west by retracting sails (but only if not on current)\n        \n        # Actually, from problem description:\n        # - If we lower sails, we move north (up)\n        # - If we retract sails, we move with current (but we're not on current here)\n        # Wait, re-reading: \"Retract the sails and move in the direction of the current theyre on top of\"\n        # So if we're on '~', there's no current, so retracting sails does nothing?\n        # Actually, the description says: \"move in the direction of the current theyre on top of\"\n        # So if on '~', no current, so retracting sails gives no movement.\n        # Therefore from '~' we can only move north.\n        \n        # But wait, sample 2 has '~' tiles that seem to allow movement.\n        # Let me re-examine: The ship can:\n        # 1. Move north by lowering sails (always available)\n        # 2. Retract sails and move with current IF on current tile\n        # So from '~', only option is move north.\n        \n        # Move north (up)\n        res = dfs(y - 1, x)\n        dp[y][x] = res % MOD\n        return res\n    \n    # Start from bottom row (y = Y-1), column x_init\n    result = dfs(Y - 1, x_init)\n    \n    if result == 0:\n        return \"begin repairs\"\n    return str(result % MOD)\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 78.42726826667786}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, c, b = map(int, data[:3])\n    broken = set(map(int, data[3:3+b]))\n    \n    # Initialize result with all zeros\n    res = ['0'] * n\n    \n    # First bit is never broken, so we can set it to '1' to start a change\n    res[0] = '1'\n    changes = 0\n    \n    # We'll create changes by alternating bits where possible\n    # Start from position 2 (index 1) since position 1 is already set\n    i = 1\n    while i < n and changes < c:\n        if i+1 in broken:\n            # Skip broken bits\n            i += 1\n            continue\n        \n        # Create a change by flipping the bit\n        res[i] = '1' if res[i-1] == '0' else '0'\n        changes += 1\n        \n        # If we've reached the desired changes, break\n        if changes == c:\n            break\n        \n        # Move to next position (skip one to avoid creating extra changes)\n        i += 2\n    \n    # Output the result\n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 59.83083200454712}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive_time, calm_time):\n    \"\"\"Return True if arrival falls within aggressive period.\"\"\"\n    cycle_length = aggressive_time + calm_time\n    position_in_cycle = arrival % cycle_length\n    # Aggressive period is from 0 to aggressive_time-1 (0-indexed minutes)\n    return position_in_cycle < aggressive_time\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: problem states \"during the nth minute\" means 0-indexed\n    arrivals = [P-1, M-1, G-1]\n    \n    results = []\n    for arrival in arrivals:\n        dog1_agg = is_aggressive(arrival, A, B)\n        dog2_agg = is_aggressive(arrival, C, D)\n        \n        if dog1_agg and dog2_agg:\n            results.append(\"both\")\n        elif dog1_agg or dog2_agg:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 102.1079638004303}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror-symmetric letters\n    mirror_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'}\n    \n    n = len(word)\n    # Check each character and its mirror position\n    for i in range((n + 1) // 2):\n        left_char = word[i]\n        right_char = word[n - 1 - i]\n        \n        # Both characters must be mirror-symmetric\n        if left_char not in mirror_letters or right_char not in mirror_letters:\n            return False\n        \n        # Characters must be identical (mirror symmetry requires same character)\n        if left_char != right_char:\n            return False\n    \n    return True\n\ndef main():\n    # Read input (strip newline)\n    word = sys.stdin.readline().strip()\n    \n    if is_mirror_word(word):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 2739.1819546222687}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    vectors = []\n    idx = 1\n    for i in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        idx += 2\n        angle = math.atan2(y, x)  # returns angle in radians [-, ]\n        vectors.append((angle, i+1))  # store angle and original index\n    \n    # Sort by angle\n    vectors.sort(key=lambda v: v[0])\n    \n    # Initialize minimal angle and answer indices\n    min_angle = float('inf')\n    ans_a, ans_b = -1, -1\n    \n    # Check consecutive angles in sorted order\n    for i in range(n):\n        j = (i + 1) % n\n        angle_i = vectors[i][0]\n        angle_j = vectors[j][0]\n        \n        # Compute the difference, handling wrap-around at 2\n        diff = abs(angle_j - angle_i)\n        if diff > math.pi:\n            diff = 2 * math.pi - diff\n        \n        if diff < min_angle:\n            min_angle = diff\n            ans_a = vectors[i][1]\n            ans_b = vectors[j][1]\n    \n    # Output the indices in any order\n    print(f\"{ans_a} {ans_b}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.30905866622925}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    a_score = 0\n    b_score = 0\n    i = 0\n    while i < len(s):\n        player = s[i]\n        points = int(s[i+1])\n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        i += 2\n        # Check win conditions\n        if a_score >= 11 and a_score - b_score >= 2:\n            return 'A'\n        if b_score >= 11 and b_score - a_score >= 2:\n            return 'B'\n        if a_score == 10 and b_score == 10:\n            # Win by 2 rule activated\n            while True:\n                if i >= len(s):\n                    break\n                player = s[i]\n                points = int(s[i+1])\n                if player == 'A':\n                    a_score += points\n                else:\n                    b_score += points\n                i += 2\n                if a_score - b_score >= 2:\n                    return 'A'\n                if b_score - a_score >= 2:\n                    return 'B'\n    # Should never reach here for valid input\n    return 'A' if a_score > b_score else 'B'\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 99.15658068656921}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(400000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    D = int(next(it))\n    \n    # Build tree\n    children = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(next(it))\n        children[parent].append(i)\n    \n    # DP arrays\n    # dp0[u]: max marks in subtree rooted at u when u is NOT marked\n    # dp1[u]: max marks in subtree rooted at u when u IS marked\n    dp0 = [0] * N\n    dp1 = [0] * N\n    \n    # For each node, store distances to nearest marked descendant\n    # dist[u]: minimum distance from u to any marked node in its subtree\n    # Initialize with large value (infinity)\n    INF = 10**9\n    dist = [INF] * N\n    \n    def dfs(u):\n        # Process children first\n        for v in children[u]:\n            dfs(v)\n        \n        # Case 1: u is not marked\n        # We can take best from each child independently\n        sum_not_marked = 0\n        for v in children[u]:\n            sum_not_marked += max(dp0[v], dp1[v])\n        dp0[u] = sum_not_marked\n        \n        # Case 2: u is marked\n        # We need to ensure no marked descendant within distance D-1\n        # We can only take children where the nearest marked node is at least D away\n        # Since u is marked, distance from u to itself is 0\n        \n        # First, compute for each child whether we can take it if u is marked\n        # We can take child v if:\n        # - v is not marked AND we take dp0[v] (no conflict since v not marked)\n        # - v is marked AND dist[v] >= D (nearest marked in v's subtree is far enough)\n        \n        # But we need to be careful: if v is marked, then distance from u to that marked node is 1 + dist[v]\n        # Actually, dist[v] is min distance from v to any marked in its subtree\n        # So distance from u to that marked node would be 1 + dist[v]\n        # We need 1 + dist[v] >= D\n        \n        best_if_marked = 1  # mark u itself\n        for v in children[u]:\n            # Option 1: don't mark anything in v's subtree that would conflict\n            # Take dp0[v] (v not marked, so no conflict)\n            option1 = dp0[v]\n            \n            # Option 2: mark something in v's subtree, but ensure it's far enough\n            # We can take dp1[v] only if the nearest marked in v's subtree is at distance >= D-1 from v\n            # Because distance from u to that marked node would be 1 + dist[v]\n            # We need 1 + dist[v] >= D  =>  dist[v] >= D-1\n            option2 = dp1[v] if dist[v] >= D - 1 else -INF\n            \n            best_if_marked += max(option1, option2)\n        \n        dp1[u] = best_if_marked\n        \n        # Update dist[u]\n        if dp1[u] > dp0[u]:\n            # u is marked in optimal solution for its subtree\n            dist[u] = 0\n        else:\n            # u is not marked, take min from children + 1\n            min_child_dist = INF\n            for v in children[u]:\n                min_child_dist = min(min_child_dist, dist[v] + 1)\n            dist[u] = min_child_dist\n    \n    dfs(0)\n    print(max(dp0[0], dp1[0]))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 118.96640038490295}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draw = 0\n    second_wins = 0\n    \n    for dice in range(1, 7):\n        diff_a = abs(a - dice)\n        diff_b = abs(b - dice)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draw} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1555.2176449298859}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Map values to indices 0-5 for easier counting\n    value_to_idx = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Count how many complete sequences we can form\n    count = [0] * 6\n    removed = 0\n    \n    for val in arr:\n        idx = value_to_idx[val]\n        if idx == 0:\n            # Start of a new sequence\n            count[0] += 1\n        else:\n            # Need previous element to exist\n            if count[idx-1] > 0:\n                count[idx-1] -= 1\n                count[idx] += 1\n            else:\n                # Cannot form sequence, remove this element\n                removed += 1\n    \n    # Remove incomplete sequences\n    # Each count[i] represents how many sequences are waiting for element i+1\n    # We need to remove all elements that are part of incomplete sequences\n    for i in range(5):\n        removed += count[i] * (i+1)  # Each incomplete sequence has i+1 elements\n    \n    print(removed)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 303.41799688339233}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123795 tokens (2122195 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 23.83316707611084}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Compute total XOR of all elements\n    total_xor = 0\n    for num in arr:\n        total_xor ^= num\n    \n    # Step 2: Transform array to basis using Gaussian elimination\n    basis = []\n    for num in arr:\n        x = num\n        for b in basis:\n            x = min(x, x ^ b)\n        if x:\n            basis.append(x)\n            # Keep basis sorted in descending order for efficiency\n            basis.sort(reverse=True)\n    \n    # Step 3: Find maximum XOR subset\n    max_xor = 0\n    for b in basis:\n        max_xor = max(max_xor, max_xor ^ b)\n    \n    # Step 4: Compute answer\n    # Let S = max_xor (XOR of red subset)\n    # Then blue XOR = total_xor ^ S\n    # Beauty = S + (total_xor ^ S)\n    # Since total_xor is fixed, we want to maximize S + (total_xor ^ S)\n    # We can try all possible S from basis combinations, but we already have max_xor\n    # However, we need to check if we can achieve this partition with at least 1 and at most N-1 red elements\n    \n    # Check if max_xor partition is valid\n    # If max_xor == 0, we need to find next best\n    if max_xor == 0:\n        # All elements are 0 or cancel out\n        # We can take any non-empty proper subset\n        # Maximum beauty would be 0 + total_xor = total_xor\n        # But we need at least 1 red element, so we need to find non-zero subset if possible\n        non_zero_found = False\n        for num in arr:\n            if num != 0:\n                non_zero_found = True\n                break\n        if non_zero_found:\n            # Find maximum non-zero XOR\n            max_xor = 0\n            for b in basis:\n                if b != 0:\n                    max_xor = max(max_xor, max_xor ^ b)\n        else:\n            # All elements are 0\n            max_xor = 0\n    \n    # Final answer\n    answer = max_xor + (total_xor ^ max_xor)\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 114.06015181541443}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx]); idx += 1\n        k = int(input_data[idx]); idx += 1\n        \n        x = list(map(int, input_data[idx:idx+n])); idx += n\n        y = list(map(int, input_data[idx:idx+n])); idx += n\n        \n        # Sort points by x-coordinate\n        points = sorted(zip(x, y))\n        \n        # Precompute: for each point i, how many points can be covered by a platform\n        # starting at or before point i's x-coordinate\n        pref = [0] * n\n        j = 0\n        for i in range(n):\n            while points[i][0] - points[j][0] > k:\n                j += 1\n            pref[i] = i - j + 1\n        \n        # Precompute: maximum prefix coverage up to each position\n        max_pref = [0] * n\n        max_pref[0] = pref[0]\n        for i in range(1, n):\n            max_pref[i] = max(max_pref[i-1], pref[i])\n        \n        # For each point as potential start of second platform, combine with best first platform\n        ans = 0\n        j = 0\n        for i in range(n):\n            while points[i][0] - points[j][0] > k:\n                j += 1\n            first_platform = 0\n            if j > 0:\n                first_platform = max_pref[j-1]\n            ans = max(ans, first_platform + (i - j + 1))\n        \n        results.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 111.72478580474854}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.94603157043457}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nMOD = 10**9 + 7\n\ndef factorize(m):\n    factors = {}\n    d = 2\n    while d * d <= m:\n        while m % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            m //= d\n        d += 1 if d == 2 else 2\n    if m > 1:\n        factors[m] = factors.get(m, 0) + 1\n    return factors\n\ndef modinv(a, mod=MOD):\n    return pow(a, mod-2, mod)\n\ndef nCr(n, r, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_n_fact[n-r] % MOD\n\ninput_data = sys.stdin.read().strip().split()\nif not input_data:\n    print(0)\n    sys.exit()\nN = int(input_data[0])\nM = int(input_data[1])\n\nif M == 1:\n    print(1)\n    sys.exit()\n\nprime_factors = factorize(M)\n\nmax_exp = max(prime_factors.values()) if prime_factors else 0\nmax_n = N + max_exp\n\nfact = [1] * (max_n + 1)\nfor i in range(1, max_n + 1):\n    fact[i] = fact[i-1] * i % MOD\n\ninv_fact = [1] * (max_n + 1)\ninv_fact[max_n] = modinv(fact[max_n])\nfor i in range(max_n-1, -1, -1):\n    inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n\nresult = 1\nfor exp in prime_factors.values():\n    ways = nCr(exp + N - 1, N - 1, fact, inv_fact)\n    result = result * ways % MOD\n\nprint(result % MOD)", "runtime_sec": 66.65356659889221}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller count of chips that need to move by 1\n    result = min(even_count, odd_count)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1680.6462671756744}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    if n < 5:\n        print(0)\n        return\n    \n    suffixes = set()\n    \n    # Check all possible splits where root length >= 5 and suffixes are length 2 or 3\n    # We'll iterate over possible suffix starting positions\n    for i in range(4, n - 1):  # i is the last index of root (0-based)\n        root_len = i + 1\n        if root_len < 5:\n            continue\n        \n        # Try to parse the rest as suffixes\n        pos = i + 1\n        last_suffix = \"\"\n        valid = True\n        \n        while pos < n:\n            # Try length 3 first (if possible), then length 2\n            if pos + 3 <= n:\n                suffix = s[pos:pos+3]\n                if suffix != last_suffix:\n                    last_suffix = suffix\n                    pos += 3\n                    continue\n            \n            if pos + 2 <= n:\n                suffix = s[pos:pos+2]\n                if suffix != last_suffix:\n                    last_suffix = suffix\n                    pos += 2\n                    continue\n            \n            # If we get here, we couldn't find a valid suffix\n            valid = False\n            break\n        \n        if valid and pos == n:\n            # Collect all suffixes from this valid parsing\n            pos = i + 1\n            last_suffix = \"\"\n            while pos < n:\n                if pos + 3 <= n:\n                    suffix = s[pos:pos+3]\n                    if suffix != last_suffix:\n                        suffixes.add(suffix)\n                        last_suffix = suffix\n                        pos += 3\n                        continue\n                \n                if pos + 2 <= n:\n                    suffix = s[pos:pos+2]\n                    if suffix != last_suffix:\n                        suffixes.add(suffix)\n                        last_suffix = suffix\n                        pos += 2\n                        continue\n    \n    # Also check if the entire string is just the root (no suffixes)\n    # This would mean no suffixes are possible\n    \n    result = sorted(suffixes)\n    print(len(result))\n    for suffix in result:\n        print(suffix)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 69.96125030517578}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # water[i] stores current water in vessel i+1\n    water = [0] * n\n    \n    # For each vessel, find the next vessel that can receive overflow\n    # We'll compute this lazily during queries\n    next_vessel = list(range(1, n + 1))  # next_vessel[i] points to vessel index (1-based) that can receive overflow from i\n    \n    def find_next(v):\n        # v is 1-based vessel index\n        # Find the next vessel that can receive overflow from v\n        # Using path compression for efficiency\n        if v > n:\n            return n + 1  # Beyond last vessel, water spills to floor\n        \n        # Convert to 0-based for array access\n        idx = v - 1\n        \n        # If current vessel is not full, it can receive water\n        if water[idx] < capacities[idx]:\n            return v\n        \n        # Otherwise, find the next vessel that can receive overflow\n        # Update next_vessel for path compression\n        next_vessel[idx] = find_next(next_vessel[idx])\n        return next_vessel[idx]\n    \n    results = []\n    \n    for _ in range(m):\n        query_type = int(next(it))\n        \n        if query_type == 1:\n            p = int(next(it)) - 1  # Convert to 0-based\n            x = int(next(it))\n            \n            # Pour water starting from vessel p\n            while x > 0 and p < n:\n                # Find the next vessel that can receive water\n                next_p = find_next(p + 1) - 1  # Convert back to 0-based\n                \n                if next_p >= n:\n                    # Water spills to floor\n                    break\n                \n                # Calculate how much water can be added to this vessel\n                available = capacities[next_p] - water[next_p]\n                add_amount = min(x, available)\n                \n                if add_amount > 0:\n                    water[next_p] += add_amount\n                    x -= add_amount\n                \n                # Move to next vessel\n                p = next_p\n                \n        else:  # query_type == 2\n            k = int(next(it)) - 1  # Convert to 0-based\n            results.append(str(water[k]))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 71.87698268890381}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = int(data[1])\n    e = list(map(int, data[2:2+n]))\n    \n    # Sort Finni's fleet sizes in ascending order\n    e.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy_ships in e:\n        # Minimum ships needed to win this battle\n        needed = enemy_ships + 1\n        \n        # Check if we have enough ships left\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            # Not enough ships for this battle, break since sorted ascending\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 95.97938299179077}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 90.60091304779053}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b.\n    # Since a and b are integers, we can iterate over possible b values.\n    # But constraints are up to 10^7, so we need O(1) solution.\n    # For each b in [x, y], a = k * b must be in [l, r].\n    # So we need to check if there exists b in [x, y] such that l <= k * b <= r.\n    # This is equivalent to checking if the intervals [l, r] and [k*x, k*y] overlap.\n    # But careful: a must be integer, and b integer, so k*b must be integer.\n    # Since k and b are integers, k*b is integer automatically.\n    # So we just need to check if there exists integer b in [x, y] with k*b in [l, r].\n    # That means: ceil(l/k) <= floor(r/k) and this interval must intersect [x, y].\n    # Alternatively, we can compute the range of b: b_min = (l + k - 1) // k  (ceil division)\n    # b_max = r // k  (floor division)\n    # Then check if [b_min, b_max] intersects [x, y].\n    b_min = (l + k - 1) // k  # smallest b such that k*b >= l\n    b_max = r // k            # largest b such that k*b <= r\n    if b_min <= b_max and not (b_max < x or b_min > y):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 105.42614722251892}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+n]]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # First pass: place 'E' on land cells that have no adjacent 'E' and are not adjacent to water\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if any adjacent cell is 'E'\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        has_adjacent_E = True\n                        break\n                # If no adjacent 'E', place one\n                if not has_adjacent_E:\n                    # Also ensure we don't place next to another 'E' (should be true by check)\n                    grid[i][j] = 'E'\n    \n    # Second pass: ensure all land cells are covered\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if any adjacent cell is 'E' or water\n                covered = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m:\n                        if grid[ni][nj] == 'E':\n                            covered = True\n                            break\n                # If not covered, place 'E' on this cell\n                if not covered:\n                    grid[i][j] = 'E'\n    \n    # Output the result\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 65.42513227462769}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s):\n    \"\"\"Return length of longest substring that appears at least twice\"\"\"\n    n = len(s)\n    if n < 2:\n        return 0\n    \n    # Suffix array construction using doubling algorithm\n    # Initial ranking of characters\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    sa = list(range(n))\n    k = 1\n    \n    while True:\n        # Sort suffixes based on first k characters\n        sa.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        \n        # Assign new ranks\n        tmp[sa[0]] = 0\n        for i in range(1, n):\n            prev, curr = sa[i-1], sa[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            curr_key = (rank[curr], rank[curr + k] if curr + k < n else -1)\n            tmp[curr] = tmp[prev] + (prev_key != curr_key)\n        \n        rank, tmp = tmp, rank\n        \n        # If all suffixes have unique ranks, we're done\n        if rank[sa[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # Kasai's algorithm for LCP array\n    lcp = [0] * n\n    inv_sa = [0] * n\n    for i in range(n):\n        inv_sa[sa[i]] = i\n    \n    k = 0\n    for i in range(n):\n        if inv_sa[i] == n - 1:\n            k = 0\n            continue\n        j = sa[inv_sa[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_sa[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # Longest repeated substring length is max LCP value\n    return max(lcp) if lcp else 0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    s = data[1]\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 149.59288549423218}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_pythagorean_triples(n):\n    \"\"\"Count right-angled triangles with 1  a  b  c  n\"\"\"\n    count = 0\n    \n    # Iterate through possible values of a and b\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):  # b >= a\n            # Calculate c^2 = a^2 + b^2\n            c_squared = a * a + b * b\n            c = int(math.isqrt(c_squared))  # integer square root\n            \n            # Check if c is valid and satisfies Pythagorean theorem\n            if c <= n and c * c == c_squared:\n                count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    # Read input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    \n    n = int(data)\n    result = count_pythagorean_triples(n)\n    print(result)", "runtime_sec": 58.15457773208618}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    # Days from purchase to eating: B\n    # Days from best-by to eating: B - A\n    days_from_best_by = B - A\n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 136.82837915420532}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "UnicodeEncodeError('gbk', 'import sys\\r\\nimport math\\r\\n\\r\\ndef solve():\\r\\n    data = sys.stdin.read().strip().split()\\r\\n    if not data:\\r\\n        return\\r\\n    L = int(data[0])\\r\\n    x1, y1 = int(data[1]), int(data[2])\\r\\n    x2, y2 = int(data[3]), int(data[4])\\r\\n    \\r\\n    # Calculate distance from origin to the line\\r\\n    # Line through (x1,y1) and (x2,y2)\\r\\n    # Using formula for distance from point to line: |Ax0 + By0 + C| / sqrt(A^2 + B^2)\\r\\n    # where line: (y2-y1)x - (x2-x1)y + (x2*y1 - x1*y2) = 0\\r\\n    A = y2 - y1\\r\\n    B = -(x2 - x1)\\r\\n    C = x2 * y1 - x1 * y2\\r\\n    \\r\\n    # Distance from origin (0,0) to the line\\r\\n    d = abs(C) / math.sqrt(A*A + B*B) if (A != 0 or B != 0) else 0\\r\\n    \\r\\n    # The dog is tied at (0,0) and cannot cross the wall.\\r\\n    # The accessible area is a circular sector minus a circular segment.\\r\\n    # Let r be the chain length.\\r\\n    # The area covered is: r - (r * acos(d/r) - d * sqrt(r - d))\\r\\n    # We need to find smallest integer r such that area >= L\\r\\n    \\r\\n    # If d == 0, the wall passes through origin, dog can\\'t access any area\\r\\n    if d == 0:\\r\\n        print(0)\\r\\n        return\\r\\n    \\r\\n    # Binary search for r\\r\\n    low, high = 1, 20000  # Upper bound: sqrt(L/) + d, but safe bound\\r\\n    while low < high:\\r\\n        mid = (low + high) // 2\\r\\n        r = mid\\r\\n        # Calculate area\\r\\n        if r <= d:\\r\\n            # Chain too short to reach beyond wall\\r\\n            area = 0\\r\\n        else:\\r\\n            theta = math.acos(d / r)\\r\\n            area = math.pi * r * r - (r * r * theta - d * math.sqrt(r * r - d * d))\\r\\n        \\r\\n        if area >= L:\\r\\n            high = mid\\r\\n        else:\\r\\n            low = mid + 1\\r\\n    \\r\\n    print(low)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    solve()', 855, 856, 'illegal multibyte sequence')", "runtime_sec": 28.940781354904175}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:]]\n    \n    # Find all white pixel positions\n    whites = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                whites.append((i, j))\n    \n    if not whites:\n        print(-1)\n        return\n    \n    # Find bounding box of white pixels\n    min_r = min(w[0] for w in whites)\n    max_r = max(w[0] for w in whites)\n    min_c = min(w[1] for w in whites)\n    max_c = max(w[1] for w in whites)\n    \n    # Calculate required frame size\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    d = max(height, width)\n    \n    # Check if frame fits within screen\n    if min_r + d - 1 >= n or min_c + d - 1 >= m:\n        print(-1)\n        return\n    \n    # Generate candidate frame positions\n    candidates = []\n    for start_r in range(min_r - (d - height), min_r + 1):\n        if start_r < 0 or start_r + d - 1 >= n:\n            continue\n        for start_c in range(min_c - (d - width), min_c + 1):\n            if start_c < 0 or start_c + d - 1 >= m:\n                continue\n            candidates.append((start_r, start_c, d))\n    \n    # Check each candidate\n    best = None\n    for sr, sc, size in candidates:\n        # Check if all whites are on the frame border\n        valid = True\n        for r, c in whites:\n            if not (r == sr or r == sr + size - 1 or c == sc or c == sc + size - 1):\n                valid = False\n                break\n            # Check it's actually on the border (not corner counted twice)\n            if not ((r == sr or r == sr + size - 1) and (sc <= c <= sc + size - 1)) and \\\n               not ((c == sc or c == sc + size - 1) and (sr <= r <= sr + size - 1)):\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check no black pixels on frame are required to be white\n        frame_pixels = set()\n        # Top and bottom edges\n        for c in range(sc, sc + size):\n            frame_pixels.add((sr, c))\n            frame_pixels.add((sr + size - 1, c))\n        # Left and right edges (excluding corners already counted)\n        for r in range(sr + 1, sr + size - 1):\n            frame_pixels.add((r, sc))\n            frame_pixels.add((r, sc + size - 1))\n        \n        # All white pixels must be in frame_pixels\n        white_set = set(whites)\n        if not white_set.issubset(frame_pixels):\n            continue\n        \n        # Check no black pixel on frame conflicts\n        conflict = False\n        for r, c in frame_pixels:\n            if (r, c) not in white_set and grid[r][c] != '.':\n                conflict = True\n                break\n        if conflict:\n            continue\n        \n        # This is a valid frame\n        if best is None or size < best[2]:\n            best = (sr, sc, size)\n        elif size == best[2]:\n            # Choose any, keep first found\n            pass\n    \n    if best is None:\n        print(-1)\n        return\n    \n    sr, sc, size = best\n    # Mark the frame with '+' where not already 'w'\n    result = [list(row) for row in grid]\n    # Top and bottom edges\n    for c in range(sc, sc + size):\n        if result[sr][c] == '.':\n            result[sr][c] = '+'\n        if result[sr + size - 1][c] == '.':\n            result[sr + size - 1][c] = '+'\n    # Left and right edges\n    for r in range(sr + 1, sr + size - 1):\n        if result[r][sc] == '.':\n            result[r][sc] = '+'\n        if result[r][sc + size - 1] == '.':\n            result[r][sc + size - 1] = '+'\n    \n    # Output\n    for row in result:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 247.89345860481262}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    result = A * B\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 535.1094937324524}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count triples (a,b,c) with 1 <= a <= b <= n-1 and a^2 + b^2  c^2 (mod n).\"\"\"\n    # Precompute squares modulo n\n    squares_mod = [0] * n\n    for i in range(n):\n        squares_mod[i] = (i * i) % n\n    \n    # Count frequencies of each square value modulo n\n    freq = [0] * n\n    for i in range(1, n):\n        freq[squares_mod[i]] += 1\n    \n    # For each pair (a,b) with a <= b, compute (a^2 + b^2) mod n and count matches\n    total = 0\n    for a in range(1, n):\n        a_sq = squares_mod[a]\n        for b in range(a, n):\n            target = (a_sq + squares_mod[b]) % n\n            total += freq[target]\n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 66.22654390335083}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    S = data[0]\n    Q = int(data[1])\n    \n    # Use deque for efficient appends at both ends\n    from collections import deque\n    dq = deque(S)\n    \n    reversed_flag = False  # Track if string is logically reversed\n    \n    idx = 2  # Start of queries in data list\n    for _ in range(Q):\n        T = int(data[idx])\n        idx += 1\n        \n        if T == 1:\n            # Toggle reversal flag instead of actually reversing\n            reversed_flag = not reversed_flag\n        else:  # T == 2\n            F = int(data[idx])\n            C = data[idx + 1]\n            idx += 2\n            \n            # Determine actual position based on reversal flag\n            if (F == 1 and not reversed_flag) or (F == 2 and reversed_flag):\n                # Add to beginning in current logical orientation\n                dq.appendleft(C)\n            else:\n                # Add to end in current logical orientation\n                dq.append(C)\n    \n    # Convert to string, reversing if needed\n    result = ''.join(dq)\n    if reversed_flag:\n        result = result[::-1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 140.83331608772278}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    idx = 0\n    N = int(data[idx]); idx += 1\n    points = []\n    for _ in range(N):\n        x = float(data[idx]); y = float(data[idx+1])\n        idx += 2\n        points.append((x, y))\n    A = float(data[idx])\n    return N, points, A\n\ndef polygon_area(points):\n    \"\"\"Calculate area of polygon using shoelace formula.\"\"\"\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1)%n]\n        area += x1*y2 - x2*y1\n    return abs(area) / 2.0\n\ndef scale_polygon(points, scale_factor):\n    \"\"\"Scale polygon around origin by scale_factor.\"\"\"\n    return [(x*scale_factor, y*scale_factor) for x, y in points]\n\ndef translate_polygon(points):\n    \"\"\"Translate polygon so min_x = min_y = 0.\"\"\"\n    min_x = min(x for x, _ in points)\n    min_y = min(y for _, y in points)\n    return [(x - min_x, y - min_y) for x, y in points]\n\ndef main():\n    N, points, target_area = read_input()\n    if N is None:\n        return\n    \n    # Calculate original area\n    original_area = polygon_area(points)\n    \n    # Calculate scale factor\n    # Since area scales by square of linear dimensions\n    scale_factor = math.sqrt(target_area / original_area)\n    \n    # Scale polygon\n    scaled_points = scale_polygon(points, scale_factor)\n    \n    # Translate to meet requirements\n    final_points = translate_polygon(scaled_points)\n    \n    # Output\n    for x, y in final_points:\n        print(f\"{x:.10f} {y:.10f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 66.96480131149292}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    cards = [int(next(it)) for _ in range(N)]\n    \n    # Step 1: Transform to differences\n    diff = [cards[0]] + [cards[i] - cards[i-1] for i in range(1, N)]\n    # Add sentinel for the gap after last card\n    diff.append(10**9)  # large sentinel\n    \n    # Step 2: Greedy pairing\n    ans = 0\n    i = 0\n    while i < len(diff):\n        if diff[i] % 2 == 0:\n            i += 1\n            continue\n        # Find next odd difference\n        j = i + 1\n        while j < len(diff) and diff[j] % 2 == 0:\n            j += 1\n        if j >= len(diff):\n            # No pair found, treat as single\n            ans += 3\n            break\n        # Pair i and j\n        ans += 2\n        i = j + 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 60.074955701828}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            out_lines.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            out_lines.append(\"-1\")\n            continue\n        \n        # Sleep needed after first alarm\n        need = a - b\n        # Sleep gained per cycle\n        gain_per_cycle = c - d\n        # Number of full cycles needed\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        # Total time = first alarm + cycles * c\n        total_time = b + cycles * c\n        out_lines.append(str(total_time))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 180.0559597015381}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Boolean array where True means crossed out\n    crossed = [False] * (N + 1)\n    crossed[0] = crossed[1] = True  # 0 and 1 are not considered\n    \n    crossed_count = 0\n    result = -1\n    \n    for p in range(2, N + 1):\n        if not crossed[p]:\n            # p is prime, cross out p and its multiples\n            for multiple in range(p, N + 1, p):\n                if not crossed[multiple]:\n                    crossed[multiple] = True\n                    crossed_count += 1\n                    if crossed_count == K:\n                        result = multiple\n                        break\n            if result != -1:\n                break\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 137.05552124977112}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, enemy kills one gnome per turn regardless of grouping\n    if k == 1:\n        # Damage is sum from n down to 1\n        total = n * (n + 1) // 2\n        print(total)\n        return\n    \n    # If m is large enough to make each group size <= k\n    # Enemy can kill entire groups each turn\n    if m >= n:\n        # Each group has 1 gnome, enemy kills one group per turn\n        total = n * (n + 1) // 2\n        print(total)\n        return\n    \n    # General case\n    # We want to create groups where enemy's optimal strategy is to attack\n    # the largest group each time to minimize damage\n    # The optimal grouping is: one large group of size x, and (m-1) groups of size 1\n    # where x = n - (m-1)\n    \n    # But we need to handle case where x <= k\n    # If x <= k, enemy can kill the large group in one turn\n    # Then we have (m-1) groups of size 1 left\n    x = n - (m - 1)\n    \n    if x <= k:\n        # Enemy kills large group first, then picks off single gnomes\n        # Damage while large group exists: sum from n down to (m-1)+1\n        # Then damage from single gnomes: sum from (m-1) down to 1\n        damage1 = (n + (m-1)+1) * (n - (m-1)) // 2\n        damage2 = (m-1) * (m-1 + 1) // 2\n        total = damage1 + damage2\n        print(total)\n        return\n    \n    # Case where x > k\n    # Enemy reduces large group by k each turn until it's <= k\n    # Then kills it, then picks off single gnomes\n    \n    # Calculate how many full k-reductions we can do\n    # We need to reduce from x down to something <= k\n    # Let r = x % k\n    # If r == 0, we reduce to exactly k, then next turn kill it\n    # If r > 0, we reduce to r, then next turn kill it\n    \n    # Number of turns attacking the large group\n    if x % k == 0:\n        turns_large = x // k  # includes final turn that kills the group\n    else:\n        turns_large = x // k + 1  # +1 for final turn that kills remainder\n    \n    # Damage calculation\n    total = 0\n    current_gnomes = n\n    \n    # Phase 1: Enemy attacks large group repeatedly\n    for i in range(turns_large):\n        total += current_gnomes\n        if i == turns_large - 1:\n            # Last attack on large group kills it completely\n            current_gnomes -= x\n        else:\n            # Regular attack reduces large group by k\n            current_gnomes -= k\n    \n    # Phase 2: Enemy picks off single gnome groups\n    # We have (m-1) single gnomes left\n    for i in range(m-1):\n        total += current_gnomes\n        current_gnomes -= 1\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 77.5569863319397}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.20345878601074}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    restaurants = []\n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, -score, i))  # Store negative score for descending order\n        idx += 2\n    \n    # Sort by city (lexicographical) then by negative score (descending original score)\n    restaurants.sort(key=lambda x: (x[0], x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 296.2991044521332}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\nimport heapq\n\nsys.setrecursionlimit(10**6)\n\ndef bfs(grid, start, n, m, state_id):\n    \"\"\"BFS to find distances from state cells to all '.' cells\"\"\"\n    dist = [[float('inf')] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state_id:\n                dist[i][j] = 0\n                q.append((i, j))\n    \n    while q:\n        x, y = q.popleft()\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                new_dist = dist[x][y] + (1 if grid[nx][ny] == '.' else 0)\n                if new_dist < dist[nx][ny]:\n                    dist[nx][ny] = new_dist\n                    q.append((nx, ny))\n    return dist\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return -1\n    \n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Get distances from each state to all '.' cells\n    dist1 = bfs(grid, 0, n, m, '1')\n    dist2 = bfs(grid, 0, n, m, '2')\n    dist3 = bfs(grid, 0, n, m, '3')\n    \n    # Find minimum connection cost between each pair of states\n    # Direct connection between two states\n    min_12 = min_13 = min_23 = float('inf')\n    # Connection through a common '.' cell\n    min_through = float('inf')\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            \n            d1, d2, d3 = dist1[i][j], dist2[i][j], dist3[i][j]\n            \n            # Update direct connections\n            if grid[i][j] == '1' or grid[i][j] == '2':\n                min_12 = min(min_12, d1 + d2)\n            if grid[i][j] == '1' or grid[i][j] == '3':\n                min_13 = min(min_13, d1 + d3)\n            if grid[i][j] == '2' or grid[i][j] == '3':\n                min_23 = min(min_23, d2 + d3)\n            \n            # Update connection through common cell (only for '.' cells)\n            if grid[i][j] == '.':\n                min_through = min(min_through, d1 + d2 + d3)\n    \n    # Check if any state is unreachable\n    unreachable = False\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1' and dist1[i][j] == float('inf'):\n                unreachable = True\n            if grid[i][j] == '2' and dist2[i][j] == float('inf'):\n                unreachable = True\n            if grid[i][j] == '3' and dist3[i][j] == float('inf'):\n                unreachable = True\n    \n    if unreachable:\n        return -1\n    \n    # Calculate minimum overall connection\n    # Option 1: Connect all three directly through common cell\n    ans = min_through\n    \n    # Option 2: Connect two states directly, then connect third to one of them\n    ans = min(ans, min_12 + min_13)  # Connect 1-2, then 1-3\n    ans = min(ans, min_12 + min_23)  # Connect 1-2, then 2-3\n    ans = min(ans, min_13 + min_23)  # Connect 1-3, then 2-3\n    \n    # Option 3: Connect all three in a chain\n    ans = min(ans, min_12 + min_13 + min_23 - max(min_12, min_13, min_23))\n    \n    return ans if ans < float('inf') else -1\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "runtime_sec": 163.64500999450684}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Step 1: Check if graph is complete tripartite\n    # We'll try to 3-color the complement graph\n    # In complement graph, edges exist where original graph has no edge\n    # We need a 3-coloring where each color class is independent in original graph\n    # and between any two color classes, all edges exist in original graph\n    \n    # Build complement adjacency (for large n, we'll use degree check)\n    # Since n up to 1e5, we can't build full complement\n    # Instead, we'll use the property: for a vertex v, all vertices not in its adjacency must be in the same partition as v\n    # unless they are connected to v in original graph\n    \n    # Sort vertices by degree to find potential partition representatives\n    vertices = list(range(n))\n    vertices.sort(key=lambda x: len(adj[x]))\n    \n    # Pick vertex with smallest degree as candidate for partition 1\n    v0 = vertices[0]\n    \n    # Find all vertices not connected to v0\n    not_connected_to_v0 = set(range(n)) - set(adj[v0]) - {v0}\n    \n    # If v0 is connected to all other vertices, impossible\n    if len(not_connected_to_v0) == 0:\n        print(-1)\n        return\n    \n    # Pick one vertex from not_connected_to_v0 as candidate for partition 2\n    v1 = next(iter(not_connected_to_v0))\n    \n    # Find vertices not connected to v1\n    not_connected_to_v1 = set(range(n)) - set(adj[v1]) - {v1}\n    \n    # The intersection of not_connected_to_v0 and not_connected_to_v1 gives partition 3 candidates\n    possible_v2 = not_connected_to_v0.intersection(not_connected_to_v1) - {v0, v1}\n    \n    if len(possible_v2) == 0:\n        print(-1)\n        return\n    \n    v2 = next(iter(possible_v2))\n    \n    # Now we have three candidate representatives: v0, v1, v2\n    # Assign partitions:\n    # Partition 1: all vertices not connected to v0 (including v0 itself)\n    # Partition 2: all vertices not connected to v1 (including v1 itself)\n    # Partition 3: all vertices not connected to v2 (including v2 itself)\n    \n    # But we need to verify consistency\n    partition = [-1] * n\n    \n    # Assign based on connection to representatives\n    for i in range(n):\n        if i == v0:\n            partition[i] = 1\n        elif i == v1:\n            partition[i] = 2\n        elif i == v2:\n            partition[i] = 3\n        else:\n            # Check which partitions i is not connected to\n            not_conn = []\n            if i not in adj[v0] and v0 not in adj[i]:\n                not_conn.append(1)\n            if i not in adj[v1] and v1 not in adj[i]:\n                not_conn.append(2)\n            if i not in adj[v2] and v2 not in adj[i]:\n                not_conn.append(3)\n            \n            if len(not_conn) != 1:\n                print(-1)\n                return\n            partition[i] = not_conn[0]\n    \n    # Verify the partition satisfies all conditions\n    # Check each partition is non-empty\n    cnt = [0, 0, 0, 0]  # 1-indexed\n    for p in partition:\n        cnt[p] += 1\n    if cnt[1] == 0 or cnt[2] == 0 or cnt[3] == 0:\n        print(-1)\n        return\n    \n    # Check no edges within same partition\n    for u in range(n):\n        for v in adj[u]:\n            if u < v and partition[u] == partition[v]:\n                print(-1)\n                return\n    \n    # Check all edges between different partitions exist\n    # Build expected edges count between partitions\n    expected_edges = 0\n    for i in range(1, 4):\n        for j in range(i + 1, 4):\n            expected_edges += cnt[i] * cnt[j]\n    \n    # Count actual edges\n    actual_edges = m\n    \n    if actual_edges != expected_edges:\n        print(-1)\n        return\n    \n    print(' '.join(str(partition[i]) for i in range(n)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 88.40728497505188}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into those that increase rating and those that decrease\n    inc = []\n    dec = []\n    for a, b in projects:\n        if b >= 0:\n            inc.append((a, b))\n        else:\n            dec.append((a, b))\n    \n    # Sort increasing projects by required rating ascending\n    inc.sort(key=lambda x: x[0])\n    \n    # Sort decreasing projects by (required rating + change) descending\n    # Equivalent to sorting by (a + b) descending\n    dec.sort(key=lambda x: x[0] + x[1], reverse=True)\n    \n    # Process increasing projects first\n    for a, b in inc:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    # Process decreasing projects\n    for a, b in dec:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1848.258303642273}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.07913494110107}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track number of distinct difficulties currently in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add current problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 342.9616162776947}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    ans = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1530.0189821720123}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    edges = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx]); b = int(data[idx+1])\n        idx += 2\n        edges.append((a, b))\n    \n    # Count how many times each city appears as first endpoint\n    count = [0] * (n + 1)\n    for a, b in edges:\n        count[a] += 1\n    \n    # For each road, assign it to the city that appears less frequently\n    # as first endpoint, preferring the first city if equal\n    result = []\n    for a, b in edges:\n        if count[a] < count[b]:\n            result.append(f\"{a} {b}\")\n        elif count[a] > count[b]:\n            result.append(f\"{b} {a}\")\n        else:\n            # If equal, assign to the smaller city (or could be either)\n            result.append(f\"{a} {b}\")\n    \n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 59.94615626335144}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # Find positions of grasshopper and target\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Check if positions are in the same residue class modulo k\n    if (g_pos - t_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Determine direction and step\n    step = k if t_pos > g_pos else -k\n    \n    # Check all cells in the path\n    pos = g_pos\n    while pos != t_pos:\n        pos += step\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2656.391298532486}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(grid, visited, i, j, r, c, treat_cloud_as_land=False):\n    \"\"\"DFS to mark connected land cells (and optionally clouds as land)\"\"\"\n    if i < 0 or i >= r or j < 0 or j >= c:\n        return\n    if visited[i][j]:\n        return\n    if grid[i][j] == 'W':\n        return\n    if grid[i][j] == 'C' and not treat_cloud_as_land:\n        return\n    \n    visited[i][j] = True\n    dfs(grid, visited, i+1, j, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i-1, j, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i, j+1, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i, j-1, r, c, treat_cloud_as_land)\n\ndef count_islands(grid, r, c, treat_cloud_as_land=False):\n    \"\"\"Count islands in grid, optionally treating clouds as land\"\"\"\n    visited = [[False]*c for _ in range(r)]\n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if not visited[i][j]:\n                if grid[i][j] == 'L' or (treat_cloud_as_land and grid[i][j] == 'C'):\n                    dfs(grid, visited, i, j, r, c, treat_cloud_as_land)\n                    count += 1\n    return count\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    r, c = map(int, data[0].split())\n    grid = [list(row.strip()) for row in data[1:1+r]]\n    \n    # Count islands if we treat all clouds as water (minimum islands)\n    min_islands = count_islands(grid, r, c, treat_cloud_as_land=False)\n    \n    # Count islands if we treat all clouds as land (maximum islands)\n    max_islands = count_islands(grid, r, c, treat_cloud_as_land=True)\n    \n    # The minimum number of islands consistent with the image\n    # is the minimum between treating clouds as water or as land\n    # Actually, we need to consider that clouds could be either land or water\n    # So the minimum possible islands is when we treat clouds as water\n    # (since that doesn't create new islands)\n    print(min_islands)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 110.22767734527588}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.73613357543945}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_ways(n):\n    \"\"\"Count number of valid quadruples (a, k) where a > 0, k > 1, and a*k^3 <= n\"\"\"\n    ways = 0\n    # For each possible first thief amount a\n    max_a = int(n ** (1/4)) + 2  # Rough upper bound for a\n    for a in range(1, max_a + 1):\n        # For each possible multiplier k > 1\n        # We need a*k^3 <= n, so k <= (n/a)^(1/3)\n        max_k = int((n / a) ** (1/3)) + 2\n        for k in range(2, max_k + 1):\n            if a * (k ** 3) <= n:\n                ways += 1\n            else:\n                break\n    return ways\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    \n    # Binary search for smallest n with exactly m ways\n    low, high = 1, 10**18  # Upper bound large enough\n    answer = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        ways = count_ways(mid)\n        \n        if ways == m:\n            answer = mid\n            high = mid - 1  # Look for smaller n\n        elif ways < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 69.0751371383667}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite RGB pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We'll try all possible starting positions for the substring of length k\n        # For each starting position, we need to check alignment with the infinite RGB pattern\n        # There are 3 possible alignments (starting with 'R', 'G', or 'B')\n        min_changes = float('inf')\n        \n        # Precompute prefix sums for each alignment to answer queries in O(1) per position\n        # We'll create 3 arrays where arr[j][i] = number of mismatches for alignment j up to position i\n        prefix = [[0]*(n+1) for _ in range(3)]\n        \n        for align in range(3):\n            for i in range(n):\n                expected_char = pattern[(i + align) % 3]\n                mismatch = 1 if s[i] != expected_char else 0\n                prefix[align][i+1] = prefix[align][i] + mismatch\n        \n        # Now check all substrings of length k\n        for start in range(n - k + 1):\n            end = start + k\n            for align in range(3):\n                changes = prefix[align][end] - prefix[align][start]\n                min_changes = min(min_changes, changes)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 105.2161192893982}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    words = data[1:1+n]\n    start, end = words[0], words[1]\n    word_len = len(start)\n    \n    # Build set of existing words\n    word_set = set(words)\n    \n    # Helper to generate neighbors (one-letter changes)\n    def neighbors(word):\n        res = []\n        chars = list(word)\n        for i in range(word_len):\n            original = chars[i]\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if c == original:\n                    continue\n                chars[i] = c\n                new_word = ''.join(chars)\n                if new_word in word_set:\n                    res.append(new_word)\n            chars[i] = original\n        return res\n    \n    # BFS from start to end without any added word\n    def bfs(start_word, end_word, word_set):\n        if start_word == end_word:\n            return 0\n        q = deque([start_word])\n        dist = {start_word: 0}\n        while q:\n            cur = q.popleft()\n            for nb in neighbors(cur):\n                if nb not in dist:\n                    dist[nb] = dist[cur] + 1\n                    if nb == end_word:\n                        return dist[nb]\n                    q.append(nb)\n        return float('inf')  # unreachable\n    \n    original_steps = bfs(start, end, word_set)\n    \n    # If already reachable, we try to improve by adding one word\n    best_word = \"0\"\n    best_steps = original_steps\n    \n    # Generate all possible words of same length (26^L is huge, but L  8)\n    # Instead, consider words that are one-letter changes from existing words\n    # and not already in dictionary.\n    candidate_words = set()\n    for w in word_set:\n        chars = list(w)\n        for i in range(word_len):\n            original = chars[i]\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if c == original:\n                    continue\n                chars[i] = c\n                cand = ''.join(chars)\n                if cand not in word_set:\n                    candidate_words.add(cand)\n            chars[i] = original\n    \n    # Also consider words that are one-letter change from start or end\n    # (they might be direct bridges)\n    for w in [start, end]:\n        chars = list(w)\n        for i in range(word_len):\n            original = chars[i]\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if c == original:\n                    continue\n                chars[i] = c\n                cand = ''.join(chars)\n                if cand not in word_set:\n                    candidate_words.add(cand)\n            chars[i] = original\n    \n    # Evaluate each candidate\n    for cand in sorted(candidate_words):  # sorted for alphabetical tie-breaking\n        word_set.add(cand)\n        steps = bfs(start, end, word_set)\n        if steps < best_steps:\n            best_steps = steps\n            best_word = cand\n        word_set.remove(cand)\n        # Early stop if we found a direct connection (steps=1)\n        if best_steps == 1:\n            break\n    \n    # Output formatting\n    if best_word == \"0\":\n        if original_steps == float('inf'):\n            print(\"0\")\n            print(\"-1\")\n        else:\n            print(\"0\")\n            print(original_steps)\n    else:\n        print(best_word)\n        print(best_steps)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 81.9550347328186}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    # Track whether a sock is currently on the table\n    on_table = [False] * (n + 1)\n    current_on_table = 0\n    max_on_table = 0\n    \n    for sock in socks:\n        if not on_table[sock]:\n            # First sock of the pair: put on table\n            on_table[sock] = True\n            current_on_table += 1\n            max_on_table = max(max_on_table, current_on_table)\n        else:\n            # Second sock of the pair: remove from table\n            on_table[sock] = False\n            current_on_table -= 1\n    \n    print(max_on_table)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 421.5596842765808}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2 => R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 90.86927223205566}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef days_in_month(month):\n    \"\"\"Return number of days in given month (1-indexed).\"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    return days[month - 1]\n\ndef date_to_days(d, m):\n    \"\"\"Convert day and month to day number in year (1 to 365).\"\"\"\n    total = 0\n    for month in range(1, m):\n        total += days_in_month(month)\n    total += d\n    return total\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    # Parse observations\n    observations = []\n    for _ in range(N):\n        d1 = int(data[idx]); idx += 1\n        m1 = int(data[idx]); idx += 1\n        d2 = int(data[idx]); idx += 1\n        m2 = int(data[idx]); idx += 1\n        \n        start_day = date_to_days(d1, m1)\n        end_day = date_to_days(d2, m2)\n        \n        # Handle wrap-around across year boundary\n        if end_day < start_day:\n            end_day += 365\n        \n        duration = end_day - start_day + 1  # inclusive\n        \n        counts = []\n        for __ in range(M):\n            counts.append(int(data[idx])); idx += 1\n        \n        observations.append((duration, counts))\n    \n    # Brute force search for event durations\n    # Each duration is integer between 1 and 365\n    # Use backtracking with pruning\n    \n    result = [0] * M\n    \n    def backtrack(pos):\n        if pos == M:\n            # Check all observations\n            for dur, counts in observations:\n                total_events = 0\n                for i in range(M):\n                    total_events += counts[i] * result[i]\n                if total_events != dur:\n                    return False\n            return True\n        \n        # Try all possible durations for current event type\n        for d in range(1, 366):\n            result[pos] = d\n            # Early pruning: check if any observation is already impossible\n            valid = True\n            for dur, counts in observations:\n                # Calculate minimum possible total for remaining unknown durations\n                min_possible = 0\n                max_possible = 0\n                for i in range(M):\n                    if i < pos:\n                        min_possible += counts[i] * result[i]\n                        max_possible += counts[i] * result[i]\n                    elif i == pos:\n                        min_possible += counts[i] * d\n                        max_possible += counts[i] * d\n                    else:\n                        # Unknown future durations: min=1, max=365\n                        min_possible += counts[i] * 1\n                        max_possible += counts[i] * 365\n                \n                if min_possible > dur or max_possible < dur:\n                    valid = False\n                    break\n            \n            if valid and backtrack(pos + 1):\n                return True\n        \n        result[pos] = 0\n        return False\n    \n    if backtrack(0):\n        print(' '.join(map(str, result)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 77.0997166633606}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Step 1: Find connected components\n    visited = [False] * (n + 1)\n    components = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp = []\n            while stack:\n                node = stack.pop()\n                comp.append(node)\n                for nei in adj[node]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        stack.append(nei)\n            components.append(comp)\n    \n    # Step 2: For each component, find min and max node numbers\n    comp_info = []\n    for comp in components:\n        min_node = min(comp)\n        max_node = max(comp)\n        comp_info.append((min_node, max_node))\n    \n    # Step 3: Sort by min_node and process to find gaps\n    comp_info.sort()\n    \n    # Merge overlapping intervals\n    merged = []\n    for l, r in comp_info:\n        if not merged or merged[-1][1] < l:\n            merged.append([l, r])\n        else:\n            merged[-1][1] = max(merged[-1][1], r)\n    \n    # Step 4: Count gaps between merged intervals\n    answer = 0\n    for i in range(len(merged) - 1):\n        l1, r1 = merged[i]\n        l2, r2 = merged[i + 1]\n        # Nodes from r1+1 to l2-1 need to be connected\n        gap_start = r1 + 1\n        gap_end = l2 - 1\n        if gap_start <= gap_end:\n            answer += (gap_end - gap_start + 1)\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 70.56655263900757}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    max_count = 0\n    # For each possible value, check how many elements can be adjusted to it\n    for val in set(arr):\n        # Elements that can become val: val-1, val, val+1\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 137.56720566749573}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nxs, ys, ss, ri, rf = map(int, sys.stdin.readline().split())\nxa, ya, sa = map(int, sys.stdin.readline().split())\n\n# Distance from Anthony to zone center\ndist = math.hypot(xa - xs, ya - ys)\n\n# If Anthony starts inside the final zone, no damage\nif dist <= rf:\n    print(\"0.000000\")\n    sys.exit(0)\n\n# Time for zone to shrink from ri to rf\nshrink_time = (ri - rf) / ss if ss > 0 else 0\n\n# Function to compute distance from zone edge at time t\n# Zone radius at time t: r(t) = max(rf, ri - ss * t)\ndef zone_radius(t):\n    return max(rf, ri - ss * t)\n\n# Distance Anthony can run in time t: sa * t\ndef anthony_distance(t):\n    return sa * t\n\n# Check if Anthony can reach the zone edge by time t\n# He reaches if his running distance >= distance to edge at time t\ndef can_reach(t):\n    r = zone_radius(t)\n    # Distance from Anthony to edge at time t\n    edge_dist = max(0, dist - r)\n    return anthony_distance(t) >= edge_dist\n\n# Binary search for minimum time to reach edge\nlo, hi = 0.0, shrink_time + (dist - rf) / sa  # Upper bound: time to run to final edge\nfor _ in range(100):  # Sufficient precision for 1e-6\n    mid = (lo + hi) / 2\n    if can_reach(mid):\n        hi = mid\n    else:\n        lo = mid\n\nreach_time = hi\n\n# If Anthony can reach before zone stops shrinking\nif reach_time <= shrink_time:\n    # Damage = time spent outside before reaching\n    damage = reach_time\nelse:\n    # Zone stops shrinking at shrink_time\n    # Check if Anthony can reach final zone\n    final_edge_dist = max(0, dist - rf)\n    time_to_final = final_edge_dist / sa\n    \n    if time_to_final <= shrink_time:\n        # He reaches while zone is still shrinking\n        damage = time_to_final\n    else:\n        # He reaches after zone stopped shrinking\n        # He takes damage during shrink_time, plus extra while running to final zone\n        damage = shrink_time + (time_to_final - shrink_time)\n\nprint(f\"{damage:.6f}\")", "runtime_sec": 111.35764932632446}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 135.34396839141846}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        lcm_val = lcm_val // math.gcd(lcm_val, t) * t\n        if lcm_val > 10**18:\n            # Early exit if LCM exceeds the maximum possible answer\n            break\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 705.180059671402}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.37816858291626}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [int(next(it)) for _ in range(q)]\n    \n    # Precompute all possible sums using at most k bills of at most 2 denominations\n    # We'll store for each sum the minimum number of bills\n    max_sum = max(queries)\n    INF = 10**9\n    dp = [INF] * (max_sum + 1)\n    dp[0] = 0\n    \n    # Try all pairs of denominations (including single denomination)\n    for i in range(n):\n        d1 = a[i]\n        # Single denomination case\n        for cnt1 in range(1, k + 1):\n            s = d1 * cnt1\n            if s > max_sum:\n                break\n            dp[s] = min(dp[s], cnt1)\n        # Two denominations case\n        for j in range(i + 1, n):\n            d2 = a[j]\n            for cnt1 in range(k + 1):\n                if cnt1 > 0 and d1 * cnt1 > max_sum:\n                    break\n                for cnt2 in range(k + 1 - cnt1):\n                    if cnt2 == 0:\n                        continue\n                    s = d1 * cnt1 + d2 * cnt2\n                    if s > max_sum:\n                        break\n                    dp[s] = min(dp[s], cnt1 + cnt2)\n    \n    # Answer queries\n    out_lines = []\n    for x in queries:\n        if x <= max_sum and dp[x] != INF:\n            out_lines.append(str(dp[x]))\n        else:\n            out_lines.append(\"-1\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1939.0409843921661}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Pair boxes with remainder r and remainder (k-r) mod k\n    # Special cases: remainder 0 and remainder k/2 when k is even\n    ans = 0\n    \n    # Pair remainder 0 with itself\n    ans += (rem_count[0] // 2) * 2\n    \n    # If k is even, pair remainder k/2 with itself\n    if k % 2 == 0:\n        ans += (rem_count[k // 2] // 2) * 2\n    \n    # Pair remainder i with remainder k-i for i from 1 to (k-1)//2\n    for i in range(1, (k + 1) // 2):\n        j = k - i\n        if i != j:  # This is always true when k is odd, and for i < k/2 when k is even\n            pairs = min(rem_count[i], rem_count[j])\n            ans += pairs * 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 306.31925988197327}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    k, d, t = map(int, data)\n    \n    # If k is multiple of d, stove always on\n    if k % d == 0:\n        print(float(t))\n        return\n    \n    # Calculate cycle parameters\n    # One cycle: stove on for k minutes, then off until next multiple of d\n    off_time = (d - (k % d)) % d\n    if off_time == 0:\n        off_time = d\n    \n    cycle_time = k + off_time\n    \n    # Cooking progress per cycle\n    # When on: 1/t per minute, when off: 1/(2t) per minute\n    progress_per_cycle = k / t + off_time / (2 * t)\n    \n    # Number of full cycles needed\n    full_cycles = math.floor(1.0 / progress_per_cycle)\n    remaining_progress = 1.0 - full_cycles * progress_per_cycle\n    \n    # Time for full cycles\n    total_time = full_cycles * cycle_time\n    \n    # Handle remaining progress\n    if remaining_progress > 0:\n        # First try to use on time\n        on_needed = remaining_progress * t\n        if on_needed <= k:\n            total_time += on_needed\n        else:\n            # Use all on time, then some off time\n            total_time += k\n            remaining_progress -= k / t\n            # Remaining progress uses off time\n            off_needed = remaining_progress * (2 * t)\n            total_time += off_needed\n    \n    # Print with sufficient precision\n    print(f\"{total_time:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 63.43309688568115}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Build adjacency list for the directed graph of important pairs\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n    \n    # Kosaraju's algorithm for strongly connected components (SCC)\n    visited = [False] * (n + 1)\n    order = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Build reversed graph\n    rev_adj = [[] for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n    \n    comp = [0] * (n + 1)\n    comp_id = 0\n    \n    def dfs2(u, cid):\n        comp[u] = cid\n        for v in rev_adj[u]:\n            if comp[v] == 0:\n                dfs2(v, cid)\n    \n    for u in reversed(order):\n        if comp[u] == 0:\n            comp_id += 1\n            dfs2(u, comp_id)\n    \n    # Count SCCs with indegree 0 (excluding dummy SCC 0)\n    indeg = [0] * (comp_id + 1)\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if comp[u] != comp[v]:\n                indeg[comp[v]] += 1\n    \n    zero_indeg_count = sum(1 for i in range(1, comp_id + 1) if indeg[i] == 0)\n    \n    # Minimum edges needed = max(1, zero_indeg_count) if comp_id > 1, else 0\n    if comp_id == 1:\n        print(0)\n    else:\n        print(max(1, zero_indeg_count))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 68.11581206321716}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    a = s\n    i = 1\n    while True:\n        if a in seen:\n            print(i)\n            return\n        seen[a] = i\n        a = f(a)\n        i += 1\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 498.84625244140625}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.10693025588989}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find first ':' after first '['\n    first_colon = -1\n    for i in range(first_open + 1, n):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ']'\n    last_close = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1 or last_close <= first_colon:\n        print(-1)\n        return\n    \n    # Find last ':' before last ']'\n    last_colon = -1\n    for i in range(last_close - 1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon + 1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2836.3137674331665}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        skills = list(map(int, input_data[idx:idx+n]))\n        idx += n\n        \n        # Count frequency of each skill\n        freq = collections.Counter(skills)\n        \n        # Get maximum frequency of any skill\n        max_freq = max(freq.values()) if freq else 0\n        \n        # Count number of distinct skills\n        distinct_count = len(freq)\n        \n        # The answer is min(max_freq, distinct_count) with adjustment\n        # If max_freq == distinct_count, we need to reduce by 1 because\n        # we need one skill for the second team that's not in the first team\n        if max_freq > distinct_count:\n            ans = distinct_count\n        elif max_freq == distinct_count:\n            ans = distinct_count - 1\n        else:\n            ans = max_freq\n        \n        # Ensure answer is non-negative\n        ans = max(0, ans)\n        results.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 143.51329946517944}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the greatest common divisor of all numbers\n    g = arr[0]\n    for num in arr[1:]:\n        while num > 0:\n            g, num = num, g % num\n    \n    # For each number, divide by gcd and check if it's only composed of factors 2 and 3\n    for num in arr:\n        x = num // g\n        # Remove all factors of 2\n        while x % 2 == 0:\n            x //= 2\n        # Remove all factors of 3\n        while x % 3 == 0:\n            x //= 3\n        # If anything remains other than 1, it's not possible\n        if x != 1:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1357.315957069397}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_float():\n    return float(sys.stdin.readline().strip())\n\ndef calculate_tax(income, bands, s, p, P):\n    \"\"\"Calculate tax for given income based on tax bands.\"\"\"\n    tax = 0.0\n    remaining = income\n    \n    # Apply each tax band\n    for i in range(bands):\n        band_size = s[i]\n        band_rate = p[i] / 100.0\n        \n        if remaining <= 0:\n            break\n            \n        if remaining <= band_size:\n            tax += remaining * band_rate\n            remaining = 0\n        else:\n            tax += band_size * band_rate\n            remaining -= band_size\n    \n    # Apply final percentage to remaining income\n    if remaining > 0:\n        tax += remaining * (P / 100.0)\n    \n    return tax\n\ndef find_pre_tax_amount(target_after_tax, earned, bands, s, p, P):\n    \"\"\"Find pre-tax amount needed to get target after-tax amount.\"\"\"\n    # Binary search for the correct pre-tax amount\n    low = 0.0\n    high = 1e12  # Upper bound large enough\n    \n    for _ in range(100):  # 100 iterations for high precision\n        mid = (low + high) / 2.0\n        total_income = earned + mid\n        tax = calculate_tax(total_income, bands, s, p, P)\n        after_tax = total_income - tax\n        \n        if after_tax >= target_after_tax:\n            high = mid\n        else:\n            low = mid\n    \n    return (low + high) / 2.0\n\ndef main():\n    # Read number of tax bands\n    B = int(sys.stdin.readline().strip())\n    \n    # Read tax bands\n    s = []\n    p = []\n    for _ in range(B):\n        line = sys.stdin.readline().strip().split()\n        s.append(float(line[0]))\n        p.append(float(line[1]))\n    \n    # Read final percentage\n    P = read_float()\n    \n    # Read number of friends\n    F = int(sys.stdin.readline().strip())\n    \n    results = []\n    for _ in range(F):\n        line = sys.stdin.readline().strip().split()\n        earned = float(line[0])\n        target_after_tax = float(line[1])\n        \n        # Find how much George needs to give\n        gift = find_pre_tax_amount(target_after_tax, earned, B, s, p, P)\n        results.append(f\"{gift:.6f}\")\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 70.63799858093262}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        edges.append((x, y, w))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(n, adj, i)\n    \n    # Compute base total cost without any zero road\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # For each route, new cost is min(original, using zero road)\n        # Using zero road: dist[a][x] + 0 + dist[y][b] or dist[a][y] + 0 + dist[x][b]\n        new_total = 0\n        for a, b in routes:\n            original = dists[a][b]\n            via_zero = min(dists[a][x] + dists[y][b], dists[a][y] + dists[x][b])\n            new_total += min(original, via_zero)\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 112.07814931869507}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(200000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    rx, ry = find(x, parent), find(y, parent)\n    if rx == ry:\n        return\n    if size[rx] < size[ry]:\n        rx, ry = ry, rx\n    parent[ry] = rx\n    size[rx] += size[ry]\n\ndef bfs(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    q = [start]\n    dist[start] = 0\n    farthest = start\n    for u in q:\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n                if dist[v] > dist[farthest]:\n                    farthest = v\n    return farthest, dist\n\ndef tree_diameter(adj, comp_nodes):\n    if not comp_nodes:\n        return 0\n    start = next(iter(comp_nodes))\n    far1, _ = bfs(start, adj)\n    far2, dist = bfs(far1, adj)\n    return dist[far2]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    c = int(next(it))\n    l = int(next(it))\n    adj = [[] for _ in range(c)]\n    parent = list(range(c))\n    size = [1] * c\n    for _ in range(l):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        adj[b].append(a)\n        union(a, b, parent, size)\n    comps = {}\n    for i in range(c):\n        root = find(i, parent)\n        if root not in comps:\n            comps[root] = []\n        comps[root].append(i)\n    diameters = []\n    for nodes in comps.values():\n        diameters.append(tree_diameter(adj, nodes))\n    diameters.sort(reverse=True)\n    if len(diameters) == 1:\n        print(diameters[0])\n        return\n    max_d = diameters[0]\n    second_d = diameters[1]\n    result = max(max_d, (max_d + 1) // 2 + (second_d + 1) // 2 + 1)\n    for i in range(2, len(diameters)):\n        result = max(result, (result + 1) // 2 + (diameters[i] + 1) // 2 + 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 112.92918014526367}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count total wins for each player\n    total_wins = [0, 0, 0]\n    for x in a:\n        total_wins[x] += 1\n    \n    results = []\n    \n    # Try all possible t values (points needed to win a set)\n    # t must be at least 1 and at most max(total_wins[1], total_wins[2])\n    max_t = max(total_wins[1], total_wins[2])\n    \n    for t in range(1, max_t + 1):\n        # Simulate the match with this t\n        sets_won = [0, 0, 0]\n        points = [0, 0, 0]\n        last_set_winner = 0\n        valid = True\n        \n        for x in a:\n            points[x] += 1\n            \n            # Check if current set is over\n            if points[1] == t or points[2] == t:\n                winner = 1 if points[1] == t else 2\n                sets_won[winner] += 1\n                last_set_winner = winner\n                points[1] = points[2] = 0\n                \n                # Check if match is over\n                if sets_won[1] == sets_won[2]:\n                    # Both have same number of sets, match can't be over yet\n                    continue\n                \n                # Match is over if one player has more sets than the other\n                # and we've processed all serves\n                # We'll check this after processing all serves\n        \n        # After processing all serves\n        # Check if match ended exactly at the last serve\n        if points[1] > 0 or points[2] > 0:\n            # There's an incomplete set at the end\n            valid = False\n        \n        if valid:\n            # Check if match ended properly\n            if sets_won[1] != sets_won[2]:\n                s = max(sets_won[1], sets_won[2])\n                # Verify that the winner won exactly s sets\n                if (sets_won[1] == s and sets_won[2] < s) or (sets_won[2] == s and sets_won[1] < s):\n                    # Also verify that the match ended at the right time\n                    # The last set should be won by the overall winner\n                    winner = 1 if sets_won[1] > sets_won[2] else 2\n                    if last_set_winner == winner:\n                        results.append((s, t))\n    \n    # Sort results\n    results.sort(key=lambda x: (x[0], x[1]))\n    \n    # Output\n    print(len(results))\n    for s, t in results:\n        print(f\"{s} {t}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 520.5688765048981}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B, C, D, E, F = map(int, sys.stdin.read().split())\n    max_water = F // 100 * 100\n    water_ops = [100 * A, 100 * B]\n    sugar_ops = [C, D]\n    \n    # DP for possible water amounts\n    water_possible = [False] * (max_water + 1)\n    water_possible[0] = True\n    for w in water_ops:\n        for i in range(w, max_water + 1):\n            if water_possible[i - w]:\n                water_possible[i] = True\n    \n    # DP for possible sugar amounts\n    max_sugar = F\n    sugar_possible = [False] * (max_sugar + 1)\n    sugar_possible[0] = True\n    for s in sugar_ops:\n        for i in range(s, max_sugar + 1):\n            if sugar_possible[i - s]:\n                sugar_possible[i] = True\n    \n    best_total, best_sugar = 100 * A, 0  # Start with minimal water\n    best_density = -1.0\n    \n    for water in range(100, max_water + 1, 100):\n        if not water_possible[water]:\n            continue\n        max_dissolved = min(water // 100 * E, F - water)\n        for sugar in range(max_dissolved, -1, -1):\n            if sugar_possible[sugar] and water + sugar <= F:\n                if water + sugar == 0:\n                    continue\n                density = 100 * sugar / (water + sugar)\n                if density > best_density:\n                    best_density = density\n                    best_total = water + sugar\n                    best_sugar = sugar\n                break  # Found max sugar for this water amount\n    \n    print(best_total, best_sugar)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 145.65248370170593}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0, []\n    p = int(data[0])\n    digits = list(map(int, data[1:1 + p]))\n    return p, digits\n\ndef find_triple_correlation(p, digits):\n    min_threshold = (p + 39) // 40 + 1  # ceil(p/40) + 1\n    best = None  # (a, n, b, m, c, first_occurrence)\n    \n    # Try all possible a, b, c from 0 to 9\n    for a in range(10):\n        for b in range(10):\n            for c in range(10):\n                # Try all possible n, m where positions are valid\n                for n in range(1, p):  # n >= 1\n                    for m in range(1, p):  # m >= 1\n                        # Check if correlation occurs enough times\n                        count = 0\n                        first_occurrence = None\n                        \n                        # Check condition 1: a followed n later by b implies c m after b\n                        valid = True\n                        for i in range(p - (n + m)):\n                            if digits[i] == a and digits[i + n] == b:\n                                # b must not be within m-1 of end for implication\n                                if i + n + m < p:\n                                    if digits[i + n + m] != c:\n                                        valid = False\n                                        break\n                                # Count occurrence if all positions exist\n                                if i + n + m < p:\n                                    if first_occurrence is None:\n                                        first_occurrence = i\n                                    count += 1\n                        if not valid:\n                            continue\n                        \n                        # Check condition 2: b followed m later by c implies a n before b\n                        for i in range(n, p - m):\n                            if digits[i] == b and digits[i + m] == c:\n                                # b must not be within n-1 of beginning\n                                if i - n >= 0:\n                                    if digits[i - n] != a:\n                                        valid = False\n                                        break\n                        if not valid:\n                            continue\n                        \n                        # Check condition 3: a followed n+m later by c implies b n after a\n                        for i in range(p - (n + m)):\n                            if digits[i] == a and digits[i + n + m] == c:\n                                if digits[i + n] != b:\n                                    valid = False\n                                    break\n                        if not valid:\n                            continue\n                        \n                        # Check minimum occurrence threshold\n                        if count >= min_threshold:\n                            # Update best according to tie-breaking rules\n                            if best is None:\n                                best = (a, n, b, m, c, first_occurrence)\n                            else:\n                                # Compare first occurrence\n                                if first_occurrence < best[5]:\n                                    best = (a, n, b, m, c, first_occurrence)\n                                elif first_occurrence == best[5]:\n                                    # Compare n\n                                    if n < best[1]:\n                                        best = (a, n, b, m, c, first_occurrence)\n                                    elif n == best[1]:\n                                        # Compare m\n                                        if m < best[3]:\n                                            best = (a, n, b, m, c, first_occurrence)\n    \n    return best\n\ndef main():\n    p, digits = read_input()\n    if p == 0:\n        print(\"random sequence\")\n        return\n    \n    result = find_triple_correlation(p, digits)\n    if result is None:\n        print(\"random sequence\")\n    else:\n        a, n, b, m, c, _ = result\n        print(f\"triple correlation {a}({n}){b}({m}){c} found\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 79.4746503829956}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef max_beauty(n, k, s):\n    def max_len_for_char(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_len_for_char('a'), max_len_for_char('b'))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    \n    result = max_beauty(n, k, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 2042.4065210819244}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import Counter\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    nums = list(map(int, data[1:1 + n * n]))\n    \n    # Count frequencies\n    freq = Counter(nums)\n    \n    # Determine positions based on symmetry\n    # For n x n matrix, positions are grouped by symmetry:\n    # - Center (if n odd): 1 position\n    # - Middle row/col (if n odd): (n-1) positions each, but they pair with themselves when reversed\n    # - Regular positions: 4 symmetric positions each\n    \n    # Calculate required counts for each symmetry group\n    center_count = 1 if n % 2 == 1 else 0\n    middle_count = (n - 1) if n % 2 == 1 else 0  # Actually need to handle row and column middle separately\n    \n    # Better approach: categorize positions by how many symmetric positions they have\n    # For position (i, j) with 0-indexed:\n    # It has symmetric positions: (i, n-1-j), (n-1-i, j), (n-1-i, n-1-j)\n    # Some positions coincide, reducing the group size\n    \n    # We'll build required counts for each group size\n    groups = Counter()\n    for i in range(n):\n        for j in range(n):\n            # Count distinct symmetric positions\n            sym_positions = {(i, j), (i, n-1-j), (n-1-i, j), (n-1-i, n-1-j)}\n            groups[len(sym_positions)] += 1\n    # Each group of size k requires k identical numbers\n    # But groups counts the number of positions, so divide by k to get number of groups\n    required = {}\n    for k, cnt in groups.items():\n        if cnt % k != 0:\n            print(\"NO\")\n            return\n        required[k] = cnt // k\n    \n    # Now check if we have enough numbers with appropriate frequencies\n    # We need to assign numbers to groups\n    # Sort numbers by frequency\n    freq_items = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Try to assign: larger groups first\n    group_assignments = {}\n    remaining_required = required.copy()\n    \n    for num, count in freq_items:\n        # Try to assign to largest possible group\n        assigned = False\n        for k in sorted(remaining_required.keys(), reverse=True):\n            if count >= k and remaining_required[k] > 0:\n                # Assign this number to a group of size k\n                if k not in group_assignments:\n                    group_assignments[k] = []\n                group_assignments[k].append(num)\n                remaining_required[k] -= 1\n                freq[num] -= k\n                assigned = True\n                break\n        if not assigned:\n            # If can't assign to any group, check if it's leftover from previous assignments\n            if count > 0:\n                print(\"NO\")\n                return\n    \n    # Check if all requirements satisfied\n    if any(v > 0 for v in remaining_required.values()):\n        print(\"NO\")\n        return\n    \n    # Construct matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Prepare numbers for each group type\n    group_numbers = {}\n    for k, nums_list in group_assignments.items():\n        group_numbers[k] = nums_list.copy()\n    \n    # Fill matrix\n    used = set()\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] != 0:\n                continue\n            sym_positions = [(i, j), (i, n-1-j), (n-1-i, j), (n-1-i, n-1-j)]\n            unique_positions = []\n            for pos in sym_positions:\n                if pos not in used:\n                    unique_positions.append(pos)\n                    used.add(pos)\n            k = len(unique_positions)\n            # Get a number for this group\n            if not group_numbers[k]:\n                print(\"NO\")\n                return\n            num = group_numbers[k].pop()\n            for x, y in unique_positions:\n                matrix[x][y] = num\n    \n    print(\"YES\")\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 85.2334372997284}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.47080874443054}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees clockwise in nm matrix.\"\"\"\n    return y, n - x + 1, m, n\n\ndef rotate_90_counterclockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees counterclockwise in nm matrix.\"\"\"\n    return m - y + 1, x, m, n\n\ndef horizontal_flip(x, y, n, m):\n    \"\"\"Flip point horizontally (mirror across vertical axis).\"\"\"\n    return x, m - y + 1, n, m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = identity\n    x %= 4\n    z %= 4\n    # Horizontal flip is its own inverse, so y % 2\n    y %= 2\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        cur_n, cur_m = n, m\n        \n        # Apply x clockwise rotations\n        for _ in range(x):\n            xi, yi, cur_n, cur_m = rotate_90_clockwise(xi, yi, cur_n, cur_m)\n        \n        # Apply y horizontal flips\n        for _ in range(y):\n            xi, yi, cur_n, cur_m = horizontal_flip(xi, yi, cur_n, cur_m)\n        \n        # Apply z counterclockwise rotations\n        for _ in range(z):\n            xi, yi, cur_n, cur_m = rotate_90_counterclockwise(xi, yi, cur_n, cur_m)\n        \n        results.append(f\"{xi} {yi}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 70.49160623550415}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    # Each character has N possibilities, and there are 3 characters\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 374.098427772522}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L1 = int(data[0])\n    L2 = int(data[1])\n    N = int(data[2])\n    tubes = list(map(int, data[3:3+N]))\n    \n    # Step 1: Generate all possible sums of two tubes\n    two_sums = []\n    for i in range(N):\n        for j in range(i+1, N):\n            s = tubes[i] + tubes[j]\n            two_sums.append(s)\n    two_sums.sort()\n    \n    # Step 2: For each L, find the maximum sum  L\n    def max_sum_up_to(limit, sums_list):\n        # Binary search for the largest sum  limit\n        lo, hi = 0, len(sums_list)-1\n        best = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if sums_list[mid] <= limit:\n                best = sums_list[mid]\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return best\n    \n    best1 = max_sum_up_to(L1, two_sums)\n    best2 = max_sum_up_to(L2, two_sums)\n    \n    if best1 == -1 or best2 == -1:\n        print(\"Impossible\")\n    else:\n        print(best1 + best2)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 62.018579721450806}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' at the beginning and consecutive '>' at the end\n        left_count = 0\n        while left_count < n and s[left_count] == '<':\n            left_count += 1\n        right_count = 0\n        while right_count < n and s[n - 1 - right_count] == '>':\n            right_count += 1\n        # Minimum deletions needed is the smaller of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 181.73245310783386}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X) / 2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    # Check if Y - 2X is divisible by 2 and non-negative\n    if (Y - 2 * X) % 2 != 0:\n        print(\"No\")\n        return\n    \n    t = (Y - 2 * X) // 2\n    c = X - t\n    \n    if c >= 0 and t >= 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 626.0707657337189}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if any row or column is completely evil\n    for i in range(n):\n        if all(grid[i][j] == 'E' for j in range(n)):\n            # Check if there's any column without all 'E'\n            found = False\n            for j in range(n):\n                if any(grid[k][j] == '.' for k in range(n)):\n                    found = True\n                    break\n            if not found:\n                print(-1)\n                return\n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            # Check if there's any row without all 'E'\n            found = False\n            for i in range(n):\n                if any(grid[i][k] == '.' for k in range(n)):\n                    found = True\n                    break\n            if not found:\n                print(-1)\n                return\n    \n    # Try to find n spells by selecting one from each row\n    spells = []\n    for i in range(n):\n        found = False\n        for j in range(n):\n            if grid[i][j] == '.':\n                spells.append((i+1, j+1))\n                found = True\n                break\n        if not found:\n            # If no '.' in this row, try columns approach\n            spells = []\n            for j in range(n):\n                found = False\n                for i in range(n):\n                    if grid[i][j] == '.':\n                        spells.append((i+1, j+1))\n                        found = True\n                        break\n                if not found:\n                    print(-1)\n                    return\n            break\n    \n    # Output spells\n    for r, c in spells:\n        print(f\"{r} {c}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 960.4850611686707}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Read inputs\n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute all possible fret positions across all strings\n    positions = []\n    for note in b:\n        note_positions = []\n        for string_val in a:\n            fret = note - string_val\n            if fret >= 1:  # fret numbers start from 1\n                note_positions.append(fret)\n        positions.append(note_positions)\n    \n    # We need to pick one position per note to minimize max-min difference\n    # This is a classic sliding window problem on sorted positions\n    \n    # Flatten with note index for tracking\n    flat = []\n    for i, pos_list in enumerate(positions):\n        for p in pos_list:\n            flat.append((p, i))  # (fret, note_index)\n    \n    # Sort by fret value\n    flat.sort(key=lambda x: x[0])\n    \n    # Sliding window to cover all notes\n    m = len(flat)\n    note_count = [0] * n\n    covered = 0\n    left = 0\n    ans = float('inf')\n    \n    for right in range(m):\n        fret_val, note_idx = flat[right]\n        if note_count[note_idx] == 0:\n            covered += 1\n        note_count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while covered == n and left <= right:\n            # Update answer\n            min_fret = flat[left][0]\n            max_fret = flat[right][0]\n            ans = min(ans, max_fret - min_fret)\n            \n            # Move left pointer\n            left_fret, left_note_idx = flat[left]\n            note_count[left_note_idx] -= 1\n            if note_count[left_note_idx] == 0:\n                covered -= 1\n            left += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 311.9092071056366}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nR = int(sys.stdin.readline().strip())\n\n# Calculate circumference: C = 2 *  * R\ncircumference = 2 * math.pi * R\n\n# Print with sufficient precision\nprint(circumference)", "runtime_sec": 49.98764371871948}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = [0] * (n + 1)  # 1-indexed parent array\n    for i in range(2, n + 1):\n        p[i] = int(data[i - 1])\n    \n    # Step 1: Compute depth of each node\n    depth = [0] * (n + 1)\n    for i in range(2, n + 1):\n        depth[i] = depth[p[i]] + 1\n    \n    # Step 2: Count nodes at each depth\n    max_depth = max(depth)\n    cnt = [0] * (max_depth + 1)\n    for i in range(1, n + 1):\n        cnt[depth[i]] += 1\n    \n    # Step 3: Compute answer\n    ans = 0\n    for d in range(max_depth + 1):\n        ans += cnt[d] % 2  # only odd counts contribute\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2050.5134415626526}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    \"\"\"\n    Count the number of ships Vasya can make using the process:\n    - Start with rectangle a x b (a > b)\n    - Cut off a square of size b x b, count 1 ship\n    - Remainder is (a-b) x b\n    - Repeat until remainder is square (a == b)\n    \n    This is equivalent to counting how many times we can subtract b from a\n    until a becomes less than b, then swapping and continuing.\n    \"\"\"\n    ships = 0\n    while b > 0:\n        # How many full squares of size b x b can we cut from a x b?\n        ships += a // b\n        # Update a, b for the remainder\n        a, b = b, a % b\n    return ships\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    a, b = map(int, data[:2])\n    result = count_ships(a, b)\n    print(result)", "runtime_sec": 1883.8788006305695}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # If N is even, answer is N (since N is divisible by 2 and N)\n    # If N is odd, answer is 2*N (since 2*N is divisible by 2 and N)\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 499.04213070869446}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.41850280761719}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 93.17562627792358}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 92.04817247390747}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.12051272392273}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 90.59577560424805}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    x = [int(next(it)) for _ in range(n)]\n    v = [int(next(it)) for _ in range(n)]\n    \n    # Pair points by (v, x) and sort\n    points = list(zip(v, x))\n    points.sort()\n    \n    # Extract sorted x values after sorting by v\n    sorted_x = [p[1] for p in points]\n    \n    # Fenwick tree for prefix sums and count\n    class Fenwick:\n        def __init__(self, n):\n            self.n = n\n            self.bit_sum = [0] * (n + 1)\n            self.bit_cnt = [0] * (n + 1)\n        \n        def update(self, idx, val):\n            i = idx + 1\n            while i <= self.n:\n                self.bit_sum[i] += val\n                self.bit_cnt[i] += 1\n                i += i & -i\n        \n        def query(self, idx):\n            # Returns (sum, count) for indices <= idx\n            s = 0\n            c = 0\n            i = idx + 1\n            while i > 0:\n                s += self.bit_sum[i]\n                c += self.bit_cnt[i]\n                i -= i & -i\n            return s, c\n    \n    # Coordinate compression for x values\n    comp = {val: i for i, val in enumerate(sorted(sorted_x))}\n    \n    fen = Fenwick(n)\n    total = 0\n    \n    # Process points in increasing v order\n    for i in range(n):\n        cur_x = sorted_x[i]\n        idx = comp[cur_x]\n        \n        # Query for points with smaller x (already inserted)\n        sum_left, cnt_left = fen.query(idx - 1)\n        total += cnt_left * cur_x - sum_left\n        \n        fen.update(idx, cur_x)\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 155.37024235725403}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.41894555091858}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # For n >= 2, we need to make n-1 moves between houses\n    # We always start at Rabbit's house (R)\n    # The optimal strategy is to alternate between the two shortest edges\n    # from the current house, but we can think of it as:\n    # For the first move from R, choose min(a, b)\n    # Then for subsequent moves, we can always choose the minimum edge\n    # from the current house to one of the other two houses\n    \n    # However, a simpler approach: after the first meal at R,\n    # we need n-1 more meals. We can think of making n-1 moves.\n    # The minimum total distance is:\n    # min(a, b) + (n-2) * min(a, b, c)\n    # But this doesn't always work because the first move might\n    # determine which house we're at for subsequent moves.\n    \n    # Actually, we can model it as:\n    # Start at R, need n-1 moves to visit other houses for meals.\n    # The optimal path will be to take the minimum edge from R first,\n    # then repeatedly take the minimum available edge from current house.\n    # This is equivalent to:\n    # If n == 1: 0\n    # If n == 2: min(a, b)\n    # If n >= 3: min(a, b) + (n-2) * min(a, b, c)\n    \n    # But wait, what if the minimum from R is a, but then from O\n    # the minimum is c, but b might be smaller than c?\n    # Actually from O, the available edges are a and c (back to R or to E)\n    # So we need to consider the graph properly.\n    \n    # Let's think dynamically:\n    # We have three houses: R (0), O (1), E (2)\n    # Distances: R-O = a, R-E = b, O-E = c\n    # Start at R (0)\n    # We need to make n-1 moves to other houses\n    # Each move goes to a different house than current\n    \n    # We can use DP: dp[i][pos] = min distance after i meals, ending at pos\n    # But n <= 100, so O(n*3) is fine\n    \n    INF = 10**9\n    dp = [[INF, INF, INF] for _ in range(n)]\n    dp[0][0] = 0  # First meal at R, distance 0\n    \n    # Transitions: from pos to next_pos (different from pos)\n    for i in range(n-1):\n        for pos in range(3):\n            if dp[i][pos] == INF:\n                continue\n            # Try moving to each other house\n            for next_pos in range(3):\n                if next_pos == pos:\n                    continue\n                # Get distance between pos and next_pos\n                if (pos == 0 and next_pos == 1) or (pos == 1 and next_pos == 0):\n                    dist = a\n                elif (pos == 0 and next_pos == 2) or (pos == 2 and next_pos == 0):\n                    dist = b\n                else:  # (1,2) or (2,1)\n                    dist = c\n                dp[i+1][next_pos] = min(dp[i+1][next_pos], dp[i][pos] + dist)\n    \n    # After n meals (n-1 moves), we can end anywhere\n    result = min(dp[n-1])\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1983.7023751735687}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    bosses = [0] * (n + 1)  # 1-indexed\n    for i in range(2, n + 1):\n        boss = int(input[i - 1])  # A_i for member i\n        bosses[i] = boss\n    \n    subordinates = [0] * (n + 1)  # 1-indexed\n    for member in range(2, n + 1):\n        boss = bosses[member]\n        subordinates[boss] += 1\n    \n    # Output results for members 1 through n\n    for member in range(1, n + 1):\n        print(subordinates[member])\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 140.94889998435974}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # Duplicate array to handle circular wrap-around\n    A_ext = A + A\n    \n    # Function to check if we can achieve at least K sections with AND >= target\n    def can_achieve(target):\n        if target == 0:\n            return True  # Always possible with any division\n        \n        # Try each possible starting position for the first section\n        for start in range(N):\n            sections = 0\n            i = start\n            while i < start + N:\n                # Try to extend current section as far as possible\n                current_or = 0\n                j = i\n                while j < start + N:\n                    new_or = current_or | A_ext[j]\n                    if (new_or & target) == target:\n                        current_or = new_or\n                        j += 1\n                    else:\n                        break\n                if current_or & target == target:\n                    sections += 1\n                    i = j\n                else:\n                    break\n                if sections >= K:\n                    return True\n            if sections >= K:\n                return True\n        return False\n    \n    # Binary search on the answer\n    ans = 0\n    for bit in range(30, -1, -1):\n        candidate = ans | (1 << bit)\n        if can_achieve(candidate):\n            ans = candidate\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 69.2665708065033}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith('po'):\n        return 'FILIPINO'\n    elif sentence.endswith('desu') or sentence.endswith('masu'):\n        return 'JAPANESE'\n    elif sentence.endswith('mnida'):\n        return 'KOREAN'\n    else:\n        # According to problem statement, this case shouldn't occur\n        return 'UNKNOWN'\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i].strip()\n        results.append(detect_language(sentence))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 222.56747198104858}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    trains = []\n    for _ in range(N-1):\n        C = int(next(it))\n        S = int(next(it))\n        F = int(next(it))\n        trains.append((C, S, F))\n    \n    results = []\n    for start in range(N):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait until next departure\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results.append(str(current_time))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 137.5932891368866}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"impossible\"\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    iron_cells = set()\n    for _ in range(m):\n        iron_cells.add(int(next(it)))\n    \n    coal_cells = set()\n    for _ in range(k):\n        coal_cells.add(int(next(it)))\n    \n    # Build graph\n    graph = [[] for _ in range(n + 1)]\n    for cell in range(1, n + 1):\n        a = int(next(it))\n        for _ in range(a):\n            neighbor = int(next(it))\n            graph[cell].append(neighbor)\n    \n    # BFS from start (cell 1) to find distances to all cells\n    dist_from_start = [-1] * (n + 1)\n    dist_from_start[1] = 0\n    queue = deque([1])\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if dist_from_start[v] == -1:\n                dist_from_start[v] = dist_from_start[u] + 1\n                queue.append(v)\n    \n    # Build reverse graph for BFS from iron and coal cells\n    reverse_graph = [[] for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n    \n    # BFS from all iron cells to find distances to all cells (reverse direction)\n    dist_to_iron = [-1] * (n + 1)\n    queue = deque()\n    for iron in iron_cells:\n        dist_to_iron[iron] = 0\n        queue.append(iron)\n    while queue:\n        u = queue.popleft()\n        for v in reverse_graph[u]:\n            if dist_to_iron[v] == -1:\n                dist_to_iron[v] = dist_to_iron[u] + 1\n                queue.append(v)\n    \n    # BFS from all coal cells to find distances to all cells (reverse direction)\n    dist_to_coal = [-1] * (n + 1)\n    queue = deque()\n    for coal in coal_cells:\n        dist_to_coal[coal] = 0\n        queue.append(coal)\n    while queue:\n        u = queue.popleft()\n        for v in reverse_graph[u]:\n            if dist_to_coal[v] == -1:\n                dist_to_coal[v] = dist_to_coal[u] + 1\n                queue.append(v)\n    \n    # Find minimum sum of distances: start -> X -> iron + start -> Y -> coal\n    # where X and Y can be the same cell (meeting point)\n    min_settlers = float('inf')\n    for cell in range(1, n + 1):\n        if dist_from_start[cell] != -1 and dist_to_iron[cell] != -1 and dist_to_coal[cell] != -1:\n            # Settlers needed: one path to claim iron, one path to claim coal\n            # Each path requires settlers equal to distance (since each new cell claims one settler)\n            # But we can reuse settlers if paths share cells\n            # The minimal settlers is max(dist_from_start[cell], dist_to_iron[cell], dist_to_coal[cell])?\n            # Actually, we need to consider two separate claims:\n            # 1. Claim an iron cell: need to reach some iron cell from start\n            # 2. Claim a coal cell: need to reach some coal cell from start\n            # We can think of meeting at cell, then going to iron and coal\n            settlers = dist_from_start[cell] + dist_to_iron[cell] + dist_to_coal[cell]\n            min_settlers = min(min_settlers, settlers)\n    \n    if min_settlers == float('inf'):\n        return \"impossible\"\n    else:\n        return str(min_settlers)\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 127.68134593963623}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    sizes = list(map(int, data[1:1+n]))\n    \n    # Check if total counts match: each size should appear exactly as many times as needed for consecutive sets\n    max_size = max(sizes)\n    freq = [0] * (max_size + 1)\n    for s in sizes:\n        freq[s] += 1\n    \n    # Verify that for each size k, freq[k] >= freq[k+1] (since sets are consecutive from 1)\n    for k in range(1, max_size):\n        if freq[k] < freq[k+1]:\n            print(\"impossible\")\n            return\n    \n    # DP: dp[l][r] = min openings to combine interval [l, r] into valid matryoshka groups\n    INF = 10**9\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Base: single doll requires 0 openings\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # Precompute prefix sums for quick range sum queries\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i+1] = prefix[i] + sizes[i]\n    \n    # Helper to check if interval can form a valid consecutive set starting from 1\n    def can_form_set(l, r):\n        length = r - l + 1\n        sub = sorted(sizes[l:r+1])\n        # Check if it's exactly 1..length\n        return all(sub[i] == i+1 for i in range(length))\n    \n    # Fill DP for increasing lengths\n    for length in range(2, n+1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            # Try all possible splits\n            for k in range(l, r):\n                if dp[l][k] < INF and dp[k+1][r] < INF:\n                    # Cost to combine two groups: sum of sizes in both groups minus the largest size in each?\n                    # Actually: openings needed = sum of sizes in both groups - max_size_in_left - max_size_in_right\n                    # But we need to consider nested structure: we open all dolls except the outermost in each group\n                    # For a group with consecutive sizes 1..m, we need to open all except size m\n                    # So openings = total_sizes - max_size\n                    left_sum = prefix[k+1] - prefix[l]\n                    right_sum = prefix[r+1] - prefix[k+1]\n                    left_max = max(sizes[l:k+1])\n                    right_max = max(sizes[k+1:r+1])\n                    combine_cost = (left_sum - left_max) + (right_sum - right_max)\n                    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + combine_cost)\n            \n            # Also check if the entire interval itself can be a valid set\n            if can_form_set(l, r):\n                total_sum = prefix[r+1] - prefix[l]\n                max_val = max(sizes[l:r+1])\n                dp[l][r] = min(dp[l][r], total_sum - max_val)\n    \n    result = dp[0][n-1]\n    if result >= INF:\n        print(\"impossible\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 79.16416120529175}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    H, W = map(int, data[0].split())\n    grid = data[1:1+H]\n    \n    # Directions: up, down, left, right, and four diagonals\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                    bomb_count += 1\n            row_chars.append(str(bomb_count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 138.37440657615662}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data)\n    \n    # Ensure n <= m for easier handling\n    if n > m:\n        n, m = m, n\n    \n    # Cases based on dimensions\n    if n == 1:\n        # For 1 row, we can pair cells with distance 3 horizontally\n        # Pattern: place pairs every 4 columns starting from column 1\n        # Maximum pairs = floor(m / 4) * 2\n        # But we need to handle remainder\n        if m < 4:\n            result = 0\n        else:\n            full_cycles = m // 4\n            remainder = m % 4\n            result = full_cycles * 2\n            if remainder >= 3:\n                result += 2\n            elif remainder >= 1:\n                result += 1\n    elif n == 2:\n        # For 2 rows, we can use vertical and diagonal moves\n        # Pattern: we can fill almost all cells except some edge cases\n        # Each 2x2 block can hold 4 pieces (2 pairs)\n        # But we need to handle columns\n        if m == 1:\n            result = 0\n        elif m == 2:\n            result = 0\n        elif m == 3:\n            result = 4\n        else:\n            # For m >= 4, we can fill most cells\n            # Each column can have 2 pieces except some edge cases\n            # Actually pattern: floor((m * 2) / 3) * 2 but adjusted\n            # Let's derive formula\n            full_blocks = m // 3\n            remainder = m % 3\n            result = full_blocks * 4\n            if remainder == 1:\n                result += 2\n            elif remainder == 2:\n                result += 4\n    else:\n        # For n >= 3 and m >= 3\n        # We can fill almost all cells\n        # Each cell can be paired with another\n        # Maximum is floor((n * m) / 2) * 2\n        # But we need to check parity\n        total_cells = n * m\n        if total_cells % 2 == 0:\n            result = total_cells\n        else:\n            result = total_cells - 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 193.79775547981262}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Determine which numbers are missing from a and b\n    used_a = set(a)\n    used_b = set(b)\n    all_numbers = set(range(1, n+1))\n    missing_a = list(all_numbers - used_a)\n    missing_b = list(all_numbers - used_b)\n    \n    # Start with a as base\n    p = a[:]\n    \n    if len(diff_positions) == 1:\n        # Only one position differs between a and b\n        pos = diff_positions[0]\n        # Try both possibilities\n        candidates = [a[pos], b[pos]]\n        for cand in candidates:\n            temp = p[:]\n            temp[pos] = cand\n            if len(set(temp)) == n:\n                p = temp\n                break\n    else:\n        # Two positions differ (most common case)\n        pos1, pos2 = diff_positions[0], diff_positions[1]\n        \n        # Try all combinations\n        # Option 1: swap a[pos1] with a[pos2]\n        temp1 = p[:]\n        temp1[pos1], temp1[pos2] = temp1[pos2], temp1[pos1]\n        \n        # Option 2: use b values at diff positions\n        temp2 = p[:]\n        temp2[pos1] = b[pos1]\n        temp2[pos2] = b[pos2]\n        \n        # Option 3: mix a and b\n        temp3 = p[:]\n        temp3[pos1] = b[pos1]\n        \n        temp4 = p[:]\n        temp4[pos2] = b[pos2]\n        \n        # Check which one forms a valid permutation\n        for candidate in [temp1, temp2, temp3, temp4]:\n            if len(set(candidate)) == n:\n                p = candidate\n                break\n        \n        # If none worked (edge case with more than 2 diff positions)\n        if len(set(p)) != n:\n            # Find missing numbers and try to place them\n            missing = list(all_numbers - set(p))\n            if missing:\n                # Try to replace at diff positions\n                for pos in diff_positions:\n                    for num in missing:\n                        temp = p[:]\n                        temp[pos] = num\n                        if len(set(temp)) == n:\n                            p = temp\n                            break\n                    if len(set(p)) == n:\n                        break\n    \n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 154.66712594032288}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(q):\n        s = data[idx]; idx += 1\n        m = int(data[idx]); idx += 1\n        b = list(map(int, data[idx:idx+m])); idx += m\n        \n        # Count frequencies of letters in s\n        freq = [0]*26\n        for ch in s:\n            freq[ord(ch)-97] += 1\n        \n        # Build t from rightmost position to leftmost\n        t = ['']*m\n        used = [False]*m\n        \n        # Process positions one by one\n        for _ in range(m):\n            # Find indices where b[i]==0 and not used\n            zero_indices = [i for i in range(m) if b[i]==0 and not used[i]]\n            # Choose the largest available letter\n            for letter in range(25, -1, -1):\n                if freq[letter] > 0:\n                    # Check if we can place this letter at any zero position\n                    # We need to ensure we have enough of this letter\n                    # Since answer exists, we can greedily pick\n                    # Actually we just need to pick one zero position\n                    # The problem guarantees solution exists\n                    pos = zero_indices[0]\n                    t[pos] = chr(letter+97)\n                    used[pos] = True\n                    freq[letter] -= 1\n                    # Update b values for positions to the left\n                    for i in range(m):\n                        if not used[i]:\n                            b[i] -= abs(i-pos)\n                    break\n        out_lines.append(''.join(t))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 63.908915996551514}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import re\n\ndef is_vowel(c):\n    \"\"\"Return True if c is a vowel according to the rules.\"\"\"\n    return c in 'AEIOUY'\n\ndef syllable_count(word):\n    \"\"\"Count syllables in a word according to the given rules.\"\"\"\n    # Extract alphabetic part for syllable counting\n    alpha_part = ''.join(ch for ch in word if ch.isalpha())\n    if not alpha_part:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    alpha_part = alpha_part.upper()\n    n = len(alpha_part)\n    \n    # Apply special rules for 'QU' and Y as consonant\n    processed = []\n    i = 0\n    while i < n:\n        if i+1 < n and alpha_part[i] == 'Q' and alpha_part[i+1] == 'U':\n            processed.append('Q')  # Represent QU as single consonant\n            i += 2\n        else:\n            processed.append(alpha_part[i])\n            i += 1\n    \n    # Mark Y as consonant if followed by another vowel\n    marked = []\n    m = len(processed)\n    for j in range(m):\n        if processed[j] == 'Y' and j+1 < m and is_vowel(processed[j+1]):\n            marked.append('C')  # Y as consonant\n        else:\n            marked.append(processed[j])\n    \n    # Convert to V/C sequence\n    seq = []\n    for ch in marked:\n        if ch == 'C':\n            seq.append('C')\n        elif is_vowel(ch):\n            seq.append('V')\n        else:\n            seq.append('C')\n    \n    # Handle silent E at end\n    if seq and seq[-1] == 'V' and alpha_part[-1] == 'E':\n        # Check exception: ...CLE pattern\n        if len(alpha_part) >= 3 and alpha_part[-1] == 'E' and alpha_part[-2] == 'L':\n            if len(alpha_part) >= 3 and not is_vowel(alpha_part[-3]):\n                # Keep the E as vowel (forms syllable with L)\n                pass\n            else:\n                seq[-1] = 'C'  # Silent E\n        else:\n            seq[-1] = 'C'  # Silent E\n    \n    # Handle ES at end\n    if len(alpha_part) >= 2 and alpha_part[-2:] == 'ES':\n        # Check if preceded by two or more consonants\n        cons_count = 0\n        k = len(alpha_part) - 3\n        while k >= 0 and not is_vowel(alpha_part[k]):\n            cons_count += 1\n            k -= 1\n        if cons_count < 2:\n            # ES doesn't add syllable\n            if len(seq) >= 2:\n                seq[-2] = 'C'\n                seq[-1] = 'C'\n    \n    # Count syllables: each maximal consonant group with vowel on both sides\n    syllables = 0\n    l = len(seq)\n    for idx in range(l):\n        if seq[idx] == 'V':\n            # Check if this vowel starts a new syllable\n            if idx == 0 or seq[idx-1] == 'C':\n                syllables += 1\n    \n    return max(1, syllables)\n\ndef find_haiku(words):\n    \"\"\"Try to split words into 5-7-5 syllable lines.\"\"\"\n    n = len(words)\n    syllable_counts = [syllable_count(w) for w in words]\n    total_syllables = sum(syllable_counts)\n    \n    if total_syllables != 17:\n        return None\n    \n    # Try all possible splits\n    for i in range(1, n-1):\n        for j in range(i+1, n):\n            line1_syllables = sum(syllable_counts[:i])\n            line2_syllables = sum(syllable_counts[i:j])\n            line3_syllables = sum(syllable_counts[j:])\n            \n            if line1_syllables == 5 and line2_syllables == 7 and line3_syllables == 5:\n                return (i, j)\n    \n    return None\n\ndef main():\n    import sys\n    line = sys.stdin.read().rstrip('\\n')\n    \n    # Split into words preserving original form\n    words = []\n    word = ''\n    for ch in line:\n        if ch == ' ':\n            if word:\n                words.append(word)\n                word = ''\n            # Don't add space to word\n        else:\n            word += ch\n    if word:\n        words.append(word)\n    \n    result = find_haiku(words)\n    if result is None:\n        print(line)\n    else:\n        i, j = result\n        line1 = ' '.join(words[:i])\n        line2 = ' '.join(words[i:j])\n        line3 = ' '.join(words[j:])\n        print(line1)\n        print(line2)\n        print(line3)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 211.26999688148499}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 90.9548168182373}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    A, B = map(int, data[:2])\n    # Special case: 1 is strongest, then 13, 12, ..., 2\n    if A == B:\n        print(\"Draw\")\n    elif A == 1:\n        print(\"Alice\")\n    elif B == 1:\n        print(\"Bob\")\n    elif A > B:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 416.48603105545044}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    values = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        v = int(next(it))\n        p = int(next(it))\n        values[i] = v\n        parent[i] = p\n        if p != 0:\n            children[p].append(i)\n    \n    # DP: dp[node] = max size of valid subset in subtree rooted at node\n    # where node is included and is the minimum value among ancestors in subset\n    dp = [0] * (n + 1)\n    \n    def dfs(u):\n        # For each child, compute dp[child] where child's value > values[u]\n        # We can include at most one such child (since all included nodes must have distinct values along ancestor chain)\n        # Actually, we can include multiple children if their values are all > values[u], \n        # but they must be in separate branches (no ancestor relation among them).\n        # However, since we are counting subsets where u is the minimum among ancestors,\n        # we can take at most one child from each branch where the child's value > values[u].\n        # But here we are computing dp[u] where u is included and is the minimum.\n        # So we need to consider all children where child's value > values[u],\n        # and we can add the maximum dp[child] among them.\n        best = 0\n        for v in children[u]:\n            dfs(v)\n            if values[v] > values[u]:\n                best = max(best, dp[v])\n        dp[u] = 1 + best\n    \n    dfs(1)\n    \n    # The answer is the maximum dp over all nodes, because we can choose any node as the \"minimum\" in its chain.\n    ans = max(dp[1:])\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 111.55888223648071}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        s = input_data[idx]\n        idx += 1\n        \n        # Find first occurrence of different consecutive characters\n        start = 0\n        while start < n and s[start] == s[0]:\n            start += 1\n        \n        if start == n:\n            # All characters are the same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rotate string to start with first change\n        s_rotated = s[start:] + s[:start]\n        \n        count = 0\n        current_len = 1\n        \n        for i in range(1, n):\n            if s_rotated[i] == s_rotated[i-1]:\n                current_len += 1\n            else:\n                count += current_len // 3\n                current_len = 1\n        \n        count += current_len // 3\n        results.append(count)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 222.57215476036072}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # One of them was set to 0, so we find which index has value 0\n    for i in range(5):\n        if x[i] == 0:\n            # Print i+1 because indices are 0-based but output should be 1-based\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 215.62240362167358}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m, k = map(int, data)\n    \n    # The maximum number of bags is (2*k + 1)^m\n    # Using modular exponentiation\n    base = (2 * k + 1) % MOD\n    result = pow(base, m, MOD)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 97.92639398574829}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def count_ways(n):\n    # Total parking spaces\n    total_spaces = 2 * n - 2\n    \n    # We need exactly n consecutive cars of same make\n    # The remaining (n-2) cars can be any of 4 makes\n    \n    # Position where the block of n consecutive cars starts\n    # It can start at position 0, 1, ..., (n-2)\n    positions = n - 1\n    \n    # For each position, choose the make for the consecutive block: 4 choices\n    # For the remaining (n-2) cars, each can be any of 4 makes\n    ways = positions * 4 * (4 ** (n - 2))\n    \n    return ways\n\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.readline().strip())\n    print(count_ways(n))", "runtime_sec": 57.578327894210815}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Check if any value appears more than twice\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Separate values that appear once vs twice\n    once = []\n    twice = []\n    for val, count in freq.items():\n        if count == 2:\n            twice.append(val)\n        else:\n            once.append(val)\n    \n    # Sort for processing\n    once.sort()\n    twice.sort()\n    \n    # Check if twice values can be split\n    # For each value appearing twice, one goes to inc, one to dec\n    # We need to ensure inc stays increasing and dec stays decreasing\n    inc = []\n    dec = []\n    \n    # Process twice values\n    for val in twice:\n        if not inc or val > inc[-1]:\n            inc.append(val)\n        else:\n            # Can't add to inc, try dec\n            if not dec or val < dec[-1]:\n                dec.append(val)\n            else:\n                print(\"NO\")\n                return\n    \n    # Process once values\n    for val in once:\n        # Try to add to inc first\n        if not inc or val > inc[-1]:\n            inc.append(val)\n        elif not dec or val < dec[-1]:\n            dec.append(val)\n        else:\n            # Try adding to dec first\n            if not dec or val < dec[-1]:\n                dec.append(val)\n            elif not inc or val > inc[-1]:\n                inc.append(val)\n            else:\n                print(\"NO\")\n                return\n    \n    # Sort inc ascending and dec descending for output\n    inc.sort()\n    dec.sort(reverse=True)\n    \n    print(\"YES\")\n    print(len(inc))\n    if inc:\n        print(' '.join(map(str, inc)))\n    else:\n        print()\n    print(len(dec))\n    if dec:\n        print(' '.join(map(str, dec)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 70.09361171722412}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    M = int(next(it))\n    N = int(next(it))\n    \n    # Initialize net balance for each person\n    balance = [0] * M\n    \n    # Process receipts\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        p = int(next(it))\n        balance[a] -= p  # payer pays, so their balance decreases\n        balance[b] += p  # receiver gets, so their balance increases\n    \n    # Filter out people with zero balance\n    nonzero = [b for b in balance if b != 0]\n    \n    # If all balances are zero, no transactions needed\n    if not nonzero:\n        print(0)\n        return\n    \n    # Try all subsets of nonzero balances to find minimal transactions\n    # The minimal number of transactions is M - number_of_zero_sum_subsets\n    # where we can settle within each subset\n    k = len(nonzero)\n    best = k - 1  # worst case: k-1 transactions (chain)\n    \n    # Try all subsets (excluding empty and full)\n    for mask in range(1, (1 << k) - 1):\n        subset_sum = 0\n        for i in range(k):\n            if mask & (1 << i):\n                subset_sum += nonzero[i]\n        \n        # If subset sums to zero, we can settle within subset\n        if subset_sum == 0:\n            # Count bits in mask to get subset size\n            subset_size = bin(mask).count('1')\n            # Transactions within subset: subset_size - 1\n            # Remaining people: k - subset_size\n            # Transactions for remaining: (k - subset_size) - 1 if > 0\n            remaining = k - subset_size\n            if remaining > 0:\n                total_transactions = (subset_size - 1) + (remaining - 1)\n            else:\n                total_transactions = subset_size - 1\n            \n            if total_transactions < best:\n                best = total_transactions\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 149.57355976104736}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of absolute values\n    abs_counts = {}\n    for num in arr:\n        abs_val = abs(num)\n        abs_counts[abs_val] = abs_counts.get(abs_val, 0) + 1\n    \n    # Get unique absolute values and sort\n    unique_abs = sorted(abs_counts.keys())\n    m = len(unique_abs)\n    \n    # Precompute prefix sums for efficient counting\n    prefix = [0] * (m + 1)\n    for i in range(m):\n        prefix[i+1] = prefix[i] + abs_counts[unique_abs[i]]\n    \n    total_pairs = 0\n    \n    # For each absolute value a, find valid b values\n    for i in range(m):\n        a = unique_abs[i]\n        \n        # Condition 1: b >= a/2\n        # Condition 2: b <= 2*a\n        # Combined: a/2 <= b <= 2*a\n        \n        # Find lower bound: first b >= a/2\n        lo = 0\n        hi = m - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if unique_abs[mid] * 2 >= a:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        lower_idx = lo\n        \n        # Find upper bound: last b <= 2*a\n        lo = 0\n        hi = m - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if unique_abs[mid] <= 2 * a:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        upper_idx = hi\n        \n        if lower_idx <= upper_idx:\n            # Count all b values in range [lower_idx, upper_idx]\n            count_in_range = prefix[upper_idx + 1] - prefix[lower_idx]\n            \n            # Subtract self if a is in range\n            if lower_idx <= i <= upper_idx:\n                count_in_range -= abs_counts[a]\n            \n            total_pairs += count_in_range * abs_counts[a]\n    \n    # Each pair counted twice, so divide by 2\n    total_pairs //= 2\n    \n    # Add pairs where both numbers have same absolute value\n    for count in abs_counts.values():\n        if count >= 2:\n            # C(count, 2) pairs from numbers with same absolute value\n            total_pairs += count * (count - 1) // 2\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 566.1787388324738}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Minimum possible sum: 1 + 2 + 3 + ... + k = k*(k+1)//2\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with minimal strictly increasing sequence: 1, 2, 3, ..., k\n    a = list(range(1, k + 1))\n    total = min_sum\n    \n    # Distribute remaining problems while maintaining constraints\n    remaining = n - total\n    \n    # We can increase each day's problems while keeping a[i] <= 2*a[i-1]\n    # Start from the last day to maximize flexibility\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] without violating constraints\n        # For day i, max value is min(2*a[i-1] if i>0 else float('inf'), remaining + a[i])\n        # But we need to ensure future days can still satisfy constraints\n        \n        # Calculate current max possible for this position\n        if i == 0:\n            max_add = remaining\n        else:\n            # We can increase up to 2*a[i-1] - a[i]\n            max_add = min(remaining, 2 * a[i - 1] - a[i])\n        \n        # Add as much as possible\n        add = max_add\n        a[i] += add\n        remaining -= add\n        \n        if remaining == 0:\n            break\n    \n    # Check if we distributed all problems\n    if remaining > 0:\n        print(\"NO\")\n        return\n    \n    # Verify constraints\n    for i in range(k - 1):\n        if not (a[i] < a[i + 1] <= 2 * a[i]):\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 67.19921827316284}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Sort values\n    a.sort()\n    \n    total = 0\n    # For each element a[i], count how many combinations where it is the maximum\n    for i in range(K-1, N):\n        # Choose K-1 elements from the i smaller elements\n        comb = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + a[i] * comb) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 149.02685403823853}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:2+r]\n    \n    # Track rows and columns that are safe (no 'S')\n    safe_rows = [True] * r\n    safe_cols = [True] * c\n    \n    # Mark unsafe rows and columns\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                safe_rows[i] = False\n                safe_cols[j] = False\n    \n    # Count cells in safe rows and columns\n    eaten = 0\n    for i in range(r):\n        if safe_rows[i]:\n            eaten += c\n    for j in range(c):\n        if safe_cols[j]:\n            eaten += r\n    \n    # Subtract double-counted cells (intersections of safe rows and columns)\n    for i in range(r):\n        for j in range(c):\n            if safe_rows[i] and safe_cols[j]:\n                eaten -= 1\n    \n    print(eaten)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1719.874619960785}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "runtime_sec": 89.695139169693}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    s = list(data[0])\n    k = int(data[1])\n    n = len(s)\n    \n    # Greedy approach: try to place largest possible digit at each position\n    for i in range(n):\n        if k == 0:\n            break\n        # Find the largest digit from i+1 to end\n        max_idx = i\n        for j in range(i+1, n):\n            if s[j] > s[max_idx]:\n                max_idx = j\n        # If we found a larger digit, swap it to position i\n        if max_idx != i:\n            # Count how many swaps needed to bring s[max_idx] to position i\n            swaps_needed = max_idx - i\n            if swaps_needed <= k:\n                # Perform the swap by moving the digit forward\n                digit = s.pop(max_idx)\n                s.insert(i, digit)\n                k -= swaps_needed\n            else:\n                # If we can't afford to bring the largest digit, \n                # try to bring the best digit within k swaps\n                best_idx = i\n                for j in range(i+1, i+k+1):\n                    if j < n and s[j] > s[best_idx]:\n                        best_idx = j\n                if best_idx != i:\n                    digit = s.pop(best_idx)\n                    s.insert(i, digit)\n                    k -= (best_idx - i)\n        \n    # If k is still > 0 and we have swaps left, we can perform additional swaps\n    # but only if they increase the number. If k is odd and we can't improve further,\n    # we might need to waste swaps by swapping equal digits if possible.\n    if k > 0:\n        # Try to waste swaps by swapping equal digits\n        has_duplicate = False\n        for i in range(n):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    has_duplicate = True\n                    break\n            if has_duplicate:\n                break\n        \n        # If no duplicates and k is odd, we need to swap the last two digits\n        # (but only if it doesn't create leading zero)\n        if not has_duplicate and k % 2 == 1:\n            if n >= 2 and not (s[0] == '0' and s[1] == '0'):\n                # Swap last two digits\n                s[-1], s[-2] = s[-2], s[-1]\n    \n    # Ensure no leading zero\n    if s[0] == '0':\n        # Find first non-zero digit to swap with first position\n        for i in range(1, n):\n            if s[i] != '0':\n                s[0], s[i] = s[i], s[0]\n                break\n    \n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 71.14333701133728}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 71.07816958427429}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = [0] + [int(data[i]) for i in range(1, n+1)]  # 1-indexed\n    \n    visited = [False] * (n + 1)\n    current = 1\n    steps = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(steps)\n            return\n        visited[current] = True\n        current = a[current]\n        steps += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 134.09833216667175}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nimport heapq\n\ndef angle_between(v1, v2):\n    \"\"\"Compute angle between two vectors in degrees.\"\"\"\n    dot = v1[0]*v2[0] + v1[1]*v2[1]\n    norm1 = math.hypot(v1[0], v1[1])\n    norm2 = math.hypot(v2[0], v2[1])\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    cos_theta = dot / (norm1 * norm2)\n    cos_theta = max(-1.0, min(1.0, cos_theta))\n    return math.degrees(math.acos(cos_theta))\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    J = int(next(it))\n    R = int(next(it))\n    D = int(next(it))\n    \n    coords = []\n    for _ in range(J):\n        x = int(next(it))\n        y = int(next(it))\n        coords.append((x, y))\n    \n    adj = [[] for _ in range(J)]\n    for _ in range(R):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n    \n    # Precompute road vectors\n    road_vecs = [[None]*J for _ in range(J)]\n    for u in range(J):\n        for v in adj[u]:\n            dx = coords[v][0] - coords[u][0]\n            dy = coords[v][1] - coords[u][1]\n            road_vecs[u][v] = (dx, dy)\n    \n    # Binary search on maximum turning angle\n    EPS = 1e-9\n    left, right = 0.0, 180.0\n    best = None\n    \n    for _ in range(60):  # enough for 1e-18 precision\n        mid = (left + right) / 2\n        \n        # Dijkstra-like BFS with distance constraint\n        dist = [float('inf')] * J\n        dist[0] = 0\n        pq = [(0.0, 0, None)]  # (distance, node, previous_node)\n        \n        while pq:\n            d, u, prev = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            if u == J-1 and d <= D:\n                break\n            \n            for v in adj[u]:\n                new_dist = d + math.hypot(coords[v][0]-coords[u][0], coords[v][1]-coords[u][1])\n                if new_dist > D * (1 + 1e-6):\n                    continue\n                if prev is not None:\n                    vec1 = road_vecs[prev][u]\n                    vec2 = road_vecs[u][v]\n                    turn_angle = angle_between(vec1, vec2)\n                    if turn_angle > mid + EPS:\n                        continue\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heapq.heappush(pq, (new_dist, v, u))\n        \n        if dist[J-1] <= D:\n            best = mid\n            right = mid\n        else:\n            left = mid\n    \n    if best is None:\n        print(\"Impossible\")\n    else:\n        print(f\"{best:.8f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 75.0960066318512}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic_progression(first, last, count):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    if count == 0:\n        return 0\n    total = (first + last) % MOD\n    total = (total * count) % MOD\n    # Multiply by modular inverse of 2\n    return (total * 500000004) % MOD  # 500000004 is modular inverse of 2 mod MOD\n\ndef sum_of_stage(stage, start_pos):\n    \"\"\"Return sum of numbers in given stage and starting position in sequence.\"\"\"\n    length = 1 << (stage - 1)  # 2^(stage-1)\n    is_odd_stage = (stage % 2 == 1)\n    \n    if is_odd_stage:\n        # Odd stage: odd numbers\n        # First number in this stage: 1 + sum_{i=1}^{stage-1} 2^{i-1} * 2\n        # But we need the actual first odd number\n        # Number of odd numbers written before this stage\n        odd_stages_before = (stage + 1) // 2\n        total_odd_before = (1 << odd_stages_before) - 1 - odd_stages_before\n        first_odd = 2 * total_odd_before + 1\n        first_in_stage = first_odd + (start_pos - 1) * 2\n    else:\n        # Even stage: even numbers\n        # Number of even numbers written before this stage\n        even_stages_before = stage // 2\n        total_even_before = (1 << even_stages_before) - 1\n        first_even = 2 * total_even_before + 2\n        first_in_stage = first_even + (start_pos - 1) * 2\n    \n    last_in_stage = first_in_stage + 2 * (length - 1)\n    return sum_arithmetic_progression(first_in_stage, last_in_stage, length)\n\ndef prefix_sum(pos):\n    \"\"\"Return sum of first pos numbers modulo MOD.\"\"\"\n    if pos == 0:\n        return 0\n    \n    stage = 1\n    remaining = pos\n    result = 0\n    \n    while remaining > 0:\n        stage_length = 1 << (stage - 1)\n        take = min(stage_length, remaining)\n        \n        is_odd_stage = (stage % 2 == 1)\n        \n        if is_odd_stage:\n            # Odd stage: odd numbers\n            odd_stages_before = (stage + 1) // 2\n            total_odd_before = (1 << odd_stages_before) - 1 - odd_stages_before\n            first_odd = 2 * total_odd_before + 1\n            first_in_segment = first_odd\n        else:\n            # Even stage: even numbers\n            even_stages_before = stage // 2\n            total_even_before = (1 << even_stages_before) - 1\n            first_even = 2 * total_even_before + 2\n            first_in_segment = first_even\n        \n        last_in_segment = first_in_segment + 2 * (take - 1)\n        segment_sum = sum_arithmetic_progression(first_in_segment, last_in_segment, take)\n        result = (result + segment_sum) % MOD\n        \n        remaining -= take\n        stage += 1\n    \n    return result\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    \n    result = (prefix_sum(r) - prefix_sum(l - 1)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 76.51517796516418}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    xs = list(map(int, data[1:1+n]))\n    \n    # The optimal P is the integer closest to the mean of xs\n    # Since stamina is (X_i - P)^2, minimizing sum of squares\n    # The derivative gives P = mean(xs). For integer P, check floor and ceil of mean.\n    mean_val = sum(xs) / n\n    p_candidates = [int(mean_val), int(mean_val) + 1]\n    \n    min_stamina = float('inf')\n    for p in p_candidates:\n        stamina = sum((x - p) ** 2 for x in xs)\n        if stamina < min_stamina:\n            min_stamina = stamina\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 584.3695845603943}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport numpy as np\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    L = int(next(it))\n    \n    # Read adjacency matrix\n    adj = []\n    for _ in range(N):\n        row = [int(next(it)) for _ in range(N)]\n        adj.append(row)\n    \n    # Convert to probability matrix\n    P = np.zeros((N, N), dtype=np.float64)\n    for i in range(N):\n        total = sum(adj[i])\n        if total > 0:\n            for j in range(N):\n                P[i][j] = adj[i][j] / total\n    \n    # Initial state vector (start at node 1, index 0)\n    state = np.zeros(N, dtype=np.float64)\n    state[0] = 1.0\n    \n    # Check each T in [L, L+9]\n    for T in range(L, L + 10):\n        # Compute state after T days using matrix exponentiation\n        # Since N  100, we can use repeated multiplication\n        current_state = state.copy()\n        for _ in range(T):\n            new_state = np.zeros(N, dtype=np.float64)\n            for i in range(N):\n                if current_state[i] > 0:\n                    for j in range(N):\n                        new_state[j] += current_state[i] * P[i][j]\n            current_state = new_state\n        \n        # Probability at node N (index N-1)\n        prob = current_state[N-1]\n        \n        # Check if probability is exactly 95% (within floating tolerance)\n        if abs(prob - 0.95) < 1e-12:\n            print(T)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.1399290561676}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs_escape(R, C, grid):\n    # Find start and destination positions\n    start = dest = None\n    water_queue = deque()\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'D':\n                dest = (i, j)\n            elif grid[i][j] == '*':\n                water_queue.append((i, j, 0))  # (row, col, time)\n    \n    if not start or not dest:\n        return \"KAKTUS\"\n    \n    # BFS for water propagation times\n    water_time = [[-1] * C for _ in range(R)]\n    for i, j, t in water_queue:\n        water_time[i][j] = t\n    \n    while water_queue:\n        r, c, t = water_queue.popleft()\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if grid[nr][nc] == '.' and water_time[nr][nc] == -1:\n                    water_time[nr][nc] = t + 1\n                    water_queue.append((nr, nc, t + 1))\n    \n    # BFS for hedgehog movement\n    hedgehog_queue = deque([(start[0], start[1], 0)])  # (row, col, time)\n    visited = [[False] * C for _ in range(R)]\n    visited[start[0]][start[1]] = True\n    \n    while hedgehog_queue:\n        r, c, t = hedgehog_queue.popleft()\n        \n        # Check if reached destination\n        if (r, c) == dest:\n            return t\n        \n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                # Check if cell is passable\n                if grid[nr][nc] == 'X':\n                    continue\n                # Check if cell is destination (always safe)\n                if grid[nr][nc] == 'D':\n                    hedgehog_queue.append((nr, nc, t + 1))\n                    visited[nr][nc] = True\n                    continue\n                # Check water constraints\n                water_arrival = water_time[nr][nc]\n                # Cell must be empty and either never flooded or flooded after we arrive\n                if grid[nr][nc] == '.' and (water_arrival == -1 or t + 1 < water_arrival):\n                    hedgehog_queue.append((nr, nc, t + 1))\n                    visited[nr][nc] = True\n    \n    return \"KAKTUS\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    R, C = map(int, data[0].split())\n    grid = [list(row.strip()) for row in data[1:1+R]]\n    \n    result = bfs_escape(R, C, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 156.95967292785645}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, w = map(int, data)\n    \n    # Check if possible: min weight = l*1, max weight = l*26\n    if w < l or w > l * 26:\n        print(\"impossible\")\n        return\n    \n    # Start with all 'a's (weight = l)\n    result = ['a'] * l\n    current_weight = l\n    \n    # Distribute remaining weight from the end\n    remaining = w - current_weight\n    for i in range(l-1, -1, -1):\n        if remaining == 0:\n            break\n        # Add as much as possible to this position, max 25 (since 'a' already gives 1)\n        add = min(25, remaining)\n        result[i] = chr(ord('a') + add)  # 'a' + add gives correct letter\n        remaining -= add\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 57.530492067337036}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each a_i\n    freq = [0] * (n + 1)\n    for val in a:\n        freq[val] += 1\n    \n    # Check if frequencies are even (necessary condition)\n    for i in range(1, n + 1):\n        if freq[i] % 2 != 0:\n            print(\"impossible\")\n            return\n    \n    # Build  and \n    pi = [0] * n\n    sigma = [0] * n\n    used_pi = [False] * (n + 1)\n    used_sigma = [False] * (n + 1)\n    \n    # First pass: assign values where possible\n    for i in range(n):\n        target = a[i]\n        # Try to find x for  and y for  such that (x + y) % n == target\n        # We'll use a greedy approach\n        found = False\n        for x in range(1, n + 1):\n            if used_pi[x]:\n                continue\n            y = (target - x) % n\n            if y == 0:\n                y = n\n            if not used_sigma[y]:\n                pi[i] = x\n                sigma[i] = y\n                used_pi[x] = True\n                used_sigma[y] = True\n                found = True\n                break\n        if not found:\n            print(\"impossible\")\n            return\n    \n    # Verify the solution\n    for i in range(n):\n        if (pi[i] + sigma[i]) % n != a[i] % n:\n            print(\"impossible\")\n            return\n    \n    # Output the permutations\n    print(' '.join(map(str, pi)))\n    print(' '.join(map(str, sigma)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 69.60417151451111}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 93.3744707107544}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] < self.rank[yr]:\n            xr, yr = yr, xr\n        self.parent[yr] = xr\n        if self.rank[xr] == self.rank[yr]:\n            self.rank[xr] += 1\n        return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for i in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v, i))\n    \n    if n <= 1:\n        print(0)\n        return\n    \n    edges_sorted = sorted(edges)\n    \n    dsu = DSU(n)\n    mst_edges = []\n    mst_weight = 0\n    \n    for w, u, v, idx in edges_sorted:\n        if dsu.union(u, v):\n            mst_edges.append((w, u, v, idx))\n            mst_weight += w\n    \n    edges_by_weight = {}\n    for w, u, v, idx in edges:\n        if w not in edges_by_weight:\n            edges_by_weight[w] = []\n        edges_by_weight[w].append((u, v, idx))\n    \n    dsu2 = DSU(n)\n    operations = 0\n    \n    i = 0\n    while i < len(edges_sorted):\n        w = edges_sorted[i][0]\n        j = i\n        while j < len(edges_sorted) and edges_sorted[j][0] == w:\n            j += 1\n        \n        same_weight_edges = edges_by_weight[w]\n        \n        dsu_temp = DSU(n)\n        for u, v, idx in same_weight_edges:\n            dsu_temp.union(u, v)\n        \n        for u, v, idx in same_weight_edges:\n            if dsu2.find(u) != dsu2.find(v):\n                dsu_temp.union(dsu2.find(u), dsu2.find(v))\n        \n        comp_count = 0\n        comp_id = {}\n        for node in range(n):\n            root = dsu_temp.find(node)\n            if root not in comp_id:\n                comp_id[root] = comp_count\n                comp_count += 1\n        \n        edge_list = []\n        for u, v, idx in same_weight_edges:\n            ru = comp_id[dsu_temp.find(u)]\n            rv = comp_id[dsu_temp.find(v)]\n            if ru != rv:\n                edge_list.append((ru, rv, idx))\n        \n        dsu_comp = DSU(comp_count)\n        mst_edges_in_comp = []\n        for ru, rv, idx in edge_list:\n            if dsu_comp.union(ru, rv):\n                mst_edges_in_comp.append(idx)\n        \n        if len(mst_edges_in_comp) < len(edge_list):\n            operations += (len(edge_list) - len(mst_edges_in_comp))\n        \n        for u, v, idx in same_weight_edges:\n            dsu2.union(u, v)\n        \n        i = j\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 85.68206238746643}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\n\nidx = 0\nN = int(data[idx]); idx += 1\nL = int(data[idx]); idx += 1\nW = int(data[idx]); idx += 1\n\npositions = []\nfor _ in range(N):\n    positions.append(int(data[idx])); idx += 1\n\n# Sort initial positions\npositions.sort()\n\n# Precompute target positions\n# N/2 trees on each side, equally spaced along length L\n# First tree at position 0, last at position L\nn_half = N // 2\nspacing = L / (n_half - 1) if n_half > 1 else 0\n\n# Target positions for left and right sides\nleft_targets = [i * spacing for i in range(n_half)]\nright_targets = [i * spacing for i in range(n_half)]\n\n# DP table: dp[i][j] = min total distance when we have assigned\n# i trees to left side and j trees to right side from the first (i+j) initial trees\ndp = [[float('inf')] * (n_half + 1) for _ in range(n_half + 1)]\ndp[0][0] = 0.0\n\nfor total_assigned in range(1, N + 1):\n    # We're assigning the (total_assigned-1)-th initial tree (0-indexed)\n    current_pos = positions[total_assigned - 1]\n    \n    # Update dp where i+j == total_assigned\n    for i in range(min(total_assigned, n_half) + 1):\n        j = total_assigned - i\n        if j < 0 or j > n_half:\n            continue\n        \n        dp[i][j] = float('inf')\n        \n        # Option 1: assign to left side (if i > 0)\n        if i > 0:\n            dist = abs(current_pos - left_targets[i-1])\n            dp[i][j] = min(dp[i][j], dp[i-1][j] + dist)\n        \n        # Option 2: assign to right side (if j > 0)\n        if j > 0:\n            # Euclidean distance to right side: horizontal offset = W, vertical offset = |current_pos - right_targets[j-1]|\n            dist = math.hypot(W, current_pos - right_targets[j-1])\n            dp[i][j] = min(dp[i][j], dp[i][j-1] + dist)\n\n# Answer is when all trees assigned: i = n_half, j = n_half\nanswer = dp[n_half][n_half]\nprint(f\"{answer:.10f}\")", "runtime_sec": 113.38543772697449}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef get_hand(i, n, s):\n    return s[i % n]\n\ndef winner_hand(a, b):\n    if a == b:\n        return a\n    if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n        return a\n    return b\n\ndef tournament(l, r, n, s):\n    if r - l == 1:\n        return get_hand(l, n, s)\n    m = (l + r) // 2\n    a = tournament(l, m, n, s)\n    b = tournament(m, r, n, s)\n    return winner_hand(a, b)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    total_players = 1 << k\n    result = tournament(0, total_players, n, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 143.99691438674927}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        if n == 2 or n == 3:\n            out_lines.append(\"-1\")\n            continue\n        # Build permutation using pattern: start with even numbers descending, then odd numbers ascending\n        # This ensures differences between 2 and 4 for most cases\n        perm = []\n        # Add even numbers in descending order\n        start_even = n if n % 2 == 0 else n - 1\n        for i in range(start_even, 0, -2):\n            perm.append(i)\n        # Add odd numbers in ascending order\n        start_odd = 1 if n % 2 == 1 else 3\n        for i in range(start_odd, n + 1, 2):\n            perm.append(i)\n        # For n=4, the pattern [4,2,1,3] works, but we need to adjust for n=5,6,7 etc.\n        # Check if last two elements violate condition and adjust if needed\n        if len(perm) >= 2 and abs(perm[-1] - perm[-2]) < 2:\n            # Swap last two elements if they are too close\n            perm[-1], perm[-2] = perm[-2], perm[-1]\n        out_lines.append(\" \".join(map(str, perm)))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.36956548690796}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 91.90485715866089}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    H = int(next(it))\n    W = int(next(it))\n    K = int(next(it))\n    x1 = int(next(it)) - 1\n    y1 = int(next(it)) - 1\n    x2 = int(next(it)) - 1\n    y2 = int(next(it)) - 1\n    \n    grid = []\n    for _ in range(H):\n        row = list(next(it))\n        grid.append(row)\n    \n    # BFS with 0-1 BFS optimization for K moves\n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # We'll use deque for 0-1 BFS\n    # Each state: (distance, x, y)\n    dq = deque()\n    dq.append((0, x1, y1))\n    \n    # For each direction, we need to explore up to K steps\n    # But we can optimize by jumping to the farthest valid position in one stroke\n    # We'll use BFS with 0-1 weights: moving within same stroke has weight 0,\n    # starting new stroke has weight 1\n    \n    # We'll maintain visited sets for each direction to avoid reprocessing\n    # visited[direction][x][y] where direction: 0=up, 1=right, 2=down, 3=left\n    visited = [[[False] * 4 for _ in range(W)] for _ in range(H)]\n    \n    while dq:\n        d, x, y = dq.popleft()\n        \n        if x == x2 and y == y2:\n            print(d)\n            return\n        \n        # Try all four directions\n        for dir_idx, (dx, dy) in enumerate([(-1, 0), (0, 1), (1, 0), (0, -1)]):\n            if visited[x][y][dir_idx]:\n                continue\n            visited[x][y][dir_idx] = True\n            \n            # Explore up to K steps in this direction\n            for step in range(1, K + 1):\n                nx = x + dx * step\n                ny = y + dy * step\n                \n                # Check bounds and obstacles\n                if nx < 0 or nx >= H or ny < 0 or ny >= W:\n                    break\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if d + 1 < dist[nx][ny]:\n                    dist[nx][ny] = d + 1\n                    dq.append((d + 1, nx, ny))\n                elif d + 1 == dist[nx][ny]:\n                    # Same distance, still need to process for other directions\n                    pass\n                else:\n                    # If current distance is worse, we can stop in this direction\n                    # because further steps would also have worse distance\n                    break\n    \n    if dist[x2][y2] == INF:\n        print(-1)\n    else:\n        print(dist[x2][y2])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 154.64577293395996}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    total_shares = 0\n    avg_cost = 0.0\n    total_profit = 0.0\n    \n    for line in data:\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == \"buy\":\n            x = int(parts[1])\n            y = int(parts[2])\n            # Update average cost using weighted average\n            total_cost = total_shares * avg_cost + x * y\n            total_shares += x\n            avg_cost = total_cost / total_shares if total_shares > 0 else 0.0\n            \n        elif cmd == \"sell\":\n            x = int(parts[1])\n            y = int(parts[2])\n            # Calculate profit from sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                total_profit += x * profit_per_share\n            total_shares -= x\n            # Average cost remains unchanged after sale\n            \n        elif cmd == \"split\":\n            x = int(parts[1])\n            total_shares *= x\n            avg_cost /= x\n            \n        elif cmd == \"merge\":\n            x = int(parts[1])\n            # Calculate how many full merges can be done\n            full_merges = total_shares // x\n            remainder = total_shares % x\n            \n            # Sell remainder shares at current average cost\n            if remainder > 0:\n                profit_per_share = avg_cost - avg_cost  # Selling at avg cost = no profit\n                # Actually, selling at avg cost means no profit/loss, so no tax effect\n                total_shares -= remainder\n            \n            # Merge the remaining shares\n            total_shares = full_merges\n            avg_cost *= x\n            \n        elif cmd == \"die\":\n            y = int(parts[1])\n            # Calculate profit from final sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                taxable_profit = total_shares * profit_per_share\n                tax = taxable_profit * 0.3\n                final_amount = total_shares * y - tax\n            else:\n                final_amount = total_shares * y\n            \n            # Add any accumulated profit from previous sales\n            if total_profit > 0:\n                tax_on_previous = total_profit * 0.3\n                final_amount -= tax_on_previous\n            \n            print(f\"{final_amount:.8f}\")\n            return\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 108.52944087982178}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\n\ndef is_consistent():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"consistent\"\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    dsu = DSU(N)\n    edges = []\n    \n    for _ in range(M):\n        u = int(data[idx]); idx += 1\n        op = data[idx]; idx += 1\n        v = int(data[idx]); idx += 1\n        \n        if op == '=':\n            dsu.union(u, v)\n        else:  # op == '>'\n            edges.append((u, v))\n    \n    # Build graph with DSU representatives\n    adj = [[] for _ in range(N)]\n    indegree = [0] * N\n    \n    for u, v in edges:\n        u_root = dsu.find(u)\n        v_root = dsu.find(v)\n        if u_root == v_root:\n            return \"inconsistent\"  # Player can't beat themselves\n        adj[u_root].append(v_root)\n        indegree[v_root] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    queue = deque([i for i in range(N) if indegree[i] == 0])\n    processed = 0\n    \n    while queue:\n        node = queue.popleft()\n        processed += 1\n        for neighbor in adj[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if all DSU representatives were processed\n    # Only need to check nodes that are actually in the graph\n    total_nodes = set()\n    for u, v in edges:\n        total_nodes.add(dsu.find(u))\n        total_nodes.add(dsu.find(v))\n    \n    if processed == len(total_nodes):\n        return \"consistent\"\n    else:\n        return \"inconsistent\"\n\nif __name__ == \"__main__\":\n    print(is_consistent())", "runtime_sec": 116.70890974998474}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    s = list(data[1])\n    for i in range(m):\n        l, r, c1, c2 = data[2 + i].split()\n        l, r = int(l), int(r)\n        for idx in range(l - 1, r):\n            if s[idx] == c1:\n                s[idx] = c2\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 946.3212711811066}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        \n        # Check if s is k-periodic\n        valid = True\n        num_blocks = n // k\n        \n        for i in range(1, num_blocks):\n            prev_block = s[(i-1)*k : i*k]\n            curr_block = s[i*k : (i+1)*k]\n            \n            # Check if curr_block is right-rotation of prev_block\n            if curr_block != prev_block[-1] + prev_block[:-1]:\n                valid = False\n                break\n        \n        if valid:\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 175.4469439983368}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    b = int(data[0])\n    d = int(data[1])\n    \n    # Since d is prime, we need to check if there exists m such that:\n    # b^m  1 (mod d) or b^m  -1 (mod d)\n    # This is because the alternating sum corresponds to evaluating n mod (b^m + 1) or (b^m - 1)\n    # For the hack to work for all n, we need d to divide either (b^m - 1) or (b^m + 1)\n    \n    # Check small m values up to a reasonable limit\n    # Since b and d can be up to ~9e18, we can't iterate too many times\n    # But note: by Fermat's little theorem, if d is prime, b^(d-1)  1 (mod d) if gcd(b,d)=1\n    # So we only need to check m up to d-1\n    \n    # First handle special case where d divides b\n    if b % d == 0:\n        # If d divides b, then for any m, b^m  0 (mod d)\n        # The alternating sum becomes sum of digits with alternating signs\n        # This doesn't preserve divisibility in general\n        # Example: b=10, d=5, m=1: 15 mod 5 = 0, but 5-1=4 mod 5  0\n        print(\"no\")\n        return\n    \n    # Check m from 1 to d-1\n    # Actually, by group theory, the order of b modulo d divides d-1\n    # So we only need to check divisors of d-1\n    \n    # Find all divisors of d-1\n    divisors = []\n    limit = int(math.isqrt(d-1))\n    for i in range(1, limit + 1):\n        if (d-1) % i == 0:\n            divisors.append(i)\n            if i != (d-1)//i:\n                divisors.append((d-1)//i)\n    divisors.sort()\n    \n    # Check each divisor as potential m\n    for m in divisors:\n        # Compute b^m mod d efficiently\n        # Use modular exponentiation\n        def mod_pow(base, exp, mod):\n            result = 1\n            base %= mod\n            while exp > 0:\n                if exp & 1:\n                    result = (result * base) % mod\n                base = (base * base) % mod\n                exp >>= 1\n            return result\n        \n        bm_mod = mod_pow(b, m, d)\n        if bm_mod == 1 or bm_mod == d-1:  # d-1  -1 (mod d)\n            print(\"yes\")\n            return\n    \n    # Also need to check the case where m is a divisor of something else?\n    # Actually, if b^m  1 (mod d), then m is a multiple of the order of b modulo d\n    # We've checked all divisors of d-1, which includes all possible orders\n    \n    # One more case: what if m is such that d divides (b^m + 1)?\n    # That's covered by bm_mod == d-1\n    \n    print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 79.86770820617676}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 5, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef fenwick_update(tree, idx, delta, n):\n    \"\"\"Update Fenwick tree: add delta to element at index idx (0-based).\"\"\"\n    i = idx + 1  # convert to 1-based for Fenwick tree\n    while i <= n:\n        tree[i] += delta\n        i += i & -i\n\ndef fenwick_query(tree, idx):\n    \"\"\"Query prefix sum up to index idx (0-based, exclusive).\"\"\"\n    i = idx  # idx is already exclusive upper bound\n    res = 0\n    while i > 0:\n        res += tree[i]\n        i -= i & -i\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    # Fenwick tree (1-indexed, size n+1)\n    tree = [0] * (n + 1)\n    \n    out_lines = []\n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            fenwick_update(tree, i, delta, n)\n        else:  # op == '?'\n            i = int(next(it))\n            # query prefix sum up to i (exclusive)\n            res = fenwick_query(tree, i)\n            out_lines.append(str(res))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 103.70506024360657}

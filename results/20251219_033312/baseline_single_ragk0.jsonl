{"eval_index": 0, "problem_id": 3165, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.52700161933899}
{"eval_index": 1, "problem_id": 2012, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    c = list(map(int, data[1:1+n]))\n    \n    # Build the string\n    result = []\n    current_char = 'a'\n    i = 0\n    \n    while i < n:\n        # Find the maximum length where we need to place same characters\n        max_len = 1\n        for length in range(1, n - i + 1):\n            if length <= n and c[length-1] > 0:\n                max_len = length\n        \n        # Place max_len characters of current_char\n        for _ in range(max_len):\n            result.append(current_char)\n        \n        # Update c values\n        for length in range(1, max_len + 1):\n            c[length-1] -= (max_len - length + 1)\n        \n        # Move to next character\n        current_char = chr(ord(current_char) + 1)\n        i += max_len\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 25.700519561767578}
{"eval_index": 2, "problem_id": 4072, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a = int(data)\n    # Check if the integer is a palindrome\n    s = str(a)\n    if s == s[::-1]:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 14.320229768753052}
{"eval_index": 3, "problem_id": 3168, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(400000)\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.height = 1\n        self.size = 1\n\nclass AVLTree:\n    def __init__(self):\n        self.root = None\n        self.total_depth = 0\n        \n    def height(self, node):\n        return node.height if node else 0\n    \n    def size(self, node):\n        return node.size if node else 0\n    \n    def update(self, node):\n        if node:\n            node.height = 1 + max(self.height(node.left), self.height(node.right))\n            node.size = 1 + self.size(node.left) + self.size(node.right)\n        return node\n    \n    def rotate_right(self, y):\n        x = y.left\n        T2 = x.right\n        \n        x.right = y\n        y.left = T2\n        \n        self.update(y)\n        self.update(x)\n        return x\n    \n    def rotate_left(self, x):\n        y = x.right\n        T2 = y.left\n        \n        y.left = x\n        x.right = T2\n        \n        self.update(x)\n        self.update(y)\n        return y\n    \n    def get_balance(self, node):\n        return self.height(node.left) - self.height(node.right) if node else 0\n    \n    def insert(self, node, value, depth=0):\n        if not node:\n            self.total_depth += depth\n            return Node(value)\n        \n        if value < node.value:\n            node.left = self.insert(node.left, value, depth + 1)\n        else:\n            node.right = self.insert(node.right, value, depth + 1)\n        \n        self.update(node)\n        \n        balance = self.get_balance(node)\n        \n        if balance > 1 and value < node.left.value:\n            return self.rotate_right(node)\n        \n        if balance < -1 and value > node.right.value:\n            return self.rotate_left(node)\n        \n        if balance > 1 and value > node.left.value:\n            node.left = self.rotate_left(node.left)\n            return self.rotate_right(node)\n        \n        if balance < -1 and value < node.right.value:\n            node.right = self.rotate_right(node.right)\n            return self.rotate_left(node)\n        \n        return node\n    \n    def insert_value(self, value):\n        self.root = self.insert(self.root, value)\n        return self.total_depth\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    values = list(map(int, data[1:1+n]))\n    \n    tree = AVLTree()\n    results = []\n    \n    for value in values:\n        depth_sum = tree.insert_value(value)\n        results.append(str(depth_sum))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 37.88580083847046}
{"eval_index": 4, "problem_id": 2196, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # We'll simulate binary addition of powers of 2\n    # Use a frequency dictionary for exponents\n    freq = {}\n    for exp in a:\n        freq[exp] = freq.get(exp, 0) + 1\n    \n    added = 0\n    max_exp = max(a) if a else 0\n    \n    # Process exponents from smallest to largest\n    for exp in range(max_exp + 2):  # +2 to handle final carry\n        count = freq.get(exp, 0)\n        \n        # Process current level\n        if count > 1:\n            # Carry over to next exponent\n            carry = count // 2\n            freq[exp+1] = freq.get(exp+1, 0) + carry\n            # Remaining at this level\n            remaining = count % 2\n            freq[exp] = remaining\n            \n            # If we had to carry, we might have created a new exponent\n            if carry > 0:\n                max_exp = max(max_exp, exp+1)\n        \n        # If count is 0 or 1, no change needed\n        \n        # Check if we need to add numbers at this exponent\n        if count == 0:\n            # We need to add 2^exp to complete the binary representation\n            added += 1\n            # After adding, we have 1 at this position\n            freq[exp] = 1\n            # This might create a carry in next iteration\n            # But we'll handle it in the next loop iteration\n    \n    # The sum should be 2^v - 1, which in binary is all 1's\n    # After processing, we should have exactly 1 at each exponent from 0 to max_exp\n    # Count how many positions are missing\n    result = 0\n    for exp in range(max_exp + 1):\n        if freq.get(exp, 0) == 0:\n            result += 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 37.789520025253296}
{"eval_index": 5, "problem_id": 4483, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        return\n    X = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # First buy cake\n    remaining_after_cake = X - A\n    \n    # Then buy as many donuts as possible\n    donuts_count = remaining_after_cake // B\n    remaining_after_donuts = remaining_after_cake - (donuts_count * B)\n    \n    print(remaining_after_donuts)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 17.245457887649536}
{"eval_index": 6, "problem_id": 3666, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom itertools import permutations\n\ndef solve():\n    # Read input\n    ratios = []\n    for _ in range(12):\n        line = sys.stdin.readline().strip()\n        if not line:\n            continue\n        n_str, d_str = line.split('/')\n        n, d = int(n_str), int(d_str)\n        g = math.gcd(n, d)\n        ratios.append((n//g, d//g))\n    \n    # Try all possible front sprocket pairs (u1, u2)\n    # Since ratios are up to 100, front sprockets could be up to 10000\n    # But we can limit search based on ratios\n    possible_fronts = set()\n    for n, d in ratios:\n        # u must be multiple of n, v multiple of d\n        # Try reasonable multiples\n        for mult in range(1, 101):\n            u = n * mult\n            v = d * mult\n            if u <= 10000 and v <= 10000:\n                possible_fronts.add(u)\n    \n    # Convert to sorted list for iteration\n    front_candidates = sorted(possible_fronts)\n    \n    # Try all pairs of front sprockets\n    for i in range(len(front_candidates)):\n        for j in range(i+1, len(front_candidates)):\n            u1, u2 = front_candidates[i], front_candidates[j]\n            \n            # For each ratio, determine possible rear sprockets\n            # ratio = u/v, so v = u * d / n\n            possible_rears = []\n            valid = True\n            \n            for n, d in ratios:\n                # Try both front sprockets\n                v1_candidate = u1 * d\n                v2_candidate = u2 * d\n                \n                # Check if divisible by n\n                if v1_candidate % n == 0:\n                    v1 = v1_candidate // n\n                    if 1 <= v1 <= 10000:\n                        possible_rears.append((v1, u1))\n                        continue\n                \n                if v2_candidate % n == 0:\n                    v2 = v2_candidate // n\n                    if 1 <= v2 <= 10000:\n                        possible_rears.append((v2, u2))\n                        continue\n                \n                # If neither works, this front pair is invalid\n                valid = False\n                break\n            \n            if not valid:\n                continue\n            \n            # We have 12 possible rear sprockets (with duplicates)\n            # Need to select 6 distinct ones that cover all ratios\n            # Each ratio gives us one rear sprocket candidate\n            # We need to assign each ratio to either u1 or u2\n            # and have at most 6 distinct rear sprockets\n            \n            # Group rear sprockets by which front they came from\n            rears_from_u1 = set()\n            rears_from_u2 = set()\n            \n            for v, u in possible_rears:\n                if u == u1:\n                    rears_from_u1.add(v)\n                else:\n                    rears_from_u2.add(v)\n            \n            # Check if we have at most 6 distinct rear sprockets total\n            all_rears = rears_from_u1.union(rears_from_u2)\n            if len(all_rears) > 6:\n                continue\n            \n            # We need exactly 6 rear sprockets\n            # If we have fewer, we can add arbitrary ones (1-10000)\n            rear_list = sorted(all_rears)\n            while len(rear_list) < 6:\n                # Add smallest available number not already used\n                for k in range(1, 10001):\n                    if k not in rear_list:\n                        rear_list.append(k)\n                        rear_list.sort()\n                        break\n            \n            # Verify all ratios can be achieved with these sprockets\n            # Generate all possible ratios\n            achievable = set()\n            for u in [u1, u2]:\n                for v in rear_list:\n                    g = math.gcd(u, v)\n                    achievable.add((u//g, v//g))\n            \n            # Check if all input ratios are in achievable set\n            all_found = True\n            for ratio in ratios:\n                if ratio not in achievable:\n                    all_found = False\n                    break\n            \n            if all_found:\n                # Output solution\n                print(f\"{u1} {u2}\")\n                print(\" \".join(map(str, rear_list)))\n                return\n    \n    # No solution found\n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 96.70089387893677}
{"eval_index": 7, "problem_id": 2041, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input().strip())\n    a = list(map(int, input().split()))\n    m = int(input().strip())\n    queries = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Step 1: Sort indices by value (descending) and then by index (ascending)\n    indices = list(range(n))\n    indices.sort(key=lambda i: (-a[i], i))\n    \n    # Step 2: Preprocess for each k: store the sorted indices of the optimal subsequence\n    # We'll store for each k the list of indices in the optimal subsequence\n    # Since k ranges from 1 to n, we can compute incrementally\n    optimal_indices = [[] for _ in range(n + 1)]\n    # We'll maintain a sorted list of indices for the current optimal subsequence\n    # Start with empty and add elements one by one from sorted 'indices'\n    current_indices = []\n    for k in range(1, n + 1):\n        # Add the next best element (largest value, smallest index in case of ties)\n        idx = indices[k - 1]\n        bisect.insort(current_indices, idx)\n        optimal_indices[k] = current_indices[:]\n    \n    # Step 3: Answer queries\n    results = []\n    for k, pos in queries:\n        # The optimal subsequence for k is at indices optimal_indices[k]\n        # We need the element at position 'pos' (1-based) in this subsequence\n        idx_in_subseq = optimal_indices[k][pos - 1]\n        results.append(a[idx_in_subseq])\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.714903354644775}
{"eval_index": 8, "problem_id": 4105, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data)\n    \n    # Check if solution exists\n    if k == 1:\n        print(\"NO\")\n        return\n    \n    # For n > k*(k-1), impossible because we need n distinct pairs with b_i != g_i\n    if n > k * (k - 1):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Generate pairs using two cycles\n    # We'll alternate between two sequences to ensure all constraints\n    pairs = []\n    \n    # We'll generate all possible pairs (b, g) with b != g\n    # Then take first n of them in a specific order\n    \n    # Create a list of all possible pairs\n    all_pairs = []\n    for b in range(1, k + 1):\n        for g in range(1, k + 1):\n            if b != g:\n                all_pairs.append((b, g))\n    \n    # We need to order them so consecutive pairs differ in both b and g\n    # Strategy: Use two interleaved sequences\n    \n    # First sequence: (1,2), (2,3), (3,4), ..., (k-1,k), (k,1)\n    # Second sequence: (1,3), (2,4), (3,5), ..., (k-2,k), (k-1,1), (k,2)\n    # Interleave them\n    \n    seq1 = []\n    seq2 = []\n    \n    # Generate first sequence\n    for i in range(1, k + 1):\n        b = i\n        g = i + 1 if i < k else 1\n        seq1.append((b, g))\n    \n    # Generate second sequence (shifted by 2)\n    for i in range(1, k + 1):\n        b = i\n        g = i + 2 if i <= k - 2 else (i + 2 - k if i == k - 1 else i + 2 - k + 1)\n        seq2.append((b, g))\n    \n    # Interleave the sequences\n    result = []\n    for i in range(k):\n        result.append(seq1[i])\n        if len(result) >= n:\n            break\n        result.append(seq2[i])\n        if len(result) >= n:\n            break\n    \n    # If we still need more pairs, continue with remaining pairs\n    # from the sequences but we need to ensure no duplicates\n    # and consecutive constraints\n    \n    # Actually, the above should work for n <= 2k\n    # For larger n, we need to be more careful\n    \n    # Better approach: Generate all pairs in a systematic way\n    # that satisfies all constraints\n    \n    # Let's use a simpler constructive approach\n    result = []\n    \n    # We'll generate pairs in a cycle\n    # Start with (1,2), then increment both by 1 mod k (with b != g)\n    \n    # Generate first k pairs in one cycle\n    for i in range(min(n, k)):\n        b = (i % k) + 1\n        g = ((i + 1) % k) + 1\n        result.append((b, g))\n    \n    # If we need more pairs, use another cycle with offset\n    if n > k:\n        # We need to ensure no duplicate pairs and consecutive constraints\n        # Use pairs with difference 2\n        for i in range(min(n - k, k)):\n            b = (i % k) + 1\n            g = ((i + 2) % k) + 1\n            result.append((b, g))\n    \n    # Continue with more offsets if needed\n    offset = 3\n    while len(result) < n and offset < k:\n        for i in range(min(n - len(result), k)):\n            b = (i % k) + 1\n            g = ((i + offset) % k) + 1\n            result.append((b, g))\n        offset += 1\n    \n    # Output the first n pairs\n    for i in range(n):\n        print(f\"{result[i][0]} {result[i][1]}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1066.5860438346863}
{"eval_index": 9, "problem_id": 3962, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    guests = []\n    idx = 1\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        idx += 2\n        guests.append((l, r))\n    \n    # Sort guests by (l_i - r_i) descending\n    guests.sort(key=lambda x: x[1] - x[0])\n    \n    total_chairs = 0\n    # For each guest, add max(l_i, r_i) + 1 for themselves\n    for i, (l, r) in enumerate(guests):\n        if i == 0:\n            # First guest in circle\n            total_chairs += max(l, r) + 1\n        else:\n            # Subsequent guests: need to satisfy left requirement of current guest\n            # and right requirement of previous guest\n            prev_l, prev_r = guests[i-1]\n            total_chairs += max(l, prev_r) + 1\n    \n    # For the last guest, also need to satisfy right requirement with first guest\n    if n > 1:\n        first_l, first_r = guests[0]\n        last_l, last_r = guests[-1]\n        total_chairs += max(last_r, first_l)\n    \n    print(total_chairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 28.774301290512085}
{"eval_index": 10, "problem_id": 2751, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef prime_factors(n):\n    \"\"\"Return prime factorization of n as dict {prime: exponent}\"\"\"\n    factors = defaultdict(int)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1 if d == 2 else 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Collect all prime factors across all numbers\n    total_factors = defaultdict(int)\n    for num in arr:\n        pf = prime_factors(num)\n        for p, exp in pf.items():\n            total_factors[p] += exp\n    \n    # Step 2: Determine maximal possible GCD\n    # For each prime, we can redistribute exponents among numbers\n    # Maximal GCD exponent for prime p is floor(total_exponent[p] / n)\n    max_gcd = 1\n    for p, total_exp in total_factors.items():\n        per_num = total_exp // n\n        if per_num > 0:\n            max_gcd *= p ** per_num\n    \n    # Step 3: Calculate minimal operations needed\n    # For each prime p, we need to move exponents from numbers with excess\n    # to numbers with deficit to achieve per_num in each number\n    operations = 0\n    for p, total_exp in total_factors.items():\n        target_per_num = total_exp // n\n        if target_per_num == 0:\n            continue\n        \n        # Count how many exponents each number currently has for prime p\n        current_exps = []\n        for num in arr:\n            exp = 0\n            temp = num\n            while temp % p == 0:\n                exp += 1\n                temp //= p\n            current_exps.append(exp)\n        \n        # For numbers with excess (more than target), we need to move out\n        # Each operation moves one prime factor (exponent 1) at a time\n        for exp in current_exps:\n            if exp > target_per_num:\n                operations += exp - target_per_num\n    \n    print(f\"{max_gcd} {operations}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 36.00980758666992}
{"eval_index": 11, "problem_id": 4007, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    f = list(map(int, data[1:1+n]))\n    \n    # Arrays to track used receivers and givers\n    used = [False] * (n + 1)  # 1-indexed for receivers\n    giver_of = [0] * (n + 1)  # who gives to i\n    \n    # Process fixed preferences\n    for i in range(n):\n        if f[i] != 0:\n            used[f[i]] = True\n            giver_of[f[i]] = i + 1\n    \n    # Collect free givers (those with f[i] == 0) and free receivers\n    free_givers = []\n    free_receivers = []\n    for i in range(1, n + 1):\n        if f[i-1] == 0:\n            free_givers.append(i)\n        if not used[i]:\n            free_receivers.append(i)\n    \n    # Match free givers to free receivers\n    # Avoid self-giving by careful pairing\n    m = len(free_givers)\n    result = f[:]\n    \n    # If only one free, handle specially (shouldn't happen due to problem guarantee)\n    if m == 1:\n        # This case shouldn't occur per problem constraints\n        g = free_givers[0]\n        r = free_receivers[0]\n        result[g-1] = r\n    else:\n        # Create a permutation avoiding fixed points\n        # We'll rotate the receivers list\n        for i in range(m):\n            g = free_givers[i]\n            r = free_receivers[(i + 1) % m]\n            result[g-1] = r\n        \n        # Fix any self-giving that might occur\n        for i in range(m):\n            g = free_givers[i]\n            if result[g-1] == g:\n                # Swap with next giver\n                j = (i + 1) % m\n                g2 = free_givers[j]\n                result[g-1], result[g2-1] = result[g2-1], result[g-1]\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 30.819586992263794}
{"eval_index": 12, "problem_id": 3175, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.92357397079468}
{"eval_index": 13, "problem_id": 1732, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    l = list(map(int, data[1:1+n]))\n    c = list(map(int, data[1+n:1+2*n]))\n    \n    # Compute gcd of all lengths\n    g = 0\n    for li in l:\n        g = math.gcd(g, li)\n    if g != 1:\n        print(-1)\n        return\n    \n    # DP: dp[gcd_value] = minimal cost to achieve that gcd\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0  # Starting with gcd 0 (no cards selected)\n    \n    for i in range(n):\n        li, ci = l[i], c[i]\n        # Need to iterate over a copy since we modify dp during iteration\n        items = list(dp.items())\n        for g_val, cost in items:\n            new_g = math.gcd(g_val, li)\n            if cost + ci < dp[new_g]:\n                dp[new_g] = cost + ci\n    \n    # Answer is minimal cost to achieve gcd = 1\n    ans = dp.get(1, float('inf'))\n    print(ans if ans != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 507.86445116996765}
{"eval_index": 14, "problem_id": 4192, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    D, T, S = map(int, data)\n    # Check if time needed (D/S) is <= available time T\n    # Use integer comparison to avoid floating point issues\n    if D <= T * S:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 460.1589081287384}
{"eval_index": 15, "problem_id": 3600, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(200000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    k = int(next(it))\n    n = int(next(it))\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        d = int(next(it))\n        for _ in range(d):\n            neighbor = int(next(it)) - 1  # Convert to 0-index\n            adj[i].append(neighbor)\n    \n    # DP on tree (forest) using bipartite matching concept\n    # dp[node][0] = max drones in subtree when node not selected\n    # dp[node][1] = max drones in subtree when node selected\n    visited = [False] * n\n    dp0 = [0] * n\n    dp1 = [0] * n\n    \n    def dfs(u, parent):\n        visited[u] = True\n        dp0[u] = 0  # u not selected\n        dp1[u] = 1  # u selected (counts as 1 drone)\n        \n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u)\n            # If u not selected, we can take max of v selected or not\n            dp0[u] += max(dp0[v], dp1[v])\n            # If u selected, v must not be selected\n            dp1[u] += dp0[v]\n    \n    total_max = 0\n    for i in range(n):\n        if not visited[i]:\n            # Treat each connected component as tree (since max degree ≤ 4, but graph might not be tree)\n            # Actually, the problem doesn't guarantee tree structure, so we need independent set on general graph\n            # But constraints: n ≤ 100000, k ≤ 15 → we can use brute force on small k\n            pass\n    \n    # Since k ≤ 15, we can use brute force with pruning\n    # Represent graph as adjacency list with 0-index\n    \n    # Try all subsets of size k\n    from itertools import combinations\n    \n    nodes = list(range(n))\n    # If k > n, impossible\n    if k > n:\n        print(\"impossible\")\n        return\n    \n    # Quick check: if any node has degree > k? Not necessarily relevant\n    \n    # Generate combinations\n    for combo in combinations(nodes, k):\n        combo_set = set(combo)\n        valid = True\n        for u in combo:\n            for v in adj[u]:\n                if v in combo_set:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"possible\")\n            return\n    \n    print(\"impossible\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 74.60016369819641}
{"eval_index": 16, "problem_id": 2891, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nlines = sys.stdin.read().strip().split()\nif not lines:\n    sys.exit(0)\nn = int(lines[0])\nc = list(map(int, lines[1:1+n]))\n\n# Total number of people\nP = sum(c)\n\n# Precompute factorials and log factorials up to max(P, 365)\nmax_val = max(P, 365)\nlog_fact = [0.0] * (max_val + 1)\nfor i in range(1, max_val + 1):\n    log_fact[i] = log_fact[i-1] + math.log10(i)\n\n# Compute log probability\nlog_prob = 0.0\n\n# First term: choose birthdays for each group\nlog_prob += log_fact[365] - log_fact[365 - n]\n\n# Second term: multinomial coefficient for arranging people into groups\nlog_prob -= log_fact[P]\nfor ci in c:\n    log_prob += log_fact[ci]\n\n# Third term: each person's birthday is uniformly random among 365 days\nlog_prob -= P * math.log10(365)\n\nprint(f\"{log_prob:.15f}\")", "runtime_sec": 59.142045974731445}
{"eval_index": 17, "problem_id": 4873, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return 0\n    \n    W, H = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+H]]\n    \n    # Find player start position\n    start = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'P':\n                start = (i, j)\n                break\n        if start:\n            break\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to explore reachable safe squares\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    gold_count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Collect gold if present\n        if grid[x][y] == 'G':\n            gold_count += 1\n        \n        # Check if any adjacent square is a trap\n        has_adjacent_trap = False\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == 'T':\n                has_adjacent_trap = True\n                break\n        \n        # If adjacent to trap, don't move further from this square\n        if has_adjacent_trap:\n            continue\n        \n        # Explore neighbors\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny]:\n                # Don't move into walls or traps\n                if grid[nx][ny] != '#' and grid[nx][ny] != 'T':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    \n    print(gold_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 109.28766059875488}
{"eval_index": 18, "problem_id": 3007, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.44977021217346}
{"eval_index": 19, "problem_id": 938, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data)\n    \n    # Find maximum k such that sum_{i=1}^{k} i <= a + b\n    total_hours = a + b\n    k = 0\n    low, high = 0, int(2e9)  # Upper bound for k\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * (mid + 1) // 2 <= total_hours:\n            k = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Generate all notes from 1 to k\n    all_notes = list(range(1, k + 1))\n    \n    # Greedy selection for first day\n    first_day = []\n    remaining_a = a\n    for note in reversed(all_notes):\n        if note <= remaining_a:\n            first_day.append(note)\n            remaining_a -= note\n    first_day.sort()\n    \n    # Notes for second day are the remaining ones\n    first_set = set(first_day)\n    second_day = [note for note in all_notes if note not in first_set]\n    \n    # Output\n    print(len(first_day))\n    if first_day:\n        print(' '.join(map(str, first_day)))\n    else:\n        print()\n    print(len(second_day))\n    if second_day:\n        print(' '.join(map(str, second_day)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 67.16048288345337}
{"eval_index": 20, "problem_id": 4907, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    \n    # Check if n is a power of two\n    # If (n & (n - 1)) == 0, then n is power of two\n    if (n & (n - 1)) == 0:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\n        # Find the largest power of two less than n\n        # This will be a winning move for Alice\n        power_of_two = 1\n        while power_of_two * 2 < n:\n            power_of_two *= 2\n        print(power_of_two)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 56.78933906555176}
{"eval_index": 21, "problem_id": 3128, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    Q = int(data[0])\n    idx = 1\n    \n    # Fenwick tree for prefix sums\n    class FenwickTree:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 2)\n        \n        def update(self, i, delta):\n            i += 1\n            while i <= self.n + 1:\n                self.bit[i] += delta\n                i += i & -i\n        \n        def query(self, i):\n            i += 1\n            res = 0\n            while i > 0:\n                res += self.bit[i]\n                i -= i & -i\n            return res\n        \n        def find_kth(self, k):\n            # Find smallest idx such that prefix sum >= k\n            idx = 0\n            bit_mask = 1 << (self.n.bit_length())\n            while bit_mask:\n                next_idx = idx + bit_mask\n                if next_idx <= self.n + 1 and self.bit[next_idx] < k:\n                    k -= self.bit[next_idx]\n                    idx = next_idx\n                bit_mask >>= 1\n            return idx  # 0-based\n    \n    # We'll maintain two structures:\n    # 1. plot_to_creation: list of creation indices in plot order\n    # 2. fenwick tree to track available positions\n    \n    # Maximum possible movies: Q (since each query can add at most 1 movie)\n    max_movies = Q\n    ft = FenwickTree(max_movies)\n    \n    # Initially all positions are available (1 means available)\n    for i in range(max_movies):\n        ft.update(i, 1)\n    \n    plot_to_creation = []\n    creation_counter = 1\n    output = []\n    \n    for _ in range(Q):\n        q = int(data[idx]); idx += 1\n        x = int(data[idx]); idx += 1\n        \n        if q == 1:\n            # Insert movie at plot position x (1-based)\n            # Find the x-th available position (0-based)\n            pos = ft.find_kth(x)\n            # Mark this position as occupied\n            ft.update(pos, -1)\n            # Insert creation index at this position\n            if pos < len(plot_to_creation):\n                plot_to_creation.insert(pos, creation_counter)\n            else:\n                plot_to_creation.append(creation_counter)\n            creation_counter += 1\n        else:  # q == 2\n            # Query creation index of movie at plot position x (1-based)\n            output.append(str(plot_to_creation[x - 1]))\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 75.36596035957336}
{"eval_index": 22, "problem_id": 2063, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef can_achieve(target, n, m, w, heights):\n    \"\"\"Check if we can make all flowers at least target height within m days.\"\"\"\n    # Difference array for range updates\n    diff = [0] * (n + 1)\n    days_used = 0\n    current = 0\n    \n    for i in range(n):\n        current += diff[i]\n        height = heights[i] + current\n        \n        if height < target:\n            needed = target - height\n            days_used += needed\n            if days_used > m:\n                return False\n            \n            # Water w contiguous flowers starting at i\n            current += needed\n            if i + w <= n:\n                diff[i + w] -= needed\n    \n    return days_used <= m\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n, m, w = map(int, data[:3])\n    heights = list(map(int, data[3:3 + n]))\n    \n    # Binary search for maximum achievable minimum height\n    low = min(heights)\n    high = min(heights) + m  # Upper bound: we can at most add m to min height\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_achieve(mid, n, m, w, heights):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(high)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 346.8230810165405}
{"eval_index": 23, "problem_id": 4807, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, Y, N = map(int, data)\n    \n    for i in range(1, N + 1):\n        if i % X == 0 and i % Y == 0:\n            print(\"FizzBuzz\")\n        elif i % X == 0:\n            print(\"Fizz\")\n        elif i % Y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 132.80511212348938}
{"eval_index": 24, "problem_id": 3259, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 99.01420474052429}
{"eval_index": 25, "problem_id": 1233, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef insertion_sort_swaps(arr):\n    \"\"\"Return number of swaps in insertion sort on array arr.\"\"\"\n    n = len(arr)\n    swaps = 0\n    for i in range(1, n):\n        j = i\n        while j > 0 and arr[j] < arr[j - 1]:\n            swaps += 1\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            j -= 1\n    return swaps\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    perm = list(map(int, data[1:1 + n]))\n    \n    # Step 1: Compute original swaps\n    original_swaps = insertion_sort_swaps(perm.copy())\n    \n    # Step 2: Precompute inversions for each element\n    # inv_count[i] = number of elements before i that are greater than perm[i]\n    inv_count = [0] * n\n    for i in range(n):\n        cnt = 0\n        for j in range(i):\n            if perm[j] > perm[i]:\n                cnt += 1\n        inv_count[i] = cnt\n    \n    # Step 3: Precompute contributions\n    # contrib[i] = inv_count[i] + (number of elements after i that are smaller than perm[i])\n    contrib = [0] * n\n    for i in range(n):\n        smaller_after = 0\n        for j in range(i + 1, n):\n            if perm[j] < perm[i]:\n                smaller_after += 1\n        contrib[i] = inv_count[i] + smaller_after\n    \n    # Step 4: Find best swap\n    best_improvement = 0\n    best_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute change in swaps if we swap perm[i] and perm[j]\n            # Improvement = reduction in swaps\n            improvement = 0\n            \n            # Contribution from i and j themselves\n            improvement += contrib[i] + contrib[j]\n            \n            # Adjust for double-counted pair (i, j)\n            if perm[i] > perm[j]:\n                improvement -= 1  # They were counted as one inversion\n            \n            # Adjust for elements between i and j\n            for k in range(i + 1, j):\n                if perm[i] > perm[k] > perm[j]:\n                    improvement -= 2  # Both directions change\n                elif perm[j] > perm[k] > perm[i]:\n                    improvement += 2  # Both directions change\n                # Cases where only one direction changes are handled by contrib\n            \n            # Compare with best\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_count = 1\n            elif improvement == best_improvement:\n                best_count += 1\n    \n    # Minimum swaps after best swap\n    min_swaps = original_swaps - best_improvement\n    print(f\"{min_swaps} {best_count}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 79.93382811546326}
{"eval_index": 26, "problem_id": 4396, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    total = 0.0\n    \n    # Process each gift\n    idx = 1\n    for _ in range(n):\n        x_str = data[idx]\n        u = data[idx + 1]\n        idx += 2\n        \n        if u == \"JPY\":\n            total += float(x_str)\n        else:  # BTC\n            # Convert BTC to JPY at rate 380000.0 JPY per BTC\n            total += float(x_str) * 380000.0\n    \n    # Print result with sufficient precision\n    print(f\"{total:.10f}\".rstrip('0').rstrip('.'))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 52.967480421066284}
{"eval_index": 27, "problem_id": 3755, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 245050 tokens (243450 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 9.225496292114258}
{"eval_index": 28, "problem_id": 225, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total % 2 != 0:\n        print(\"NO\")\n        return\n    target = total // 2\n    # Check all subsets of size 1, 2, or 3 (since 4 would give total sum)\n    # We can use bitmask for 4 elements (0 to 15)\n    for mask in range(1, 16):  # exclude empty subset\n        subset_sum = 0\n        for i in range(4):\n            if mask & (1 << i):\n                subset_sum += a[i]\n        if subset_sum == target:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2854.9948103427887}
{"eval_index": 29, "problem_id": 4086, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    seen = set()\n    result = []\n    for i in range(n-1, -1, -1):\n        if arr[i] not in seen:\n            seen.add(arr[i])\n            result.append(arr[i])\n    result.reverse()\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1147.58931016922}
{"eval_index": 30, "problem_id": 3186, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 10**6 + 7\n\ndef modinv(a, mod=MOD):\n    return pow(a, mod-2, mod)\n\ndef nCr_mod(n, r, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    r = min(r, n-r)\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n-i)) % mod\n        denominator = (denominator * (i+1)) % mod\n    return (numerator * modinv(denominator)) % mod\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, M, K = map(int, data[:3])\n    \n    if K > N * M:\n        print(0)\n        return\n    \n    # Using inclusion-exclusion principle\n    result = 0\n    sign = 1\n    for i in range(N+1):\n        if K - i*(M+1) < 0:\n            break\n        term = (nCr_mod(N, i) * nCr_mod(N + K - i*(M+1) - 1, N-1)) % MOD\n        result = (result + sign * term) % MOD\n        sign = -sign\n    \n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 67.12344980239868}
{"eval_index": 31, "problem_id": 2802, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Parse input\n    t1, t2, t3, t4 = map(float, data[:4])\n    target = float(data[4])\n    \n    # Sort first four times\n    times = sorted([t1, t2, t3, t4])\n    \n    # Helper function to calculate final score given fifth time\n    def calculate_final(fifth):\n        all_times = times + [fifth]\n        all_times.sort()\n        # Discard best (smallest) and worst (largest)\n        middle_three = all_times[1:4]\n        return sum(middle_three) / 3.0\n    \n    # Case 1: Check if already winning with worst possible last solve (20.00)\n    worst_final = calculate_final(20.0)\n    if worst_final <= target:\n        print(\"infinite\")\n        return\n    \n    # Case 2: Check if impossible even with best possible last solve (1.00)\n    best_final = calculate_final(1.0)\n    if best_final > target:\n        print(\"impossible\")\n        return\n    \n    # Case 3: Binary search for threshold time\n    lo, hi = 1.0, 20.0\n    eps = 1e-9\n    \n    for _ in range(100):  # Sufficient iterations for precision\n        mid = (lo + hi) / 2.0\n        final_score = calculate_final(mid)\n        if final_score <= target:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Output with exactly 2 decimal places\n    print(f\"{lo:.2f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 151.40166068077087}
{"eval_index": 32, "problem_id": 4351, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def main():\n    N = input().strip()\n    if N == N[::-1]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 414.58294796943665}
{"eval_index": 33, "problem_id": 3840, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # For n=1, no move is possible because 2*x+1 <= n cannot be satisfied for any positive integer x\n    if n == 1:\n        print(-1)\n        return\n    \n    # For n=2, check if any move is possible\n    # x must satisfy: 2*x+1 <= 2 => x <= 0.5, but x must be positive integer, so no move\n    if n == 2:\n        print(-1)\n        return\n    \n    # For n>=3, we can use dynamic programming\n    # dp[i][j] = minimum moves to reduce chest i to j coins\n    # But we need to consider all chests simultaneously\n    \n    # Observation: The moves affect chests in a tree-like structure\n    # For x, it affects chests x, 2x, 2x+1\n    # This forms a binary tree structure\n    \n    # We can process from leaves to root\n    # For each node i, we need to consider how many times we use moves that affect it\n    # A move with x = i affects chest i\n    # A move with x = floor(i/2) affects chest i if i is even or odd\n    \n    # Let's think differently: For each x, we can use it multiple times\n    # The problem reduces to finding non-negative integers k_x for each valid x\n    # such that for each chest i:\n    # a_i >= sum_{x where move x affects chest i} k_x\n    # And we want to minimize sum k_x\n    \n    # This is a linear programming problem, but with small constraints we can use DP\n    \n    # Let max_coins = max(a) which is at most 1000\n    # n is at most 100\n    \n    # We'll use DP on the tree structure\n    # For each node i, we'll consider how many moves with x = i we make\n    # and how many moves from parent affect it\n    \n    # Build tree: parent of i is floor(i/2) for i > 1\n    children = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        parent = i // 2\n        children[parent].append(i)\n    \n    # DP state: dp[i][m] = minimum total moves in subtree rooted at i\n    # when we make m moves with x = i\n    # But we need to track how moves propagate\n    \n    # Better approach: Process from leaves upward\n    # For leaf nodes (no children), we must use moves with x = i to reduce a_i\n    # But wait, leaves can also be affected by parent moves\n    \n    # Actually, let's think about it as a flow problem\n    # Each move with x reduces chests x, 2x, 2x+1 by 1 each\n    # So we need to cover all a_i with these patterns\n    \n    # Since n <= 100 and a_i <= 1000, we can use BFS/DP on states\n    # But state space would be huge (100^1000)\n    \n    # Alternative: This is actually a bipartite matching problem\n    # Each move covers 3 chests, we need to cover all coins\n    # But coins are indistinguishable, so it's about counts\n    \n    # Let's try a greedy approach: always use the largest possible x\n    # But need to prove optimality\n    \n    # Actually, let's implement a DP that processes from n down to 1\n    # For each x from floor(n/2) down to 1:\n    # We can use move x to reduce chests x, 2x, 2x+1\n    # The optimal number of times to use move x is min(a_x, a_2x, a_2x+1)\n    # But this might not be optimal because using move x affects multiple chests\n    \n    # Let's try the following algorithm:\n    total_moves = 0\n    \n    # Process from largest x to smallest\n    for x in range(n//2, 0, -1):\n        if 2*x + 1 <= n:\n            # Chests affected: x, 2x, 2x+1\n            # We can use this move min(a[x-1], a[2*x-1], a[2*x]) times\n            times = min(a[x-1], a[2*x-1], a[2*x])\n            total_moves += times\n            a[x-1] -= times\n            a[2*x-1] -= times\n            a[2*x] -= times\n        elif 2*x <= n:\n            # Only chests x and 2x exist\n            times = min(a[x-1], a[2*x-1])\n            total_moves += times\n            a[x-1] -= times\n            a[2*x-1] -= times\n    \n    # Check if all chests are empty\n    if all(coin == 0 for coin in a):\n        print(total_moves)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 136.11968326568604}
{"eval_index": 34, "problem_id": 2912, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    \n    # Read initial strings\n    strings = [\"\"] * (n + 1)  # 1-based indexing\n    for i in range(1, n + 1):\n        strings[i] = data[idx]; idx += 1\n    \n    # Process operations\n    for _ in range(n - 1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        strings[a] += strings[b]\n        strings[b] = \"\"\n    \n    # Find the non-empty string\n    for s in strings:\n        if s:\n            sys.stdout.write(s)\n            break\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 95.11204838752747}
{"eval_index": 35, "problem_id": 4381, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    # Total cost = train fare + half of bus fare\n    total = X + Y // 2\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 374.85398745536804}
{"eval_index": 36, "problem_id": 3570, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    lines = data[1:]\n    \n    # Stack to track events that have actually happened\n    actual_stack = []\n    # Set of events that are currently considered to have happened\n    actual_set = set()\n    # List to store output lines\n    output = []\n    \n    for line in lines:\n        parts = line.split()\n        if parts[0] == 'E':\n            # Event happens\n            event = parts[1]\n            actual_stack.append(event)\n            actual_set.add(event)\n        elif parts[0] == 'D':\n            # Dream: remove last r events\n            r = int(parts[1])\n            for _ in range(r):\n                if actual_stack:\n                    removed = actual_stack.pop()\n                    actual_set.remove(removed)\n        elif parts[0] == 'S':\n            # Scenario\n            k = int(parts[1])\n            scenario_events = parts[2:]\n            \n            # Check if scenario is consistent with current actual events\n            consistent_with_actual = True\n            for ev in scenario_events:\n                if ev.startswith('!'):\n                    # Event should NOT have happened\n                    event_name = ev[1:]\n                    if event_name in actual_set:\n                        consistent_with_actual = False\n                        break\n                else:\n                    # Event should have happened\n                    if ev not in actual_set:\n                        consistent_with_actual = False\n                        break\n            \n            if consistent_with_actual:\n                output.append(\"Yes\")\n                continue\n            \n            # If not consistent with actual, check if we can find smallest r\n            # such that after dreaming away last r events, scenario becomes consistent\n            # We need to consider events in reverse order (from most recent to oldest)\n            # to find the minimal r\n            \n            # Create a copy of the stack to simulate dreaming\n            stack_copy = actual_stack.copy()\n            set_copy = actual_set.copy()\n            \n            found_r = None\n            # Try dreaming away 1, 2, ... events until scenario becomes consistent\n            # or we run out of events\n            for r in range(1, len(stack_copy) + 1):\n                # Remove last r events from the copy\n                for _ in range(r):\n                    if stack_copy:\n                        removed = stack_copy.pop()\n                        set_copy.remove(removed)\n                \n                # Check consistency with this dreamed state\n                consistent = True\n                for ev in scenario_events:\n                    if ev.startswith('!'):\n                        event_name = ev[1:]\n                        if event_name in set_copy:\n                            consistent = False\n                            break\n                    else:\n                        if ev not in set_copy:\n                            consistent = False\n                            break\n                \n                if consistent:\n                    found_r = r\n                    break\n                \n                # Reset the copy for next r\n                stack_copy = actual_stack.copy()\n                set_copy = actual_set.copy()\n            \n            if found_r is not None:\n                output.append(f\"{found_r} Just A Dream\")\n            else:\n                output.append(\"Plot Error\")\n    \n    sys.stdout.write('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 120.36730408668518}
{"eval_index": 37, "problem_id": 865, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 213627 tokens (212027 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 9.930731773376465}
{"eval_index": 38, "problem_id": 4293, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    # Read input from standard input\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    P, Q, R = map(int, data)\n    \n    # The route consists of two consecutive flights between three airports\n    # There are 3 possible pairs of flights (excluding staying at same airport):\n    # 1. A->B then B->C = P + Q\n    # 2. A->C then C->B = R + Q\n    # 3. B->A then A->C = P + R\n    # Since flights are bidirectional, these cover all possible routes\n    \n    # Calculate all three possible sums\n    sums = [P + Q, Q + R, R + P]\n    \n    # Find and print the minimum\n    print(min(sums))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 501.31820940971375}
{"eval_index": 39, "problem_id": 3298, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import Counter\n\nMOD = 10**9 + 9\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies\n    freq = Counter(arr)\n    freq_list = sorted(freq.items())\n    m = len(freq_list)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    # Fermat's little theorem for modular inverse\n    inv_fact[n] = pow(fact[n], MOD-2, MOD)\n    for i in range(n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # DP array: dp[i][j] = ways to arrange first i distinct values with j \"sorted\" positions\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 1\n    \n    total_used = 0\n    for i in range(1, m + 1):\n        val, cnt = freq_list[i-1]\n        for j in range(n + 1):\n            if dp[i-1][j] == 0:\n                continue\n            # Try placing k copies of current value in \"sorted\" positions\n            for k in range(min(cnt, j) + 1):\n                # Choose which sorted positions get this value\n                ways_choose = fact[j] * inv_fact[k] % MOD * inv_fact[j-k] % MOD\n                # Arrange remaining cnt-k copies among non-sorted positions\n                non_sorted_positions = total_used - j + cnt - k\n                if non_sorted_positions < 0:\n                    continue\n                ways_arrange = fact[non_sorted_positions] * inv_fact[cnt-k] % MOD\n                ways = dp[i-1][j] * ways_choose % MOD * ways_arrange % MOD\n                new_j = j - k + (cnt - k)  # Update sorted positions\n                dp[i][new_j] = (dp[i][new_j] + ways) % MOD\n        total_used += cnt\n    \n    # Answer is dp[m][0] (no sorted elements)\n    print(dp[m][0] % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 76.27731990814209}
{"eval_index": 40, "problem_id": 2836, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    boys = list(map(int, data[1:1+N]))\n    A = int(data[1+N])\n    B = int(data[1+N+1])\n    \n    # Sort boys for binary search\n    boys.sort()\n    \n    # Helper to find closest boy distance for a candidate X\n    def min_distance_to_boys(x):\n        import bisect\n        idx = bisect.bisect_left(boys, x)\n        min_dist = float('inf')\n        if idx < N:\n            min_dist = min(min_dist, abs(boys[idx] - x))\n        if idx > 0:\n            min_dist = min(min_dist, abs(boys[idx-1] - x))\n        return min_dist\n    \n    best_x = -1\n    best_dist = -1\n    \n    # Check all odd numbers in [A, B]\n    # Start from first odd in range\n    start = A if A % 2 == 1 else A + 1\n    for x in range(start, B + 1, 2):\n        dist = min_distance_to_boys(x)\n        if dist > best_dist:\n            best_dist = dist\n            best_x = x\n    \n    print(best_x)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 144.67260098457336}
{"eval_index": 41, "problem_id": 4636, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        left = 0\n        right = n - 1\n        alice_total = 0\n        bob_total = 0\n        alice_last = 0\n        bob_last = 0\n        moves = 0\n        turn_alice = True\n        \n        while left <= right:\n            moves += 1\n            current_sum = 0\n            \n            if turn_alice:\n                # Alice's turn: eat from left\n                while left <= right and current_sum <= bob_last:\n                    current_sum += a[left]\n                    left += 1\n                alice_total += current_sum\n                alice_last = current_sum\n            else:\n                # Bob's turn: eat from right\n                while left <= right and current_sum <= alice_last:\n                    current_sum += a[right]\n                    right -= 1\n                bob_total += current_sum\n                bob_last = current_sum\n            \n            turn_alice = not turn_alice\n        \n        results.append(f\"{moves} {alice_total} {bob_total}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 102.36196064949036}
{"eval_index": 42, "problem_id": 3787, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, A, B = map(int, data)\n    \n    # Check necessary condition: A * B >= N and A + B <= N + 1\n    if A * B < N or A + B > N + 1:\n        print(-1)\n        return\n    \n    # Construct sequence using the block decomposition method\n    result = []\n    remaining = N\n    \n    # First, create B blocks where each block is decreasing\n    # The first (B-1) blocks will have size A (or less if needed)\n    # The last block will contain the remaining elements\n    \n    # Determine sizes of blocks\n    block_sizes = []\n    for i in range(B):\n        # Calculate how many elements this block should have\n        # We want to maximize block sizes while ensuring we have enough blocks\n        max_possible = min(A, remaining - (B - i - 1))\n        if max_possible <= 0:\n            # This shouldn't happen if condition is satisfied\n            print(-1)\n            return\n        block_sizes.append(max_possible)\n        remaining -= max_possible\n    \n    # If there are remaining elements (should be 0 if condition satisfied)\n    if remaining > 0:\n        print(-1)\n        return\n    \n    # Build the sequence\n    current = 1\n    for size in block_sizes:\n        # Create a decreasing block of 'size' elements\n        block_end = current + size - 1\n        for num in range(block_end, current - 1, -1):\n            result.append(num)\n        current = block_end + 1\n    \n    # Verify we have exactly N elements\n    if len(result) != N:\n        print(-1)\n        return\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 68.76781964302063}
{"eval_index": 43, "problem_id": 370, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    # Handle negative coordinates by working with absolute values\n    sign_x = 1 if X >= 0 else -1\n    sign_y = 1 if Y >= 0 else -1\n    x = abs(X)\n    y = abs(Y)\n    \n    # Total Manhattan distance to target\n    total_dist = x + y\n    \n    # Check if impossible\n    if K % 2 == 0 and total_dist % 2 == 1:\n        print(-1)\n        return\n    if total_dist % K == 0:\n        steps = total_dist // K\n    else:\n        steps = total_dist // K + 1\n        # Adjust steps if parity doesn't match\n        if (steps * K - total_dist) % 2 == 1:\n            steps += 1\n    \n    # Generate path\n    path = []\n    current_x = 0\n    current_y = 0\n    remaining_x = x\n    remaining_y = y\n    remaining_steps = steps\n    \n    for i in range(steps):\n        move_dist = K\n        # Determine how much to move in x and y directions\n        if remaining_x > 0:\n            move_x = min(remaining_x, move_dist)\n            move_dist -= move_x\n            remaining_x -= move_x\n        else:\n            move_x = 0\n        \n        if move_dist > 0 and remaining_y > 0:\n            move_y = min(remaining_y, move_dist)\n            move_dist -= move_y\n            remaining_y -= move_y\n        else:\n            move_y = 0\n        \n        # If we still have distance to cover, adjust by moving back/forth\n        if move_dist > 0:\n            if remaining_steps > 1:\n                # Move back and forth to consume remaining distance\n                if move_x > 0:\n                    move_x -= move_dist\n                else:\n                    move_y -= move_dist\n            else:\n                # Last step, ensure we reach target exactly\n                if remaining_x == 0 and remaining_y == 0:\n                    move_x = 0\n                    move_y = 0\n                else:\n                    # This shouldn't happen if steps calculation is correct\n                    pass\n        \n        # Update current position with signs\n        current_x += move_x * sign_x\n        current_y += move_y * sign_y\n        path.append((current_x, current_y))\n        remaining_steps -= 1\n    \n    # Output result\n    print(steps)\n    for px, py in path:\n        print(f\"{px} {py}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 74.60262322425842}
{"eval_index": 44, "problem_id": 4575, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    D = int(data[idx]); idx += 1\n    X = int(data[idx]); idx += 1\n    \n    total_eaten = 0\n    for _ in range(N):\n        A = int(data[idx]); idx += 1\n        # Days when participant eats: 1, A+1, 2A+1, ... while <= D\n        # Number of eating days = floor((D-1)/A) + 1\n        days = (D - 1) // A + 1\n        total_eaten += days\n    \n    # Initial chocolate = eaten + remaining\n    initial = total_eaten + X\n    print(initial)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 136.50980186462402}
{"eval_index": 45, "problem_id": 3243, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * n\n    components = []\n    \n    # DFS to find connected components\n    for i in range(n):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp = []\n            while stack:\n                node = stack.pop()\n                comp.append(node)\n                for neighbor in adj[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        stack.append(neighbor)\n            components.append(comp)\n    \n    # If already one component, answer is yes\n    if len(components) == 1:\n        print(\"yes\")\n        return\n    \n    # Calculate needed connections and possible removals\n    needed_connections = len(components) - 1\n    \n    # Count total sockets and used sockets\n    total_sockets = sum(capacities)\n    used_sockets = 2 * m  # each edge uses 2 sockets\n    \n    # Maximum possible new connections we can add\n    max_possible_new = (total_sockets - used_sockets) // 2\n    \n    # Check if we have enough capacity for needed connections\n    if needed_connections > max_possible_new:\n        print(\"no\")\n        return\n    \n    # Calculate minimum edits needed\n    # We need to add at least needed_connections edges\n    # But we might remove some edges first if beneficial\n    # Strategy: remove edges within components to free sockets for inter-component connections\n    \n    # Count edges that can be removed (edges within components)\n    removable_edges = 0\n    for comp in components:\n        comp_set = set(comp)\n        edge_count = 0\n        for node in comp:\n            for neighbor in adj[node]:\n                if neighbor in comp_set and neighbor > node:  # count each edge once\n                    edge_count += 1\n        # In a tree, we need |comp|-1 edges to keep it connected\n        # Any extra edges can be removed\n        if edge_count > len(comp) - 1:\n            removable_edges += edge_count - (len(comp) - 1)\n    \n    # Minimum edits calculation\n    # We need to add needed_connections edges\n    # But each removal saves us 1 edit (since we remove instead of adding)\n    # Actually, removing an edge costs 1 edit, but frees 2 sockets for new connections\n    # So we need to consider the trade-off\n    \n    # Simple approach: check if needed_connections <= k\n    # But we also need to consider socket constraints\n    \n    # We need to connect all components into one\n    # Each new connection uses 2 sockets\n    # We have max_possible_new possible new connections based on socket capacity\n    \n    if needed_connections <= k and needed_connections <= max_possible_new:\n        print(\"yes\")\n    else:\n        # Check if we can remove edges to free sockets for more connections\n        # Each removal gives us 2 more socket capacity\n        additional_from_removals = min(removable_edges, k)  # we can remove at most k edges\n        max_possible_with_removals = max_possible_new + additional_from_removals\n        \n        # Minimum edits needed considering we might need to remove edges first\n        # Worst case: we need to remove edges to free sockets, then add connections\n        if needed_connections <= max_possible_with_removals and needed_connections <= k + additional_from_removals:\n            print(\"yes\")\n        else:\n            print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 131.3340721130371}
{"eval_index": 46, "problem_id": 2249, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for num in a:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Get all distinct numbers\n    distinct_nums = list(freq.keys())\n    m = len(distinct_nums)\n    \n    # Precompute prefix sums of frequencies\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i+1] = prefix_sum[i] + freq[distinct_nums[i]]\n    \n    total_pairs = 0\n    \n    # For each possible p (first robot's number)\n    for i in range(m):\n        p = distinct_nums[i]\n        # Find the rightmost position where p appears\n        # Since we need first robot to stop at its rightmost occurrence\n        # The second robot must stop at a position > that index\n        \n        # Count of numbers to the right of rightmost p\n        # Total elements - (prefix sum up to p's last occurrence)\n        # The rightmost p is at position: prefix_sum[i] + freq[p] - 1\n        # So elements to the right = n - (prefix_sum[i] + freq[p])\n        \n        # But we need distinct q values that appear to the right\n        # Actually, we need to count all possible q values\n        # where the leftmost occurrence of q is > rightmost occurrence of p\n        \n        # For each q, we need to check if min_index(q) > max_index(p)\n        # We can precompute first and last occurrences\n        \n        # Instead, let's think differently:\n        # For a given p, valid q are those where the first occurrence of q\n        # is after the last occurrence of p\n        \n        # Precompute first and last occurrences\n        first_occurrence = {}\n        last_occurrence = {}\n        for idx, num in enumerate(a):\n            if num not in first_occurrence:\n                first_occurrence[num] = idx\n            last_occurrence[num] = idx\n    \n    # Now count valid pairs\n    total_pairs = 0\n    for p in distinct_nums:\n        p_last = last_occurrence[p]\n        for q in distinct_nums:\n            q_first = first_occurrence[q]\n            if q_first > p_last:\n                total_pairs += 1\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 79.58563804626465}
{"eval_index": 47, "problem_id": 4250, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = list(map(int, data[2:2+n]))\n    \n    # Count frequencies of each element in s\n    freq = {}\n    for num in s:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Convert to list of (value, count) and sort by value\n    items = sorted(freq.items())\n    \n    # Binary search for maximum number of copies\n    def can_make_copies(x):\n        \"\"\"Check if we can make x copies of some array t of length k\"\"\"\n        total_available = 0\n        for _, cnt in items:\n            total_available += cnt // x\n            if total_available >= k:\n                return True\n        return False\n    \n    # Binary search bounds\n    low, high = 1, n // k\n    best_x = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_make_copies(mid):\n            best_x = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Construct t using best_x\n    t = []\n    for val, cnt in items:\n        take = cnt // best_x\n        if take > 0:\n            t.extend([val] * min(take, k - len(t)))\n        if len(t) >= k:\n            break\n    \n    # Output t\n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 553.2161605358124}
{"eval_index": 48, "problem_id": 3257, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.00765085220337}
{"eval_index": 49, "problem_id": 843, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    directions = data[1]\n    jumps = list(map(int, data[2:2+n]))\n    \n    visited = [False] * n\n    pos = 0\n    \n    while 0 <= pos < n:\n        if visited[pos]:\n            print(\"INFINITE\")\n            return\n        visited[pos] = True\n        \n        if directions[pos] == '>':\n            pos += jumps[pos]\n        else:  # '<'\n            pos -= jumps[pos]\n    \n    print(\"FINITE\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1270.9963698387146}
{"eval_index": 50, "problem_id": 4340, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    result = []\n    for x in arr:\n        if x % 2 == 0:\n            result.append(x - 1)\n        else:\n            result.append(x)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 424.01825881004333}
{"eval_index": 51, "problem_id": 3055, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n = int(data[0])\n    names = data[1:1+n]\n    \n    thore_index = -1\n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_index = i\n            break\n    \n    # Case 1: Thore is first\n    if thore_index == 0:\n        print(\"Thore is awesome\")\n        return\n    \n    # Check if any name above Thore has \"ThoreHusfeld\" as prefix\n    above_names = names[:thore_index]\n    for name in above_names:\n        if name.startswith(\"ThoreHusfeld\"):\n            print(\"Thore sucks\")\n            return\n    \n    # Find smallest unique prefix\n    thore_name = \"ThoreHusfeldt\"\n    for prefix_len in range(1, len(thore_name) + 1):\n        prefix = thore_name[:prefix_len]\n        unique = True\n        for name in above_names:\n            if name.startswith(prefix):\n                unique = False\n                break\n        if unique:\n            print(prefix)\n            return\n    \n    # Should not reach here given problem constraints\n    print(thore_name)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 185.09325122833252}
{"eval_index": 52, "problem_id": 2492, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef count_pairs_less_equal(x, A, pos, neg, zero):\n    \"\"\"Count number of pairs with product <= x\"\"\"\n    cnt = 0\n    n = len(A)\n    \n    # Case 1: both numbers are positive\n    if x >= 0:\n        # Count pairs where both are positive and product <= x\n        for i, a in enumerate(pos):\n            if a == 0:\n                continue\n            # Find max j such that pos[i] * pos[j] <= x\n            # Since pos is sorted ascending, for positive numbers:\n            # if a > 0: we need pos[j] <= x // a\n            max_val = x // a if a > 0 else float('inf')\n            j = bisect.bisect_right(pos, max_val, i+1)\n            cnt += max(0, j - (i+1))\n    \n    # Case 2: both numbers are negative\n    if x >= 0:\n        # For x >= 0, all negative*negative products are positive (>= 0)\n        # So all negative pairs satisfy product <= x when x >= 0\n        m = len(neg)\n        cnt += m * (m-1) // 2\n    else:\n        # For x < 0, need negative pairs with product <= x\n        # Since neg is sorted ascending (most negative first)\n        # For two negatives a < b < 0: a*b >= 0 when sorted this way\n        # Actually need to handle carefully: product of two negatives is positive\n        # Wait, if both are negative, product is positive, so can't be <= negative x\n        # So no negative pairs contribute when x < 0\n        pass\n    \n    # Case 3: one positive, one negative\n    if x >= 0:\n        # For x >= 0, all pos*neg products are <= 0 <= x\n        cnt += len(pos) * len(neg)\n    else:\n        # For x < 0, need pos*neg <= x\n        # Since neg is negative and pos is positive\n        # For each positive p, need negative n such that p*n <= x\n        # => n <= x // p (integer division with proper rounding)\n        for p in pos:\n            if p == 0:\n                continue\n            # For negative result, need to handle division rounding\n            # We want n <= x/p\n            # Since p > 0 and x < 0, x/p is negative\n            max_n = x // p\n            if x % p != 0 and x < 0:\n                max_n -= 1  # Python floor division rounds down, need more negative\n            cnt += bisect.bisect_right(neg, max_n)\n    \n    # Case 4: pairs involving zeros\n    if x >= 0:\n        # Zero with anything gives 0 <= x\n        cnt += zero * (n - zero) + zero * (zero - 1) // 2\n    else:\n        # For x < 0, zero gives 0 which is > x\n        # So no pairs with zero contribute\n        pass\n    \n    return cnt\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    \n    N = int(input_data[0])\n    K = int(input_data[1])\n    A = list(map(int, input_data[2:2+N]))\n    \n    # Separate numbers\n    pos = []\n    neg = []\n    zero = 0\n    \n    for a in A:\n        if a > 0:\n            pos.append(a)\n        elif a < 0:\n            neg.append(a)\n        else:\n            zero += 1\n    \n    pos.sort()\n    neg.sort()  # Most negative first\n    \n    # Binary search for the K-th smallest product\n    left = -10**18\n    right = 10**18\n    \n    while left < right:\n        mid = (left + right) // 2\n        if (left + right) < 0 and (left + right) % 2 != 0:\n            mid -= 1  # Adjust for negative midpoint\n        \n        cnt = count_pairs_less_equal(mid, A, pos, neg, zero)\n        \n        if cnt >= K:\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 88.60909581184387}
{"eval_index": 53, "problem_id": 4029, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef min_moves_to_divisible_by_25(n_str):\n    \"\"\"Return minimum adjacent swaps to make number divisible by 25, or -1 if impossible.\"\"\"\n    n = n_str\n    length = len(n)\n    \n    # A number is divisible by 25 if its last two digits are 00, 25, 50, or 75\n    target_endings = [\"00\", \"25\", \"50\", \"75\"]\n    \n    min_moves = float('inf')\n    \n    for ending in target_endings:\n        # We need to find positions of the two required digits\n        # We'll search from right to left to minimize moves\n        pos1 = -1  # position of first digit (from right)\n        pos2 = -1  # position of second digit (from right)\n        \n        # Find positions of the two digits we need for the ending\n        # We need to place ending[1] at the last position, ending[0] at second last\n        # Search from right to left to minimize moves\n        \n        # First find the rightmost occurrence of ending[1] (last digit)\n        for i in range(length - 1, -1, -1):\n            if n[i] == ending[1]:\n                pos1 = i\n                break\n        \n        if pos1 == -1:\n            continue  # This ending is not possible\n        \n        # Then find the rightmost occurrence of ending[0] that is to the left of pos1\n        for i in range(pos1 - 1, -1, -1):\n            if n[i] == ending[0]:\n                pos2 = i\n                break\n        \n        if pos2 == -1:\n            continue  # This ending is not possible\n        \n        # Calculate moves needed to bring these digits to the end\n        # Move ending[1] to last position: (length - 1 - pos1) swaps\n        # Move ending[0] to second last position: (length - 2 - pos2) swaps\n        # But if ending[0] was to the right of ending[1] originally, \n        # after moving ending[1], ending[0]'s position shifts by 1\n        moves = (length - 1 - pos1) + (length - 2 - pos2)\n        \n        # Adjust if the digits were in wrong order\n        if pos2 > pos1:\n            # If ending[0] was to the right of ending[1], we need to swap them\n            # This adds 1 extra move\n            moves += 1\n        \n        # Check for leading zero after swaps\n        # We need to ensure the first digit after moving digits to end is not '0'\n        # Create a copy of digits to simulate\n        digits = list(n)\n        \n        # Remove the two digits we're moving to the end\n        digit1 = digits.pop(pos1)\n        # Adjust pos2 if it was after pos1\n        if pos1 < pos2:\n            pos2 -= 1\n        digit2 = digits.pop(pos2)\n        \n        # Insert them at the end in correct order\n        digits.append(ending[0])\n        digits.append(ending[1])\n        \n        # Check if resulting number has leading zero\n        if digits[0] == '0':\n            # Try to find a non-zero digit to swap to front\n            # Count how many swaps needed to bring a non-zero digit to front\n            found_nonzero = False\n            for i in range(1, len(digits) - 2):  # Don't consider the last two digits we fixed\n                if digits[i] != '0':\n                    # Need i swaps to bring this digit to front\n                    moves += i\n                    found_nonzero = True\n                    break\n            if not found_nonzero:\n                continue  # This configuration leads to leading zero, skip\n        \n        min_moves = min(min_moves, moves)\n    \n    return -1 if min_moves == float('inf') else min_moves\n\nif __name__ == \"__main__\":\n    n_str = sys.stdin.readline().strip()\n    result = min_moves_to_divisible_by_25(n_str)\n    print(result)", "runtime_sec": 125.15267562866211}
{"eval_index": 54, "problem_id": 3563, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef cross(o, a, b):\n    \"\"\"Cross product (a-o) x (b-o)\"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    \"\"\"Andrew's monotone chain algorithm\"\"\"\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef collinear(a, b, c):\n    \"\"\"Check if three points are collinear\"\"\"\n    return cross(a, b, c) == 0\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    points = []\n    for i in range(n):\n        x = int(data[1 + 2*i])\n        y = int(data[2 + 2*i])\n        points.append((x, y))\n    \n    # Get convex hull vertices (all points are on boundary)\n    hull = convex_hull(points)\n    m = len(hull)\n    \n    # Special case: all points collinear\n    if m <= 2:\n        print(1)\n        return\n    \n    # DP for minimum lines covering convex polygon vertices\n    # dp[i][j] = min lines to cover vertices from i to j (inclusive) in order\n    INF = 10**9\n    dp = [[INF] * m for _ in range(m)]\n    \n    # Initialize base cases\n    for i in range(m):\n        dp[i][i] = 1\n        if i + 1 < m:\n            dp[i][i+1] = 1\n    \n    # Fill DP table\n    for length in range(2, m):\n        for i in range(m - length):\n            j = i + length\n            # Try all possible splits\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            \n            # Check if vertices i..j can be covered by one line\n            # This happens if all vertices are collinear\n            collinear_all = True\n            for k in range(i+2, j+1):\n                if not collinear(hull[i], hull[i+1], hull[k]):\n                    collinear_all = False\n                    break\n            if collinear_all:\n                dp[i][j] = 1\n    \n    # The answer is dp[0][m-1]\n    print(dp[0][m-1])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 119.99539923667908}
{"eval_index": 55, "problem_id": 2402, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 95.9643657207489}
{"eval_index": 56, "problem_id": 4971, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef find_largest_bus_number(m):\n    \"\"\"Find the largest bus number ≤ m.\"\"\"\n    if m < 1729:\n        return \"none\"\n    \n    # Dictionary to store count of ways for each sum\n    ways_count = {}\n    \n    # Upper bound for i: cube root of m\n    max_i = int(m ** (1/3)) + 1\n    \n    # Generate all sums of two positive cubes ≤ m\n    for i in range(1, max_i + 1):\n        i_cube = i * i * i\n        if i_cube > m:\n            break\n        \n        for j in range(i, max_i + 1):  # j starts from i to avoid duplicates\n            sum_cubes = i_cube + j * j * j\n            if sum_cubes > m:\n                break\n            \n            # Count this representation\n            ways_count[sum_cubes] = ways_count.get(sum_cubes, 0) + 1\n    \n    # Find the largest number with at least 2 representations\n    largest_bus = -1\n    for num, count in ways_count.items():\n        if count >= 2 and num > largest_bus:\n            largest_bus = num\n    \n    return str(largest_bus) if largest_bus != -1 else \"none\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    result = find_largest_bus_number(m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 63.219053983688354}
{"eval_index": 57, "problem_id": 3103, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(1000000)\n\nMOD = 1000003\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return \"begin repairs\"\n    \n    Y, X, x_init = map(int, data[0].split())\n    grid = data[1:]\n    \n    # Find castle position\n    castle_pos = None\n    for y in range(Y):\n        for x in range(X):\n            if grid[y][x] == '@':\n                castle_pos = (y, x)\n                break\n        if castle_pos:\n            break\n    \n    # DP table: dp[y][x] = number of ways to reach (y,x)\n    dp = [[0] * X for _ in range(Y)]\n    dp[Y-1][x_init] = 1  # Start position\n    \n    # Process from bottom to top\n    for y in range(Y-1, -1, -1):\n        for x in range(X-1, -1, -1):\n            if grid[y][x] == '#':\n                continue\n            if dp[y][x] == 0:\n                continue\n            \n            # Move north (lower sails)\n            if y > 0 and grid[y-1][x] != '#':\n                dp[y-1][x] = (dp[y-1][x] + dp[y][x]) % MOD\n            \n            # Move with current (retract sails)\n            if grid[y][x] == '>':\n                if x+1 < X and grid[y][x+1] != '#':\n                    dp[y][x+1] = (dp[y][x+1] + dp[y][x]) % MOD\n            elif grid[y][x] == '<':\n                if x-1 >= 0 and grid[y][x-1] != '#':\n                    dp[y][x-1] = (dp[y][x-1] + dp[y][x]) % MOD\n            elif grid[y][x] == '~':\n                # Can move east or west from open sea\n                if x+1 < X and grid[y][x+1] != '#':\n                    dp[y][x+1] = (dp[y][x+1] + dp[y][x]) % MOD\n                if x-1 >= 0 and grid[y][x-1] != '#':\n                    dp[y][x-1] = (dp[y][x-1] + dp[y][x]) % MOD\n    \n    result = dp[castle_pos[0]][castle_pos[1]] % MOD\n    if result == 0:\n        return \"begin repairs\"\n    return str(result)\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 72.07163071632385}
{"eval_index": 58, "problem_id": 2955, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, c, b = map(int, data[:3])\n    broken = set(map(int, data[3:3+b]))\n    \n    # Initialize result with all zeros\n    res = ['0'] * n\n    \n    # First bit is never broken, so we can set it to '1' to start a change\n    res[0] = '1'\n    changes = 0\n    \n    # We'll create changes by alternating bits where possible\n    # Start from position 2 (index 1) since position 1 is already set\n    i = 1\n    while i < n and changes < c:\n        if i+1 in broken:\n            # Skip broken bits\n            i += 1\n            continue\n        \n        # Create a change by flipping the bit\n        res[i] = '1' if res[i-1] == '0' else '0'\n        changes += 1\n        \n        # Move to next position that can potentially create another change\n        i += 2\n    \n    # If we still need more changes, try to add them in remaining positions\n    if changes < c:\n        for i in range(1, n):\n            if changes >= c:\n                break\n            if i+1 in broken:\n                continue\n            if res[i] == res[i-1]:\n                # Flip this bit to create a change\n                res[i] = '1' if res[i] == '0' else '0'\n                changes += 1\n    \n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 63.58957314491272}
{"eval_index": 59, "problem_id": 4932, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_aggressive(arrival, aggressive, calm):\n    \"\"\"Return True if arrival falls within aggressive period.\"\"\"\n    cycle_length = aggressive + calm\n    position_in_cycle = arrival % cycle_length\n    # Aggressive period is from 0 to aggressive-1 (0-indexed minutes)\n    return position_in_cycle < aggressive\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    A, B, C, D = map(int, data[:4])\n    P, M, G = map(int, data[4:7])\n    \n    # Adjust arrival times: problem states \"during the nth minute\" means 0-indexed\n    arrivals = [P-1, M-1, G-1]\n    \n    results = []\n    for arrival in arrivals:\n        dog1 = is_aggressive(arrival, A, B)\n        dog2 = is_aggressive(arrival, C, D)\n        if dog1 and dog2:\n            results.append(\"both\")\n        elif dog1 or dog2:\n            results.append(\"one\")\n        else:\n            results.append(\"none\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 101.65507340431213}
{"eval_index": 60, "problem_id": 3736, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_mirror_word(word):\n    \"\"\"Check if a word matches its mirror reflection.\"\"\"\n    # Define mirror-symmetric letters\n    mirror_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'}\n    \n    # Check each character\n    for ch in word:\n        if ch not in mirror_letters:\n            return False\n    \n    # Check if the word is palindrome\n    return word == word[::-1]\n\ndef main():\n    # Read input\n    word = sys.stdin.readline().strip()\n    \n    # Check and print result\n    if is_mirror_word(word):\n        print('YES')\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 2733.095055103302}
{"eval_index": 61, "problem_id": 43, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    vectors = []\n    idx = 1\n    for i in range(n):\n        x = int(data[idx]); y = int(data[idx+1])\n        idx += 2\n        angle = math.atan2(y, x)  # returns angle in radians [-π, π]\n        vectors.append((angle, i+1))  # store original index (1-based)\n    \n    # Sort by angle\n    vectors.sort(key=lambda v: v[0])\n    \n    # Initialize minimal angle and answer indices\n    min_angle = float('inf')\n    ans_a, ans_b = -1, -1\n    \n    # Check consecutive angles in sorted order\n    for i in range(n):\n        j = (i + 1) % n\n        angle_i = vectors[i][0]\n        angle_j = vectors[j][0]\n        \n        # Compute the difference, handling wrap-around at 2π\n        diff = abs(angle_j - angle_i)\n        if diff > math.pi:\n            diff = 2 * math.pi - diff\n        \n        # Update if this is the smallest non-oriented angle found\n        if diff < min_angle:\n            min_angle = diff\n            ans_a = vectors[i][1]\n            ans_b = vectors[j][1]\n    \n    # Output the indices in any order\n    print(ans_a, ans_b)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 68.96627640724182}
{"eval_index": 62, "problem_id": 4904, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    a_score = 0\n    b_score = 0\n    i = 0\n    while i < len(s):\n        player = s[i]\n        points = int(s[i+1])\n        if player == 'A':\n            a_score += points\n        else:\n            b_score += points\n        i += 2\n        # Check win conditions\n        if a_score >= 11 and a_score - b_score >= 2:\n            return 'A'\n        if b_score >= 11 and b_score - a_score >= 2:\n            return 'B'\n        if a_score == 10 and b_score == 10:\n            # Win by 2 rule activated\n            while True:\n                if i >= len(s):\n                    break\n                player = s[i]\n                points = int(s[i+1])\n                if player == 'A':\n                    a_score += points\n                else:\n                    b_score += points\n                i += 2\n                if abs(a_score - b_score) >= 2:\n                    return 'A' if a_score > b_score else 'B'\n    # Should never reach here for valid input\n    return 'A' if a_score > b_score else 'B'\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 101.26784992218018}
{"eval_index": 63, "problem_id": 3318, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 99.32782196998596}
{"eval_index": 64, "problem_id": 640, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b = map(int, data[:2])\n    \n    first_wins = 0\n    draws = 0\n    second_wins = 0\n    \n    for dice in range(1, 7):\n        diff_a = abs(a - dice)\n        diff_b = abs(b - dice)\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draws += 1\n        else:\n            second_wins += 1\n    \n    print(f\"{first_wins} {draws} {second_wins}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1553.2938525676727}
{"eval_index": 65, "problem_id": 4418, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Map values to indices 0-5 for easier counting\n    value_to_idx = {4: 0, 8: 1, 15: 2, 16: 3, 23: 4, 42: 5}\n    \n    # Count how many complete sequences we can form\n    # We need to maintain counts of how many of each element we have available\n    # as we build sequences in order\n    counts = [0] * 6\n    \n    for val in arr:\n        idx = value_to_idx[val]\n        \n        if idx == 0:\n            # First element of sequence, always take it\n            counts[0] += 1\n        else:\n            # For other elements, we can only take it if we have\n            # the previous element available\n            if counts[idx-1] > 0:\n                counts[idx-1] -= 1\n                counts[idx] += 1\n            # Otherwise, we ignore this element (it will be removed)\n    \n    # The number of complete sequences formed is counts[5]\n    # Each complete sequence has 6 elements\n    complete_elements = counts[5] * 6\n    \n    # Minimum removals = total elements - elements in complete sequences\n    result = n - complete_elements\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 308.7616102695465}
{"eval_index": 66, "problem_id": 3799, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "RuntimeError('LLM failed after retries: LLM request failed: Error code: 400 - {\\'error\\': {\\'message\\': \"This model\\'s maximum context length is 131072 tokens. However, you requested 2123795 tokens (2122195 in the messages, 1600 in the completion). Please reduce the length of the messages or completion.\", \\'type\\': \\'invalid_request_error\\', \\'param\\': None, \\'code\\': \\'invalid_request_error\\'}}')", "runtime_sec": 17.979384899139404}
{"eval_index": 67, "problem_id": 2499, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Step 1: Compute total XOR of all elements\n    total_xor = 0\n    for num in arr:\n        total_xor ^= num\n    \n    # Step 2: Transform array to basis using Gaussian elimination\n    basis = []\n    for num in arr:\n        x = num\n        for b in basis:\n            x = min(x, x ^ b)\n        if x:\n            basis.append(x)\n    \n    # Step 3: Find maximum XOR subset\n    max_xor = 0\n    for b in basis:\n        max_xor = max(max_xor, max_xor ^ b)\n    \n    # Step 4: Compute answer\n    # Beauty = max_xor + (total_xor ^ max_xor)\n    # But since total_xor ^ max_xor = (total_xor ^ max_xor)\n    # And max_xor + (total_xor ^ max_xor) = max_xor + (total_xor ^ max_xor)\n    # We can compute directly\n    answer = max_xor + (total_xor ^ max_xor)\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 107.02964663505554}
{"eval_index": 68, "problem_id": 4640, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport bisect\n\ndef solve():\n    input = sys.stdin.readline\n    t = int(input())\n    out_lines = []\n    \n    for _ in range(t):\n        n, k = map(int, input().split())\n        xs = list(map(int, input().split()))\n        ys = list(map(int, input().split()))\n        \n        # Sort points by x-coordinate\n        points = sorted(zip(xs, ys))\n        xs_sorted = [p[0] for p in points]\n        \n        # Precompute max points that can be covered by a single platform\n        # ending at or after each position\n        pref = [0] * (n + 1)\n        j = 0\n        for i in range(n):\n            while j < n and xs_sorted[j] <= xs_sorted[i] + k:\n                j += 1\n            pref[i] = j - i  # points covered if platform starts at i\n        \n        # Suffix maximum of pref\n        suffix_max = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            suffix_max[i] = max(suffix_max[i + 1], pref[i])\n        \n        # Compute answer by trying all possible splits\n        ans = 0\n        for i in range(n):\n            # Platform 1 covers points from i to i+pref[i]-1\n            # Platform 2 can cover points starting from i+pref[i]\n            ans = max(ans, pref[i] + suffix_max[i + pref[i]])\n        \n        out_lines.append(str(ans))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 107.22172832489014}
{"eval_index": 69, "problem_id": 3476, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.28538537025452}
{"eval_index": 70, "problem_id": 711, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\nMOD = 10**9 + 7\n\ndef factorize(m):\n    factors = {}\n    d = 2\n    while d * d <= m:\n        while m % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            m //= d\n        d += 1 if d == 2 else 2\n    if m > 1:\n        factors[m] = factors.get(m, 0) + 1\n    return factors\n\ndef nCr(n, r, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    if not input_data:\n        return\n    N = int(input_data[0])\n    M = int(input_data[1])\n    \n    if M == 1:\n        print(1)\n        return\n    \n    factors = factorize(M)\n    \n    max_exp = max(factors.values()) if factors else 0\n    max_n = N + max_exp\n    \n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    result = 1\n    for exp in factors.values():\n        ways = nCr(N + exp - 1, exp, fact, inv_fact)\n        result = result * ways % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 1489.3981883525848}
{"eval_index": 71, "problem_id": 4047, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    chips = list(map(int, data[1:1+n]))\n    \n    # Count chips at even and odd positions\n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Minimum coins is the smaller count of chips that need to move by 1\n    result = min(even_count, odd_count)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1677.8324689865112}
{"eval_index": 72, "problem_id": 3902, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.05459642410278}
{"eval_index": 73, "problem_id": 2175, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    capacities = [int(next(it)) for _ in range(n)]\n    m = int(next(it))\n    \n    # water[i] stores current water in vessel i+1\n    water = [0] * n\n    \n    # For each vessel, find the next vessel that can receive overflow\n    # next_overflow[i] = j where j > i and capacities[j] > water[j]\n    # Initially, each vessel overflows to the next one\n    next_overflow = list(range(1, n + 1))\n    next_overflow[-1] = n  # last vessel overflows to n (floor)\n    \n    def find_overflow_target(idx):\n        \"\"\"Find the next vessel that can accept overflow from vessel idx.\"\"\"\n        while idx < n and water[idx] >= capacities[idx]:\n            idx = next_overflow[idx]\n        return idx\n    \n    def update_overflow_chain(start):\n        \"\"\"Update overflow pointers starting from vessel start.\"\"\"\n        i = start\n        while i < n:\n            nxt = find_overflow_target(i)\n            # Update all vessels from i to nxt-1 to overflow to nxt\n            j = i\n            while j < nxt:\n                next_overflow[j] = nxt\n                j += 1\n            i = nxt\n            if nxt >= n:\n                break\n            # Move to next vessel if current is full\n            if water[nxt] >= capacities[nxt]:\n                i = nxt + 1\n            else:\n                break\n    \n    out_lines = []\n    for _ in range(m):\n        query_type = int(next(it))\n        if query_type == 1:\n            p = int(next(it)) - 1  # 0-indexed\n            x = int(next(it))\n            \n            # Pour water into vessel p\n            while p < n and x > 0:\n                available = capacities[p] - water[p]\n                if available > 0:\n                    add = min(available, x)\n                    water[p] += add\n                    x -= add\n                if x > 0:\n                    # Current vessel is full, overflow to next\n                    p = next_overflow[p]\n            \n            # Update overflow chain starting from the original vessel\n            update_overflow_chain(p)\n            \n        else:  # query_type == 2\n            k = int(next(it)) - 1  # 0-indexed\n            out_lines.append(str(water[k]))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 273.7525007724762}
{"eval_index": 74, "problem_id": 4937, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0\n    n = int(data[0])\n    a = int(data[1])\n    enemies = list(map(int, data[2:2+n]))\n    \n    # Sort enemy fleets in ascending order\n    enemies.sort()\n    \n    wins = 0\n    ships_used = 0\n    \n    for enemy in enemies:\n        # Minimum ships needed to win this battle\n        needed = enemy + 1\n        if ships_used + needed <= a:\n            wins += 1\n            ships_used += needed\n        else:\n            break\n    \n    print(wins)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 96.81330299377441}
{"eval_index": 75, "problem_id": 3125, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split('\\n')\n    if len(data) < 2:\n        print(\"corrupted\")\n        return\n    \n    I = data[0].strip()\n    O = data[1].strip()\n    \n    # Find positions of + and - in I\n    plus_positions = [i for i, ch in enumerate(I) if ch == '+']\n    minus_positions = [i for i, ch in enumerate(I) if ch == '-']\n    \n    # If no + or - in input, check if strings match\n    if not plus_positions and not minus_positions:\n        if I == O:\n            print(\"<any> <any>\")\n        else:\n            print(\"corrupted\")\n        return\n    \n    # Generate all possible encodings\n    results = []\n    \n    # Try all possible splits of O\n    n = len(O)\n    m = len(I)\n    \n    # For each possible encoding length for + and -\n    for plus_len in range(n + 1):\n        for minus_len in range(n + 1):\n            # Check if total length matches\n            total_plus_chars = len(plus_positions) * plus_len\n            total_minus_chars = len(minus_positions) * minus_len\n            base_chars = m - len(plus_positions) - len(minus_positions)\n            \n            if total_plus_chars + total_minus_chars + base_chars != n:\n                continue\n            \n            # Try to match\n            plus_enc = None\n            minus_enc = None\n            i_idx = 0\n            o_idx = 0\n            valid = True\n            \n            for i in range(m):\n                if I[i] == '+':\n                    if plus_enc is None:\n                        plus_enc = O[o_idx:o_idx + plus_len]\n                    elif O[o_idx:o_idx + plus_len] != plus_enc:\n                        valid = False\n                        break\n                    o_idx += plus_len\n                elif I[i] == '-':\n                    if minus_enc is None:\n                        minus_enc = O[o_idx:o_idx + minus_len]\n                    elif O[o_idx:o_idx + minus_len] != minus_enc:\n                        valid = False\n                        break\n                    o_idx += minus_len\n                else:\n                    if o_idx >= n or O[o_idx] != I[i]:\n                        valid = False\n                        break\n                    o_idx += 1\n            \n            if valid and o_idx == n:\n                plus_str = plus_enc if plus_enc is not None else \"\"\n                minus_str = minus_enc if minus_enc is not None else \"\"\n                \n                # Format according to requirements\n                plus_output = \"<empty>\" if plus_str == \"\" else (\"<any>\" if plus_len == 0 and len(plus_positions) > 0 else plus_str)\n                minus_output = \"<empty>\" if minus_str == \"\" else (\"<any>\" if minus_len == 0 and len(minus_positions) > 0 else minus_str)\n                \n                # Special case: if both can be anything\n                if plus_len == 0 and minus_len == 0 and len(plus_positions) > 0 and len(minus_positions) > 0:\n                    if I.replace('+', '').replace('-', '') == O:\n                        plus_output = \"<any>\"\n                        minus_output = \"<any>\"\n                \n                results.append((plus_output, minus_output))\n    \n    # Remove duplicates\n    results = list(set(results))\n    \n    if not results:\n        print(\"corrupted\")\n    else:\n        for plus_out, minus_out in results:\n            print(f\"{plus_out} {minus_out}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 126.68369197845459}
{"eval_index": 76, "problem_id": 2579, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r, x, y, k = map(int, data)\n    # We need to check if there exists integer a in [l, r] and integer b in [x, y]\n    # such that a / b == k, i.e., a == k * b.\n    # Since a and b are integers, we can iterate over possible b values.\n    # But constraints are up to 10^7, so we need O(1) solution.\n    # For each b in [x, y], a = k * b must be in [l, r].\n    # So we need to check if there exists b in [x, y] such that l <= k * b <= r.\n    # This is equivalent to checking if the intervals [l, r] and [k*x, k*y] overlap.\n    # However, careful: a must be integer, but k*b is integer since b is integer.\n    # So we just need to see if there is an integer b in [x, y] with k*b in [l, r].\n    # That means: ceil(l/k) <= floor(r/k) and this interval must intersect [x, y].\n    # Alternatively, we can compute the range of b: b_min = (l + k - 1) // k  (ceil division)\n    # b_max = r // k  (floor division)\n    # Then check if [b_min, b_max] overlaps with [x, y].\n    b_min = (l + k - 1) // k  # smallest b such that k*b >= l\n    b_max = r // k            # largest b such that k*b <= r\n    if b_min <= b_max and not (b_max < x or b_min > y):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 110.17046809196472}
{"eval_index": 77, "problem_id": 4957, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    grid = [list(row) for row in data[1:1+n]]\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # First pass: place 'E' on land cells that have no adjacent 'E' and are not adjacent to water\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if any adjacent cell is 'E'\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        has_adjacent_E = True\n                        break\n                # If no adjacent 'E', place one\n                if not has_adjacent_E:\n                    grid[i][j] = 'E'\n    \n    # Second pass: ensure all land cells have an adjacent 'E'\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if any adjacent cell is 'E'\n                has_adjacent_E = False\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        has_adjacent_E = True\n                        break\n                # If not, place 'E' in this cell (it won't violate adjacency constraint)\n                if not has_adjacent_E:\n                    grid[i][j] = 'E'\n    \n    # Output the result\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 68.51620411872864}
{"eval_index": 78, "problem_id": 3117, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef longest_repeated_substring(s: str) -> int:\n    \"\"\"Return length of longest substring that appears at least twice.\"\"\"\n    n = len(s)\n    if n <= 1:\n        return 0\n    \n    # Suffix array construction using doubling algorithm O(n log n)\n    suffix = list(range(n))\n    rank = [ord(c) for c in s]\n    tmp = [0] * n\n    k = 1\n    \n    while k < n:\n        suffix.sort(key=lambda i: (rank[i], rank[i + k] if i + k < n else -1))\n        tmp[suffix[0]] = 0\n        for i in range(1, n):\n            prev, curr = suffix[i-1], suffix[i]\n            prev_key = (rank[prev], rank[prev + k] if prev + k < n else -1)\n            curr_key = (rank[curr], rank[curr + k] if curr + k < n else -1)\n            tmp[curr] = tmp[prev] + (prev_key != curr_key)\n        rank, tmp = tmp, rank\n        if rank[suffix[-1]] == n - 1:\n            break\n        k <<= 1\n    \n    # Kasai's algorithm for LCP array O(n)\n    lcp = [0] * n\n    inv_suffix = [0] * n\n    for i in range(n):\n        inv_suffix[suffix[i]] = i\n    \n    k = 0\n    for i in range(n):\n        if inv_suffix[i] == n - 1:\n            k = 0\n            continue\n        j = suffix[inv_suffix[i] + 1]\n        while i + k < n and j + k < n and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_suffix[i]] = k\n        if k > 0:\n            k -= 1\n    \n    # Longest repeated substring length is max LCP value\n    return max(lcp) if lcp else 0\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    L = int(data[0].strip())\n    s = data[1].strip()\n    print(longest_repeated_substring(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 149.0347559452057}
{"eval_index": 79, "problem_id": 795, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_right_triangles(n):\n    \"\"\"Count right triangles with 1 ≤ a ≤ b ≤ c ≤ n.\"\"\"\n    count = 0\n    # Iterate over possible a and b values\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):  # b ≥ a\n            c_squared = a * a + b * b\n            c = int(math.isqrt(c_squared))\n            # Check if c is valid and satisfies Pythagorean theorem exactly\n            if c <= n and c * c == c_squared:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    result = count_right_triangles(n)\n    print(result)", "runtime_sec": 57.11534523963928}
{"eval_index": 80, "problem_id": 4561, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X, A, B = map(int, data)\n    # Days from purchase to eating: B\n    # Days from best-by to eating: B - A\n    days_from_best_by = B - A\n    if days_from_best_by <= 0:\n        # Ate on or before best-by date\n        print(\"delicious\")\n    elif days_from_best_by <= X:\n        # Ate within X days after best-by\n        print(\"safe\")\n    else:\n        # Ate more than X days after best-by\n        print(\"dangerous\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 137.64978289604187}
{"eval_index": 81, "problem_id": 3653, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    L = int(data[0])\n    x1, y1 = int(data[1]), int(data[2])\n    x2, y2 = int(data[3]), int(data[4])\n    \n    # Distance from origin to wall line\n    # Wall direction vector\n    dx = x2 - x1\n    dy = y2 - y1\n    # Distance from origin to line through (x1,y1) and (x2,y2)\n    # Formula: |(x2-x1)*(y1-0) - (y2-y1)*(x1-0)| / sqrt((x2-x1)^2 + (y2-y1)^2)\n    numerator = abs(dx * y1 - dy * x1)\n    denominator = math.sqrt(dx*dx + dy*dy)\n    d = numerator / denominator if denominator != 0 else 0\n    \n    # Binary search for minimal chain length R (in meters)\n    low = 0\n    high = int(1e6)  # Upper bound large enough\n    answer = high\n    \n    while low <= high:\n        mid = (low + high) // 2\n        R = mid\n        # Area dog can cover: full circle area minus segment blocked by wall\n        # If wall is beyond radius, full circle area\n        if d >= R:\n            area = math.pi * R * R\n        else:\n            # Angle of segment blocked by wall\n            theta = 2 * math.acos(d / R)\n            # Area of circular segment: R^2 * (theta - sin(theta)) / 2\n            segment_area = R * R * (theta - math.sin(theta)) / 2\n            # Accessible area = full circle - segment\n            area = math.pi * R * R - segment_area\n        \n        if area >= L:\n            answer = R\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 110.15027737617493}
{"eval_index": 82, "problem_id": 100, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 94.62486290931702}
{"eval_index": 83, "problem_id": 4257, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    A = int(data[0])\n    B = int(data[1])\n    print(A * B)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 533.8508763313293}
{"eval_index": 84, "problem_id": 3335, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef count_pythagorean_triples_mod_n(n):\n    \"\"\"Count triples (a,b,c) with 1 <= a <= b <= n-1 and a^2 + b^2 ≡ c^2 (mod n).\"\"\"\n    # Precompute squares modulo n\n    squares_mod = [0] * n\n    for i in range(n):\n        squares_mod[i] = (i * i) % n\n    \n    # Count frequencies of each square residue\n    freq = [0] * n\n    for i in range(1, n):\n        freq[squares_mod[i]] += 1\n    \n    # For each pair (a,b) with a <= b, count how many c satisfy the congruence\n    count = 0\n    for a in range(1, n):\n        a_sq = squares_mod[a]\n        for b in range(a, n):\n            target = (a_sq + squares_mod[b]) % n\n            count += freq[target]\n    \n    return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = count_pythagorean_triples_mod_n(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 64.06761240959167}
{"eval_index": 85, "problem_id": 2525, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().splitlines()\n    S = data[0]\n    Q = int(data[1])\n    \n    # Use deque for efficient operations at both ends\n    from collections import deque\n    dq = deque(S)\n    \n    # Track whether the string is currently reversed\n    reversed_flag = False\n    \n    for i in range(2, Q + 2):\n        query = data[i].split()\n        if query[0] == '1':\n            # Toggle reversal flag instead of actually reversing\n            reversed_flag = not reversed_flag\n        else:\n            # Operation type 2\n            f = int(query[1])\n            c = query[2]\n            \n            # Adjust for reversal flag\n            if reversed_flag:\n                f = 3 - f  # Swap 1 and 2\n            \n            if f == 1:\n                dq.appendleft(c)\n            else:  # f == 2\n                dq.append(c)\n    \n    # Apply final reversal if needed\n    if reversed_flag:\n        dq.reverse()\n    \n    print(''.join(dq))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 139.70945596694946}
{"eval_index": 86, "problem_id": 4943, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    idx = 0\n    N = int(data[idx]); idx += 1\n    points = []\n    for _ in range(N):\n        x = float(data[idx]); idx += 1\n        y = float(data[idx]); idx += 1\n        points.append((x, y))\n    A = float(data[idx]); idx += 1\n    return N, points, A\n\ndef polygon_area(points):\n    \"\"\"Calculate area of polygon using shoelace formula.\"\"\"\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    return abs(area) / 2.0\n\ndef scale_polygon(points, scale_factor):\n    \"\"\"Scale polygon around origin by scale_factor.\"\"\"\n    return [(x * scale_factor, y * scale_factor) for (x, y) in points]\n\ndef translate_to_origin(points):\n    \"\"\"Translate polygon so min x and min y become 0.\"\"\"\n    min_x = min(x for x, y in points)\n    min_y = min(y for x, y in points)\n    return [(x - min_x, y - min_y) for (x, y) in points]\n\ndef main():\n    N, points, target_area = read_input()\n    if N is None:\n        return\n    \n    # Calculate original area\n    original_area = polygon_area(points)\n    \n    # Calculate scale factor\n    # Since area scales by square of linear dimensions\n    scale_factor = math.sqrt(target_area / original_area)\n    \n    # Scale polygon\n    scaled_points = scale_polygon(points, scale_factor)\n    \n    # Translate to meet requirements\n    final_points = translate_to_origin(scaled_points)\n    \n    # Output\n    for x, y in final_points:\n        print(f\"{x:.10f} {y:.10f}\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 68.22481775283813}
{"eval_index": 87, "problem_id": 3726, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.79636240005493}
{"eval_index": 88, "problem_id": 2353, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(t):\n        a = int(data[idx]); b = int(data[idx+1]); c = int(data[idx+2]); d = int(data[idx+3])\n        idx += 4\n        \n        # If first alarm already gives enough sleep\n        if b >= a:\n            out_lines.append(str(b))\n            continue\n        \n        # If cannot gain any sleep after first alarm\n        if d >= c:\n            out_lines.append(\"-1\")\n            continue\n        \n        # Sleep needed after first alarm\n        need = a - b\n        # Sleep gained per cycle (c minutes alarm, d minutes falling asleep)\n        gain_per_cycle = c - d\n        # Number of full cycles needed (ceil division)\n        cycles = (need + gain_per_cycle - 1) // gain_per_cycle\n        # Total time = first alarm + cycles * c\n        total = b + cycles * c\n        out_lines.append(str(total))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 183.82852697372437}
{"eval_index": 89, "problem_id": 4760, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N, K = map(int, data[:2])\n    \n    # Initialize sieve\n    is_prime = [True] * (N + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    crossed_out = []\n    \n    for p in range(2, N + 1):\n        if is_prime[p]:\n            # Cross out p itself\n            if not is_prime[p]:  # Already crossed? Shouldn't happen for prime p\n                continue\n            is_prime[p] = False\n            crossed_out.append(p)\n            if len(crossed_out) == K:\n                print(p)\n                return\n            \n            # Cross out multiples of p\n            for multiple in range(p * 2, N + 1, p):\n                if is_prime[multiple]:\n                    is_prime[multiple] = False\n                    crossed_out.append(multiple)\n                    if len(crossed_out) == K:\n                        print(multiple)\n                        return\n    \n    # If K is larger than total crossed out numbers (shouldn't happen per constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 142.8570535182953}
{"eval_index": 90, "problem_id": 3552, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m, k = map(int, data)\n    \n    # If k is 1, enemy kills one gnome per turn regardless of grouping\n    if k == 1:\n        # Sum of n, n-1, ..., 1\n        total = n * (n + 1) // 2\n        print(total)\n        return\n    \n    # If m is large enough to make each group size <= k-1\n    # Then enemy can only kill one group per turn\n    # We want to maximize turns by having many small groups\n    # But groups must be non-empty, so max groups = min(m, n)\n    max_groups = min(m, n)\n    \n    # If we can make all groups size <= k-1\n    if max_groups * (k - 1) >= n:\n        # Distribute gnomes as evenly as possible among max_groups groups\n        # Each group size <= k-1\n        # Enemy kills one group per turn\n        # Damage = sum of remaining gnomes each turn\n        # This is equivalent to sum from n down to 0 in steps of 1\n        # But actually we lose one group per turn, not necessarily one gnome\n        \n        # Calculate group sizes as evenly as possible\n        base_size = n // max_groups\n        remainder = n % max_groups\n        \n        # Create list of group sizes\n        groups = [base_size + 1 if i < remainder else base_size for i in range(max_groups)]\n        \n        # Sort descending to maximize early damage\n        groups.sort(reverse=True)\n        \n        total_damage = 0\n        remaining_gnomes = n\n        \n        # Simulate turns: each turn enemy kills one group\n        for group_size in groups:\n            total_damage += remaining_gnomes\n            remaining_gnomes -= group_size\n        \n        print(total_damage)\n        return\n    \n    # Otherwise, we need to create some large groups that will be reduced by k each turn\n    # Optimal strategy: create (m-1) groups of size 1 (or as small as possible)\n    # and one large group with the remaining gnomes\n    # The enemy will attack the large group each turn until it's reduced\n    \n    # Number of small groups (size 1)\n    small_groups = min(m - 1, n)\n    \n    # Size of large group\n    large_group_size = n - small_groups\n    \n    # If large_group_size <= 0, all groups are size 1\n    if large_group_size <= 0:\n        # All groups are size 1, enemy kills one group per turn\n        total_damage = n * (n + 1) // 2\n        print(total_damage)\n        return\n    \n    # Calculate damage from the phase where large group is being reduced\n    # Number of full k-reductions on large group\n    full_reductions = large_group_size // k\n    \n    # Remaining after full reductions\n    remainder = large_group_size % k\n    \n    total_damage = 0\n    current_gnomes = n\n    \n    # Phase 1: Large group being reduced by k each turn\n    for i in range(full_reductions):\n        total_damage += current_gnomes\n        current_gnomes -= k\n    \n    # Phase 2: Handle remainder of large group\n    if remainder > 0:\n        total_damage += current_gnomes\n        current_gnomes -= remainder\n    \n    # Phase 3: Enemy kills small groups one by one\n    # Number of small groups to kill\n    small_groups_to_kill = small_groups\n    \n    for i in range(small_groups_to_kill):\n        total_damage += current_gnomes\n        current_gnomes -= 1\n    \n    print(total_damage)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 125.70941400527954}
{"eval_index": 91, "problem_id": 1205, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 98.82377529144287}
{"eval_index": 92, "problem_id": 4423, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    restaurants = []\n    \n    idx = 1\n    for i in range(1, n + 1):\n        city = data[idx]\n        score = int(data[idx + 1])\n        restaurants.append((city, score, i))\n        idx += 2\n    \n    # Sort: first by city lexicographically, then by score descending\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n    \n    for _, _, idx in restaurants:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 297.2516665458679}
{"eval_index": 93, "problem_id": 3903, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\nimport heapq\n\nsys.setrecursionlimit(10**6)\n\ndef bfs(grid, start, n, m, state):\n    \"\"\"BFS to find distances from state cells to all '.' cells\"\"\"\n    dist = [[float('inf')] * m for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == state:\n                dist[i][j] = 0\n                q.append((i, j))\n    \n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    while q:\n        x, y = q.popleft()\n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':\n                new_dist = dist[x][y] + (1 if grid[nx][ny] == '.' else 0)\n                if new_dist < dist[nx][ny]:\n                    dist[nx][ny] = new_dist\n                    q.append((nx, ny))\n    return dist\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    grid = data[2:]\n    \n    # Find distances from each state to all cells\n    dist1 = bfs(grid, '1', n, m, '1')\n    dist2 = bfs(grid, '2', n, m, '2')\n    dist3 = bfs(grid, '3', n, m, '3')\n    \n    # Find minimum connection costs between states\n    INF = float('inf')\n    min_12 = INF\n    min_13 = INF\n    min_23 = INF\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                # Direct connection between two states\n                if grid[i][j] == '1' or grid[i][j] == '2':\n                    min_12 = min(min_12, dist1[i][j] + dist2[i][j])\n                if grid[i][j] == '1' or grid[i][j] == '3':\n                    min_13 = min(min_13, dist1[i][j] + dist3[i][j])\n                if grid[i][j] == '2' or grid[i][j] == '3':\n                    min_23 = min(min_23, dist2[i][j] + dist3[i][j])\n                \n                # Connection through a '.' cell\n                if grid[i][j] == '.':\n                    min_12 = min(min_12, dist1[i][j] + dist2[i][j] + 1)\n                    min_13 = min(min_13, dist1[i][j] + dist3[i][j] + 1)\n                    min_23 = min(min_23, dist2[i][j] + dist3[i][j] + 1)\n    \n    # Check if any state is unreachable\n    if min_12 == INF or min_13 == INF or min_23 == INF:\n        print(-1)\n        return\n    \n    # Three possible connection strategies:\n    # 1. Connect all three through a single '.' cell\n    min_through_point = INF\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if dist1[i][j] < INF and dist2[i][j] < INF and dist3[i][j] < INF:\n                    total = dist1[i][j] + dist2[i][j] + dist3[i][j] + 2\n                    min_through_point = min(min_through_point, total)\n    \n    # 2. Connect in a chain: 1-2-3\n    chain_12_23 = min_12 + min_23\n    chain_13_23 = min_13 + min_23\n    chain_12_13 = min_12 + min_13\n    \n    # 3. Direct connections between all pairs\n    direct_all = min_12 + min_13 + min_23\n    \n    result = min(min_through_point, chain_12_23, chain_13_23, chain_12_13, direct_all)\n    \n    # Subtract double counting for direct connections\n    # When we sum min_12 + min_13 + min_23, we count some '.' cells multiple times\n    # Find the minimum overlap\n    min_overlap = INF\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                total = dist1[i][j] + dist2[i][j] + dist3[i][j]\n                if grid[i][j] == '.':\n                    total += 2  # The '.' cell itself counts as 1 road cell\n                min_overlap = min(min_overlap, total)\n    \n    result = min(result, min_overlap)\n    \n    print(result if result < INF else -1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 173.3652093410492}
{"eval_index": 94, "problem_id": 2273, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 94.31652092933655}
{"eval_index": 95, "problem_id": 4039, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    r = int(next(it))\n    projects = []\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        projects.append((a, b))\n    \n    # Separate projects into positive and negative b_i\n    pos = []\n    neg = []\n    for a, b in projects:\n        if b >= 0:\n            pos.append((a, b))\n        else:\n            neg.append((a, b))\n    \n    # Sort positive projects by required rating a_i (ascending)\n    pos.sort(key=lambda x: x[0])\n    \n    # Process positive projects first\n    for a, b in pos:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n    \n    # Sort negative projects by (a_i + b_i) descending, then by a_i descending\n    # This is equivalent to sorting by (a_i + b_i) descending\n    neg.sort(key=lambda x: (x[0] + x[1]), reverse=True)\n    \n    # Process negative projects\n    for a, b in neg:\n        if r < a:\n            print(\"NO\")\n            return\n        r += b\n        if r < 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1855.6554441452026}
{"eval_index": 96, "problem_id": 3268, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 93.24209022521973}
{"eval_index": 97, "problem_id": 2037, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+m]))\n    \n    # Track count of each difficulty in current pool\n    count = [0] * (n + 1)\n    # Track how many distinct difficulties we have in pool\n    distinct = 0\n    result = []\n    \n    for difficulty in a:\n        # Add problem to pool\n        if count[difficulty] == 0:\n            distinct += 1\n        count[difficulty] += 1\n        \n        # Check if we can hold a round\n        if distinct == n:\n            result.append('1')\n            # Remove one problem of each difficulty\n            for d in range(1, n + 1):\n                count[d] -= 1\n                if count[d] == 0:\n                    distinct -= 1\n        else:\n            result.append('0')\n    \n    sys.stdout.write(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 343.4693012237549}
{"eval_index": 98, "problem_id": 4059, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    ans = 0\n    for a in range(1, N):\n        max_b = (N - 1) // a\n        for b in range(1, max_b + 1):\n            c = N - a * b\n            if c > 0:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1525.3598320484161}
{"eval_index": 99, "problem_id": 3465, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    roads = []\n    idx = 1\n    for _ in range(n):\n        a = int(data[idx]); b = int(data[idx+1])\n        roads.append((a, b))\n        idx += 2\n    \n    # Count how many times each city appears as first endpoint\n    count = [0] * (n + 1)\n    for a, b in roads:\n        count[a] += 1\n    \n    # For each road, choose the city that appears less frequently\n    # to assign as builder, preferring the first endpoint if equal\n    result = []\n    for a, b in roads:\n        if count[a] < count[b]:\n            result.append(f\"{a} {b}\")\n        elif count[a] > count[b]:\n            result.append(f\"{b} {a}\")\n        else:\n            # If equal, choose a as builder (arbitrary but consistent)\n            result.append(f\"{a} {b}\")\n    \n    sys.stdout.write(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 62.159061670303345}
{"eval_index": 100, "problem_id": 163, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    # Find positions of grasshopper (G) and target (T)\n    g_pos = s.find('G')\n    t_pos = s.find('T')\n    \n    # Ensure we move from smaller to larger index for consistency\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n        # Swap is fine because problem is symmetric\n    \n    # Check if positions are congruent modulo k (necessary condition)\n    if (t_pos - g_pos) % k != 0:\n        print(\"NO\")\n        return\n    \n    # Check all cells between G and T at step size k\n    for pos in range(g_pos, t_pos + 1, k):\n        if s[pos] == '#':\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 3386.745679616928}
{"eval_index": 101, "problem_id": 4984, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(grid, visited, i, j, r, c, treat_cloud_as_land=False):\n    \"\"\"DFS to mark connected land cells (and optionally clouds as land)\"\"\"\n    if i < 0 or i >= r or j < 0 or j >= c:\n        return\n    if visited[i][j]:\n        return\n    if grid[i][j] == 'W':\n        return\n    if grid[i][j] == 'C' and not treat_cloud_as_land:\n        return\n    \n    visited[i][j] = True\n    dfs(grid, visited, i+1, j, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i-1, j, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i, j+1, r, c, treat_cloud_as_land)\n    dfs(grid, visited, i, j-1, r, c, treat_cloud_as_land)\n\ndef count_islands(grid, r, c, treat_cloud_as_land=False):\n    \"\"\"Count islands in grid, optionally treating clouds as land\"\"\"\n    visited = [[False]*c for _ in range(r)]\n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if not visited[i][j]:\n                if grid[i][j] == 'L' or (treat_cloud_as_land and grid[i][j] == 'C'):\n                    dfs(grid, visited, i, j, r, c, treat_cloud_as_land)\n                    count += 1\n    return count\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    r, c = map(int, data[0].split())\n    grid = [list(line.strip()) for line in data[1:1+r]]\n    \n    # Count islands if we treat all clouds as water (minimum possible islands)\n    min_islands = count_islands(grid, r, c, treat_cloud_as_land=False)\n    \n    # Count islands if we treat all clouds as land (maximum possible islands)\n    # But we want minimum, so we already have it from above\n    \n    # However, we need to consider that clouds could be either land or water\n    # To minimize islands, we want to treat clouds as water whenever possible\n    # But we must ensure connectivity: if a cloud connects two land masses,\n    # it must be land, not water\n    \n    # Actually, the minimum islands is simply the number of connected components\n    # of land cells, ignoring clouds completely\n    # Because we can always interpret clouds as water to avoid creating\n    # additional islands or connecting existing ones\n    \n    print(min_islands)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 113.14070272445679}
{"eval_index": 102, "problem_id": 3089, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 94.14690446853638}
{"eval_index": 103, "problem_id": 371, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef count_ways(n):\n    \"\"\"Count number of valid quadruples (a, k) where a > 0, k > 1,\n    and a*k^3 <= n.\"\"\"\n    cnt = 0\n    # For each possible k from 2 to n^(1/3)\n    max_k = int(round(n ** (1/3)))\n    # Adjust for floating point errors\n    while (max_k + 1) ** 3 <= n:\n        max_k += 1\n    while max_k ** 3 > n:\n        max_k -= 1\n    \n    for k in range(2, max_k + 1):\n        # For given k, a can be from 1 to floor(n / k^3)\n        max_a = n // (k * k * k)\n        cnt += max_a\n    return cnt\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data)\n    \n    # Binary search for smallest n with count_ways(n) == m\n    # Upper bound: need n such that count_ways(n) >= m\n    # Maximum m is 10^15, need upper bound where count_ways(n) >= 10^15\n    # For large n, count_ways(n) ≈ n * sum_{k=2}^{n^(1/3)} 1/k^3\n    # sum_{k=2}^{∞} 1/k^3 ≈ 0.20206 (Apéry's constant minus 1)\n    # So count_ways(n) ≈ 0.20206 * n\n    # For m=10^15, need n ≈ m/0.20206 ≈ 5e15\n    # Add some margin\n    low = 1\n    high = 10**16  # Conservative upper bound\n    \n    # First find high bound where count_ways(high) >= m\n    while count_ways(high) < m:\n        high *= 2\n    \n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        ways = count_ways(mid)\n        if ways == m:\n            # Found candidate, but need smallest n\n            # Continue searching left\n            result = mid\n            high = mid - 1\n        elif ways < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 73.96568989753723}
{"eval_index": 104, "problem_id": 4649, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    \n    # Precompute the infinite RGB pattern for comparison\n    pattern = \"RGB\"\n    \n    for _ in range(q):\n        n = int(data[idx]); k = int(data[idx+1])\n        s = data[idx+2]\n        idx += 3\n        \n        # We'll try all three possible starting characters (R, G, B)\n        # and slide a window of size k through s\n        min_changes = float('inf')\n        \n        for start_char in range(3):  # 0:R, 1:G, 2:B\n            # Build expected pattern for this starting character\n            expected = []\n            for i in range(k):\n                expected.append(pattern[(start_char + i) % 3])\n            \n            # Initial window at position 0\n            changes = 0\n            for i in range(k):\n                if s[i] != expected[i]:\n                    changes += 1\n            min_changes = min(min_changes, changes)\n            \n            # Slide the window\n            for i in range(k, n):\n                # Remove leftmost character\n                if s[i-k] != expected[0]:\n                    changes -= 1\n                # Shift expected pattern\n                expected.append(pattern[(start_char + i) % 3])\n                expected.pop(0)\n                # Add new character\n                if s[i] != expected[-1]:\n                    changes += 1\n                min_changes = min(min_changes, changes)\n        \n        out_lines.append(str(min_changes))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 106.69959545135498}
{"eval_index": 105, "problem_id": 3270, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    words = data[1:1+n]\n    start, end = words[0], words[1]\n    dictionary = set(words)\n    word_len = len(start)\n    \n    # Helper to generate neighbors of a word\n    def neighbors(word):\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if c == word[i]:\n                    continue\n                new_word = word[:i] + c + word[i+1:]\n                if new_word in dictionary:\n                    yield new_word\n    \n    # BFS from start to end without any added word\n    def bfs(start, end, dict_set):\n        if start == end:\n            return 0\n        visited = {start}\n        q = deque([(start, 0)])\n        while q:\n            word, dist = q.popleft()\n            for nb in neighbors(word):\n                if nb == end:\n                    return dist + 1\n                if nb not in visited:\n                    visited.add(nb)\n                    q.append((nb, dist + 1))\n        return float('inf')\n    \n    original_dist = bfs(start, end, dictionary)\n    \n    # If start and end are already connected, we might not need to add any word\n    if original_dist != float('inf'):\n        best_word = \"0\"\n        best_dist = original_dist\n        # Try adding each possible word\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                candidate = start[:i] + c + start[i+1:]\n                if candidate in dictionary or candidate == start:\n                    continue\n                dictionary.add(candidate)\n                dist = bfs(start, end, dictionary)\n                dictionary.remove(candidate)\n                if dist < best_dist or (dist == best_dist and candidate < best_word):\n                    best_dist = dist\n                    best_word = candidate\n        # If no improvement, output 0 and original distance\n        if best_word == \"0\":\n            print(\"0\")\n            print(original_dist)\n        else:\n            print(best_word)\n            print(best_dist)\n    else:\n        # No path exists originally, try to add a word that connects start and end\n        best_word = \"0\"\n        best_dist = float('inf')\n        # Consider words that are one edit from start or end\n        candidates = set()\n        for i in range(word_len):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                cand1 = start[:i] + c + start[i+1:]\n                if cand1 not in dictionary and cand1 != start:\n                    candidates.add(cand1)\n                cand2 = end[:i] + c + end[i+1:]\n                if cand2 not in dictionary and cand2 != end:\n                    candidates.add(cand2)\n        for candidate in sorted(candidates):\n            dictionary.add(candidate)\n            dist = bfs(start, end, dictionary)\n            dictionary.remove(candidate)\n            if dist < best_dist:\n                best_dist = dist\n                best_word = candidate\n        if best_word == \"0\":\n            print(\"0\")\n            print(-1)\n        else:\n            print(best_word)\n            print(best_dist)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 159.39627838134766}
{"eval_index": 106, "problem_id": 1862, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    socks = list(map(int, data[1:]))\n    \n    # Track whether a sock is currently on the table\n    on_table = [False] * (n + 1)\n    current_on_table = 0\n    max_on_table = 0\n    \n    for sock in socks:\n        if not on_table[sock]:\n            # First sock of the pair: put on table\n            on_table[sock] = True\n            current_on_table += 1\n            max_on_table = max(max_on_table, current_on_table)\n        else:\n            # Second sock of the pair: remove from table\n            on_table[sock] = False\n            current_on_table -= 1\n    \n    print(max_on_table)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 420.19621753692627}
{"eval_index": 107, "problem_id": 4878, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if len(data) < 2:\n        return\n    R1 = int(data[0])\n    S = int(data[1])\n    # From S = (R1 + R2)/2 => R2 = 2*S - R1\n    R2 = 2 * S - R1\n    print(R2)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 92.34540605545044}
{"eval_index": 108, "problem_id": 3086, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef days_in_month(month):\n    \"\"\"Return number of days in given month (1-indexed).\"\"\"\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    return days[month - 1]\n\ndef date_to_days(d, m):\n    \"\"\"Convert day and month to day number in year (1 to 365).\"\"\"\n    total = 0\n    for month in range(1, m):\n        total += days_in_month(month)\n    total += d\n    return total\n\ndef parse_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return None\n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    observations = []\n    for _ in range(N):\n        d1 = int(data[idx]); idx += 1\n        m1 = int(data[idx]); idx += 1\n        d2 = int(data[idx]); idx += 1\n        m2 = int(data[idx]); idx += 1\n        start_day = date_to_days(d1, m1)\n        end_day = date_to_days(d2, m2)\n        if end_day < start_day:\n            end_day += 365  # wrap to next year\n        duration = end_day - start_day + 1  # inclusive\n        counts = []\n        for __ in range(M):\n            counts.append(int(data[idx])); idx += 1\n        observations.append((duration, counts))\n    return N, M, observations\n\ndef solve():\n    parsed = parse_input()\n    if parsed is None:\n        return \"-1\"\n    N, M, observations = parsed\n    \n    # Brute force all possible durations from 1 to 365\n    possible_durations = []\n    for d1 in range(1, 366):\n        for d2 in range(1, 366):\n            for d3 in range(1, 366):\n                # Extend for M > 3 if needed, but M ≤ 200 so we need smarter approach\n                pass\n    \n    # Since M can be up to 200, brute force over all durations is impossible.\n    # Instead, we solve linear equations.\n    # For each observation i: sum_{j=1 to M} (counts[i][j] * duration_j) = total_days_i\n    # This is a system of N equations with M unknowns.\n    \n    # Build matrix A (N x M) and vector b (N x 1)\n    A = []\n    b = []\n    for duration, counts in observations:\n        A.append(counts[:])  # each row is counts for that observation\n        b.append(duration)\n    \n    # Solve linear system A * x = b\n    # Use Gaussian elimination over integers since durations are integers 1..365\n    # We'll try all possible integer solutions within bounds\n    \n    # Since M ≤ 200 and N ≤ 200, we can use integer linear solving\n    # But we need to handle multiple solutions and no solution cases\n    \n    # Simple approach: try all combinations for small M, but here M up to 200\n    # Instead, use constraint solving: durations are between 1 and 365\n    \n    # We'll use a backtracking search with pruning\n    durations = [0] * M\n    \n    def backtrack(idx):\n        if idx == M:\n            # Check all equations\n            for i in range(N):\n                total = 0\n                for j in range(M):\n                    total += A[i][j] * durations[j]\n                if total != b[i]:\n                    return False\n            return True\n        \n        # Try all possible durations for this event type\n        for d in range(1, 366):\n            durations[idx] = d\n            # Early pruning: check if current partial assignment can satisfy all equations\n            feasible = True\n            for i in range(N):\n                # Compute partial sum for this equation\n                partial_sum = 0\n                for j in range(idx + 1):\n                    partial_sum += A[i][j] * durations[j]\n                # Maximum possible sum if remaining durations are 365\n                max_possible = partial_sum\n                for j in range(idx + 1, M):\n                    max_possible += A[i][j] * 365\n                # Minimum possible sum if remaining durations are 1\n                min_possible = partial_sum\n                for j in range(idx + 1, M):\n                    min_possible += A[i][j] * 1\n                if b[i] < min_possible or b[i] > max_possible:\n                    feasible = False\n                    break\n            if feasible:\n                if backtrack(idx + 1):\n                    return True\n        return False\n    \n    if backtrack(0):\n        return ' '.join(map(str, durations))\n    else:\n        return \"-1\"\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)", "runtime_sec": 89.61474251747131}
{"eval_index": 109, "problem_id": 2290, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(next(it))\n        v = int(next(it))\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Step 1: Find connected components\n    visited = [False] * (n + 1)\n    components = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp = []\n            while stack:\n                node = stack.pop()\n                comp.append(node)\n                for nei in adj[node]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        stack.append(nei)\n            components.append(comp)\n    \n    # Step 2: For each component, find min and max node\n    comp_min_max = []\n    for comp in components:\n        mn = min(comp)\n        mx = max(comp)\n        comp_min_max.append((mn, mx))\n    \n    # Step 3: Sort by min value\n    comp_min_max.sort()\n    \n    # Step 4: Merge overlapping intervals\n    merged = []\n    current_l, current_r = comp_min_max[0]\n    for l, r in comp_min_max[1:]:\n        if l <= current_r + 1:\n            current_r = max(current_r, r)\n        else:\n            merged.append((current_l, current_r))\n            current_l, current_r = l, r\n    merged.append((current_l, current_r))\n    \n    # Step 5: Count gaps between merged intervals\n    answer = 0\n    for i in range(len(merged) - 1):\n        l1, r1 = merged[i]\n        l2, r2 = merged[i + 1]\n        # Nodes from r1+1 to l2-1 need to be connected\n        gap = l2 - r1 - 1\n        if gap > 0:\n            answer += gap\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 70.42500424385071}
{"eval_index": 110, "problem_id": 4544, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequencies of each value\n    freq = {}\n    for val in arr:\n        freq[val] = freq.get(val, 0) + 1\n    \n    max_count = 0\n    # For each possible value, check how many elements can be adjusted to it\n    for val in set(arr):\n        # Elements that can become val: val-1, val, val+1\n        count = freq.get(val, 0)\n        count += freq.get(val-1, 0)\n        count += freq.get(val+1, 0)\n        max_count = max(max_count, count)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 138.70459151268005}
{"eval_index": 111, "problem_id": 3429, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nxs, ys, ss, ri, rf = map(int, sys.stdin.readline().split())\nxa, ya, sa = map(int, sys.stdin.readline().split())\n\n# Distance from Anthony to zone center\ndist = math.hypot(xa - xs, ya - ys)\n\n# Time when zone stops shrinking (if it shrinks at all)\nt_shrink_end = (ri - rf) / ss if ss > 0 else 0\n\n# Function to compute damage if Anthony starts moving at time t_start\ndef damage_if_start_at(t_start):\n    # Radius at time t_start\n    r_start = ri - ss * t_start\n    \n    # If Anthony is already inside the zone at t_start, no damage\n    if dist <= r_start:\n        return 0.0\n    \n    # Distance Anthony needs to cover to reach zone boundary\n    dist_to_cover = dist - r_start\n    \n    # Time needed to cover that distance at speed sa\n    t_travel = dist_to_cover / sa\n    \n    # Damage calculation:\n    # Anthony takes damage from t_start until he reaches the zone\n    # But zone might stop shrinking during this period\n    \n    # Time when zone would reach Anthony if it kept shrinking\n    # Solve: ri - ss * t = dist - sa * (t - t_start)\n    # => ri - ss*t = dist - sa*t + sa*t_start\n    # => (sa - ss)*t = dist - ri + sa*t_start\n    # => t = (dist - ri + sa*t_start) / (sa - ss) if sa != ss\n    \n    # Check if Anthony can outrun the shrinking\n    if sa > ss:\n        t_meet = (dist - ri + sa * t_start) / (sa - ss)\n        # If meeting happens before zone stops shrinking\n        if t_meet <= t_shrink_end:\n            # Damage from t_start to t_meet\n            return t_meet - t_start\n        \n    # If sa <= ss or meeting happens after zone stops shrinking\n    # Zone stops shrinking at t_shrink_end, then radius is fixed at rf\n    \n    # Where is Anthony at t_shrink_end?\n    if t_start <= t_shrink_end:\n        # Anthony runs from t_start to t_shrink_end\n        t_run_before_stop = min(t_shrink_end - t_start, dist_to_cover / sa)\n        dist_covered = sa * t_run_before_stop\n        remaining_dist = dist_to_cover - dist_covered\n        \n        # Radius at t_shrink_end\n        r_at_stop = rf\n        \n        # If Anthony hasn't reached zone by t_shrink_end\n        if remaining_dist > 0:\n            # He still needs to cover remaining_dist to reach fixed radius rf\n            t_additional = remaining_dist / sa\n            return t_shrink_end - t_start + t_additional\n        else:\n            # He reached zone before zone stopped shrinking\n            return t_run_before_stop\n    else:\n        # Anthony starts moving after zone stopped shrinking\n        # Radius is fixed at rf\n        if dist <= rf:\n            return 0.0\n        dist_to_cover_fixed = dist - rf\n        t_travel_fixed = dist_to_cover_fixed / sa\n        return t_travel_fixed\n\n# Binary search for optimal start time\nlo, hi = 0.0, 1e18\nfor _ in range(100):  # Sufficient precision\n    mid1 = lo + (hi - lo) / 3\n    mid2 = hi - (hi - lo) / 3\n    \n    d1 = damage_if_start_at(mid1)\n    d2 = damage_if_start_at(mid2)\n    \n    if d1 < d2:\n        hi = mid2\n    else:\n        lo = mid1\n\n# Check boundary cases\ndamage_start_immediately = damage_if_start_at(0.0)\ndamage_wait_forever = damage_if_start_at(1e18)  # Effectively never move\n\nbest_damage = min(damage_start_immediately, damage_wait_forever, damage_if_start_at((lo + hi) / 2))\n\nprint(f\"{best_damage:.6f}\")", "runtime_sec": 85.10545182228088}
{"eval_index": 112, "problem_id": 2472, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    jobs = []\n    idx = 1\n    for _ in range(n):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        jobs.append((b, a))  # (deadline, duration)\n        idx += 2\n    \n    # Sort by deadline (earliest first)\n    jobs.sort()\n    \n    current_time = 0\n    for deadline, duration in jobs:\n        current_time += duration\n        if current_time > deadline:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 136.98047161102295}
{"eval_index": 113, "problem_id": 4183, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    periods = list(map(int, data[1:1+n]))\n    \n    # Compute LCM of all periods\n    lcm_val = 1\n    for t in periods:\n        lcm_val = lcm_val // math.gcd(lcm_val, t) * t\n        if lcm_val > 10**18:  # Early exit if exceeds limit\n            break\n    \n    print(lcm_val)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 702.8362452983856}
{"eval_index": 114, "problem_id": 3378, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 97.29530549049377}
{"eval_index": 115, "problem_id": 479, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [int(next(it)) for _ in range(q)]\n    \n    # Precompute all possible sums using at most k bills of at most 2 denominations\n    # We'll store for each sum the minimum number of bills\n    max_sum = max(queries)\n    INF = 10**9\n    dp = [INF] * (max_sum + 1)\n    dp[0] = 0\n    \n    # Try all pairs of denominations (including single denomination)\n    for i in range(n):\n        d1 = a[i]\n        # Single denomination case\n        for cnt in range(1, k + 1):\n            val = d1 * cnt\n            if val <= max_sum:\n                dp[val] = min(dp[val], cnt)\n        # Two denominations case\n        for j in range(i + 1, n):\n            d2 = a[j]\n            # Try all combinations of counts\n            for cnt1 in range(k + 1):\n                for cnt2 in range(k + 1 - cnt1):\n                    if cnt1 + cnt2 == 0:\n                        continue\n                    val = d1 * cnt1 + d2 * cnt2\n                    if val <= max_sum:\n                        dp[val] = min(dp[val], cnt1 + cnt2)\n    \n    # Answer queries\n    out_lines = []\n    for x in queries:\n        if x <= max_sum and dp[x] != INF:\n            out_lines.append(str(dp[x]))\n        else:\n            out_lines.append(\"-1\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1939.48379945755}
{"eval_index": 116, "problem_id": 4421, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    d = list(map(int, data[2:2+n]))\n    \n    # Count remainders modulo k\n    rem_count = [0] * k\n    for val in d:\n        rem_count[val % k] += 1\n    \n    # Pair boxes with remainder r and remainder (k-r) mod k\n    ans = 0\n    # Special case: remainder 0 pairs with itself\n    ans += (rem_count[0] // 2) * 2\n    \n    # For other remainders\n    for r in range(1, (k+1)//2):\n        other = k - r\n        if r != other:\n            ans += min(rem_count[r], rem_count[other]) * 2\n        else:\n            # When k is even and r == k//2\n            ans += (rem_count[r] // 2) * 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.07227683067322}
{"eval_index": 117, "problem_id": 3752, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    k, d, t = map(int, data)\n    \n    # If k is multiple of d, stove always on after first cycle\n    if k % d == 0:\n        print(float(t))\n        return\n    \n    # Calculate cycle length and cooking progress per cycle\n    # One cycle: stove on for k minutes, then off until next multiple of d\n    off_time = (d - k % d) % d\n    if off_time == 0:\n        off_time = d\n    \n    cycle_len = k + off_time\n    \n    # Cooking progress per cycle\n    # When on: 1/t per minute, when off: 1/(2t) per minute\n    progress_per_cycle = k / t + off_time / (2 * t)\n    \n    # Number of full cycles needed\n    full_cycles = math.floor(1.0 / progress_per_cycle)\n    remaining_progress = 1.0 - full_cycles * progress_per_cycle\n    \n    # Time for full cycles\n    total_time = full_cycles * cycle_len\n    \n    # Handle remaining progress\n    if remaining_progress > 0:\n        # First try to use on time\n        needed_on_time = remaining_progress * t\n        if needed_on_time <= k:\n            total_time += needed_on_time\n        else:\n            # Use all on time, then off time\n            total_time += k\n            remaining_progress -= k / t\n            # Remaining progress uses off time\n            needed_off_time = remaining_progress * (2 * t)\n            total_time += needed_off_time\n    \n    # Print with sufficient precision\n    print(f\"{total_time:.12f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 63.15840291976929}
{"eval_index": 118, "problem_id": 2557, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    # Build adjacency list for the directed graph of required connections\n    adj = [[] for _ in range(n)]\n    indeg = [0] * n\n    outdeg = [0] * n\n    \n    for _ in range(m):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n        outdeg[a] += 1\n        indeg[b] += 1\n    \n    # Find strongly connected components using Kosaraju's algorithm\n    visited = [False] * n\n    order = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Build reversed graph\n    rev_adj = [[] for _ in range(n)]\n    for u in range(n):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n    \n    comp = [-1] * n\n    comp_count = 0\n    \n    def dfs2(u, label):\n        comp[u] = label\n        for v in rev_adj[u]:\n            if comp[v] == -1:\n                dfs2(v, label)\n    \n    for u in reversed(order):\n        if comp[u] == -1:\n            dfs2(u, comp_count)\n            comp_count += 1\n    \n    # Build condensation DAG\n    dag_adj = [set() for _ in range(comp_count)]\n    dag_indeg = [0] * comp_count\n    dag_outdeg = [0] * comp_count\n    \n    for u in range(n):\n        cu = comp[u]\n        for v in adj[u]:\n            cv = comp[v]\n            if cu != cv and cv not in dag_adj[cu]:\n                dag_adj[cu].add(cv)\n                dag_indeg[cv] += 1\n                dag_outdeg[cu] += 1\n    \n    # Count sources and sinks in condensation DAG\n    sources = sum(1 for i in range(comp_count) if dag_indeg[i] == 0)\n    sinks = sum(1 for i in range(comp_count) if dag_outdeg[i] == 0)\n    \n    # Minimum edges to make condensation DAG strongly connected\n    if comp_count == 1:\n        result = 0\n    else:\n        result = max(sources, sinks)\n    \n    # Add edges within each SCC if needed\n    for c in range(comp_count):\n        # Count vertices in this SCC\n        vertices = [i for i in range(n) if comp[i] == c]\n        if len(vertices) > 1:\n            # Need at least len(vertices) edges to make SCC strongly connected\n            # But we already have some edges from original graph\n            # For minimum, we need to add edges to make it strongly connected\n            # The minimum edges to make a strongly connected component with k vertices\n            # is k if there are no edges, but we have some edges already\n            # Actually, within an SCC, we need at least k edges to form a cycle covering all vertices\n            # But since we're counting total pipes, and condensation already handles inter-SCC edges,\n            # we need to ensure each SCC is strongly connected internally\n            # Minimum edges to make a directed graph strongly connected is max(sources, sinks) of its condensation\n            # For a single SCC with multiple vertices, we need at least len(vertices) edges\n            # But we might already have some edges\n            # For this problem, we can think differently:\n            # The answer is n + result - 1, where result is from condensation\n            # But let's verify with examples\n            pass\n    \n    # The correct formula from known solution: answer = max(n, m, n + result - 1)\n    # But actually, known solution for this problem (CF 500C?):\n    # answer = n + result - 1 if comp_count > 1 else n\n    # Wait, let's think: we need at least n-1 edges to connect n vertices in a DAG\n    # Plus additional edges to satisfy all requirements\n    # From known editorial: answer = n + max(sources, sinks) - 1\n    # But need to handle case when comp_count == 1\n    if comp_count == 1:\n        # All vertices in one SCC, need at least n edges to make it strongly connected\n        # But we might need more if m > n\n        result = max(n, m)\n    else:\n        result = n + max(sources, sinks) - 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 94.48848605155945}
{"eval_index": 119, "problem_id": 4311, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def f(n):\n    return n // 2 if n % 2 == 0 else 3 * n + 1\n\ndef solve():\n    s = int(input().strip())\n    seen = {}\n    a = s\n    i = 1\n    while True:\n        if a in seen:\n            print(i)\n            return\n        seen[a] = i\n        a = f(a)\n        i += 1\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 497.37511944770813}
{"eval_index": 120, "problem_id": 3187, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 96.11335182189941}
{"eval_index": 121, "problem_id": 0, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Find first '['\n    first_open = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open = i\n            break\n    if first_open == -1:\n        print(-1)\n        return\n    \n    # Find last ']' after first '['\n    last_close = -1\n    for i in range(n-1, first_open, -1):\n        if s[i] == ']':\n            last_close = i\n            break\n    if last_close == -1:\n        print(-1)\n        return\n    \n    # Find first ':' between first '[' and last ']'\n    first_colon = -1\n    for i in range(first_open + 1, last_close):\n        if s[i] == ':':\n            first_colon = i\n            break\n    if first_colon == -1:\n        print(-1)\n        return\n    \n    # Find last ':' between first_colon and last_close\n    last_colon = -1\n    for i in range(last_close - 1, first_colon, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n    if last_colon == -1:\n        print(-1)\n        return\n    \n    # Count '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon + 1, last_colon):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # Accordion length: '[' + ':' + pipes + ':' + ']' = 4 + pipe_count\n    print(4 + pipe_count)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 3872.9478764533997}
{"eval_index": 122, "problem_id": 4530, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nidx = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[idx])\n    idx += 1\n    arr = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    freq = collections.Counter(arr)\n    max_freq = max(freq.values())\n    distinct = len(freq)\n    \n    # The answer is min(max_freq, distinct) but we need to handle the case\n    # where they are equal carefully\n    if max_freq > distinct:\n        ans = distinct\n    elif max_freq == distinct:\n        ans = distinct - 1\n    else:\n        ans = max_freq\n    \n    # Ensure answer is non-negative\n    if ans < 0:\n        ans = 0\n    \n    results.append(str(ans))\n\nprint('\\n'.join(results))", "runtime_sec": 145.5980429649353}
{"eval_index": 123, "problem_id": 3879, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the greatest common divisor of all numbers\n    g = arr[0]\n    for x in arr[1:]:\n        g = math.gcd(g, x)\n    \n    # For each number, divide by gcd to get the reduced factor\n    for x in arr:\n        reduced = x // g\n        # Keep dividing by 2 and 3 until we can't\n        while reduced % 2 == 0:\n            reduced //= 2\n        while reduced % 3 == 0:\n            reduced //= 3\n        # If after removing all factors of 2 and 3 we don't get 1, it's impossible\n        if reduced != 1:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1354.7746353149414}
{"eval_index": 124, "problem_id": 2928, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef read_float():\n    return float(sys.stdin.readline().strip())\n\ndef calculate_tax(income, bands, s, p, P):\n    \"\"\"Calculate tax for given income based on tax bands.\"\"\"\n    tax = 0.0\n    remaining = income\n    \n    # Apply each tax band\n    for i in range(bands):\n        if remaining <= 0:\n            break\n        band_size = s[i]\n        band_rate = p[i] / 100.0\n        \n        if remaining >= band_size:\n            tax += band_size * band_rate\n            remaining -= band_size\n        else:\n            tax += remaining * band_rate\n            remaining = 0\n            break\n    \n    # Apply final percentage to remaining income above all bands\n    if remaining > 0:\n        tax += remaining * (P / 100.0)\n    \n    return tax\n\ndef find_gift(earned, target_after_tax, bands, s, p, P):\n    \"\"\"Find gift amount needed to achieve target after-tax amount.\"\"\"\n    # Binary search for gift amount\n    low = 0.0\n    high = 1e12  # Upper bound large enough\n    \n    for _ in range(100):  # 100 iterations for high precision\n        mid = (low + high) / 2.0\n        total_income = earned + mid\n        tax = calculate_tax(total_income, bands, s, p, P)\n        after_tax = total_income - tax\n        \n        if after_tax >= target_after_tax:\n            high = mid\n        else:\n            low = mid\n    \n    return (low + high) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    idx = 0\n    B = int(data[idx]); idx += 1\n    \n    s = []\n    p = []\n    for _ in range(B):\n        s_val = float(data[idx]); idx += 1\n        p_val = float(data[idx]); idx += 1\n        s.append(s_val)\n        p.append(p_val)\n    \n    P = float(data[idx]); idx += 1\n    F = int(data[idx]); idx += 1\n    \n    results = []\n    for _ in range(F):\n        earned = float(data[idx]); idx += 1\n        target = float(data[idx]); idx += 1\n        \n        gift = find_gift(earned, target, B, s, p, P)\n        results.append(f\"{gift:.6f}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 71.98490953445435}
{"eval_index": 125, "problem_id": 4628, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\ndef dijkstra(n, adj, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x = int(next(it))\n        y = int(next(it))\n        w = int(next(it))\n        edges.append((x, y, w))\n        adj[x].append((y, w))\n        adj[y].append((x, w))\n    \n    routes = []\n    for _ in range(k):\n        a = int(next(it))\n        b = int(next(it))\n        routes.append((a, b))\n    \n    # Precompute all-pairs shortest paths\n    dists = [None] * (n + 1)\n    for i in range(1, n + 1):\n        dists[i] = dijkstra(n, adj, i)\n    \n    # Compute base total cost without any zero road\n    base_total = 0\n    for a, b in routes:\n        base_total += dists[a][b]\n    \n    # Try making each road zero\n    best = base_total\n    for x, y, w in edges:\n        # For each route, compute new distance with road (x,y) zero\n        new_total = 0\n        for a, b in routes:\n            # New distance is min(original, path through zero road)\n            # Path through zero road: dist[a][x] + 0 + dist[y][b] or dist[a][y] + 0 + dist[x][b]\n            original = dists[a][b]\n            through_zero = min(dists[a][x] + dists[y][b], dists[a][y] + dists[x][b])\n            new_total += min(original, through_zero)\n        best = min(best, new_total)\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 112.6919846534729}
{"eval_index": 126, "problem_id": 3527, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport sys\nsys.setrecursionlimit(200000)\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    rx, ry = find(x, parent), find(y, parent)\n    if rx == ry:\n        return\n    if size[rx] < size[ry]:\n        rx, ry = ry, rx\n    parent[ry] = rx\n    size[rx] += size[ry]\n\ndef bfs(start, adj):\n    n = len(adj)\n    dist = [-1] * n\n    q = [start]\n    dist[start] = 0\n    farthest = start\n    for u in q:\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n                if dist[v] > dist[farthest]:\n                    farthest = v\n    return farthest, dist\n\ndef tree_diameter(adj, comp_nodes):\n    if not comp_nodes:\n        return 0\n    start = comp_nodes[0]\n    far1, _ = bfs(start, adj)\n    far2, dist = bfs(far1, adj)\n    return dist[far2]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    c = int(next(it))\n    l = int(next(it))\n    adj = [[] for _ in range(c)]\n    parent = list(range(c))\n    size = [1] * c\n    for _ in range(l):\n        a = int(next(it))\n        b = int(next(it))\n        adj[a].append(b)\n        adj[b].append(a)\n        union(a, b, parent, size)\n    comps = {}\n    for i in range(c):\n        root = find(i, parent)\n        if root not in comps:\n            comps[root] = []\n        comps[root].append(i)\n    diameters = []\n    for nodes in comps.values():\n        d = tree_diameter(adj, nodes)\n        diameters.append(d)\n    diameters.sort(reverse=True)\n    if len(diameters) == 1:\n        print(diameters[0])\n        return\n    max_d = diameters[0]\n    second_d = diameters[1] if len(diameters) > 1 else 0\n    third_d = diameters[2] if len(diameters) > 2 else 0\n    candidate1 = max_d\n    candidate2 = (max_d + 1) // 2 + (second_d + 1) // 2 + 1\n    candidate3 = (second_d + 1) // 2 + (third_d + 1) // 2 + 2 if len(diameters) > 2 else 0\n    result = max(candidate1, candidate2, candidate3)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 117.6686851978302}
{"eval_index": 127, "problem_id": 1764, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Precompute prefix sums for quick score queries\n    pref1 = [0] * (n + 1)\n    pref2 = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pref1[i] = pref1[i-1] + (1 if a[i-1] == 1 else 0)\n        pref2[i] = pref2[i-1] + (1 if a[i-1] == 2 else 0)\n    \n    # Helper to get score difference between positions\n    def get_score(player, l, r):\n        if player == 1:\n            return pref1[r] - pref1[l-1]\n        else:\n            return pref2[r] - pref2[l-1]\n    \n    results = []\n    \n    # Try all possible t values (1 to n)\n    for t in range(1, n + 1):\n        pos = 1\n        wins1 = 0\n        wins2 = 0\n        last_winner = 0\n        valid = True\n        \n        while pos <= n:\n            # Binary search to find where someone reaches t points\n            low, high = pos, n\n            while low < high:\n                mid = (low + high) // 2\n                score1 = get_score(1, pos, mid)\n                score2 = get_score(2, pos, mid)\n                if score1 >= t or score2 >= t:\n                    high = mid\n                else:\n                    low = mid + 1\n            \n            end = low\n            if end > n:\n                valid = False\n                break\n            \n            score1 = get_score(1, pos, end)\n            score2 = get_score(2, pos, end)\n            \n            if score1 >= t and score2 >= t:\n                valid = False\n                break\n            \n            if score1 >= t:\n                wins1 += 1\n                last_winner = 1\n            else:\n                wins2 += 1\n                last_winner = 2\n            \n            pos = end + 1\n        \n        if not valid:\n            continue\n        \n        # Check if match ended properly\n        if pos == n + 1 and wins1 != wins2:\n            s = max(wins1, wins2)\n            winner = 1 if wins1 > wins2 else 2\n            if winner == last_winner:\n                results.append((s, t))\n    \n    # Sort and output\n    results.sort(key=lambda x: (x[0], x[1]))\n    print(len(results))\n    for s, t in results:\n        print(s, t)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 74.23563241958618}
{"eval_index": 128, "problem_id": 4615, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    A, B, C, D, E, F = map(int, sys.stdin.read().split())\n    max_water = F // 100 * 100\n    water_ops = [100 * A, 100 * B]\n    sugar_ops = [C, D]\n    \n    # DP for possible water amounts\n    water_possible = [False] * (max_water + 1)\n    water_possible[0] = True\n    for w in water_ops:\n        for i in range(w, max_water + 1):\n            if water_possible[i - w]:\n                water_possible[i] = True\n    \n    # DP for possible sugar amounts\n    max_sugar = F\n    sugar_possible = [False] * (max_sugar + 1)\n    sugar_possible[0] = True\n    for s in sugar_ops:\n        for i in range(s, max_sugar + 1):\n            if sugar_possible[i - s]:\n                sugar_possible[i] = True\n    \n    best_total = 100 * A  # minimum water amount\n    best_sugar = 0\n    best_density = -1.0\n    \n    for water in range(100, max_water + 1, 100):\n        if not water_possible[water]:\n            continue\n        max_dissolved = min(water // 100 * E, F - water)\n        for sugar in range(max_dissolved + 1):\n            if not sugar_possible[sugar]:\n                continue\n            total = water + sugar\n            if total > F or total == 0:\n                continue\n            density = 100 * sugar / total\n            if density > best_density:\n                best_density = density\n                best_total = total\n                best_sugar = sugar\n            elif abs(density - best_density) < 1e-12 and total > best_total:\n                best_total = total\n                best_sugar = sugar\n    \n    print(best_total, best_sugar)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 105.6066644191742}
{"eval_index": 129, "problem_id": 3369, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef read_input():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return 0, []\n    p = int(data[0])\n    seq = list(map(int, data[1:1 + p]))\n    return p, seq\n\ndef find_triple_correlation(p, seq):\n    min_threshold = (p + 39) // 40 + 1  # ceil(p/40) + 1\n    best = None  # (a, n, b, m, c, first_index)\n    \n    # Try all possible a, b, c (digits 0-9) and n, m (distances)\n    for a in range(10):\n        for b in range(10):\n            for c in range(10):\n                for n in range(1, p):  # n >= 1\n                    for m in range(1, p - n):  # m >= 1, and n+m < p\n                        count = 0\n                        first_index = None\n                        \n                        # Check all positions i where seq[i] == a\n                        for i in range(p - n - m):\n                            if seq[i] == a and seq[i + n] == b and seq[i + n + m] == c:\n                                # Verify the three conditions\n                                valid = True\n                                \n                                # Condition 1: a followed n later by b implies c m after b\n                                # (already satisfied by the check above, but need to check boundaries)\n                                if i + n + m >= p:\n                                    valid = False\n                                \n                                # Condition 2: b followed m later by c implies a n before b\n                                # Check all positions j where seq[j] == b\n                                if valid:\n                                    for j in range(n, p - m):\n                                        if seq[j] == b and seq[j + m] == c:\n                                            if j - n < 0 or seq[j - n] != a:\n                                                valid = False\n                                                break\n                                \n                                # Condition 3: a followed n+m later by c implies b n after a\n                                if valid:\n                                    for k in range(p - n - m):\n                                        if seq[k] == a and seq[k + n + m] == c:\n                                            if k + n >= p or seq[k + n] != b:\n                                                valid = False\n                                                break\n                                \n                                if valid:\n                                    count += 1\n                                    if first_index is None:\n                                        first_index = i\n                        \n                        if count >= min_threshold:\n                            candidate = (a, n, b, m, c, first_index)\n                            if best is None:\n                                best = candidate\n                            else:\n                                # Compare: earliest first_index, then smaller n, then smaller m\n                                if first_index < best[5]:\n                                    best = candidate\n                                elif first_index == best[5]:\n                                    if n < best[1]:\n                                        best = candidate\n                                    elif n == best[1] and m < best[3]:\n                                        best = candidate\n    \n    return best\n\ndef main():\n    p, seq = read_input()\n    if p == 0:\n        print(\"random sequence\")\n        return\n    \n    result = find_triple_correlation(p, seq)\n    if result is None:\n        print(\"random sequence\")\n    else:\n        a, n, b, m, c, _ = result\n        print(f\"triple correlation {a}({n}){b}({m}){c} found\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 79.60049438476562}
{"eval_index": 130, "problem_id": 435, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k = map(int, data[:2])\n    s = data[2]\n    \n    def max_beauty(target_char):\n        left = 0\n        changes_used = 0\n        max_len = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes_used += 1\n            \n            while changes_used > k:\n                if s[left] != target_char:\n                    changes_used -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    result = max(max_beauty('a'), max_beauty('b'))\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 2044.5568952560425}
{"eval_index": 131, "problem_id": 4038, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import Counter\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1 + n * n]))\n    \n    # Count frequencies\n    freq = Counter(arr)\n    \n    # Determine positions based on symmetry\n    # For an n x n matrix, positions are grouped by symmetry:\n    # - Center (if n odd): 1 position\n    # - Middle row/col (if n odd): (n-1) positions each, but they pair with themselves\n    # - Regular positions: 4 symmetric positions each\n    \n    # Initialize matrix with zeros\n    mat = [[0] * n for _ in range(n)]\n    \n    # Helper to fill symmetric positions\n    def fill_symmetric(value, i, j):\n        mat[i][j] = value\n        mat[i][n-1-j] = value\n        mat[n-1-i][j] = value\n        mat[n-1-i][n-1-j] = value\n    \n    # Process positions\n    values = sorted(freq.keys(), key=lambda x: (-freq[x], x))\n    idx = 0\n    \n    # Fill center if n is odd\n    if n % 2 == 1:\n        center = n // 2\n        # Find a value with count >= 1\n        found = False\n        for v in values:\n            if freq[v] >= 1:\n                mat[center][center] = v\n                freq[v] -= 1\n                if freq[v] == 0:\n                    del freq[v]\n                found = True\n                break\n        if not found:\n            print(\"NO\")\n            return\n    \n    # Fill middle row and column if n is odd\n    if n % 2 == 1:\n        center = n // 2\n        # Middle row (excluding center)\n        for j in range(center):\n            # Need pairs for symmetry (2 positions each)\n            needed = 2\n            found = False\n            for v in list(freq.keys()):\n                if freq[v] >= needed:\n                    mat[center][j] = v\n                    mat[center][n-1-j] = v\n                    freq[v] -= needed\n                    if freq[v] == 0:\n                        del freq[v]\n                    found = True\n                    break\n            if not found:\n                print(\"NO\")\n                return\n        # Middle column (excluding center)\n        for i in range(center):\n            needed = 2\n            found = False\n            for v in list(freq.keys()):\n                if freq[v] >= needed:\n                    mat[i][center] = v\n                    mat[n-1-i][center] = v\n                    freq[v] -= needed\n                    if freq[v] == 0:\n                        del freq[v]\n                    found = True\n                    break\n            if not found:\n                print(\"NO\")\n                return\n    \n    # Fill the rest (quadrants)\n    for i in range(n // 2):\n        for j in range(n // 2):\n            # Skip if already filled (middle row/col cases)\n            if mat[i][j] != 0:\n                continue\n            # Need 4 symmetric positions\n            needed = 4\n            found = False\n            for v in list(freq.keys()):\n                if freq[v] >= needed:\n                    fill_symmetric(v, i, j)\n                    freq[v] -= needed\n                    if freq[v] == 0:\n                        del freq[v]\n                    found = True\n                    break\n            if not found:\n                print(\"NO\")\n                return\n    \n    # Check if all frequencies are zero\n    if freq:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for row in mat:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 80.74163269996643}
{"eval_index": 132, "problem_id": 3923, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    # Special case: N=1\n    if N == 1:\n        if A == 1 or B == 1:\n            print(1)\n        else:\n            print(-1)\n        return\n    \n    # If both A and B are 1, we need identity permutation\n    if A == 1 and B == 1:\n        print(' '.join(str(i) for i in range(1, N+1)))\n        return\n    \n    # If only one of A or B is 1\n    if A == 1 or B == 1:\n        # The non-1 value must equal N\n        other = A if B == 1 else B\n        if other != N:\n            print(-1)\n            return\n        # Create a single cycle of length N\n        result = list(range(2, N+1)) + [1]\n        print(' '.join(str(x) for x in result))\n        return\n    \n    # Both A and B > 1\n    # We need to partition N into cycles of lengths A and B\n    # Let x = number of A-cycles, y = number of B-cycles\n    # Then x*A + y*B = N\n    \n    # Find non-negative integer solution\n    found = False\n    x = y = 0\n    \n    # Try all possible x from 0 to N//A\n    for x_try in range(N // A + 1):\n        remaining = N - x_try * A\n        if remaining % B == 0:\n            y_try = remaining // B\n            if y_try >= 0:\n                x = x_try\n                y = y_try\n                found = True\n                break\n    \n    if not found:\n        print(-1)\n        return\n    \n    # Build permutation with x cycles of length A and y cycles of length B\n    result = [0] * N\n    current = 1\n    \n    # Create A-cycles\n    for _ in range(x):\n        cycle = list(range(current, current + A))\n        # Rotate cycle by 1 to create permutation\n        for i in range(A):\n            result[cycle[i] - 1] = cycle[(i + 1) % A]\n        current += A\n    \n    # Create B-cycles\n    for _ in range(y):\n        cycle = list(range(current, current + B))\n        # Rotate cycle by 1 to create permutation\n        for i in range(B):\n            result[cycle[i] - 1] = cycle[(i + 1) % B]\n        current += B\n    \n    print(' '.join(str(x) for x in result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 113.99648308753967}
{"eval_index": 133, "problem_id": 931, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef rotate_90_clockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees clockwise in n×m matrix\"\"\"\n    return y, n - x + 1, m, n\n\ndef rotate_90_counterclockwise(x, y, n, m):\n    \"\"\"Rotate point (x,y) 90 degrees counterclockwise in n×m matrix\"\"\"\n    return m - y + 1, x, m, n\n\ndef horizontal_flip(x, y, n, m):\n    \"\"\"Horizontal flip (mirror) of point (x,y) in n×m matrix\"\"\"\n    return x, m - y + 1, n, m\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    x = int(next(it))\n    y = int(next(it))\n    z = int(next(it))\n    p = int(next(it))\n    \n    # Reduce rotations modulo 4 since 4 rotations = identity\n    x %= 4\n    z %= 4\n    # Horizontal flip is its own inverse, so y % 2\n    y %= 2\n    \n    results = []\n    for _ in range(p):\n        xi = int(next(it))\n        yi = int(next(it))\n        \n        # Apply transformations in order: x clockwise, y horizontal, z counterclockwise\n        curr_n, curr_m = n, m\n        \n        # x clockwise rotations\n        for _ in range(x):\n            xi, yi, curr_n, curr_m = rotate_90_clockwise(xi, yi, curr_n, curr_m)\n        \n        # y horizontal flips\n        if y:\n            xi, yi, curr_n, curr_m = horizontal_flip(xi, yi, curr_n, curr_m)\n        \n        # z counterclockwise rotations\n        for _ in range(z):\n            xi, yi, curr_n, curr_m = rotate_90_counterclockwise(xi, yi, curr_n, curr_m)\n        \n        results.append(f\"{xi} {yi}\")\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 69.09681534767151}
{"eval_index": 134, "problem_id": 4382, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    # Each of the 3 positions can be any digit from 1 to N\n    # Total possibilities = N * N * N = N^3\n    result = N ** 3\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 374.06250619888306}
{"eval_index": 135, "problem_id": 3437, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    L1 = int(data[0])\n    L2 = int(data[1])\n    N = int(data[2])\n    tubes = list(map(int, data[3:3+N]))\n    \n    # Step 1: Generate all possible sums of two tubes\n    two_sums = []\n    for i in range(N):\n        for j in range(i+1, N):\n            s = tubes[i] + tubes[j]\n            two_sums.append(s)\n    two_sums.sort()\n    \n    # Step 2: For each L, find the maximum sum ≤ L\n    def max_sum_up_to(limit, sums_list):\n        # Binary search for the largest sum ≤ limit\n        lo, hi = 0, len(sums_list)-1\n        best = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if sums_list[mid] <= limit:\n                best = sums_list[mid]\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return best\n    \n    best1 = max_sum_up_to(L1, two_sums)\n    best2 = max_sum_up_to(L2, two_sums)\n    \n    if best1 == -1 or best2 == -1:\n        print(\"Impossible\")\n    else:\n        print(best1 + best2)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 61.94020986557007}
{"eval_index": 136, "problem_id": 2321, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        s = data[idx + 1]\n        idx += 2\n        # Count consecutive '<' at the beginning and consecutive '>' at the end\n        left_count = 0\n        while left_count < n and s[left_count] == '<':\n            left_count += 1\n        right_count = 0\n        while right_count < n and s[n - 1 - right_count] == '>':\n            right_count += 1\n        # Minimum deletions needed is the smaller of these two counts\n        results.append(str(min(left_count, right_count)))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 186.14433312416077}
{"eval_index": 137, "problem_id": 4226, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Let c = number of cranes, t = number of turtles\n    # c + t = X\n    # 2c + 4t = Y\n    # Solve for t: 2(X - t) + 4t = Y => 2X - 2t + 4t = Y => 2X + 2t = Y => t = (Y - 2X)/2\n    # t must be non-negative integer, and c = X - t must be non-negative integer\n    \n    if (Y - 2 * X) % 2 != 0:\n        print(\"No\")\n        return\n    \n    t = (Y - 2 * X) // 2\n    c = X - t\n    \n    if c >= 0 and t >= 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 621.4500801563263}
{"eval_index": 138, "problem_id": 3953, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if any row or column is completely evil\n    for i in range(n):\n        if all(grid[i][j] == 'E' for j in range(n)):\n            # This row is all evil, check if any column has a non-evil cell\n            possible = False\n            for j in range(n):\n                if any(grid[k][j] == '.' for k in range(n)):\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    for j in range(n):\n        if all(grid[i][j] == 'E' for i in range(n)):\n            # This column is all evil, check if any row has a non-evil cell\n            possible = False\n            for i in range(n):\n                if any(grid[i][k] == '.' for k in range(n)):\n                    possible = True\n                    break\n            if not possible:\n                print(-1)\n                return\n    \n    # Find solution\n    # Try row-based approach first\n    row_solution = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '.':\n                row_solution.append((i+1, j+1))\n                break\n    \n    # Try column-based approach\n    col_solution = []\n    for j in range(n):\n        for i in range(n):\n            if grid[i][j] == '.':\n                col_solution.append((i+1, j+1))\n                break\n    \n    # Choose the shorter solution\n    if len(row_solution) <= len(col_solution):\n        solution = row_solution\n    else:\n        solution = col_solution\n    \n    # Verify solution covers all cells\n    purified = [[False]*n for _ in range(n)]\n    for r, c in solution:\n        i, j = r-1, c-1\n        # Purify entire row and column\n        for k in range(n):\n            purified[i][k] = True\n            purified[k][j] = True\n    \n    # Check if all cells are purified\n    for i in range(n):\n        for j in range(n):\n            if not purified[i][j]:\n                print(-1)\n                return\n    \n    # Output solution\n    for r, c in solution:\n        print(f\"{r} {c}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 199.54661083221436}
{"eval_index": 139, "problem_id": 2102, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    # Read inputs\n    a = list(map(int, data[:6]))\n    n = int(data[6])\n    b = list(map(int, data[7:7+n]))\n    \n    # For each note, compute all possible fret positions across all strings\n    positions = []\n    for note in b:\n        note_positions = []\n        for string_val in a:\n            fret = note - string_val\n            if fret >= 1:  # fret numbers start from 1\n                note_positions.append(fret)\n        positions.append(note_positions)\n    \n    # We need to pick one position per note to minimize max-min\n    # Use two-pointer sliding window on sorted list of all (fret, note_index) pairs\n    all_pairs = []\n    for i, pos_list in enumerate(positions):\n        for fret in pos_list:\n            all_pairs.append((fret, i))\n    \n    if not all_pairs:\n        print(0)\n        return\n    \n    all_pairs.sort()  # Sort by fret value\n    \n    # Sliding window to find minimal range covering all notes\n    m = len(all_pairs)\n    left = 0\n    note_count = [0] * n\n    covered = 0\n    min_diff = float('inf')\n    \n    for right in range(m):\n        fret_val, note_idx = all_pairs[right]\n        if note_count[note_idx] == 0:\n            covered += 1\n        note_count[note_idx] += 1\n        \n        # Try to shrink window from left while still covering all notes\n        while covered == n:\n            min_diff = min(min_diff, fret_val - all_pairs[left][0])\n            left_fret, left_note = all_pairs[left]\n            note_count[left_note] -= 1\n            if note_count[left_note] == 0:\n                covered -= 1\n            left += 1\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 309.63544154167175}
{"eval_index": 140, "problem_id": 4315, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\nR = int(sys.stdin.readline().strip())\n\n# Calculate circumference: C = 2 * π * R\ncircumference = 2 * math.pi * R\n\n# Print with sufficient precision\nprint(circumference)", "runtime_sec": 49.487284421920776}
{"eval_index": 141, "problem_id": 3786, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    p = [0] * (n + 1)  # 1-indexed\n    for i in range(2, n + 1):\n        p[i] = int(data[i - 1])\n    \n    # dp[i] = number of apples that will reach inflorescence i (mod 2)\n    dp = [0] * (n + 1)\n    # Initially, each inflorescence has exactly one apple\n    for i in range(1, n + 1):\n        dp[i] = 1\n    \n    # Process nodes in topological order (increasing i)\n    for i in range(2, n + 1):\n        dp[p[i]] ^= dp[i]  # XOR to simulate parity\n    \n    # Count apples collected at inflorescence 1\n    result = dp[1]\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 98.25234723091125}
{"eval_index": 142, "problem_id": 506, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef count_ships(a, b):\n    \"\"\"\n    Count the number of ships Vasya can make using the process:\n    - Start with rectangle a x b (a > b)\n    - Cut off a square of size b x b, count 1 ship\n    - Remainder is (a-b) x b\n    - Repeat until remainder is square or zero\n    \"\"\"\n    ships = 0\n    while b > 0:\n        # Add ships from current rectangle a x b\n        ships += a // b\n        # Update a, b for next iteration\n        a, b = b, a % b\n    return ships\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    a, b = map(int, data[:2])\n    result = count_ships(a, b)\n    print(result)", "runtime_sec": 1877.9580671787262}
{"eval_index": 143, "problem_id": 4297, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    N = int(data)\n    # The answer is LCM(2, N) = 2 * N / GCD(2, N)\n    # Since 2 is prime, GCD(2, N) is either 1 or 2\n    if N % 2 == 0:\n        print(N)\n    else:\n        print(2 * N)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 499.0230176448822}
{"eval_index": 144, "problem_id": 3247, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.50760293006897}
{"eval_index": 145, "problem_id": 1338, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Precompute factorials up to 50\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i\n    \n    # DP to count permutations with maximum f(p)\n    # dp[k] = number of max-f permutations of length k\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for k in range(2, n + 1):\n        # For length k, we can place the largest element (k) at position i (1-indexed)\n        # Then left part has i-1 elements, right part has k-i elements\n        # Both parts must also be max-f permutations\n        total = 0\n        for i in range(1, k + 1):\n            left_count = dp[i-1]\n            right_count = dp[k-i]\n            # Number of ways to interleave left and right parts\n            # Choose positions for left elements among k-1 remaining positions\n            ways = math.comb(k-1, i-1)\n            total += left_count * right_count * ways\n        dp[k] = total\n    \n    # Now construct the m-th permutation\n    result = []\n    remaining = list(range(1, n + 1))\n    \n    def construct(k, target_m, elements):\n        if k == 0:\n            return []\n        if k == 1:\n            return [elements[0]]\n        \n        # Find position of largest element\n        for pos in range(1, k + 1):\n            left_size = pos - 1\n            right_size = k - pos\n            \n            left_count = dp[left_size]\n            right_count = dp[right_size]\n            ways = math.comb(k-1, left_size)\n            block_size = left_count * right_count * ways\n            \n            if target_m <= block_size:\n                # Largest element goes at position pos\n                # Need to find which combination of left/right permutations\n                per_left_right = left_count * right_count\n                block_in_group = (target_m - 1) // per_left_right\n                m_in_group = (target_m - 1) % per_left_right\n                \n                # Choose which left permutation\n                left_perm_idx = m_in_group // right_count\n                right_perm_idx = m_in_group % right_count\n                \n                # Choose left elements\n                # We need to choose left_size elements from elements[0:k-1]\n                # The largest element (elements[k-1]) goes at position pos\n                left_elements = []\n                right_elements = []\n                \n                # Generate all combinations and find the correct one\n                from itertools import combinations\n                all_combs = list(combinations(elements[:-1], left_size))\n                left_comb = all_combs[block_in_group]\n                \n                left_set = set(left_comb)\n                for elem in elements[:-1]:\n                    if elem in left_set:\n                        left_elements.append(elem)\n                    else:\n                        right_elements.append(elem)\n                \n                # Recursively construct left and right parts\n                left_perm = construct(left_size, left_perm_idx + 1, left_elements)\n                right_perm = construct(right_size, right_perm_idx + 1, right_elements)\n                \n                return left_perm + [elements[-1]] + right_perm\n            else:\n                target_m -= block_size\n        \n        # Should not reach here\n        return []\n    \n    result = construct(n, m, remaining)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 79.09778666496277}
{"eval_index": 146, "problem_id": 4922, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    m = int(data[0])\n    n = int(data[1])\n    \n    # Simply check if number of clauses is at least 8\n    if m >= 8:\n        print(\"satisfactory\")\n    else:\n        print(\"unsatisfactory\")\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 92.62487816810608}
{"eval_index": 147, "problem_id": 3334, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    dist = [[0]*n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            d = int(next(it))\n            dist[i][j] = d\n            dist[j][i] = d\n    \n    # Check if distances satisfy tree properties\n    # 1. Triangle inequality for all triples\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    print(\"impossible\")\n                    return\n    \n    # 2. Check if distances correspond to a tree\n    # For a tree, there should be exactly n-1 pairs with distance 1\n    # But we don't know which are edges, so we need to reconstruct tree\n    \n    # Try to reconstruct tree using distances\n    # We'll use the fact that in a tree, for any vertex u, \n    # the farthest vertex v gives a diameter endpoint\n    \n    # Find diameter endpoints\n    max_dist = -1\n    a = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if dist[i][j] > max_dist:\n                max_dist = dist[i][j]\n                a = i\n    \n    # Find farthest from a\n    max_dist = -1\n    b = a\n    for i in range(n):\n        if dist[a][i] > max_dist:\n            max_dist = dist[a][i]\n            b = i\n    \n    # Now a and b are diameter endpoints\n    # Reconstruct tree along the diameter\n    diameter = dist[a][b]\n    if diameter == 0:\n        print(\"impossible\")\n        return\n    \n    # Place vertices along the diameter\n    # For each vertex, compute its distance to a and b\n    positions = []\n    for i in range(n):\n        da = dist[a][i]\n        db = dist[b][i]\n        # Check if consistent with tree metric\n        if da + db != diameter:\n            print(\"impossible\")\n            return\n        positions.append(da)  # Distance from a\n    \n    # Sort vertices by distance from a\n    vertices = list(range(n))\n    vertices.sort(key=lambda x: positions[x])\n    \n    # Verify distances between all pairs match given distances\n    for i in range(n):\n        for j in range(i+1, n):\n            computed = abs(positions[i] - positions[j])\n            if computed != dist[i][j]:\n                print(\"impossible\")\n                return\n    \n    # Now we have a path graph with vertices at integer positions\n    # Total number of signs = sum of all distances + n (signs at ports)\n    total_signs = sum(positions) + n\n    \n    # Calculate sum of distances between all pairs of signs\n    # Signs are at integer positions from 0 to total_signs-1\n    # But actually, signs are placed at each integer point along edges\n    # For a path graph, the signs are at all integer points from 0 to diameter\n    \n    # Count signs at each integer position\n    sign_counts = [0]*(diameter+1)\n    for pos in positions:\n        sign_counts[pos] += 1\n    \n    # Calculate sum of distances between all pairs of signs\n    total_pairs = 0\n    sum_dist = 0\n    \n    for i in range(diameter+1):\n        for j in range(i+1, diameter+1):\n            cnt_i = sign_counts[i]\n            cnt_j = sign_counts[j]\n            if cnt_i > 0 and cnt_j > 0:\n                pairs = cnt_i * cnt_j\n                total_pairs += pairs\n                sum_dist += pairs * (j - i)\n    \n    # Also include pairs where both signs are at same position\n    for i in range(diameter+1):\n        cnt = sign_counts[i]\n        if cnt > 1:\n            pairs = cnt * (cnt - 1) // 2\n            total_pairs += pairs\n            # Distance is 0 for same position\n    \n    if total_pairs == 0:\n        print(\"impossible\")\n        return\n    \n    average = sum_dist / total_pairs\n    print(f\"{average:.15f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 87.06123876571655}
{"eval_index": 148, "problem_id": 459, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef is_solved(cube):\n    \"\"\"Check if cube is solved (each face has uniform color).\"\"\"\n    faces = [\n        cube[0:4],   # U\n        cube[4:8],   # L\n        cube[8:12],  # F\n        cube[12:16], # R\n        cube[16:20], # B\n        cube[20:24]  # D\n    ]\n    return all(len(set(face)) == 1 for face in faces)\n\ndef rotate_face(cube, face_indices, clockwise=True):\n    \"\"\"Rotate a face defined by indices (4 positions).\"\"\"\n    new_cube = cube[:]\n    a, b, c, d = face_indices\n    if clockwise:\n        new_cube[a], new_cube[b], new_cube[c], new_cube[d] = cube[b], cube[d], cube[a], cube[c]\n    else:\n        new_cube[a], new_cube[b], new_cube[c], new_cube[d] = cube[c], cube[a], cube[d], cube[b]\n    return new_cube\n\ndef rotate_adjacent(cube, adj_indices, clockwise=True):\n    \"\"\"Rotate adjacent stickers around a face.\"\"\"\n    new_cube = cube[:]\n    # adj_indices: list of 4 lists, each with 3 indices (for 3 adjacent stickers)\n    if clockwise:\n        temp = [new_cube[i] for lst in adj_indices for i in lst]\n        for i in range(4):\n            for j in range(3):\n                new_cube[adj_indices[i][j]] = temp[((i-1) % 4)*3 + j]\n    else:\n        temp = [new_cube[i] for lst in adj_indices for i in lst]\n        for i in range(4):\n            for j in range(3):\n                new_cube[adj_indices[i][j]] = temp[((i+1) % 4)*3 + j]\n    return new_cube\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    cube = list(map(int, data))\n    \n    # Face indices for 2x2x2 cube (0-based)\n    # Order: U, L, F, R, B, D\n    # Each face: 4 stickers in reading order (top-left, top-right, bottom-left, bottom-right)\n    # Adjacent stickers for each face rotation (12 stickers total)\n    # Defined for clockwise rotation; counter-clockwise is opposite direction\n    \n    # Face rotations: each face can be rotated clockwise or counter-clockwise\n    faces = {\n        'U': ([0,1,3,2], [[4,5,6,7], [8,9,10,11], [12,13,14,15], [16,17,18,19]]),\n        'L': ([4,5,7,6], [[0,2,3,1], [8,10,11,9], [20,22,23,21], [16,18,19,17]]),\n        'F': ([8,9,11,10], [[0,1,3,2], [12,13,15,14], [20,21,23,22], [4,5,7,6]]),\n        'R': ([12,13,15,14], [[0,2,3,1], [16,17,19,18], [20,22,23,21], [8,10,11,9]]),\n        'B': ([16,17,19,18], [[0,1,3,2], [4,5,7,6], [20,21,23,22], [12,13,15,14]]),\n        'D': ([20,21,23,22], [[4,5,7,6], [8,9,11,10], [12,13,15,14], [16,17,19,18]])\n    }\n    \n    # Check if already solved\n    if is_solved(cube):\n        print(\"YES\")\n        return\n    \n    # Try all possible single rotations\n    for face_name, (face_idx, adj_idx) in faces.items():\n        # Clockwise rotation\n        new_cube = rotate_face(cube, face_idx, clockwise=True)\n        new_cube = rotate_adjacent(new_cube, adj_idx, clockwise=True)\n        if is_solved(new_cube):\n            print(\"YES\")\n            return\n        \n        # Counter-clockwise rotation\n        new_cube = rotate_face(cube, face_idx, clockwise=False)\n        new_cube = rotate_adjacent(new_cube, adj_idx, clockwise=False)\n        if is_solved(new_cube):\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 130.09504532814026}
{"eval_index": 149, "problem_id": 4521, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.54354476928711}
{"eval_index": 150, "problem_id": 3574, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\ndef build_sparse_table(arr, n):\n    \"\"\"Build sparse tables for range minimum and maximum queries.\"\"\"\n    k = n.bit_length()\n    min_st = [[0] * n for _ in range(k)]\n    max_st = [[0] * n for _ in range(k)]\n    \n    for i in range(n):\n        min_st[0][i] = arr[i]\n        max_st[0][i] = arr[i]\n    \n    j = 1\n    while (1 << j) <= n:\n        i = 0\n        while i + (1 << j) - 1 < n:\n            min_st[j][i] = min(min_st[j-1][i], min_st[j-1][i + (1 << (j-1))])\n            max_st[j][i] = max(max_st[j-1][i], max_st[j-1][i + (1 << (j-1))])\n            i += 1\n        j += 1\n    \n    return min_st, max_st\n\ndef query_min_max(min_st, max_st, l, r):\n    \"\"\"Query minimum and maximum in range [l, r] using sparse tables.\"\"\"\n    length = r - l + 1\n    k = length.bit_length() - 1\n    min_val = min(min_st[k][l], min_st[k][r - (1 << k) + 1])\n    max_val = max(max_st[k][l], max_st[k][r - (1 << k) + 1])\n    return min_val, max_val\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    arr = [int(next(it)) for _ in range(n)]\n    q = int(next(it))\n    queries = [(int(next(it)) - 1, int(next(it)) - 1) for _ in range(q)]\n    \n    # Build sparse tables for RMQ\n    min_st, max_st = build_sparse_table(arr, n)\n    \n    # Precompute next and previous greater or equal elements\n    next_ge = [n] * n\n    prev_ge = [-1] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and arr[stack[-1]] <= arr[i]:\n            idx = stack.pop()\n            next_ge[idx] = i\n        if stack:\n            prev_ge[i] = stack[-1]\n        stack.append(i)\n    \n    # Precompute next and previous smaller or equal elements\n    next_le = [n] * n\n    prev_le = [-1] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and arr[stack[-1]] >= arr[i]:\n            idx = stack.pop()\n            next_le[idx] = i\n        if stack:\n            prev_le[i] = stack[-1]\n        stack.append(i)\n    \n    out_lines = []\n    for l, r in queries:\n        # Get min and max in the query range\n        range_min, range_max = query_min_max(min_st, max_st, l, r)\n        \n        # Find positions where min and max occur within range\n        # For magical property, we need subarray where first and last are min and max (or vice versa)\n        # The longest magical subarray will be from first occurrence of min to last occurrence of max\n        # or from first occurrence of max to last occurrence of min\n        \n        # Find first min and last max\n        first_min_pos = l\n        while first_min_pos <= r and arr[first_min_pos] != range_min:\n            first_min_pos += 1\n        \n        last_max_pos = r\n        while last_max_pos >= l and arr[last_max_pos] != range_max:\n            last_max_pos -= 1\n        \n        # Find first max and last min\n        first_max_pos = l\n        while first_max_pos <= r and arr[first_max_pos] != range_max:\n            first_max_pos += 1\n        \n        last_min_pos = r\n        while last_min_pos >= l and arr[last_min_pos] != range_min:\n            last_min_pos -= 1\n        \n        # Calculate candidate lengths\n        len1 = abs(last_max_pos - first_min_pos) + 1 if first_min_pos <= last_max_pos else 0\n        len2 = abs(last_min_pos - first_max_pos) + 1 if first_max_pos <= last_min_pos else 0\n        \n        # Also consider the case where min and max are the same (all elements equal)\n        if range_min == range_max:\n            answer = r - l + 1\n        else:\n            answer = max(len1, len2)\n        \n        out_lines.append(str(answer))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 127.56557989120483}
{"eval_index": 151, "problem_id": 461, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # For n >= 2, we need to choose between two strategies:\n    # 1. Alternate between two houses using the shortest edge\n    # 2. Use all three houses in a cycle\n    \n    # Strategy 1: Alternate between two houses\n    # We start at Rabbit (R), need n-1 moves between two houses\n    # Choose the pair with minimum edge: min(a, b, c)\n    min_edge = min(a, b, c)\n    strategy1 = min_edge * (n - 1)\n    \n    # Strategy 2: Use all three houses\n    # We need to consider starting from Rabbit (R)\n    # Options: R->O->E or R->E->O\n    # For n >= 3, we can complete cycles of 3 houses\n    \n    # Path R->O->E: distance = a + c\n    # Path R->E->O: distance = b + c\n    # Choose the minimum of these two for the first cycle\n    first_cycle_min = min(a + c, b + c)\n    \n    # After first cycle, we're at E or O, need to continue\n    # For remaining visits (n-3), we can use the minimum edge\n    # between any two houses\n    if n >= 3:\n        strategy2 = first_cycle_min + min_edge * (n - 3)\n    else:\n        strategy2 = float('inf')\n    \n    # For n = 2, we just need one move from Rabbit to another house\n    # Choose the minimum of a and b (since we're at Rabbit)\n    if n == 2:\n        result = min(a, b)\n    else:\n        result = min(strategy1, strategy2)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 67.86238241195679}
{"eval_index": 152, "problem_id": 4584, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    if not input:\n        return\n    n = int(input[0])\n    bosses = [0] * (n + 1)  # 1-indexed\n    for i in range(2, n + 1):\n        boss = int(input[i - 1])  # A_i for member i\n        bosses[i] = boss\n    \n    subordinates = [0] * (n + 1)  # 1-indexed\n    for member in range(2, n + 1):\n        boss = bosses[member]\n        subordinates[boss] += 1\n    \n    # Output results for members 1 through n\n    for member in range(1, n + 1):\n        print(subordinates[member])\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 138.3730685710907}
{"eval_index": 153, "problem_id": 3256, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    \n    # Duplicate array to handle circular wrap-around\n    A_ext = A + A\n    \n    # Function to check if we can achieve at least K sections with AND >= target\n    def can_achieve(target):\n        if target == 0:\n            return True  # Always possible with any division\n        \n        # Try each possible starting position for the first section\n        for start in range(N):\n            sections = 0\n            i = start\n            while i < start + N:\n                # Build a section with OR >= target\n                current_or = 0\n                j = i\n                while j < start + N:\n                    new_or = current_or | A_ext[j]\n                    if (new_or & target) == target:\n                        # This section has all required bits\n                        current_or = new_or\n                        j += 1\n                    else:\n                        break\n                if (current_or & target) == target:\n                    sections += 1\n                    i = j\n                else:\n                    # Cannot form a valid section starting at i\n                    break\n                if sections >= K:\n                    return True\n            # If we completed the circle with enough sections\n            if i >= start + N and sections >= K:\n                return True\n        return False\n    \n    # Binary search on the answer\n    ans = 0\n    for bit in range(30, -1, -1):\n        candidate = ans | (1 << bit)\n        if can_achieve(candidate):\n            ans = candidate\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 65.51332664489746}
{"eval_index": 154, "problem_id": 2253, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef detect_language(sentence):\n    \"\"\"Detect language based on suffix rules.\"\"\"\n    if sentence.endswith('po'):\n        return 'FILIPINO'\n    elif sentence.endswith('desu') or sentence.endswith('masu'):\n        return 'JAPANESE'\n    elif sentence.endswith('mnida'):\n        return 'KOREAN'\n    else:\n        # According to problem, this case shouldn't happen\n        return 'UNKNOWN'\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        sentence = data[i].strip()\n        results.append(detect_language(sentence))\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 221.30837297439575}
{"eval_index": 155, "problem_id": 4620, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    trains = []\n    for _ in range(N-1):\n        C = int(next(it))\n        S = int(next(it))\n        F = int(next(it))\n        trains.append((C, S, F))\n    \n    results = []\n    for start in range(N):\n        current_time = 0\n        for i in range(start, N-1):\n            C, S, F = trains[i]\n            if current_time <= S:\n                current_time = S\n            else:\n                # Wait for next departure\n                remainder = current_time % F\n                if remainder != 0:\n                    current_time += F - remainder\n            current_time += C\n        results.append(str(current_time))\n    \n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 136.15312957763672}
{"eval_index": 156, "problem_id": 3395, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"impossible\"\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    \n    iron_cells = set()\n    for _ in range(m):\n        iron_cells.add(int(next(it)))\n    \n    coal_cells = set()\n    for _ in range(k):\n        coal_cells.add(int(next(it)))\n    \n    # Build graph\n    graph = [[] for _ in range(n + 1)]\n    for cell in range(1, n + 1):\n        a = int(next(it))\n        for _ in range(a):\n            neighbor = int(next(it))\n            graph[cell].append(neighbor)\n    \n    # BFS from start (cell 1) to find distances to all cells\n    dist_from_start = [-1] * (n + 1)\n    q = deque([1])\n    dist_from_start[1] = 0\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if dist_from_start[v] == -1:\n                dist_from_start[v] = dist_from_start[u] + 1\n                q.append(v)\n    \n    # Check if any iron and coal are reachable from start\n    reachable_iron = [dist for cell, dist in enumerate(dist_from_start) if cell in iron_cells and dist != -1]\n    reachable_coal = [dist for cell, dist in enumerate(dist_from_start) if cell in coal_cells and dist != -1]\n    \n    if not reachable_iron or not reachable_coal:\n        return \"impossible\"\n    \n    # Build reverse graph for BFS from iron/coal cells\n    reverse_graph = [[] for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n    \n    # BFS from all iron cells to find distances to all cells (reverse direction)\n    dist_to_iron = [-1] * (n + 1)\n    q = deque()\n    for cell in iron_cells:\n        dist_to_iron[cell] = 0\n        q.append(cell)\n    while q:\n        u = q.popleft()\n        for v in reverse_graph[u]:\n            if dist_to_iron[v] == -1:\n                dist_to_iron[v] = dist_to_iron[u] + 1\n                q.append(v)\n    \n    # BFS from all coal cells to find distances to all cells (reverse direction)\n    dist_to_coal = [-1] * (n + 1)\n    q = deque()\n    for cell in coal_cells:\n        dist_to_coal[cell] = 0\n        q.append(cell)\n    while q:\n        u = q.popleft()\n        for v in reverse_graph[u]:\n            if dist_to_coal[v] == -1:\n                dist_to_coal[v] = dist_to_coal[u] + 1\n                q.append(v)\n    \n    # Find minimum settlers needed\n    min_settlers = float('inf')\n    for cell in range(1, n + 1):\n        if dist_from_start[cell] != -1 and dist_to_iron[cell] != -1 and dist_to_coal[cell] != -1:\n            # Settlers needed = distance from start + distance to iron + distance to coal\n            # But we need to subtract 2 because:\n            # - The start cell (cell 1) doesn't require a settler\n            # - The meeting cell (current cell) would be counted twice in the sum\n            settlers = dist_from_start[cell] + dist_to_iron[cell] + dist_to_coal[cell]\n            min_settlers = min(min_settlers, settlers)\n    \n    if min_settlers == float('inf'):\n        return \"impossible\"\n    return str(min_settlers)\n\nif __name__ == \"__main__\":\n    print(solve())", "runtime_sec": 123.95529508590698}
{"eval_index": 157, "problem_id": 2892, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    sizes = list(map(int, data[1:1+n]))\n    \n    # Check if total count of each size matches what we expect for valid sets\n    from collections import Counter\n    cnt = Counter(sizes)\n    max_size = max(sizes)\n    # For each size from 1 to max_size, we need at least one doll of that size\n    # and the counts should be non-increasing as size increases\n    for s in range(1, max_size+1):\n        if cnt[s] == 0:\n            print(\"impossible\")\n            return\n    for s in range(1, max_size):\n        if cnt[s] < cnt[s+1]:\n            print(\"impossible\")\n            return\n    \n    # DP approach: dp[l][r] = min openings to combine interval [l,r] into valid groups\n    INF = 10**9\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Initialize for single dolls\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # Precompute prefix sums for quick range sum queries\n    prefix = [0] * (n+1)\n    for i in range(n):\n        prefix[i+1] = prefix[i] + sizes[i]\n    \n    # Fill DP for increasing lengths\n    for length in range(2, n+1):\n        for l in range(n-length+1):\n            r = l + length - 1\n            # Try all possible split points\n            for k in range(l, r):\n                if dp[l][k] < INF and dp[k+1][r] < INF:\n                    # Cost to combine two groups = sum of sizes in both groups - max_size_in_left - max_size_in_right\n                    left_sum = prefix[k+1] - prefix[l]\n                    right_sum = prefix[r+1] - prefix[k+1]\n                    left_max = max(sizes[l:k+1])\n                    right_max = max(sizes[k+1:r+1])\n                    combine_cost = left_sum - left_max + right_sum - right_max\n                    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + combine_cost)\n    \n    result = dp[0][n-1]\n    if result >= INF:\n        print(\"impossible\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 71.9428551197052}
{"eval_index": 158, "problem_id": 4589, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    H, W = map(int, data[0].split())\n    grid = data[1:1+H]\n    \n    # Directions: up, down, left, right, and four diagonals\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    result = []\n    for i in range(H):\n        row_chars = []\n        for j in range(W):\n            if grid[i][j] == '#':\n                row_chars.append('#')\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                    bomb_count += 1\n            row_chars.append(str(bomb_count))\n        result.append(''.join(row_chars))\n    \n    sys.stdout.write('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 138.00790333747864}
{"eval_index": 159, "problem_id": 3774, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data)\n    \n    # Ensure n <= m for easier handling\n    if n > m:\n        n, m = m, n\n    \n    # Cases based on board dimensions\n    if n == 1:\n        # For 1 row, we can pair cells that are 3 apart horizontally\n        # Maximum pairs = floor(m / 6) * 4 + max(0, (m % 6) - 2) * 2\n        full_sets = m // 6\n        remainder = m % 6\n        extra = max(0, remainder - 2) * 2\n        result = full_sets * 4 + extra\n    elif n == 2:\n        # For 2 rows, pattern repeats every 4 columns\n        # Each 4 columns gives 4 pairs (8 chessmen)\n        full_sets = m // 4\n        remainder = m % 4\n        # For remainder columns: 1->0, 2->0, 3->2 pairs\n        extra = 0\n        if remainder == 3:\n            extra = 4\n        result = full_sets * 8 + extra\n    else:\n        # For n >= 3 and m >= 3\n        # Most cells can be paired except possibly some edge cases\n        total_cells = n * m\n        # If both dimensions are odd, we might lose 1 cell\n        if (n % 2 == 1) and (m % 2 == 1):\n            result = total_cells - 1\n        else:\n            result = total_cells\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 147.8665611743927}
{"eval_index": 160, "problem_id": 507, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    b = list(map(int, data[1+n:1+2*n]))\n    \n    # Find positions where a and b differ\n    diff_positions = [i for i in range(n) if a[i] != b[i]]\n    \n    # Determine which values are missing from a and b\n    used_a = set(a)\n    used_b = set(b)\n    all_values = set(range(1, n+1))\n    missing_a = list(all_values - used_a)\n    missing_b = list(all_values - used_b)\n    \n    # Start with a as base permutation\n    p = a[:]\n    \n    if len(diff_positions) == 1:\n        # Only one position differs between a and b\n        pos = diff_positions[0]\n        # Try both possibilities\n        if missing_a:\n            p[pos] = missing_a[0]\n        else:\n            # If no missing value, use b's value at that position\n            p[pos] = b[pos]\n    else:\n        # Two positions differ (most common case)\n        pos1, pos2 = diff_positions[0], diff_positions[1]\n        \n        # Try swapping a[pos1] and a[pos2]\n        p[pos1], p[pos2] = a[pos2], a[pos1]\n        \n        # Check if this creates a valid permutation\n        if len(set(p)) != n:\n            # If not valid, try the other combination\n            p = a[:]\n            p[pos1] = b[pos1]\n            p[pos2] = b[pos2]\n            \n            # If still not valid, try mixing\n            if len(set(p)) != n:\n                p = a[:]\n                p[pos1] = b[pos1]\n                p[pos2] = a[pos2]\n                if len(set(p)) != n:\n                    p = a[:]\n                    p[pos1] = a[pos1]\n                    p[pos2] = b[pos2]\n    \n    # Final validation (should always pass with given constraints)\n    if len(set(p)) != n:\n        # Fallback: use b as permutation\n        p = b[:]\n    \n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1895.8259160518646}
{"eval_index": 161, "problem_id": 4088, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    q = int(data[0])\n    idx = 1\n    out_lines = []\n    for _ in range(q):\n        s = data[idx]; idx += 1\n        m = int(data[idx]); idx += 1\n        b = list(map(int, data[idx:idx+m])); idx += m\n        \n        # Count frequencies of letters in s\n        freq = [0]*26\n        for ch in s:\n            freq[ord(ch)-97] += 1\n        \n        # Build t from right to left\n        t = ['']*m\n        used = [False]*m\n        \n        # Process positions from largest letter to smallest\n        for letter in range(25, -1, -1):\n            # Find positions where b[i]==0 and not used\n            zero_positions = []\n            for i in range(m):\n                if not used[i] and b[i] == 0:\n                    zero_positions.append(i)\n            \n            # Assign the current letter to these positions\n            # but only if we have enough of this letter\n            need = len(zero_positions)\n            if need == 0:\n                continue\n                \n            # Take min(need, available) letters\n            take = min(need, freq[letter])\n            if take == 0:\n                continue\n                \n            # Assign to first 'take' zero positions\n            for pos in zero_positions[:take]:\n                t[pos] = chr(letter + 97)\n                used[pos] = True\n                # Update b values for positions to the left\n                for j in range(m):\n                    if not used[j]:\n                        b[j] -= abs(pos - j)\n            \n            # Reduce frequency\n            freq[letter] -= take\n        \n        out_lines.append(''.join(t))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 64.93859362602234}
{"eval_index": 162, "problem_id": 3054, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import re\n\ndef is_vowel(c, next_c=None):\n    \"\"\"Check if character c is a vowel given next character.\"\"\"\n    c = c.upper()\n    if next_c:\n        next_c = next_c.upper()\n    # Y is consonant if followed by another vowel\n    if c == 'Y' and next_c and next_c in 'AEIOU':\n        return False\n    return c in 'AEIOUY'\n\ndef count_syllables(word):\n    \"\"\"Count syllables in a word according to problem rules.\"\"\"\n    # Extract alphabetic part\n    alphabetic = re.sub(r'[^A-Za-z]', '', word)\n    if not alphabetic:\n        return 1  # Non-alphabetic word still has 1 syllable\n    \n    # Convert to uppercase for processing\n    upper = alphabetic.upper()\n    n = len(upper)\n    \n    # Handle silent E and ES exceptions\n    # Check for silent E at end\n    silent_e = False\n    if n >= 1 and upper[-1] == 'E':\n        if n >= 3 and upper[-2] == 'L' and upper[-3] not in 'AEIOUY':\n            # Not silent: able -> a-ble\n            pass\n        else:\n            silent_e = True\n    \n    # Check for ES at end\n    es_exception = False\n    if n >= 2 and upper[-2:] == 'ES':\n        if n >= 4 and upper[-3] not in 'AEIOUY' and upper[-4] not in 'AEIOUY':\n            # witches, verses: has extra syllable\n            pass\n        else:\n            es_exception = True\n    \n    # Count vowel groups\n    syllables = 0\n    i = 0\n    while i < n:\n        # Handle QU sequence\n        if i < n-1 and upper[i:i+2] == 'QU':\n            i += 2\n            continue\n        \n        # Check if current char is vowel\n        next_c = upper[i+1] if i < n-1 else None\n        if is_vowel(upper[i], next_c):\n            syllables += 1\n            # Skip consecutive vowels (they belong to same syllable)\n            while i < n:\n                next_c = upper[i+1] if i < n-1 else None\n                if i < n-1 and is_vowel(upper[i+1], upper[i+2] if i < n-2 else None):\n                    i += 1\n                else:\n                    break\n        i += 1\n    \n    # Apply exceptions\n    if silent_e:\n        syllables -= 1\n    if es_exception:\n        syllables -= 1\n    \n    # Ensure at least 1 syllable\n    return max(1, syllables)\n\ndef split_haiku(words):\n    \"\"\"Try to split words into haiku (5-7-5 syllables).\"\"\"\n    n = len(words)\n    \n    # Precompute syllable counts\n    counts = [count_syllables(w) for w in words]\n    total = sum(counts)\n    if total != 17:\n        return None\n    \n    # Try all possible splits\n    for i in range(1, n-1):  # First line end index\n        for j in range(i+1, n):  # Second line end index\n            first = sum(counts[:i])\n            second = sum(counts[i:j])\n            third = sum(counts[j:])\n            \n            if first == 5 and second == 7 and third == 5:\n                return (\n                    ' '.join(words[:i]),\n                    ' '.join(words[i:j]),\n                    ' '.join(words[j:])\n                )\n    return None\n\ndef main():\n    import sys\n    line = sys.stdin.read().strip()\n    \n    # Split into words preserving punctuation\n    words = []\n    current = ''\n    for char in line:\n        if char == ' ':\n            if current:\n                words.append(current)\n                current = ''\n        else:\n            current += char\n    if current:\n        words.append(current)\n    \n    # Try to form haiku\n    result = split_haiku(words)\n    if result:\n        print('\\n'.join(result))\n    else:\n        print(line)\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 204.12064719200134}
{"eval_index": 163, "problem_id": 2030, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 90.80763578414917}
{"eval_index": 164, "problem_id": 4352, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    A, B = map(int, input().split())\n    # Special case: 1 is the strongest, beating 13\n    if A == 1 and B == 13:\n        print(\"Alice\")\n    elif A == 13 and B == 1:\n        print(\"Bob\")\n    elif A > B:\n        print(\"Alice\")\n    elif A < B:\n        print(\"Bob\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 416.70852971076965}
{"eval_index": 165, "problem_id": 3030, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    values = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        v = int(next(it))\n        p = int(next(it))\n        values[i] = v\n        parent[i] = p\n        if p != 0:\n            children[p].append(i)\n    \n    # DP: dp[node] = max size of valid subset in subtree rooted at node\n    # where node is included and all ancestors in subset have values > values[node]\n    dp = [0] * (n + 1)\n    \n    def dfs(u):\n        # For each child, compute dp[child] assuming we include u\n        child_dp = []\n        for v in children[u]:\n            dfs(v)\n            child_dp.append(dp[v])\n        \n        # Sort child_dp in descending order\n        child_dp.sort(reverse=True)\n        \n        # We can include u and then choose children whose values are < values[u]\n        # But we need to ensure heap property: if we include a child, all its ancestors\n        # in the subset must have strictly greater values.\n        # Since we are including u, we can only include children with values < values[u]\n        # However, the DP already ensures that for each child, dp[child] is computed\n        # assuming all ancestors in subset have values > values[child].\n        # So we can simply add dp[child] for children with values[child] < values[u]\n        # But we must also consider that we might not take all such children if they\n        # conflict with each other (they don't, because they are in different subtrees).\n        # Actually, we can take all children with values[child] < values[u] because\n        # the heap property only concerns ancestor-descendant relationships, and\n        # different branches are independent.\n        \n        # However, there is a catch: if we include a child, then for that child's subtree,\n        # the condition is that all ancestors in subset have values > values[child].\n        # Since we are including u, and values[u] > values[child] is required, we must\n        # only consider children where values[child] < values[u].\n        # But dp[child] already assumes that all ancestors in subset have values > values[child].\n        # So if values[u] > values[child], then including u is fine for child's subtree.\n        # Therefore, we can add dp[child] for all children with values[child] < values[u].\n        \n        total = 1  # include u itself\n        for v in children[u]:\n            if values[v] < values[u]:\n                total += dp[v]\n        dp[u] = total\n    \n    dfs(1)\n    \n    # The answer is the maximum dp value over all nodes\n    # because we can choose any node as the \"root\" of our subset\n    # (the node with the largest value in the subset)\n    ans = max(dp[1:])  # exclude dp[0]\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 158.0336685180664}
{"eval_index": 166, "problem_id": 2250, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(input_data[idx]); idx += 1\n        s = input_data[idx]; idx += 1\n        \n        # Find first position where s[i] != s[(i+1)%n]\n        start = 0\n        while start < n and s[start] == s[0]:\n            start += 1\n        \n        if start == n:\n            # All characters are same\n            results.append((n + 2) // 3)\n            continue\n        \n        # Rearrange string to start at first change\n        s = s[start:] + s[:start]\n        \n        cnt = 1\n        changes = 0\n        \n        for i in range(1, n):\n            if s[i] == s[i-1]:\n                cnt += 1\n            else:\n                changes += cnt // 3\n                cnt = 1\n        \n        changes += cnt // 3\n        results.append(changes)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 220.85678434371948}
{"eval_index": 167, "problem_id": 4460, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    # Read the five integers from standard input\n    x = list(map(int, input().split()))\n    \n    # The initial values were [1, 2, 3, 4, 5]\n    # One of them was set to 0, so find which position has value 0\n    for i in range(5):\n        if x[i] == 0:\n            # Output the 1-based index\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 213.82414603233337}
{"eval_index": 168, "problem_id": 3585, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m, k = map(int, data)\n    \n    # The maximum number of bags is (2*k + 1)^m\n    # Using modular exponentiation\n    base = (2 * k + 1) % MOD\n    result = pow(base, m, MOD)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 102.93167471885681}
{"eval_index": 169, "problem_id": 1910, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 93.30351901054382}
{"eval_index": 170, "problem_id": 4415, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count frequencies\n    freq = {}\n    for val in a:\n        freq[val] = freq.get(val, 0) + 1\n    \n    # Check if any value appears more than twice\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Separate values that appear once vs twice\n    once = []\n    twice = []\n    for val, count in freq.items():\n        if count == 2:\n            twice.append(val)\n        else:\n            once.append(val)\n    \n    # Sort for processing\n    once.sort()\n    twice.sort()\n    \n    # Check if twice values can be split\n    # For each value appearing twice, one copy goes to increasing, one to decreasing\n    # The increasing copy must be <= next increasing value\n    # The decreasing copy must be >= next decreasing value\n    inc = []\n    dec = []\n    \n    # Process twice values\n    for val in twice:\n        inc.append(val)\n        dec.append(val)\n    \n    # Process once values\n    # Try to assign to increasing first if possible\n    for val in once:\n        if not inc or val > inc[-1]:\n            inc.append(val)\n        elif not dec or val < dec[-1]:\n            dec.append(val)\n        else:\n            # Can't assign to either sequence\n            print(\"NO\")\n            return\n    \n    # Check if sequences are strictly monotonic\n    for i in range(1, len(inc)):\n        if inc[i] <= inc[i-1]:\n            print(\"NO\")\n            return\n    for i in range(1, len(dec)):\n        if dec[i] >= dec[i-1]:\n            print(\"NO\")\n            return\n    \n    # Output\n    print(\"YES\")\n    print(len(inc))\n    if inc:\n        print(' '.join(map(str, inc)))\n    else:\n        print()\n    print(len(dec))\n    if dec:\n        # Output decreasing sequence in descending order\n        dec_sorted = sorted(dec, reverse=True)\n        print(' '.join(map(str, dec_sorted)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 69.562429189682}
{"eval_index": 171, "problem_id": 3205, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport itertools\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    M = int(next(it))\n    N = int(next(it))\n    \n    # Initialize balances\n    balances = [0] * M\n    \n    # Process receipts\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        p = int(next(it))\n        balances[a] -= p  # payer loses money\n        balances[b] += p  # receiver gains money\n    \n    # Filter out people with zero balance\n    nonzero = [b for b in balances if b != 0]\n    \n    # If no nonzero balances, no transactions needed\n    if not nonzero:\n        print(0)\n        return\n    \n    # Try all subsets of nonzero balances to see if they sum to zero\n    # This is NP-hard, but M ≤ 20 makes it feasible\n    k = len(nonzero)\n    min_transactions = k  # worst case: each person makes one transaction\n    \n    # Try all subsets (excluding empty and full)\n    for mask in range(1, (1 << k) - 1):\n        subset_sum = 0\n        for i in range(k):\n            if mask & (1 << i):\n                subset_sum += nonzero[i]\n        \n        # If subset sums to zero, we can settle within subset\n        if subset_sum == 0:\n            # Count bits in mask to get subset size\n            subset_size = bin(mask).count('1')\n            # Transactions needed = (subset_size - 1) + (k - subset_size - 1) + 1\n            # Simplified: k - subset_size + 1\n            transactions = k - subset_size + 1\n            if transactions < min_transactions:\n                min_transactions = transactions\n    \n    print(min_transactions)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.02784848213196}
{"eval_index": 172, "problem_id": 1707, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 92.75588607788086}
{"eval_index": 173, "problem_id": 4036, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Minimum possible sum: 1 + 2 + 3 + ... + k = k*(k+1)//2\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with minimal strictly increasing sequence: 1, 2, 3, ..., k\n    a = list(range(1, k + 1))\n    total = min_sum\n    \n    # Distribute remaining problems while maintaining constraints\n    remaining = n - total\n    \n    # We can increase each day's problems while keeping a[i] <= 2*a[i-1]\n    # Start from the last day (largest values) to maximize flexibility\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to this day without violating constraints\n        # For day i (0-indexed), the maximum value is:\n        # - For i=0: no upper bound from previous day, but we need to keep future days valid\n        # - For i>0: a[i] <= 2*a[i-1]\n        \n        # Calculate current maximum based on previous day\n        if i == 0:\n            # First day: only limited by needing to keep sequence valid\n            # The maximum for first day is limited by needing a[1] <= 2*a[0]\n            # So a[0] can be at most n - sum of remaining days with minimal increases\n            # But simpler: we'll let the loop handle it naturally\n            max_add = remaining\n        else:\n            # For day i, maximum value is 2*a[i-1]\n            max_val = 2 * a[i-1]\n            max_add = max_val - a[i]\n        \n        # Add as much as possible\n        add = min(remaining, max_add)\n        a[i] += add\n        remaining -= add\n        \n        if remaining == 0:\n            break\n    \n    # Check if we distributed all problems\n    if remaining > 0:\n        print(\"NO\")\n        return\n    \n    # Verify all constraints\n    # 1. Sum should be n\n    if sum(a) != n:\n        print(\"NO\")\n        return\n    \n    # 2. All positive\n    if any(x <= 0 for x in a):\n        print(\"NO\")\n        return\n    \n    # 3. Strictly increasing and a[i] <= 2*a[i-1]\n    for i in range(1, k):\n        if not (a[i-1] < a[i] <= 2 * a[i-1]):\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 75.85606241226196}
{"eval_index": 174, "problem_id": 3131, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\n\nMOD = 1000000007\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef mod_inv(x, mod):\n    return mod_pow(x, mod - 2, mod)\n\ndef nCr_mod(n, r, mod, fact, inv_fact):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n] * inv_fact[r] % mod) * inv_fact[n - r] % mod\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    K = int(data[1])\n    a = list(map(int, data[2:2+N]))\n    \n    if K > N:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = mod_inv(fact[max_n], MOD)\n    for i in range(max_n-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Sort values in non-decreasing order\n    a.sort()\n    \n    total = 0\n    # For each element a[i], count how many subsets of size K have a[i] as maximum\n    # This happens when we choose a[i] as maximum and choose K-1 elements from the i elements before it\n    for i in range(K-1, N):\n        count = nCr_mod(i, K-1, MOD, fact, inv_fact)\n        total = (total + a[i] * count) % MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 150.02791810035706}
{"eval_index": 175, "problem_id": 560, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    r, c = map(int, data[:2])\n    grid = data[2:2+r]\n    \n    # Track rows and columns that have strawberries\n    row_has_strawberry = [False] * r\n    col_has_strawberry = [False] * c\n    \n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                row_has_strawberry[i] = True\n                col_has_strawberry[j] = True\n    \n    # Count rows without strawberries\n    safe_rows = 0\n    for i in range(r):\n        if not row_has_strawberry[i]:\n            safe_rows += 1\n    \n    # Count columns without strawberries\n    safe_cols = 0\n    for j in range(c):\n        if not col_has_strawberry[j]:\n            safe_cols += 1\n    \n    # Calculate maximum cells that can be eaten\n    # All cells in safe rows + all cells in safe columns\n    # But subtract overlap (cells counted twice)\n    total = safe_rows * c + safe_cols * r - safe_rows * safe_cols\n    \n    # However, if a cell has a strawberry, it cannot be eaten at all\n    # So we need to subtract any strawberry cells that were included in the count\n    # But actually, if a row or column has any strawberry, it won't be counted as safe\n    # So the formula above already excludes all strawberry cells\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 1539.7035295963287}
{"eval_index": 176, "problem_id": 4718, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "S = input().strip()\nprint('2018' + S[4:])", "runtime_sec": 88.81924533843994}
{"eval_index": 177, "problem_id": 3088, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n_str, k_str = data[0], data[1]\n    n = list(n_str)\n    k = int(k_str)\n    length = len(n)\n    \n    # Greedy approach with backtracking for exactly k swaps\n    def backtrack(pos, swaps_left):\n        if swaps_left == 0 or pos == length:\n            return\n        \n        # Find the maximum digit from current position to end\n        max_digit = n[pos]\n        max_pos = pos\n        for i in range(pos + 1, length):\n            if n[i] > max_digit:\n                max_digit = n[i]\n                max_pos = i\n        \n        if max_pos == pos:\n            # No better digit found, move to next position\n            backtrack(pos + 1, swaps_left)\n        else:\n            # Try all positions with max_digit\n            candidates = []\n            for i in range(pos + 1, length):\n                if n[i] == max_digit:\n                    candidates.append(i)\n            \n            # Try each candidate\n            for candidate in candidates:\n                # Swap\n                n[pos], n[candidate] = n[candidate], n[pos]\n                backtrack(pos + 1, swaps_left - 1)\n                # Restore\n                n[pos], n[candidate] = n[candidate], n[pos]\n            \n            # Also consider not swapping if we have enough swaps left\n            if swaps_left >= 2:\n                backtrack(pos + 1, swaps_left)\n    \n    # Start backtracking\n    backtrack(0, k)\n    \n    # Convert to string and output\n    result = ''.join(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 63.0448203086853}
{"eval_index": 178, "problem_id": 2682, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": false, "failure_type": "exception", "exception": "TypeError('write() argument must be str, not list')", "runtime_sec": 83.0485212802887}
{"eval_index": 179, "problem_id": 4608, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = [0] + [int(data[i]) for i in range(1, n+1)]  # 1-indexed\n    \n    visited = [False] * (n + 1)\n    current = 1\n    count = 0\n    \n    while not visited[current]:\n        if current == 2:\n            print(count)\n            return\n        visited[current] = True\n        current = a[current]\n        count += 1\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 135.3117060661316}
{"eval_index": 180, "problem_id": 3281, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nimport heapq\n\ndef angle_between(v1, v2):\n    \"\"\"Calculate angle between two vectors in degrees\"\"\"\n    dot = v1[0]*v2[0] + v1[1]*v2[1]\n    norm1 = math.hypot(v1[0], v1[1])\n    norm2 = math.hypot(v2[0], v2[1])\n    \n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    \n    cos_theta = dot / (norm1 * norm2)\n    cos_theta = max(-1.0, min(1.0, cos_theta))\n    return math.degrees(math.acos(cos_theta))\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    J = int(next(it))\n    R = int(next(it))\n    D = int(next(it))\n    \n    coords = []\n    for _ in range(J):\n        x = int(next(it))\n        y = int(next(it))\n        coords.append((x, y))\n    \n    adj = [[] for _ in range(J)]\n    for _ in range(R):\n        a = int(next(it)) - 1\n        b = int(next(it)) - 1\n        adj[a].append(b)\n    \n    EPS = 1e-9\n    \n    def can_achieve(max_angle):\n        \"\"\"Check if there's a path with all turning angles <= max_angle and distance <= D\"\"\"\n        # dist[node][prev_edge] = min distance to reach node with last edge direction\n        INF = float('inf')\n        dist = [[INF] * J for _ in range(J)]\n        \n        # Priority queue: (distance, node, prev_node)\n        pq = []\n        \n        # Initialize from start node (junction 1, index 0)\n        # For start node, there's no previous edge, so we can take any outgoing edge\n        for nxt in adj[0]:\n            dx = coords[nxt][0] - coords[0][0]\n            dy = coords[nxt][1] - coords[0][1]\n            dist[nxt][0] = math.hypot(dx, dy)\n            heapq.heappush(pq, (dist[nxt][0], nxt, 0))\n        \n        while pq:\n            d, u, prev = heapq.heappop(pq)\n            if d > dist[u][prev] + EPS:\n                continue\n            \n            # If we reached destination\n            if u == J-1:\n                if d <= D + EPS:\n                    return True\n                continue\n            \n            # Calculate vector of incoming edge (from prev to u)\n            if prev != u:  # Not the start case\n                v_in = (coords[u][0] - coords[prev][0], coords[u][1] - coords[prev][1])\n            \n            for v in adj[u]:\n                # Calculate vector of outgoing edge (from u to v)\n                v_out = (coords[v][0] - coords[u][0], coords[v][1] - coords[u][1])\n                \n                # Calculate turning angle\n                if prev == u:  # Starting from junction 1\n                    angle = 0.0\n                else:\n                    angle = angle_between(v_in, v_out)\n                \n                if angle > max_angle + EPS:\n                    continue\n                \n                new_dist = d + math.hypot(v_out[0], v_out[1])\n                if new_dist > D + EPS:\n                    continue\n                \n                if new_dist < dist[v][u] - EPS:\n                    dist[v][u] = new_dist\n                    heapq.heappush(pq, (new_dist, v, u))\n        \n        return False\n    \n    # Binary search for minimum maximum angle\n    left, right = 0.0, 180.0\n    best = None\n    \n    for _ in range(60):  # Enough iterations for 1e-6 precision\n        mid = (left + right) / 2\n        if can_achieve(mid):\n            best = mid\n            right = mid\n        else:\n            left = mid\n    \n    if best is None:\n        print(\"Impossible\")\n    else:\n        print(f\"{best:.8f}\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 126.29027485847473}
{"eval_index": 181, "problem_id": 501, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\nMOD = 1000000007\n\ndef sum_arithmetic_progression(first, last, count):\n    \"\"\"Return sum of arithmetic progression modulo MOD.\"\"\"\n    if count == 0:\n        return 0\n    total = (first + last) % MOD\n    total = (total * count) % MOD\n    # Multiply by modular inverse of 2\n    return (total * 500000004) % MOD  # 500000004 is modular inverse of 2 mod MOD\n\ndef sum_of_stage(stage_index, start_pos, end_pos):\n    \"\"\"Return sum of numbers from start_pos to end_pos within a stage.\n    \n    stage_index: 1-based stage number\n    start_pos: 1-based position within stage (1 <= start_pos <= end_pos)\n    end_pos: 1-based position within stage\n    \"\"\"\n    # Stage size: 2^(stage_index-1)\n    stage_size = 1 << (stage_index - 1)\n    \n    # Determine which set we're using in this stage\n    # Stage 1: odd numbers (set 1)\n    # Stage 2: even numbers (set 2)\n    # Stage 3: odd numbers (set 1)\n    # etc.\n    is_odd_stage = (stage_index % 2 == 1)\n    \n    # Calculate how many numbers were written before this stage\n    # Sum of geometric series: 2^0 + 2^1 + ... + 2^(stage_index-2)\n    # = 2^(stage_index-1) - 1\n    numbers_before = (1 << (stage_index - 1)) - 1\n    \n    # Calculate the starting number in this set for this stage\n    # For odd stages (odd numbers): numbers_before//2 + 1 gives the nth odd number\n    # For even stages (even numbers): numbers_before//2 + 1 gives the nth even number\n    nth_number = numbers_before // 2 + 1\n    \n    # Adjust for the starting position within the stage\n    first_nth = nth_number + (start_pos - 1)\n    last_nth = nth_number + (end_pos - 1)\n    \n    # Convert to actual numbers\n    if is_odd_stage:\n        first_num = 2 * first_nth - 1\n        last_num = 2 * last_nth - 1\n    else:\n        first_num = 2 * first_nth\n        last_num = 2 * last_nth\n    \n    count = end_pos - start_pos + 1\n    return sum_arithmetic_progression(first_num, last_num, count)\n\ndef find_stage_and_position(pos):\n    \"\"\"Find which stage contains position pos and the position within that stage.\"\"\"\n    # Binary search for the stage\n    low, high = 1, 61  # 2^60 > 10^18\n    while low < high:\n        mid = (low + high) // 2\n        # Numbers up to end of stage mid: 2^mid - 1\n        if (1 << mid) - 1 < pos:\n            low = mid + 1\n        else:\n            high = mid\n    \n    stage = low\n    # Position within stage\n    numbers_before = (1 << (stage - 1)) - 1\n    pos_in_stage = pos - numbers_before\n    return stage, pos_in_stage\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, r = map(int, data[:2])\n    \n    # Find stage and position for l and r\n    l_stage, l_pos = find_stage_and_position(l)\n    r_stage, r_pos = find_stage_and_position(r)\n    \n    total = 0\n    \n    # Case 1: l and r are in the same stage\n    if l_stage == r_stage:\n        total = sum_of_stage(l_stage, l_pos, r_pos)\n    else:\n        # Sum from l to end of l_stage\n        stage_size = 1 << (l_stage - 1)\n        total = (total + sum_of_stage(l_stage, l_pos, stage_size)) % MOD\n        \n        # Sum for complete stages between l_stage and r_stage\n        for stage in range(l_stage + 1, r_stage):\n            stage_size = 1 << (stage - 1)\n            total = (total + sum_of_stage(stage, 1, stage_size)) % MOD\n        \n        # Sum from beginning of r_stage to r\n        total = (total + sum_of_stage(r_stage, 1, r_pos)) % MOD\n    \n    print(total % MOD)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 127.28671360015869}
{"eval_index": 182, "problem_id": 4244, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    xs = list(map(int, data[1:1+n]))\n    \n    # Since coordinates are between 1 and 100, we can brute force all possible meeting points\n    min_stamina = float('inf')\n    for p in range(1, 101):  # Try all integer coordinates from 1 to 100\n        total = 0\n        for x in xs:\n            diff = x - p\n            total += diff * diff\n        if total < min_stamina:\n            min_stamina = total\n    \n    print(min_stamina)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 581.9934809207916}
{"eval_index": 183, "problem_id": 3265, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport numpy as np\n\nsys.setrecursionlimit(1000000)\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    N = int(next(it))\n    L = int(next(it))\n    \n    # Read adjacency matrix\n    adj = []\n    for _ in range(N):\n        row = [int(next(it)) for _ in range(N)]\n        adj.append(row)\n    \n    # Build transition probability matrix\n    P = np.zeros((N, N), dtype=np.float64)\n    for i in range(N):\n        total = sum(adj[i])\n        if total > 0:\n            for j in range(N):\n                P[i][j] = adj[i][j] / total\n    \n    # Initial state vector: probability 1 at node 1 (index 0)\n    state = np.zeros(N, dtype=np.float64)\n    state[0] = 1.0\n    \n    # Check days from L to L+9\n    for T in range(L, L + 10):\n        # Compute state after T days using matrix exponentiation\n        # Since N ≤ 100, we can compute iteratively\n        current = state.copy()\n        for _ in range(T):\n            # Multiply current state vector by transition matrix\n            new_state = np.zeros(N, dtype=np.float64)\n            for i in range(N):\n                if current[i] > 0:\n                    for j in range(N):\n                        new_state[j] += current[i] * P[i][j]\n            current = new_state\n        \n        # Probability at node N (index N-1)\n        prob = current[N-1]\n        \n        # Check if probability is exactly 95% (within floating point tolerance)\n        if abs(prob - 0.95) < 1e-12:\n            print(T)\n            return\n    \n    # No valid T found\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 66.69758796691895}
{"eval_index": 184, "problem_id": 2844, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nfrom collections import deque\n\ndef bfs_escape(R, C, grid):\n    # Find start and destination positions\n    start = dest = None\n    water_queue = deque()\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'D':\n                dest = (i, j)\n            elif grid[i][j] == '*':\n                water_queue.append((i, j, 0))  # (row, col, time)\n    \n    if not start or not dest:\n        return \"KAKTUS\"\n    \n    # BFS for water propagation times\n    water_time = [[-1] * C for _ in range(R)]\n    for i, j, t in water_queue:\n        water_time[i][j] = t\n    \n    while water_queue:\n        r, c, t = water_queue.popleft()\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if grid[nr][nc] == '.' and water_time[nr][nc] == -1:\n                    water_time[nr][nc] = t + 1\n                    water_queue.append((nr, nc, t + 1))\n    \n    # BFS for hedgehog movement\n    visited = [[False] * C for _ in range(R)]\n    queue = deque([(start[0], start[1], 0)])  # (row, col, time)\n    visited[start[0]][start[1]] = True\n    \n    while queue:\n        r, c, t = queue.popleft()\n        \n        # Check if reached destination\n        if (r, c) == dest:\n            return str(t)\n        \n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                # Check if cell is passable\n                if grid[nr][nc] == '.' or grid[nr][nc] == 'D':\n                    # Check water timing: either water never reaches this cell,\n                    # or hedgehog arrives before water\n                    water_arrival = water_time[nr][nc]\n                    if water_arrival == -1 or t + 1 < water_arrival:\n                        visited[nr][nc] = True\n                        queue.append((nr, nc, t + 1))\n    \n    return \"KAKTUS\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    \n    R, C = map(int, data[0].split())\n    grid = [list(line.strip()) for line in data[1:1+R]]\n    \n    result = bfs_escape(R, C, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 154.71790266036987}
{"eval_index": 185, "problem_id": 4857, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    l, w = map(int, data)\n    \n    # Check if possible: min weight = l*1, max weight = l*26\n    if w < l or w > l * 26:\n        print(\"impossible\")\n        return\n    \n    # Start with all 'a's (weight = l)\n    result = ['a'] * l\n    current_weight = l\n    \n    # Distribute remaining weight from the end\n    remaining = w - current_weight\n    for i in range(l-1, -1, -1):\n        if remaining == 0:\n            break\n        # Add as much as possible to this position, max 25 (since 'a'=1)\n        add = min(25, remaining)\n        result[i] = chr(ord('a') + add)  # 'a' + add gives correct letter\n        remaining -= add\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 56.67160773277283}
{"eval_index": 186, "problem_id": 3628, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    a = list(map(int, data[1:1+n]))\n    \n    # Count occurrences of each value in a\n    count = [0] * (n + 1)\n    for val in a:\n        count[val] += 1\n    \n    # Check if any count exceeds n (impossible since each value 1..n appears once in each permutation)\n    # Actually, we need to check if we can assign pairs (π_i, σ_i) such that (π_i + σ_i) mod n = a_i\n    # This is equivalent to checking if the multiset {a_i} can be decomposed into sums of two permutations\n    \n    # We'll use a greedy matching approach with backtracking\n    # Since n ≤ 1000, we can use DFS with pruning\n    \n    # Prepare available numbers for π and σ (both start with all 1..n)\n    available_pi = [True] * (n + 1)  # index 1..n\n    available_sigma = [True] * (n + 1)\n    \n    pi = [0] * n\n    sigma = [0] * n\n    \n    # For each position i, we need to choose π_i and σ_i such that:\n    # (π_i + σ_i) % n == a_i % n (but a_i is already in 1..n)\n    # Actually careful: a_i ≡ π_i + σ_i (mod n), with π_i, σ_i in 1..n\n    # So (π_i + σ_i) % n should equal a_i % n, but since a_i is in 1..n, we can use a_i directly\n    # However, note that π_i + σ_i could be > n, so we need modulo equivalence\n    \n    # Let's define: we need π_i + σ_i ≡ a_i (mod n)\n    # This means π_i + σ_i = a_i or π_i + σ_i = a_i + n\n    # Since π_i, σ_i ≥ 1, and a_i ≤ n, the possible sums are:\n    # Case 1: π_i + σ_i = a_i  (if a_i ≥ 2, since min sum is 2)\n    # Case 2: π_i + σ_i = a_i + n\n    \n    # We'll try to assign using backtracking with heuristic: process positions in order\n    \n    def backtrack(pos):\n        if pos == n:\n            return True\n        \n        target = a[pos]\n        \n        # Try all possible π_i\n        for pi_val in range(1, n + 1):\n            if not available_pi[pi_val]:\n                continue\n            \n            # Calculate needed σ_i value for both cases\n            # Case 1: pi_val + sigma_val = target\n            sigma_val1 = target - pi_val\n            # Case 2: pi_val + sigma_val = target + n\n            sigma_val2 = target + n - pi_val\n            \n            # Try case 1\n            if 1 <= sigma_val1 <= n and available_sigma[sigma_val1]:\n                available_pi[pi_val] = False\n                available_sigma[sigma_val1] = False\n                pi[pos] = pi_val\n                sigma[pos] = sigma_val1\n                \n                if backtrack(pos + 1):\n                    return True\n                \n                available_pi[pi_val] = True\n                available_sigma[sigma_val1] = True\n            \n            # Try case 2\n            if 1 <= sigma_val2 <= n and available_sigma[sigma_val2]:\n                available_pi[pi_val] = False\n                available_sigma[sigma_val2] = False\n                pi[pos] = pi_val\n                sigma[pos] = sigma_val2\n                \n                if backtrack(pos + 1):\n                    return True\n                \n                available_pi[pi_val] = True\n                available_sigma[sigma_val2] = True\n        \n        return False\n    \n    if backtrack(0):\n        print(' '.join(map(str, pi)))\n        print(' '.join(map(str, sigma)))\n    else:\n        print('impossible')\n\nif __name__ == '__main__':\n    solve()", "runtime_sec": 86.07559204101562}
{"eval_index": 187, "problem_id": 2194, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\ndef main():\n    # Fallback code due to invalid LLM JSON.\n    # Intentionally minimal; will likely fail tests.\n    data = sys.stdin.read()\n    if data is None:\n        return\n    # print nothing\nif __name__ == '__main__':\n    main()\n", "runtime_sec": 93.05153703689575}
{"eval_index": 188, "problem_id": 4394, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport heapq\n\nsys.setrecursionlimit(300000)\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if xroot == yroot:\n        return False\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n    return True\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        w = int(next(it))\n        edges.append((w, u, v))\n    \n    if n <= 1:\n        print(0)\n        return\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Kruskal's algorithm to find MST and identify equal weight edges\n    i = 0\n    operations = 0\n    while i < m:\n        j = i\n        while j < m and edges[j][0] == edges[i][0]:\n            j += 1\n        \n        # Process edges with same weight w\n        # First, count how many edges in this weight group connect different components\n        count_connecting = 0\n        for k in range(i, j):\n            w, u, v = edges[k]\n            if find(parent, u) != find(parent, v):\n                count_connecting += 1\n        \n        # Then actually union them\n        for k in range(i, j):\n            w, u, v = edges[k]\n            if union(parent, rank, u, v):\n                count_connecting -= 1\n        \n        # If there were more than 1 connecting edges in this weight group,\n        # we need to increase all but one of them to break ties\n        if count_connecting > 0:\n            operations += count_connecting\n        \n        i = j\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 359.0459713935852}
{"eval_index": 189, "problem_id": 3662, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "COMPLEXITY", "first_failure": null, "final_code": "import sys\nimport math\n\n# Read input\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\n\nidx = 0\nN = int(data[idx]); idx += 1\nL = int(data[idx]); idx += 1\nW = int(data[idx]); idx += 1\n\npositions = []\nfor _ in range(N):\n    positions.append(int(data[idx])); idx += 1\n\n# Sort positions along left side\npositions.sort()\n\n# There will be N/2 pairs, each pair has one tree on left and one on right\n# The left positions are fixed: start at 0, end at L, equally spaced\n# The right positions are exactly the same as left positions (same spacing)\n# We need to assign N/2 trees to left positions and N/2 trees to right positions\n# The trees are initially all on left side at given positions\n\n# Precompute target positions\nhalf = N // 2\nspacing = L / (half - 1) if half > 1 else 0\nleft_targets = [i * spacing for i in range(half)]\nright_targets = left_targets[:]  # same positions on right side\n\n# DP approach: dp[i][j] = min total distance when we have assigned\n# i trees to left targets and j trees to right targets\n# We process trees in sorted order\nINF = float('inf')\ndp = [[INF] * (half + 1) for _ in range(half + 1)]\ndp[0][0] = 0.0\n\nfor k in range(N):\n    # New DP table for current tree\n    new_dp = [[INF] * (half + 1) for _ in range(half + 1)]\n    for i in range(half + 1):\n        for j in range(half + 1):\n            if dp[i][j] == INF:\n                continue\n            # Option 1: assign current tree to next left target\n            if i < half:\n                dist = abs(positions[k] - left_targets[i])\n                new_dp[i+1][j] = min(new_dp[i+1][j], dp[i][j] + dist)\n            # Option 2: assign current tree to next right target\n            if j < half:\n                # Distance to right target: horizontal distance + road width\n                horizontal_dist = abs(positions[k] - right_targets[j])\n                dist = math.sqrt(horizontal_dist**2 + W**2)\n                new_dp[i][j+1] = min(new_dp[i][j+1], dp[i][j] + dist)\n    dp = new_dp\n\nanswer = dp[half][half]\nprint(f\"{answer:.10f}\")", "runtime_sec": 111.42992925643921}
{"eval_index": 190, "problem_id": 1036, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "TLE", "first_failure": null, "final_code": "import sys\n\ndef get_hand(i, n, s):\n    return s[i % n]\n\ndef winner_hand(a, b):\n    if a == b:\n        return a\n    if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n        return a\n    return b\n\ndef tournament(l, r, n, s):\n    if r - l == 1:\n        return get_hand(l, n, s)\n    m = (l + r) // 2\n    a = tournament(l, m, n, s)\n    b = tournament(m, r, n, s)\n    return winner_hand(a, b)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    s = data[2]\n    total_players = 1 << k\n    result = tournament(0, total_players, n, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 142.7561318874359}
{"eval_index": 191, "problem_id": 4645, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        if n == 2 or n == 3:\n            results.append(\"-1\")\n            continue\n        \n        # Build permutation using pattern: start with even numbers descending, then odd numbers ascending\n        # This ensures differences between 2 and 4 for most cases\n        perm = []\n        # Add even numbers in descending order\n        even_start = n if n % 2 == 0 else n - 1\n        for i in range(even_start, 0, -2):\n            perm.append(i)\n        \n        # Add odd numbers in ascending order\n        odd_start = 1 if n % 2 == 1 else 3\n        for i in range(odd_start, n + 1, 2):\n            perm.append(i)\n        \n        # For n=4, the pattern needs adjustment\n        if n == 4:\n            perm = [3, 1, 4, 2]\n        \n        # For n=5, the pattern needs adjustment\n        if n == 5:\n            perm = [4, 1, 3, 5, 2]\n        \n        # For n=6, the pattern works as is\n        if n == 6:\n            perm = [6, 4, 2, 5, 3, 1]\n        \n        # For n=7, the pattern works as is\n        if n == 7:\n            perm = [6, 4, 2, 5, 7, 3, 1]\n        \n        # Verify the permutation satisfies constraints (for debugging)\n        valid = True\n        for i in range(n - 1):\n            diff = abs(perm[i] - perm[i + 1])\n            if diff < 2 or diff > 4:\n                valid = False\n                break\n        \n        if not valid:\n            # Fallback: use a different pattern if the main one fails\n            # This handles edge cases\n            if n % 2 == 0:\n                perm = list(range(2, n + 1, 2)) + list(range(1, n + 1, 2))\n            else:\n                perm = list(range(2, n, 2)) + list(range(1, n + 1, 2))\n            \n            # Final verification\n            for i in range(n - 1):\n                diff = abs(perm[i] - perm[i + 1])\n                if diff < 2 or diff > 4:\n                    results.append(\"-1\")\n                    continue\n        \n        results.append(\" \".join(map(str, perm)))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 73.6491277217865}
{"eval_index": 192, "problem_id": 3505, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count frequency of each number\n    freq = {}\n    for x in arr:\n        freq[x] = freq.get(x, 0) + 1\n    \n    # Get unique numbers and sort them\n    unique_nums = sorted(freq.keys())\n    m = len(unique_nums)\n    \n    ans = 0\n    \n    # Case 1: a_i = a_j = a_k/2 (i.e., 2*x = x, which only happens when x=0)\n    if 0 in freq:\n        zero_count = freq[0]\n        # Choose i,j from zeros, k from zeros (but i,j,k distinct)\n        # Number of ways: C(zero_count, 2) * (zero_count - 2)\n        if zero_count >= 3:\n            ans += zero_count * (zero_count - 1) * (zero_count - 2)\n    \n    # Case 2: a_i = a_j != a_k (i.e., 2*x = y, where x != y)\n    for x in unique_nums:\n        cnt_x = freq[x]\n        y = 2 * x\n        if y in freq and x != y:\n            cnt_y = freq[y]\n            # Choose i,j from x's (order matters, so P(cnt_x,2) = cnt_x*(cnt_x-1))\n            # Choose k from y's\n            ans += cnt_x * (cnt_x - 1) * cnt_y\n    \n    # Case 3: a_i != a_j, and a_i + a_j = a_k\n    # We iterate over all pairs of distinct numbers (x,y) where x <= y\n    # and count ways where x+y exists in array\n    for i in range(m):\n        x = unique_nums[i]\n        cnt_x = freq[x]\n        for j in range(i, m):\n            y = unique_nums[j]\n            if i == j:\n                # Already handled in case 2\n                continue\n            cnt_y = freq[y]\n            target = x + y\n            if target in freq:\n                cnt_target = freq[target]\n                # Choose i from x's, j from y's (order matters)\n                # But careful: if x == y, we already handled in case 2\n                # Here x != y, so we have two different numbers\n                # Number of ways: cnt_x * cnt_y * cnt_target\n                ans += cnt_x * cnt_y * cnt_target\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 73.05406451225281}
{"eval_index": 193, "problem_id": 2508, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nimport math\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    H = int(next(it))\n    W = int(next(it))\n    K = int(next(it))\n    x1 = int(next(it)) - 1\n    y1 = int(next(it)) - 1\n    x2 = int(next(it)) - 1\n    y2 = int(next(it)) - 1\n    \n    grid = []\n    for _ in range(H):\n        row = list(next(it))\n        grid.append(row)\n    \n    # BFS with 0-1 BFS optimization for K moves\n    INF = 10**9\n    dist = [[INF] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    \n    # We'll use deque for 0-1 BFS\n    dq = deque()\n    dq.append((x1, y1))\n    \n    # For each direction, we'll explore up to K steps\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while dq:\n        x, y = dq.popleft()\n        current_dist = dist[x][y]\n        \n        if x == x2 and y == y2:\n            print(current_dist)\n            return\n        \n        for dx, dy in dirs:\n            # Explore up to K steps in this direction\n            for step in range(1, K + 1):\n                nx = x + dx * step\n                ny = y + dy * step\n                \n                # Check bounds and obstacles\n                if nx < 0 or nx >= H or ny < 0 or ny >= W:\n                    break\n                if grid[nx][ny] == '@':\n                    break\n                \n                # If we found a better distance\n                if dist[nx][ny] > current_dist + 1:\n                    dist[nx][ny] = current_dist + 1\n                    dq.append((nx, ny))\n                elif dist[nx][ny] < current_dist + 1:\n                    # No need to continue in this direction if we already have a better path\n                    break\n    \n    print(-1 if dist[x2][y2] == INF else dist[x2][y2])\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 147.08879899978638}
{"eval_index": 194, "problem_id": 4982, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    total_shares = 0\n    avg_cost = 0.0\n    total_profit = 0.0\n    \n    for line in data:\n        parts = line.split()\n        cmd = parts[0]\n        \n        if cmd == 'buy':\n            x = int(parts[1])\n            y = int(parts[2])\n            # Update average cost using weighted average\n            if total_shares == 0:\n                avg_cost = y\n            else:\n                avg_cost = (total_shares * avg_cost + x * y) / (total_shares + x)\n            total_shares += x\n            \n        elif cmd == 'sell':\n            x = int(parts[1])\n            y = int(parts[2])\n            # Calculate profit from this sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                total_profit += x * profit_per_share\n            total_shares -= x\n            # Average cost remains unchanged after selling\n            \n        elif cmd == 'split':\n            x = int(parts[1])\n            total_shares *= x\n            avg_cost /= x\n            \n        elif cmd == 'merge':\n            x = int(parts[1])\n            # Calculate how many shares can be merged\n            merged_shares = total_shares // x\n            remainder = total_shares % x\n            \n            # Sell remainder shares at current average cost\n            if remainder > 0:\n                profit_per_share = avg_cost - avg_cost  # Always 0 since selling at avg_cost\n                # No profit/loss when selling at average cost\n                total_shares -= remainder\n            \n            # Update shares and average cost after merge\n            total_shares = merged_shares\n            avg_cost *= x\n            \n        elif cmd == 'die':\n            y = int(parts[1])\n            # Calculate profit from final sale\n            profit_per_share = y - avg_cost\n            if profit_per_share > 0:\n                taxable_profit = total_shares * profit_per_share\n                tax = taxable_profit * 0.3\n                final_amount = total_shares * y - tax\n            else:\n                final_amount = total_shares * y  # No tax on loss\n            \n            # Add any accumulated profit from previous sales\n            if total_profit > 0:\n                tax_on_previous = total_profit * 0.3\n                final_amount -= tax_on_previous\n            \n            print(f\"{final_amount:.8f}\")\n            return\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 109.04100513458252}
{"eval_index": 195, "problem_id": 3115, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\nsys.setrecursionlimit(300000)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n\ndef is_consistent():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return \"consistent\"\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    uf = UnionFind(N)\n    edges = []\n    \n    for _ in range(M):\n        a = int(data[idx]); idx += 1\n        op = data[idx]; idx += 1\n        b = int(data[idx]); idx += 1\n        \n        if op == '=':\n            uf.union(a, b)\n        else:  # '>'\n            edges.append((a, b))\n    \n    # Build adjacency list for DAG\n    adj = [[] for _ in range(N)]\n    indegree = [0] * N\n    \n    for a, b in edges:\n        root_a = uf.find(a)\n        root_b = uf.find(b)\n        if root_a == root_b:\n            return \"inconsistent\"\n        adj[root_a].append(root_b)\n        indegree[root_b] += 1\n    \n    # Topological sort to check for cycles\n    from collections import deque\n    \n    # Get unique roots\n    roots = set()\n    for i in range(N):\n        roots.add(uf.find(i))\n    \n    # Initialize queue with roots having indegree 0\n    queue = deque([r for r in roots if indegree[r] == 0])\n    processed = 0\n    \n    while queue:\n        node = queue.popleft()\n        processed += 1\n        for neighbor in adj[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # If we processed all roots, no cycle\n    if processed == len(roots):\n        return \"consistent\"\n    else:\n        return \"inconsistent\"\n\nif __name__ == \"__main__\":\n    print(is_consistent())", "runtime_sec": 151.67142605781555}
{"eval_index": 196, "problem_id": 1141, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    n, m = map(int, data[0].split())\n    s = list(data[1])\n    for i in range(m):\n        l, r, c1, c2 = data[2 + i].split()\n        l, r = int(l) - 1, int(r) - 1\n        for j in range(l, r + 1):\n            if s[j] == c1:\n                s[j] = c2\n    print(''.join(s))\n\nif __name__ == \"__main__\":\n    main()", "runtime_sec": 942.5073232650757}
{"eval_index": 197, "problem_id": 4738, "difficulty": "introductory", "apps_config": "introductory", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "def solve():\n    import sys\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Try all possible k from 1 to n\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        \n        # Check if s is k-periodic\n        valid = True\n        num_blocks = n // k\n        \n        for i in range(1, num_blocks):\n            prev_block = s[(i-1)*k : i*k]\n            curr_block = s[i*k : (i+1)*k]\n            \n            # Check if curr_block is right-rotation of prev_block\n            if curr_block != prev_block[-1] + prev_block[:-1]:\n                valid = False\n                break\n        \n        if valid:\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 176.65583109855652}
{"eval_index": 198, "problem_id": 3250, "difficulty": "competition", "apps_config": "competition", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": false, "gate_allowed": true, "complexity_estimate": null, "failure_type": "RE", "first_failure": null, "final_code": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    b = int(data[0])\n    d = int(data[1])\n    \n    # Since d is prime, we need to check if there exists m such that:\n    # b^m ≡ 1 (mod d) or b^m ≡ -1 (mod d)\n    # This is because the reduction function essentially computes n mod (b^m ± 1)\n    \n    # Check small m values up to a reasonable limit\n    # Since d < 2^63, we can check up to d (but practically much smaller)\n    # Using Fermat's little theorem: b^(d-1) ≡ 1 (mod d) if gcd(b,d)=1\n    # So we only need to check divisors of (d-1)\n    \n    # First handle special case where d divides b\n    if b % d == 0:\n        # If d divides b, then only m=1 might work\n        # For m=1, f_{b,1}(n) = alternating sum of digits\n        # This works if b ≡ ±1 (mod d), but b ≡ 0 (mod d) here\n        # Actually when b ≡ 0 (mod d), b^m ≡ 0 (mod d) for m≥1\n        # The reduction becomes n mod (0 ± 1) = n mod (±1) which is always 0\n        # So no valid hack exists\n        print(\"no\")\n        return\n    \n    # Find all divisors of (d-1)\n    divisors = []\n    limit = int(math.isqrt(d-1))\n    for i in range(1, limit + 1):\n        if (d-1) % i == 0:\n            divisors.append(i)\n            if i != (d-1)//i:\n                divisors.append((d-1)//i)\n    \n    # Sort divisors\n    divisors.sort()\n    \n    # Check each divisor m\n    for m in divisors:\n        if m <= 0:\n            continue\n        # Compute b^m mod d efficiently\n        pow_mod = pow(b, m, d)\n        if pow_mod == 1 or pow_mod == d-1:  # d-1 ≡ -1 (mod d)\n            print(\"yes\")\n            return\n    \n    # Also need to check m that are divisors of 2*(d-1) for the -1 case\n    # Actually if b^m ≡ -1 (mod d), then b^(2m) ≡ 1 (mod d)\n    # So m would be a divisor of 2*(d-1) but not necessarily of (d-1)\n    \n    # Check divisors of 2*(d-1)\n    divisors2 = []\n    limit2 = int(math.isqrt(2*(d-1)))\n    for i in range(1, limit2 + 1):\n        if (2*(d-1)) % i == 0:\n            divisors2.append(i)\n            if i != (2*(d-1))//i:\n                divisors2.append((2*(d-1))//i)\n    \n    divisors2.sort()\n    \n    for m in divisors2:\n        if m <= 0:\n            continue\n        pow_mod = pow(b, m, d)\n        if pow_mod == d-1:  # Check for -1 case\n            print(\"yes\")\n            return\n    \n    print(\"no\")\n\nif __name__ == \"__main__\":\n    solve()", "runtime_sec": 77.63780808448792}
{"eval_index": 199, "problem_id": 2903, "difficulty": "interview", "apps_config": "interview", "apps_split": "test", "rag_k": 0, "mode": "baseline_single", "passed": true, "gate_allowed": true, "complexity_estimate": null, "failure_type": "WA", "first_failure": null, "final_code": "import sys\n\ndef fenwick_update(tree, idx, delta, n):\n    \"\"\"Update Fenwick tree: add delta to element at index idx (0-based).\"\"\"\n    i = idx + 1  # convert to 1-based for Fenwick tree\n    while i <= n:\n        tree[i] += delta\n        i += i & -i\n\ndef fenwick_query(tree, idx):\n    \"\"\"Query prefix sum up to index idx (0-based, exclusive).\"\"\"\n    i = idx  # idx is already exclusive upper bound\n    res = 0\n    while i > 0:\n        res += tree[i]\n        i -= i & -i\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    q = int(next(it))\n    \n    # Fenwick tree (1-indexed array of size n+1)\n    tree = [0] * (n + 1)\n    \n    out_lines = []\n    for _ in range(q):\n        op = next(it)\n        if op == '+':\n            i = int(next(it))\n            delta = int(next(it))\n            fenwick_update(tree, i, delta, n)\n        else:  # op == '?'\n            i = int(next(it))\n            # query prefix sum up to i (exclusive)\n            res = fenwick_query(tree, i)\n            out_lines.append(str(res))\n    \n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()", "runtime_sec": 105.68289732933044}
